const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/browserAll-Cplxpe42.js","assets/webworkerAll-CyzMB49c.js","assets/colorToUniform-B2b8-1Ah.js","assets/WebGPURenderer-CTBXFgSQ.js","assets/SharedSystems--OG3m4AK.js","assets/WebGLRenderer-0tiCfP3M.js"])))=>i.map(i=>d[i]);
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key2, value2) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key2] = value2;
var __publicField = (obj, key2, value2) => __defNormalProp(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value2);
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity) fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
    else fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
var react = { exports: {} };
var react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReact_production_min;
function requireReact_production_min() {
  if (hasRequiredReact_production_min) return react_production_min;
  hasRequiredReact_production_min = 1;
  var l2 = Symbol.for("react.element"), n2 = Symbol.for("react.portal"), p2 = Symbol.for("react.fragment"), q = Symbol.for("react.strict_mode"), r2 = Symbol.for("react.profiler"), t2 = Symbol.for("react.provider"), u2 = Symbol.for("react.context"), v2 = Symbol.for("react.forward_ref"), w2 = Symbol.for("react.suspense"), x2 = Symbol.for("react.memo"), y2 = Symbol.for("react.lazy"), z = Symbol.iterator;
  function A(a2) {
    if (null === a2 || "object" !== typeof a2) return null;
    a2 = z && a2[z] || a2["@@iterator"];
    return "function" === typeof a2 ? a2 : null;
  }
  var B = { isMounted: function() {
    return false;
  }, enqueueForceUpdate: function() {
  }, enqueueReplaceState: function() {
  }, enqueueSetState: function() {
  } }, C = Object.assign, D = {};
  function E(a2, b2, e2) {
    this.props = a2;
    this.context = b2;
    this.refs = D;
    this.updater = e2 || B;
  }
  E.prototype.isReactComponent = {};
  E.prototype.setState = function(a2, b2) {
    if ("object" !== typeof a2 && "function" !== typeof a2 && null != a2) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, a2, b2, "setState");
  };
  E.prototype.forceUpdate = function(a2) {
    this.updater.enqueueForceUpdate(this, a2, "forceUpdate");
  };
  function F() {
  }
  F.prototype = E.prototype;
  function G(a2, b2, e2) {
    this.props = a2;
    this.context = b2;
    this.refs = D;
    this.updater = e2 || B;
  }
  var H2 = G.prototype = new F();
  H2.constructor = G;
  C(H2, E.prototype);
  H2.isPureReactComponent = true;
  var I = Array.isArray, J = Object.prototype.hasOwnProperty, K = { current: null }, L = { key: true, ref: true, __self: true, __source: true };
  function M2(a2, b2, e2) {
    var d2, c2 = {}, k2 = null, h2 = null;
    if (null != b2) for (d2 in void 0 !== b2.ref && (h2 = b2.ref), void 0 !== b2.key && (k2 = "" + b2.key), b2) J.call(b2, d2) && !L.hasOwnProperty(d2) && (c2[d2] = b2[d2]);
    var g2 = arguments.length - 2;
    if (1 === g2) c2.children = e2;
    else if (1 < g2) {
      for (var f2 = Array(g2), m2 = 0; m2 < g2; m2++) f2[m2] = arguments[m2 + 2];
      c2.children = f2;
    }
    if (a2 && a2.defaultProps) for (d2 in g2 = a2.defaultProps, g2) void 0 === c2[d2] && (c2[d2] = g2[d2]);
    return { $$typeof: l2, type: a2, key: k2, ref: h2, props: c2, _owner: K.current };
  }
  function N2(a2, b2) {
    return { $$typeof: l2, type: a2.type, key: b2, ref: a2.ref, props: a2.props, _owner: a2._owner };
  }
  function O(a2) {
    return "object" === typeof a2 && null !== a2 && a2.$$typeof === l2;
  }
  function escape(a2) {
    var b2 = { "=": "=0", ":": "=2" };
    return "$" + a2.replace(/[=:]/g, function(a3) {
      return b2[a3];
    });
  }
  var P = /\/+/g;
  function Q(a2, b2) {
    return "object" === typeof a2 && null !== a2 && null != a2.key ? escape("" + a2.key) : b2.toString(36);
  }
  function R(a2, b2, e2, d2, c2) {
    var k2 = typeof a2;
    if ("undefined" === k2 || "boolean" === k2) a2 = null;
    var h2 = false;
    if (null === a2) h2 = true;
    else switch (k2) {
      case "string":
      case "number":
        h2 = true;
        break;
      case "object":
        switch (a2.$$typeof) {
          case l2:
          case n2:
            h2 = true;
        }
    }
    if (h2) return h2 = a2, c2 = c2(h2), a2 = "" === d2 ? "." + Q(h2, 0) : d2, I(c2) ? (e2 = "", null != a2 && (e2 = a2.replace(P, "$&/") + "/"), R(c2, b2, e2, "", function(a3) {
      return a3;
    })) : null != c2 && (O(c2) && (c2 = N2(c2, e2 + (!c2.key || h2 && h2.key === c2.key ? "" : ("" + c2.key).replace(P, "$&/") + "/") + a2)), b2.push(c2)), 1;
    h2 = 0;
    d2 = "" === d2 ? "." : d2 + ":";
    if (I(a2)) for (var g2 = 0; g2 < a2.length; g2++) {
      k2 = a2[g2];
      var f2 = d2 + Q(k2, g2);
      h2 += R(k2, b2, e2, f2, c2);
    }
    else if (f2 = A(a2), "function" === typeof f2) for (a2 = f2.call(a2), g2 = 0; !(k2 = a2.next()).done; ) k2 = k2.value, f2 = d2 + Q(k2, g2++), h2 += R(k2, b2, e2, f2, c2);
    else if ("object" === k2) throw b2 = String(a2), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b2 ? "object with keys {" + Object.keys(a2).join(", ") + "}" : b2) + "). If you meant to render a collection of children, use an array instead.");
    return h2;
  }
  function S2(a2, b2, e2) {
    if (null == a2) return a2;
    var d2 = [], c2 = 0;
    R(a2, d2, "", "", function(a3) {
      return b2.call(e2, a3, c2++);
    });
    return d2;
  }
  function T(a2) {
    if (-1 === a2._status) {
      var b2 = a2._result;
      b2 = b2();
      b2.then(function(b3) {
        if (0 === a2._status || -1 === a2._status) a2._status = 1, a2._result = b3;
      }, function(b3) {
        if (0 === a2._status || -1 === a2._status) a2._status = 2, a2._result = b3;
      });
      -1 === a2._status && (a2._status = 0, a2._result = b2);
    }
    if (1 === a2._status) return a2._result.default;
    throw a2._result;
  }
  var U = { current: null }, V = { transition: null }, W = { ReactCurrentDispatcher: U, ReactCurrentBatchConfig: V, ReactCurrentOwner: K };
  function X() {
    throw Error("act(...) is not supported in production builds of React.");
  }
  react_production_min.Children = { map: S2, forEach: function(a2, b2, e2) {
    S2(a2, function() {
      b2.apply(this, arguments);
    }, e2);
  }, count: function(a2) {
    var b2 = 0;
    S2(a2, function() {
      b2++;
    });
    return b2;
  }, toArray: function(a2) {
    return S2(a2, function(a3) {
      return a3;
    }) || [];
  }, only: function(a2) {
    if (!O(a2)) throw Error("React.Children.only expected to receive a single React element child.");
    return a2;
  } };
  react_production_min.Component = E;
  react_production_min.Fragment = p2;
  react_production_min.Profiler = r2;
  react_production_min.PureComponent = G;
  react_production_min.StrictMode = q;
  react_production_min.Suspense = w2;
  react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W;
  react_production_min.act = X;
  react_production_min.cloneElement = function(a2, b2, e2) {
    if (null === a2 || void 0 === a2) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a2 + ".");
    var d2 = C({}, a2.props), c2 = a2.key, k2 = a2.ref, h2 = a2._owner;
    if (null != b2) {
      void 0 !== b2.ref && (k2 = b2.ref, h2 = K.current);
      void 0 !== b2.key && (c2 = "" + b2.key);
      if (a2.type && a2.type.defaultProps) var g2 = a2.type.defaultProps;
      for (f2 in b2) J.call(b2, f2) && !L.hasOwnProperty(f2) && (d2[f2] = void 0 === b2[f2] && void 0 !== g2 ? g2[f2] : b2[f2]);
    }
    var f2 = arguments.length - 2;
    if (1 === f2) d2.children = e2;
    else if (1 < f2) {
      g2 = Array(f2);
      for (var m2 = 0; m2 < f2; m2++) g2[m2] = arguments[m2 + 2];
      d2.children = g2;
    }
    return { $$typeof: l2, type: a2.type, key: c2, ref: k2, props: d2, _owner: h2 };
  };
  react_production_min.createContext = function(a2) {
    a2 = { $$typeof: u2, _currentValue: a2, _currentValue2: a2, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
    a2.Provider = { $$typeof: t2, _context: a2 };
    return a2.Consumer = a2;
  };
  react_production_min.createElement = M2;
  react_production_min.createFactory = function(a2) {
    var b2 = M2.bind(null, a2);
    b2.type = a2;
    return b2;
  };
  react_production_min.createRef = function() {
    return { current: null };
  };
  react_production_min.forwardRef = function(a2) {
    return { $$typeof: v2, render: a2 };
  };
  react_production_min.isValidElement = O;
  react_production_min.lazy = function(a2) {
    return { $$typeof: y2, _payload: { _status: -1, _result: a2 }, _init: T };
  };
  react_production_min.memo = function(a2, b2) {
    return { $$typeof: x2, type: a2, compare: void 0 === b2 ? null : b2 };
  };
  react_production_min.startTransition = function(a2) {
    var b2 = V.transition;
    V.transition = {};
    try {
      a2();
    } finally {
      V.transition = b2;
    }
  };
  react_production_min.unstable_act = X;
  react_production_min.useCallback = function(a2, b2) {
    return U.current.useCallback(a2, b2);
  };
  react_production_min.useContext = function(a2) {
    return U.current.useContext(a2);
  };
  react_production_min.useDebugValue = function() {
  };
  react_production_min.useDeferredValue = function(a2) {
    return U.current.useDeferredValue(a2);
  };
  react_production_min.useEffect = function(a2, b2) {
    return U.current.useEffect(a2, b2);
  };
  react_production_min.useId = function() {
    return U.current.useId();
  };
  react_production_min.useImperativeHandle = function(a2, b2, e2) {
    return U.current.useImperativeHandle(a2, b2, e2);
  };
  react_production_min.useInsertionEffect = function(a2, b2) {
    return U.current.useInsertionEffect(a2, b2);
  };
  react_production_min.useLayoutEffect = function(a2, b2) {
    return U.current.useLayoutEffect(a2, b2);
  };
  react_production_min.useMemo = function(a2, b2) {
    return U.current.useMemo(a2, b2);
  };
  react_production_min.useReducer = function(a2, b2, e2) {
    return U.current.useReducer(a2, b2, e2);
  };
  react_production_min.useRef = function(a2) {
    return U.current.useRef(a2);
  };
  react_production_min.useState = function(a2) {
    return U.current.useState(a2);
  };
  react_production_min.useSyncExternalStore = function(a2, b2, e2) {
    return U.current.useSyncExternalStore(a2, b2, e2);
  };
  react_production_min.useTransition = function() {
    return U.current.useTransition();
  };
  react_production_min.version = "18.3.1";
  return react_production_min;
}
var hasRequiredReact;
function requireReact() {
  if (hasRequiredReact) return react.exports;
  hasRequiredReact = 1;
  {
    react.exports = requireReact_production_min();
  }
  return react.exports;
}
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_production_min;
function requireReactJsxRuntime_production_min() {
  if (hasRequiredReactJsxRuntime_production_min) return reactJsxRuntime_production_min;
  hasRequiredReactJsxRuntime_production_min = 1;
  var f2 = requireReact(), k2 = Symbol.for("react.element"), l2 = Symbol.for("react.fragment"), m2 = Object.prototype.hasOwnProperty, n2 = f2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p2 = { key: true, ref: true, __self: true, __source: true };
  function q(c2, a2, g2) {
    var b2, d2 = {}, e2 = null, h2 = null;
    void 0 !== g2 && (e2 = "" + g2);
    void 0 !== a2.key && (e2 = "" + a2.key);
    void 0 !== a2.ref && (h2 = a2.ref);
    for (b2 in a2) m2.call(a2, b2) && !p2.hasOwnProperty(b2) && (d2[b2] = a2[b2]);
    if (c2 && c2.defaultProps) for (b2 in a2 = c2.defaultProps, a2) void 0 === d2[b2] && (d2[b2] = a2[b2]);
    return { $$typeof: k2, type: c2, key: e2, ref: h2, props: d2, _owner: n2.current };
  }
  reactJsxRuntime_production_min.Fragment = l2;
  reactJsxRuntime_production_min.jsx = q;
  reactJsxRuntime_production_min.jsxs = q;
  return reactJsxRuntime_production_min;
}
var hasRequiredJsxRuntime;
function requireJsxRuntime() {
  if (hasRequiredJsxRuntime) return jsxRuntime.exports;
  hasRequiredJsxRuntime = 1;
  {
    jsxRuntime.exports = requireReactJsxRuntime_production_min();
  }
  return jsxRuntime.exports;
}
var jsxRuntimeExports = requireJsxRuntime();
var client = {};
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredScheduler_production_min;
function requireScheduler_production_min() {
  if (hasRequiredScheduler_production_min) return scheduler_production_min;
  hasRequiredScheduler_production_min = 1;
  (function(exports$1) {
    function f2(a2, b2) {
      var c2 = a2.length;
      a2.push(b2);
      a: for (; 0 < c2; ) {
        var d2 = c2 - 1 >>> 1, e2 = a2[d2];
        if (0 < g2(e2, b2)) a2[d2] = b2, a2[c2] = e2, c2 = d2;
        else break a;
      }
    }
    function h2(a2) {
      return 0 === a2.length ? null : a2[0];
    }
    function k2(a2) {
      if (0 === a2.length) return null;
      var b2 = a2[0], c2 = a2.pop();
      if (c2 !== b2) {
        a2[0] = c2;
        a: for (var d2 = 0, e2 = a2.length, w2 = e2 >>> 1; d2 < w2; ) {
          var m2 = 2 * (d2 + 1) - 1, C = a2[m2], n2 = m2 + 1, x2 = a2[n2];
          if (0 > g2(C, c2)) n2 < e2 && 0 > g2(x2, C) ? (a2[d2] = x2, a2[n2] = c2, d2 = n2) : (a2[d2] = C, a2[m2] = c2, d2 = m2);
          else if (n2 < e2 && 0 > g2(x2, c2)) a2[d2] = x2, a2[n2] = c2, d2 = n2;
          else break a;
        }
      }
      return b2;
    }
    function g2(a2, b2) {
      var c2 = a2.sortIndex - b2.sortIndex;
      return 0 !== c2 ? c2 : a2.id - b2.id;
    }
    if ("object" === typeof performance && "function" === typeof performance.now) {
      var l2 = performance;
      exports$1.unstable_now = function() {
        return l2.now();
      };
    } else {
      var p2 = Date, q = p2.now();
      exports$1.unstable_now = function() {
        return p2.now() - q;
      };
    }
    var r2 = [], t2 = [], u2 = 1, v2 = null, y2 = 3, z = false, A = false, B = false, D = "function" === typeof setTimeout ? setTimeout : null, E = "function" === typeof clearTimeout ? clearTimeout : null, F = "undefined" !== typeof setImmediate ? setImmediate : null;
    "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function G(a2) {
      for (var b2 = h2(t2); null !== b2; ) {
        if (null === b2.callback) k2(t2);
        else if (b2.startTime <= a2) k2(t2), b2.sortIndex = b2.expirationTime, f2(r2, b2);
        else break;
        b2 = h2(t2);
      }
    }
    function H2(a2) {
      B = false;
      G(a2);
      if (!A) if (null !== h2(r2)) A = true, I(J);
      else {
        var b2 = h2(t2);
        null !== b2 && K(H2, b2.startTime - a2);
      }
    }
    function J(a2, b2) {
      A = false;
      B && (B = false, E(L), L = -1);
      z = true;
      var c2 = y2;
      try {
        G(b2);
        for (v2 = h2(r2); null !== v2 && (!(v2.expirationTime > b2) || a2 && !M2()); ) {
          var d2 = v2.callback;
          if ("function" === typeof d2) {
            v2.callback = null;
            y2 = v2.priorityLevel;
            var e2 = d2(v2.expirationTime <= b2);
            b2 = exports$1.unstable_now();
            "function" === typeof e2 ? v2.callback = e2 : v2 === h2(r2) && k2(r2);
            G(b2);
          } else k2(r2);
          v2 = h2(r2);
        }
        if (null !== v2) var w2 = true;
        else {
          var m2 = h2(t2);
          null !== m2 && K(H2, m2.startTime - b2);
          w2 = false;
        }
        return w2;
      } finally {
        v2 = null, y2 = c2, z = false;
      }
    }
    var N2 = false, O = null, L = -1, P = 5, Q = -1;
    function M2() {
      return exports$1.unstable_now() - Q < P ? false : true;
    }
    function R() {
      if (null !== O) {
        var a2 = exports$1.unstable_now();
        Q = a2;
        var b2 = true;
        try {
          b2 = O(true, a2);
        } finally {
          b2 ? S2() : (N2 = false, O = null);
        }
      } else N2 = false;
    }
    var S2;
    if ("function" === typeof F) S2 = function() {
      F(R);
    };
    else if ("undefined" !== typeof MessageChannel) {
      var T = new MessageChannel(), U = T.port2;
      T.port1.onmessage = R;
      S2 = function() {
        U.postMessage(null);
      };
    } else S2 = function() {
      D(R, 0);
    };
    function I(a2) {
      O = a2;
      N2 || (N2 = true, S2());
    }
    function K(a2, b2) {
      L = D(function() {
        a2(exports$1.unstable_now());
      }, b2);
    }
    exports$1.unstable_IdlePriority = 5;
    exports$1.unstable_ImmediatePriority = 1;
    exports$1.unstable_LowPriority = 4;
    exports$1.unstable_NormalPriority = 3;
    exports$1.unstable_Profiling = null;
    exports$1.unstable_UserBlockingPriority = 2;
    exports$1.unstable_cancelCallback = function(a2) {
      a2.callback = null;
    };
    exports$1.unstable_continueExecution = function() {
      A || z || (A = true, I(J));
    };
    exports$1.unstable_forceFrameRate = function(a2) {
      0 > a2 || 125 < a2 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P = 0 < a2 ? Math.floor(1e3 / a2) : 5;
    };
    exports$1.unstable_getCurrentPriorityLevel = function() {
      return y2;
    };
    exports$1.unstable_getFirstCallbackNode = function() {
      return h2(r2);
    };
    exports$1.unstable_next = function(a2) {
      switch (y2) {
        case 1:
        case 2:
        case 3:
          var b2 = 3;
          break;
        default:
          b2 = y2;
      }
      var c2 = y2;
      y2 = b2;
      try {
        return a2();
      } finally {
        y2 = c2;
      }
    };
    exports$1.unstable_pauseExecution = function() {
    };
    exports$1.unstable_requestPaint = function() {
    };
    exports$1.unstable_runWithPriority = function(a2, b2) {
      switch (a2) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          a2 = 3;
      }
      var c2 = y2;
      y2 = a2;
      try {
        return b2();
      } finally {
        y2 = c2;
      }
    };
    exports$1.unstable_scheduleCallback = function(a2, b2, c2) {
      var d2 = exports$1.unstable_now();
      "object" === typeof c2 && null !== c2 ? (c2 = c2.delay, c2 = "number" === typeof c2 && 0 < c2 ? d2 + c2 : d2) : c2 = d2;
      switch (a2) {
        case 1:
          var e2 = -1;
          break;
        case 2:
          e2 = 250;
          break;
        case 5:
          e2 = 1073741823;
          break;
        case 4:
          e2 = 1e4;
          break;
        default:
          e2 = 5e3;
      }
      e2 = c2 + e2;
      a2 = { id: u2++, callback: b2, priorityLevel: a2, startTime: c2, expirationTime: e2, sortIndex: -1 };
      c2 > d2 ? (a2.sortIndex = c2, f2(t2, a2), null === h2(r2) && a2 === h2(t2) && (B ? (E(L), L = -1) : B = true, K(H2, c2 - d2))) : (a2.sortIndex = e2, f2(r2, a2), A || z || (A = true, I(J)));
      return a2;
    };
    exports$1.unstable_shouldYield = M2;
    exports$1.unstable_wrapCallback = function(a2) {
      var b2 = y2;
      return function() {
        var c2 = y2;
        y2 = b2;
        try {
          return a2.apply(this, arguments);
        } finally {
          y2 = c2;
        }
      };
    };
  })(scheduler_production_min);
  return scheduler_production_min;
}
var hasRequiredScheduler;
function requireScheduler() {
  if (hasRequiredScheduler) return scheduler.exports;
  hasRequiredScheduler = 1;
  {
    scheduler.exports = requireScheduler_production_min();
  }
  return scheduler.exports;
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactDom_production_min;
function requireReactDom_production_min() {
  if (hasRequiredReactDom_production_min) return reactDom_production_min;
  hasRequiredReactDom_production_min = 1;
  var aa = requireReact(), ca = requireScheduler();
  function p2(a2) {
    for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c2 = 1; c2 < arguments.length; c2++) b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
    return "Minified React error #" + a2 + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var da = /* @__PURE__ */ new Set(), ea = {};
  function fa(a2, b2) {
    ha(a2, b2);
    ha(a2 + "Capture", b2);
  }
  function ha(a2, b2) {
    ea[a2] = b2;
    for (a2 = 0; a2 < b2.length; a2++) da.add(b2[a2]);
  }
  var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
  function oa(a2) {
    if (ja.call(ma, a2)) return true;
    if (ja.call(la, a2)) return false;
    if (ka.test(a2)) return ma[a2] = true;
    la[a2] = true;
    return false;
  }
  function pa(a2, b2, c2, d2) {
    if (null !== c2 && 0 === c2.type) return false;
    switch (typeof b2) {
      case "function":
      case "symbol":
        return true;
      case "boolean":
        if (d2) return false;
        if (null !== c2) return !c2.acceptsBooleans;
        a2 = a2.toLowerCase().slice(0, 5);
        return "data-" !== a2 && "aria-" !== a2;
      default:
        return false;
    }
  }
  function qa(a2, b2, c2, d2) {
    if (null === b2 || "undefined" === typeof b2 || pa(a2, b2, c2, d2)) return true;
    if (d2) return false;
    if (null !== c2) switch (c2.type) {
      case 3:
        return !b2;
      case 4:
        return false === b2;
      case 5:
        return isNaN(b2);
      case 6:
        return isNaN(b2) || 1 > b2;
    }
    return false;
  }
  function v2(a2, b2, c2, d2, e2, f2, g2) {
    this.acceptsBooleans = 2 === b2 || 3 === b2 || 4 === b2;
    this.attributeName = d2;
    this.attributeNamespace = e2;
    this.mustUseProperty = c2;
    this.propertyName = a2;
    this.type = b2;
    this.sanitizeURL = f2;
    this.removeEmptyString = g2;
  }
  var z = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a2) {
    z[a2] = new v2(a2, 0, false, a2, null, false, false);
  });
  [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a2) {
    var b2 = a2[0];
    z[b2] = new v2(b2, 1, false, a2[1], null, false, false);
  });
  ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a2) {
    z[a2] = new v2(a2, 2, false, a2.toLowerCase(), null, false, false);
  });
  ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a2) {
    z[a2] = new v2(a2, 2, false, a2, null, false, false);
  });
  "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a2) {
    z[a2] = new v2(a2, 3, false, a2.toLowerCase(), null, false, false);
  });
  ["checked", "multiple", "muted", "selected"].forEach(function(a2) {
    z[a2] = new v2(a2, 3, true, a2, null, false, false);
  });
  ["capture", "download"].forEach(function(a2) {
    z[a2] = new v2(a2, 4, false, a2, null, false, false);
  });
  ["cols", "rows", "size", "span"].forEach(function(a2) {
    z[a2] = new v2(a2, 6, false, a2, null, false, false);
  });
  ["rowSpan", "start"].forEach(function(a2) {
    z[a2] = new v2(a2, 5, false, a2.toLowerCase(), null, false, false);
  });
  var ra = /[\-:]([a-z])/g;
  function sa(a2) {
    return a2[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a2) {
    var b2 = a2.replace(
      ra,
      sa
    );
    z[b2] = new v2(b2, 1, false, a2, null, false, false);
  });
  "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a2) {
    var b2 = a2.replace(ra, sa);
    z[b2] = new v2(b2, 1, false, a2, "http://www.w3.org/1999/xlink", false, false);
  });
  ["xml:base", "xml:lang", "xml:space"].forEach(function(a2) {
    var b2 = a2.replace(ra, sa);
    z[b2] = new v2(b2, 1, false, a2, "http://www.w3.org/XML/1998/namespace", false, false);
  });
  ["tabIndex", "crossOrigin"].forEach(function(a2) {
    z[a2] = new v2(a2, 1, false, a2.toLowerCase(), null, false, false);
  });
  z.xlinkHref = new v2("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
  ["src", "href", "action", "formAction"].forEach(function(a2) {
    z[a2] = new v2(a2, 1, false, a2.toLowerCase(), null, true, true);
  });
  function ta(a2, b2, c2, d2) {
    var e2 = z.hasOwnProperty(b2) ? z[b2] : null;
    if (null !== e2 ? 0 !== e2.type : d2 || !(2 < b2.length) || "o" !== b2[0] && "O" !== b2[0] || "n" !== b2[1] && "N" !== b2[1]) qa(b2, c2, e2, d2) && (c2 = null), d2 || null === e2 ? oa(b2) && (null === c2 ? a2.removeAttribute(b2) : a2.setAttribute(b2, "" + c2)) : e2.mustUseProperty ? a2[e2.propertyName] = null === c2 ? 3 === e2.type ? false : "" : c2 : (b2 = e2.attributeName, d2 = e2.attributeNamespace, null === c2 ? a2.removeAttribute(b2) : (e2 = e2.type, c2 = 3 === e2 || 4 === e2 && true === c2 ? "" : "" + c2, d2 ? a2.setAttributeNS(d2, b2, c2) : a2.setAttribute(b2, c2)));
  }
  var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
  var Ia = Symbol.for("react.offscreen");
  var Ja = Symbol.iterator;
  function Ka(a2) {
    if (null === a2 || "object" !== typeof a2) return null;
    a2 = Ja && a2[Ja] || a2["@@iterator"];
    return "function" === typeof a2 ? a2 : null;
  }
  var A = Object.assign, La;
  function Ma(a2) {
    if (void 0 === La) try {
      throw Error();
    } catch (c2) {
      var b2 = c2.stack.trim().match(/\n( *(at )?)/);
      La = b2 && b2[1] || "";
    }
    return "\n" + La + a2;
  }
  var Na = false;
  function Oa(a2, b2) {
    if (!a2 || Na) return "";
    Na = true;
    var c2 = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (b2) if (b2 = function() {
        throw Error();
      }, Object.defineProperty(b2.prototype, "props", { set: function() {
        throw Error();
      } }), "object" === typeof Reflect && Reflect.construct) {
        try {
          Reflect.construct(b2, []);
        } catch (l2) {
          var d2 = l2;
        }
        Reflect.construct(a2, [], b2);
      } else {
        try {
          b2.call();
        } catch (l2) {
          d2 = l2;
        }
        a2.call(b2.prototype);
      }
      else {
        try {
          throw Error();
        } catch (l2) {
          d2 = l2;
        }
        a2();
      }
    } catch (l2) {
      if (l2 && d2 && "string" === typeof l2.stack) {
        for (var e2 = l2.stack.split("\n"), f2 = d2.stack.split("\n"), g2 = e2.length - 1, h2 = f2.length - 1; 1 <= g2 && 0 <= h2 && e2[g2] !== f2[h2]; ) h2--;
        for (; 1 <= g2 && 0 <= h2; g2--, h2--) if (e2[g2] !== f2[h2]) {
          if (1 !== g2 || 1 !== h2) {
            do
              if (g2--, h2--, 0 > h2 || e2[g2] !== f2[h2]) {
                var k2 = "\n" + e2[g2].replace(" at new ", " at ");
                a2.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a2.displayName));
                return k2;
              }
            while (1 <= g2 && 0 <= h2);
          }
          break;
        }
      }
    } finally {
      Na = false, Error.prepareStackTrace = c2;
    }
    return (a2 = a2 ? a2.displayName || a2.name : "") ? Ma(a2) : "";
  }
  function Pa(a2) {
    switch (a2.tag) {
      case 5:
        return Ma(a2.type);
      case 16:
        return Ma("Lazy");
      case 13:
        return Ma("Suspense");
      case 19:
        return Ma("SuspenseList");
      case 0:
      case 2:
      case 15:
        return a2 = Oa(a2.type, false), a2;
      case 11:
        return a2 = Oa(a2.type.render, false), a2;
      case 1:
        return a2 = Oa(a2.type, true), a2;
      default:
        return "";
    }
  }
  function Qa(a2) {
    if (null == a2) return null;
    if ("function" === typeof a2) return a2.displayName || a2.name || null;
    if ("string" === typeof a2) return a2;
    switch (a2) {
      case ya:
        return "Fragment";
      case wa:
        return "Portal";
      case Aa:
        return "Profiler";
      case za:
        return "StrictMode";
      case Ea:
        return "Suspense";
      case Fa:
        return "SuspenseList";
    }
    if ("object" === typeof a2) switch (a2.$$typeof) {
      case Ca:
        return (a2.displayName || "Context") + ".Consumer";
      case Ba:
        return (a2._context.displayName || "Context") + ".Provider";
      case Da:
        var b2 = a2.render;
        a2 = a2.displayName;
        a2 || (a2 = b2.displayName || b2.name || "", a2 = "" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
        return a2;
      case Ga:
        return b2 = a2.displayName || null, null !== b2 ? b2 : Qa(a2.type) || "Memo";
      case Ha:
        b2 = a2._payload;
        a2 = a2._init;
        try {
          return Qa(a2(b2));
        } catch (c2) {
        }
    }
    return null;
  }
  function Ra(a2) {
    var b2 = a2.type;
    switch (a2.tag) {
      case 24:
        return "Cache";
      case 9:
        return (b2.displayName || "Context") + ".Consumer";
      case 10:
        return (b2._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return a2 = b2.render, a2 = a2.displayName || a2.name || "", b2.displayName || ("" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return b2;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return Qa(b2);
      case 8:
        return b2 === za ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if ("function" === typeof b2) return b2.displayName || b2.name || null;
        if ("string" === typeof b2) return b2;
    }
    return null;
  }
  function Sa(a2) {
    switch (typeof a2) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return a2;
      case "object":
        return a2;
      default:
        return "";
    }
  }
  function Ta(a2) {
    var b2 = a2.type;
    return (a2 = a2.nodeName) && "input" === a2.toLowerCase() && ("checkbox" === b2 || "radio" === b2);
  }
  function Ua(a2) {
    var b2 = Ta(a2) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a2.constructor.prototype, b2), d2 = "" + a2[b2];
    if (!a2.hasOwnProperty(b2) && "undefined" !== typeof c2 && "function" === typeof c2.get && "function" === typeof c2.set) {
      var e2 = c2.get, f2 = c2.set;
      Object.defineProperty(a2, b2, { configurable: true, get: function() {
        return e2.call(this);
      }, set: function(a3) {
        d2 = "" + a3;
        f2.call(this, a3);
      } });
      Object.defineProperty(a2, b2, { enumerable: c2.enumerable });
      return { getValue: function() {
        return d2;
      }, setValue: function(a3) {
        d2 = "" + a3;
      }, stopTracking: function() {
        a2._valueTracker = null;
        delete a2[b2];
      } };
    }
  }
  function Va(a2) {
    a2._valueTracker || (a2._valueTracker = Ua(a2));
  }
  function Wa(a2) {
    if (!a2) return false;
    var b2 = a2._valueTracker;
    if (!b2) return true;
    var c2 = b2.getValue();
    var d2 = "";
    a2 && (d2 = Ta(a2) ? a2.checked ? "true" : "false" : a2.value);
    a2 = d2;
    return a2 !== c2 ? (b2.setValue(a2), true) : false;
  }
  function Xa(a2) {
    a2 = a2 || ("undefined" !== typeof document ? document : void 0);
    if ("undefined" === typeof a2) return null;
    try {
      return a2.activeElement || a2.body;
    } catch (b2) {
      return a2.body;
    }
  }
  function Ya(a2, b2) {
    var c2 = b2.checked;
    return A({}, b2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c2 ? c2 : a2._wrapperState.initialChecked });
  }
  function Za(a2, b2) {
    var c2 = null == b2.defaultValue ? "" : b2.defaultValue, d2 = null != b2.checked ? b2.checked : b2.defaultChecked;
    c2 = Sa(null != b2.value ? b2.value : c2);
    a2._wrapperState = { initialChecked: d2, initialValue: c2, controlled: "checkbox" === b2.type || "radio" === b2.type ? null != b2.checked : null != b2.value };
  }
  function ab(a2, b2) {
    b2 = b2.checked;
    null != b2 && ta(a2, "checked", b2, false);
  }
  function bb(a2, b2) {
    ab(a2, b2);
    var c2 = Sa(b2.value), d2 = b2.type;
    if (null != c2) if ("number" === d2) {
      if (0 === c2 && "" === a2.value || a2.value != c2) a2.value = "" + c2;
    } else a2.value !== "" + c2 && (a2.value = "" + c2);
    else if ("submit" === d2 || "reset" === d2) {
      a2.removeAttribute("value");
      return;
    }
    b2.hasOwnProperty("value") ? cb(a2, b2.type, c2) : b2.hasOwnProperty("defaultValue") && cb(a2, b2.type, Sa(b2.defaultValue));
    null == b2.checked && null != b2.defaultChecked && (a2.defaultChecked = !!b2.defaultChecked);
  }
  function db(a2, b2, c2) {
    if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
      var d2 = b2.type;
      if (!("submit" !== d2 && "reset" !== d2 || void 0 !== b2.value && null !== b2.value)) return;
      b2 = "" + a2._wrapperState.initialValue;
      c2 || b2 === a2.value || (a2.value = b2);
      a2.defaultValue = b2;
    }
    c2 = a2.name;
    "" !== c2 && (a2.name = "");
    a2.defaultChecked = !!a2._wrapperState.initialChecked;
    "" !== c2 && (a2.name = c2);
  }
  function cb(a2, b2, c2) {
    if ("number" !== b2 || Xa(a2.ownerDocument) !== a2) null == c2 ? a2.defaultValue = "" + a2._wrapperState.initialValue : a2.defaultValue !== "" + c2 && (a2.defaultValue = "" + c2);
  }
  var eb = Array.isArray;
  function fb(a2, b2, c2, d2) {
    a2 = a2.options;
    if (b2) {
      b2 = {};
      for (var e2 = 0; e2 < c2.length; e2++) b2["$" + c2[e2]] = true;
      for (c2 = 0; c2 < a2.length; c2++) e2 = b2.hasOwnProperty("$" + a2[c2].value), a2[c2].selected !== e2 && (a2[c2].selected = e2), e2 && d2 && (a2[c2].defaultSelected = true);
    } else {
      c2 = "" + Sa(c2);
      b2 = null;
      for (e2 = 0; e2 < a2.length; e2++) {
        if (a2[e2].value === c2) {
          a2[e2].selected = true;
          d2 && (a2[e2].defaultSelected = true);
          return;
        }
        null !== b2 || a2[e2].disabled || (b2 = a2[e2]);
      }
      null !== b2 && (b2.selected = true);
    }
  }
  function gb(a2, b2) {
    if (null != b2.dangerouslySetInnerHTML) throw Error(p2(91));
    return A({}, b2, { value: void 0, defaultValue: void 0, children: "" + a2._wrapperState.initialValue });
  }
  function hb(a2, b2) {
    var c2 = b2.value;
    if (null == c2) {
      c2 = b2.children;
      b2 = b2.defaultValue;
      if (null != c2) {
        if (null != b2) throw Error(p2(92));
        if (eb(c2)) {
          if (1 < c2.length) throw Error(p2(93));
          c2 = c2[0];
        }
        b2 = c2;
      }
      null == b2 && (b2 = "");
      c2 = b2;
    }
    a2._wrapperState = { initialValue: Sa(c2) };
  }
  function ib(a2, b2) {
    var c2 = Sa(b2.value), d2 = Sa(b2.defaultValue);
    null != c2 && (c2 = "" + c2, c2 !== a2.value && (a2.value = c2), null == b2.defaultValue && a2.defaultValue !== c2 && (a2.defaultValue = c2));
    null != d2 && (a2.defaultValue = "" + d2);
  }
  function jb(a2) {
    var b2 = a2.textContent;
    b2 === a2._wrapperState.initialValue && "" !== b2 && null !== b2 && (a2.value = b2);
  }
  function kb(a2) {
    switch (a2) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function lb(a2, b2) {
    return null == a2 || "http://www.w3.org/1999/xhtml" === a2 ? kb(b2) : "http://www.w3.org/2000/svg" === a2 && "foreignObject" === b2 ? "http://www.w3.org/1999/xhtml" : a2;
  }
  var mb, nb = (function(a2) {
    return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b2, c2, d2, e2) {
      MSApp.execUnsafeLocalFunction(function() {
        return a2(b2, c2, d2, e2);
      });
    } : a2;
  })(function(a2, b2) {
    if ("http://www.w3.org/2000/svg" !== a2.namespaceURI || "innerHTML" in a2) a2.innerHTML = b2;
    else {
      mb = mb || document.createElement("div");
      mb.innerHTML = "<svg>" + b2.valueOf().toString() + "</svg>";
      for (b2 = mb.firstChild; a2.firstChild; ) a2.removeChild(a2.firstChild);
      for (; b2.firstChild; ) a2.appendChild(b2.firstChild);
    }
  });
  function ob(a2, b2) {
    if (b2) {
      var c2 = a2.firstChild;
      if (c2 && c2 === a2.lastChild && 3 === c2.nodeType) {
        c2.nodeValue = b2;
        return;
      }
    }
    a2.textContent = b2;
  }
  var pb = {
    animationIterationCount: true,
    aspectRatio: true,
    borderImageOutset: true,
    borderImageSlice: true,
    borderImageWidth: true,
    boxFlex: true,
    boxFlexGroup: true,
    boxOrdinalGroup: true,
    columnCount: true,
    columns: true,
    flex: true,
    flexGrow: true,
    flexPositive: true,
    flexShrink: true,
    flexNegative: true,
    flexOrder: true,
    gridArea: true,
    gridRow: true,
    gridRowEnd: true,
    gridRowSpan: true,
    gridRowStart: true,
    gridColumn: true,
    gridColumnEnd: true,
    gridColumnSpan: true,
    gridColumnStart: true,
    fontWeight: true,
    lineClamp: true,
    lineHeight: true,
    opacity: true,
    order: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,
    fillOpacity: true,
    floodOpacity: true,
    stopOpacity: true,
    strokeDasharray: true,
    strokeDashoffset: true,
    strokeMiterlimit: true,
    strokeOpacity: true,
    strokeWidth: true
  }, qb = ["Webkit", "ms", "Moz", "O"];
  Object.keys(pb).forEach(function(a2) {
    qb.forEach(function(b2) {
      b2 = b2 + a2.charAt(0).toUpperCase() + a2.substring(1);
      pb[b2] = pb[a2];
    });
  });
  function rb(a2, b2, c2) {
    return null == b2 || "boolean" === typeof b2 || "" === b2 ? "" : c2 || "number" !== typeof b2 || 0 === b2 || pb.hasOwnProperty(a2) && pb[a2] ? ("" + b2).trim() : b2 + "px";
  }
  function sb(a2, b2) {
    a2 = a2.style;
    for (var c2 in b2) if (b2.hasOwnProperty(c2)) {
      var d2 = 0 === c2.indexOf("--"), e2 = rb(c2, b2[c2], d2);
      "float" === c2 && (c2 = "cssFloat");
      d2 ? a2.setProperty(c2, e2) : a2[c2] = e2;
    }
  }
  var tb = A({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
  function ub(a2, b2) {
    if (b2) {
      if (tb[a2] && (null != b2.children || null != b2.dangerouslySetInnerHTML)) throw Error(p2(137, a2));
      if (null != b2.dangerouslySetInnerHTML) {
        if (null != b2.children) throw Error(p2(60));
        if ("object" !== typeof b2.dangerouslySetInnerHTML || !("__html" in b2.dangerouslySetInnerHTML)) throw Error(p2(61));
      }
      if (null != b2.style && "object" !== typeof b2.style) throw Error(p2(62));
    }
  }
  function vb(a2, b2) {
    if (-1 === a2.indexOf("-")) return "string" === typeof b2.is;
    switch (a2) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return false;
      default:
        return true;
    }
  }
  var wb = null;
  function xb(a2) {
    a2 = a2.target || a2.srcElement || window;
    a2.correspondingUseElement && (a2 = a2.correspondingUseElement);
    return 3 === a2.nodeType ? a2.parentNode : a2;
  }
  var yb = null, zb = null, Ab = null;
  function Bb(a2) {
    if (a2 = Cb(a2)) {
      if ("function" !== typeof yb) throw Error(p2(280));
      var b2 = a2.stateNode;
      b2 && (b2 = Db(b2), yb(a2.stateNode, a2.type, b2));
    }
  }
  function Eb(a2) {
    zb ? Ab ? Ab.push(a2) : Ab = [a2] : zb = a2;
  }
  function Fb() {
    if (zb) {
      var a2 = zb, b2 = Ab;
      Ab = zb = null;
      Bb(a2);
      if (b2) for (a2 = 0; a2 < b2.length; a2++) Bb(b2[a2]);
    }
  }
  function Gb(a2, b2) {
    return a2(b2);
  }
  function Hb() {
  }
  var Ib = false;
  function Jb(a2, b2, c2) {
    if (Ib) return a2(b2, c2);
    Ib = true;
    try {
      return Gb(a2, b2, c2);
    } finally {
      if (Ib = false, null !== zb || null !== Ab) Hb(), Fb();
    }
  }
  function Kb(a2, b2) {
    var c2 = a2.stateNode;
    if (null === c2) return null;
    var d2 = Db(c2);
    if (null === d2) return null;
    c2 = d2[b2];
    a: switch (b2) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d2 = !d2.disabled) || (a2 = a2.type, d2 = !("button" === a2 || "input" === a2 || "select" === a2 || "textarea" === a2));
        a2 = !d2;
        break a;
      default:
        a2 = false;
    }
    if (a2) return null;
    if (c2 && "function" !== typeof c2) throw Error(p2(231, b2, typeof c2));
    return c2;
  }
  var Lb = false;
  if (ia) try {
    var Mb = {};
    Object.defineProperty(Mb, "passive", { get: function() {
      Lb = true;
    } });
    window.addEventListener("test", Mb, Mb);
    window.removeEventListener("test", Mb, Mb);
  } catch (a2) {
    Lb = false;
  }
  function Nb(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
    var l2 = Array.prototype.slice.call(arguments, 3);
    try {
      b2.apply(c2, l2);
    } catch (m2) {
      this.onError(m2);
    }
  }
  var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a2) {
    Ob = true;
    Pb = a2;
  } };
  function Tb(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
    Ob = false;
    Pb = null;
    Nb.apply(Sb, arguments);
  }
  function Ub(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
    Tb.apply(this, arguments);
    if (Ob) {
      if (Ob) {
        var l2 = Pb;
        Ob = false;
        Pb = null;
      } else throw Error(p2(198));
      Qb || (Qb = true, Rb = l2);
    }
  }
  function Vb(a2) {
    var b2 = a2, c2 = a2;
    if (a2.alternate) for (; b2.return; ) b2 = b2.return;
    else {
      a2 = b2;
      do
        b2 = a2, 0 !== (b2.flags & 4098) && (c2 = b2.return), a2 = b2.return;
      while (a2);
    }
    return 3 === b2.tag ? c2 : null;
  }
  function Wb(a2) {
    if (13 === a2.tag) {
      var b2 = a2.memoizedState;
      null === b2 && (a2 = a2.alternate, null !== a2 && (b2 = a2.memoizedState));
      if (null !== b2) return b2.dehydrated;
    }
    return null;
  }
  function Xb(a2) {
    if (Vb(a2) !== a2) throw Error(p2(188));
  }
  function Yb(a2) {
    var b2 = a2.alternate;
    if (!b2) {
      b2 = Vb(a2);
      if (null === b2) throw Error(p2(188));
      return b2 !== a2 ? null : a2;
    }
    for (var c2 = a2, d2 = b2; ; ) {
      var e2 = c2.return;
      if (null === e2) break;
      var f2 = e2.alternate;
      if (null === f2) {
        d2 = e2.return;
        if (null !== d2) {
          c2 = d2;
          continue;
        }
        break;
      }
      if (e2.child === f2.child) {
        for (f2 = e2.child; f2; ) {
          if (f2 === c2) return Xb(e2), a2;
          if (f2 === d2) return Xb(e2), b2;
          f2 = f2.sibling;
        }
        throw Error(p2(188));
      }
      if (c2.return !== d2.return) c2 = e2, d2 = f2;
      else {
        for (var g2 = false, h2 = e2.child; h2; ) {
          if (h2 === c2) {
            g2 = true;
            c2 = e2;
            d2 = f2;
            break;
          }
          if (h2 === d2) {
            g2 = true;
            d2 = e2;
            c2 = f2;
            break;
          }
          h2 = h2.sibling;
        }
        if (!g2) {
          for (h2 = f2.child; h2; ) {
            if (h2 === c2) {
              g2 = true;
              c2 = f2;
              d2 = e2;
              break;
            }
            if (h2 === d2) {
              g2 = true;
              d2 = f2;
              c2 = e2;
              break;
            }
            h2 = h2.sibling;
          }
          if (!g2) throw Error(p2(189));
        }
      }
      if (c2.alternate !== d2) throw Error(p2(190));
    }
    if (3 !== c2.tag) throw Error(p2(188));
    return c2.stateNode.current === c2 ? a2 : b2;
  }
  function Zb(a2) {
    a2 = Yb(a2);
    return null !== a2 ? $b(a2) : null;
  }
  function $b(a2) {
    if (5 === a2.tag || 6 === a2.tag) return a2;
    for (a2 = a2.child; null !== a2; ) {
      var b2 = $b(a2);
      if (null !== b2) return b2;
      a2 = a2.sibling;
    }
    return null;
  }
  var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
  function mc(a2) {
    if (lc && "function" === typeof lc.onCommitFiberRoot) try {
      lc.onCommitFiberRoot(kc, a2, void 0, 128 === (a2.current.flags & 128));
    } catch (b2) {
    }
  }
  var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
  function nc(a2) {
    a2 >>>= 0;
    return 0 === a2 ? 32 : 31 - (pc(a2) / qc | 0) | 0;
  }
  var rc = 64, sc = 4194304;
  function tc(a2) {
    switch (a2 & -a2) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return a2 & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return a2 & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return a2;
    }
  }
  function uc(a2, b2) {
    var c2 = a2.pendingLanes;
    if (0 === c2) return 0;
    var d2 = 0, e2 = a2.suspendedLanes, f2 = a2.pingedLanes, g2 = c2 & 268435455;
    if (0 !== g2) {
      var h2 = g2 & ~e2;
      0 !== h2 ? d2 = tc(h2) : (f2 &= g2, 0 !== f2 && (d2 = tc(f2)));
    } else g2 = c2 & ~e2, 0 !== g2 ? d2 = tc(g2) : 0 !== f2 && (d2 = tc(f2));
    if (0 === d2) return 0;
    if (0 !== b2 && b2 !== d2 && 0 === (b2 & e2) && (e2 = d2 & -d2, f2 = b2 & -b2, e2 >= f2 || 16 === e2 && 0 !== (f2 & 4194240))) return b2;
    0 !== (d2 & 4) && (d2 |= c2 & 16);
    b2 = a2.entangledLanes;
    if (0 !== b2) for (a2 = a2.entanglements, b2 &= d2; 0 < b2; ) c2 = 31 - oc(b2), e2 = 1 << c2, d2 |= a2[c2], b2 &= ~e2;
    return d2;
  }
  function vc(a2, b2) {
    switch (a2) {
      case 1:
      case 2:
      case 4:
        return b2 + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return b2 + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function wc(a2, b2) {
    for (var c2 = a2.suspendedLanes, d2 = a2.pingedLanes, e2 = a2.expirationTimes, f2 = a2.pendingLanes; 0 < f2; ) {
      var g2 = 31 - oc(f2), h2 = 1 << g2, k2 = e2[g2];
      if (-1 === k2) {
        if (0 === (h2 & c2) || 0 !== (h2 & d2)) e2[g2] = vc(h2, b2);
      } else k2 <= b2 && (a2.expiredLanes |= h2);
      f2 &= ~h2;
    }
  }
  function xc(a2) {
    a2 = a2.pendingLanes & -1073741825;
    return 0 !== a2 ? a2 : a2 & 1073741824 ? 1073741824 : 0;
  }
  function yc() {
    var a2 = rc;
    rc <<= 1;
    0 === (rc & 4194240) && (rc = 64);
    return a2;
  }
  function zc(a2) {
    for (var b2 = [], c2 = 0; 31 > c2; c2++) b2.push(a2);
    return b2;
  }
  function Ac(a2, b2, c2) {
    a2.pendingLanes |= b2;
    536870912 !== b2 && (a2.suspendedLanes = 0, a2.pingedLanes = 0);
    a2 = a2.eventTimes;
    b2 = 31 - oc(b2);
    a2[b2] = c2;
  }
  function Bc(a2, b2) {
    var c2 = a2.pendingLanes & ~b2;
    a2.pendingLanes = b2;
    a2.suspendedLanes = 0;
    a2.pingedLanes = 0;
    a2.expiredLanes &= b2;
    a2.mutableReadLanes &= b2;
    a2.entangledLanes &= b2;
    b2 = a2.entanglements;
    var d2 = a2.eventTimes;
    for (a2 = a2.expirationTimes; 0 < c2; ) {
      var e2 = 31 - oc(c2), f2 = 1 << e2;
      b2[e2] = 0;
      d2[e2] = -1;
      a2[e2] = -1;
      c2 &= ~f2;
    }
  }
  function Cc(a2, b2) {
    var c2 = a2.entangledLanes |= b2;
    for (a2 = a2.entanglements; c2; ) {
      var d2 = 31 - oc(c2), e2 = 1 << d2;
      e2 & b2 | a2[d2] & b2 && (a2[d2] |= b2);
      c2 &= ~e2;
    }
  }
  var C = 0;
  function Dc(a2) {
    a2 &= -a2;
    return 1 < a2 ? 4 < a2 ? 0 !== (a2 & 268435455) ? 16 : 536870912 : 4 : 1;
  }
  var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function Sc(a2, b2) {
    switch (a2) {
      case "focusin":
      case "focusout":
        Lc = null;
        break;
      case "dragenter":
      case "dragleave":
        Mc = null;
        break;
      case "mouseover":
      case "mouseout":
        Nc = null;
        break;
      case "pointerover":
      case "pointerout":
        Oc.delete(b2.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Pc.delete(b2.pointerId);
    }
  }
  function Tc(a2, b2, c2, d2, e2, f2) {
    if (null === a2 || a2.nativeEvent !== f2) return a2 = { blockedOn: b2, domEventName: c2, eventSystemFlags: d2, nativeEvent: f2, targetContainers: [e2] }, null !== b2 && (b2 = Cb(b2), null !== b2 && Fc(b2)), a2;
    a2.eventSystemFlags |= d2;
    b2 = a2.targetContainers;
    null !== e2 && -1 === b2.indexOf(e2) && b2.push(e2);
    return a2;
  }
  function Uc(a2, b2, c2, d2, e2) {
    switch (b2) {
      case "focusin":
        return Lc = Tc(Lc, a2, b2, c2, d2, e2), true;
      case "dragenter":
        return Mc = Tc(Mc, a2, b2, c2, d2, e2), true;
      case "mouseover":
        return Nc = Tc(Nc, a2, b2, c2, d2, e2), true;
      case "pointerover":
        var f2 = e2.pointerId;
        Oc.set(f2, Tc(Oc.get(f2) || null, a2, b2, c2, d2, e2));
        return true;
      case "gotpointercapture":
        return f2 = e2.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a2, b2, c2, d2, e2)), true;
    }
    return false;
  }
  function Vc(a2) {
    var b2 = Wc(a2.target);
    if (null !== b2) {
      var c2 = Vb(b2);
      if (null !== c2) {
        if (b2 = c2.tag, 13 === b2) {
          if (b2 = Wb(c2), null !== b2) {
            a2.blockedOn = b2;
            Ic(a2.priority, function() {
              Gc(c2);
            });
            return;
          }
        } else if (3 === b2 && c2.stateNode.current.memoizedState.isDehydrated) {
          a2.blockedOn = 3 === c2.tag ? c2.stateNode.containerInfo : null;
          return;
        }
      }
    }
    a2.blockedOn = null;
  }
  function Xc(a2) {
    if (null !== a2.blockedOn) return false;
    for (var b2 = a2.targetContainers; 0 < b2.length; ) {
      var c2 = Yc(a2.domEventName, a2.eventSystemFlags, b2[0], a2.nativeEvent);
      if (null === c2) {
        c2 = a2.nativeEvent;
        var d2 = new c2.constructor(c2.type, c2);
        wb = d2;
        c2.target.dispatchEvent(d2);
        wb = null;
      } else return b2 = Cb(c2), null !== b2 && Fc(b2), a2.blockedOn = c2, false;
      b2.shift();
    }
    return true;
  }
  function Zc(a2, b2, c2) {
    Xc(a2) && c2.delete(b2);
  }
  function $c() {
    Jc = false;
    null !== Lc && Xc(Lc) && (Lc = null);
    null !== Mc && Xc(Mc) && (Mc = null);
    null !== Nc && Xc(Nc) && (Nc = null);
    Oc.forEach(Zc);
    Pc.forEach(Zc);
  }
  function ad(a2, b2) {
    a2.blockedOn === b2 && (a2.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
  }
  function bd(a2) {
    function b2(b3) {
      return ad(b3, a2);
    }
    if (0 < Kc.length) {
      ad(Kc[0], a2);
      for (var c2 = 1; c2 < Kc.length; c2++) {
        var d2 = Kc[c2];
        d2.blockedOn === a2 && (d2.blockedOn = null);
      }
    }
    null !== Lc && ad(Lc, a2);
    null !== Mc && ad(Mc, a2);
    null !== Nc && ad(Nc, a2);
    Oc.forEach(b2);
    Pc.forEach(b2);
    for (c2 = 0; c2 < Qc.length; c2++) d2 = Qc[c2], d2.blockedOn === a2 && (d2.blockedOn = null);
    for (; 0 < Qc.length && (c2 = Qc[0], null === c2.blockedOn); ) Vc(c2), null === c2.blockedOn && Qc.shift();
  }
  var cd = ua.ReactCurrentBatchConfig, dd = true;
  function ed(a2, b2, c2, d2) {
    var e2 = C, f2 = cd.transition;
    cd.transition = null;
    try {
      C = 1, fd(a2, b2, c2, d2);
    } finally {
      C = e2, cd.transition = f2;
    }
  }
  function gd(a2, b2, c2, d2) {
    var e2 = C, f2 = cd.transition;
    cd.transition = null;
    try {
      C = 4, fd(a2, b2, c2, d2);
    } finally {
      C = e2, cd.transition = f2;
    }
  }
  function fd(a2, b2, c2, d2) {
    if (dd) {
      var e2 = Yc(a2, b2, c2, d2);
      if (null === e2) hd(a2, b2, d2, id2, c2), Sc(a2, d2);
      else if (Uc(e2, a2, b2, c2, d2)) d2.stopPropagation();
      else if (Sc(a2, d2), b2 & 4 && -1 < Rc.indexOf(a2)) {
        for (; null !== e2; ) {
          var f2 = Cb(e2);
          null !== f2 && Ec(f2);
          f2 = Yc(a2, b2, c2, d2);
          null === f2 && hd(a2, b2, d2, id2, c2);
          if (f2 === e2) break;
          e2 = f2;
        }
        null !== e2 && d2.stopPropagation();
      } else hd(a2, b2, d2, null, c2);
    }
  }
  var id2 = null;
  function Yc(a2, b2, c2, d2) {
    id2 = null;
    a2 = xb(d2);
    a2 = Wc(a2);
    if (null !== a2) if (b2 = Vb(a2), null === b2) a2 = null;
    else if (c2 = b2.tag, 13 === c2) {
      a2 = Wb(b2);
      if (null !== a2) return a2;
      a2 = null;
    } else if (3 === c2) {
      if (b2.stateNode.current.memoizedState.isDehydrated) return 3 === b2.tag ? b2.stateNode.containerInfo : null;
      a2 = null;
    } else b2 !== a2 && (a2 = null);
    id2 = a2;
    return null;
  }
  function jd(a2) {
    switch (a2) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (ec()) {
          case fc:
            return 1;
          case gc:
            return 4;
          case hc:
          case ic:
            return 16;
          case jc:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var kd = null, ld = null, md = null;
  function nd() {
    if (md) return md;
    var a2, b2 = ld, c2 = b2.length, d2, e2 = "value" in kd ? kd.value : kd.textContent, f2 = e2.length;
    for (a2 = 0; a2 < c2 && b2[a2] === e2[a2]; a2++) ;
    var g2 = c2 - a2;
    for (d2 = 1; d2 <= g2 && b2[c2 - d2] === e2[f2 - d2]; d2++) ;
    return md = e2.slice(a2, 1 < d2 ? 1 - d2 : void 0);
  }
  function od(a2) {
    var b2 = a2.keyCode;
    "charCode" in a2 ? (a2 = a2.charCode, 0 === a2 && 13 === b2 && (a2 = 13)) : a2 = b2;
    10 === a2 && (a2 = 13);
    return 32 <= a2 || 13 === a2 ? a2 : 0;
  }
  function pd() {
    return true;
  }
  function qd() {
    return false;
  }
  function rd(a2) {
    function b2(b3, d2, e2, f2, g2) {
      this._reactName = b3;
      this._targetInst = e2;
      this.type = d2;
      this.nativeEvent = f2;
      this.target = g2;
      this.currentTarget = null;
      for (var c2 in a2) a2.hasOwnProperty(c2) && (b3 = a2[c2], this[c2] = b3 ? b3(f2) : f2[c2]);
      this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
      this.isPropagationStopped = qd;
      return this;
    }
    A(b2.prototype, { preventDefault: function() {
      this.defaultPrevented = true;
      var a3 = this.nativeEvent;
      a3 && (a3.preventDefault ? a3.preventDefault() : "unknown" !== typeof a3.returnValue && (a3.returnValue = false), this.isDefaultPrevented = pd);
    }, stopPropagation: function() {
      var a3 = this.nativeEvent;
      a3 && (a3.stopPropagation ? a3.stopPropagation() : "unknown" !== typeof a3.cancelBubble && (a3.cancelBubble = true), this.isPropagationStopped = pd);
    }, persist: function() {
    }, isPersistent: pd });
    return b2;
  }
  var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a2) {
    return a2.timeStamp || Date.now();
  }, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a2) {
    return void 0 === a2.relatedTarget ? a2.fromElement === a2.srcElement ? a2.toElement : a2.fromElement : a2.relatedTarget;
  }, movementX: function(a2) {
    if ("movementX" in a2) return a2.movementX;
    a2 !== yd && (yd && "mousemove" === a2.type ? (wd = a2.screenX - yd.screenX, xd = a2.screenY - yd.screenY) : xd = wd = 0, yd = a2);
    return wd;
  }, movementY: function(a2) {
    return "movementY" in a2 ? a2.movementY : xd;
  } }), Bd = rd(Ad), Cd = A({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A({}, sd, { clipboardData: function(a2) {
    return "clipboardData" in a2 ? a2.clipboardData : window.clipboardData;
  } }), Jd = rd(Id), Kd = A({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, Nd = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
  function Pd(a2) {
    var b2 = this.nativeEvent;
    return b2.getModifierState ? b2.getModifierState(a2) : (a2 = Od[a2]) ? !!b2[a2] : false;
  }
  function zd() {
    return Pd;
  }
  var Qd = A({}, ud, { key: function(a2) {
    if (a2.key) {
      var b2 = Md[a2.key] || a2.key;
      if ("Unidentified" !== b2) return b2;
    }
    return "keypress" === a2.type ? (a2 = od(a2), 13 === a2 ? "Enter" : String.fromCharCode(a2)) : "keydown" === a2.type || "keyup" === a2.type ? Nd[a2.keyCode] || "Unidentified" : "";
  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a2) {
    return "keypress" === a2.type ? od(a2) : 0;
  }, keyCode: function(a2) {
    return "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
  }, which: function(a2) {
    return "keypress" === a2.type ? od(a2) : "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
  } }), Rd = rd(Qd), Sd = A({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A({}, Ad, {
    deltaX: function(a2) {
      return "deltaX" in a2 ? a2.deltaX : "wheelDeltaX" in a2 ? -a2.wheelDeltaX : 0;
    },
    deltaY: function(a2) {
      return "deltaY" in a2 ? a2.deltaY : "wheelDeltaY" in a2 ? -a2.wheelDeltaY : "wheelDelta" in a2 ? -a2.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = ia && "CompositionEvent" in window, be = null;
  ia && "documentMode" in document && (be = document.documentMode);
  var ce = ia && "TextEvent" in window && !be, de = ia && (!ae || be && 8 < be && 11 >= be), ee = String.fromCharCode(32), fe = false;
  function ge(a2, b2) {
    switch (a2) {
      case "keyup":
        return -1 !== $d.indexOf(b2.keyCode);
      case "keydown":
        return 229 !== b2.keyCode;
      case "keypress":
      case "mousedown":
      case "focusout":
        return true;
      default:
        return false;
    }
  }
  function he(a2) {
    a2 = a2.detail;
    return "object" === typeof a2 && "data" in a2 ? a2.data : null;
  }
  var ie = false;
  function je(a2, b2) {
    switch (a2) {
      case "compositionend":
        return he(b2);
      case "keypress":
        if (32 !== b2.which) return null;
        fe = true;
        return ee;
      case "textInput":
        return a2 = b2.data, a2 === ee && fe ? null : a2;
      default:
        return null;
    }
  }
  function ke(a2, b2) {
    if (ie) return "compositionend" === a2 || !ae && ge(a2, b2) ? (a2 = nd(), md = ld = kd = null, ie = false, a2) : null;
    switch (a2) {
      case "paste":
        return null;
      case "keypress":
        if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
          if (b2.char && 1 < b2.char.length) return b2.char;
          if (b2.which) return String.fromCharCode(b2.which);
        }
        return null;
      case "compositionend":
        return de && "ko" !== b2.locale ? null : b2.data;
      default:
        return null;
    }
  }
  var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
  function me(a2) {
    var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
    return "input" === b2 ? !!le[a2.type] : "textarea" === b2 ? true : false;
  }
  function ne(a2, b2, c2, d2) {
    Eb(d2);
    b2 = oe(b2, "onChange");
    0 < b2.length && (c2 = new td("onChange", "change", null, c2, d2), a2.push({ event: c2, listeners: b2 }));
  }
  var pe = null, qe = null;
  function re(a2) {
    se(a2, 0);
  }
  function te(a2) {
    var b2 = ue(a2);
    if (Wa(b2)) return a2;
  }
  function ve(a2, b2) {
    if ("change" === a2) return b2;
  }
  var we = false;
  if (ia) {
    var xe;
    if (ia) {
      var ye = "oninput" in document;
      if (!ye) {
        var ze = document.createElement("div");
        ze.setAttribute("oninput", "return;");
        ye = "function" === typeof ze.oninput;
      }
      xe = ye;
    } else xe = false;
    we = xe && (!document.documentMode || 9 < document.documentMode);
  }
  function Ae() {
    pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
  }
  function Be(a2) {
    if ("value" === a2.propertyName && te(qe)) {
      var b2 = [];
      ne(b2, qe, a2, xb(a2));
      Jb(re, b2);
    }
  }
  function Ce(a2, b2, c2) {
    "focusin" === a2 ? (Ae(), pe = b2, qe = c2, pe.attachEvent("onpropertychange", Be)) : "focusout" === a2 && Ae();
  }
  function De(a2) {
    if ("selectionchange" === a2 || "keyup" === a2 || "keydown" === a2) return te(qe);
  }
  function Ee(a2, b2) {
    if ("click" === a2) return te(b2);
  }
  function Fe(a2, b2) {
    if ("input" === a2 || "change" === a2) return te(b2);
  }
  function Ge(a2, b2) {
    return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
  }
  var He = "function" === typeof Object.is ? Object.is : Ge;
  function Ie(a2, b2) {
    if (He(a2, b2)) return true;
    if ("object" !== typeof a2 || null === a2 || "object" !== typeof b2 || null === b2) return false;
    var c2 = Object.keys(a2), d2 = Object.keys(b2);
    if (c2.length !== d2.length) return false;
    for (d2 = 0; d2 < c2.length; d2++) {
      var e2 = c2[d2];
      if (!ja.call(b2, e2) || !He(a2[e2], b2[e2])) return false;
    }
    return true;
  }
  function Je(a2) {
    for (; a2 && a2.firstChild; ) a2 = a2.firstChild;
    return a2;
  }
  function Ke(a2, b2) {
    var c2 = Je(a2);
    a2 = 0;
    for (var d2; c2; ) {
      if (3 === c2.nodeType) {
        d2 = a2 + c2.textContent.length;
        if (a2 <= b2 && d2 >= b2) return { node: c2, offset: b2 - a2 };
        a2 = d2;
      }
      a: {
        for (; c2; ) {
          if (c2.nextSibling) {
            c2 = c2.nextSibling;
            break a;
          }
          c2 = c2.parentNode;
        }
        c2 = void 0;
      }
      c2 = Je(c2);
    }
  }
  function Le(a2, b2) {
    return a2 && b2 ? a2 === b2 ? true : a2 && 3 === a2.nodeType ? false : b2 && 3 === b2.nodeType ? Le(a2, b2.parentNode) : "contains" in a2 ? a2.contains(b2) : a2.compareDocumentPosition ? !!(a2.compareDocumentPosition(b2) & 16) : false : false;
  }
  function Me() {
    for (var a2 = window, b2 = Xa(); b2 instanceof a2.HTMLIFrameElement; ) {
      try {
        var c2 = "string" === typeof b2.contentWindow.location.href;
      } catch (d2) {
        c2 = false;
      }
      if (c2) a2 = b2.contentWindow;
      else break;
      b2 = Xa(a2.document);
    }
    return b2;
  }
  function Ne(a2) {
    var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
    return b2 && ("input" === b2 && ("text" === a2.type || "search" === a2.type || "tel" === a2.type || "url" === a2.type || "password" === a2.type) || "textarea" === b2 || "true" === a2.contentEditable);
  }
  function Oe(a2) {
    var b2 = Me(), c2 = a2.focusedElem, d2 = a2.selectionRange;
    if (b2 !== c2 && c2 && c2.ownerDocument && Le(c2.ownerDocument.documentElement, c2)) {
      if (null !== d2 && Ne(c2)) {
        if (b2 = d2.start, a2 = d2.end, void 0 === a2 && (a2 = b2), "selectionStart" in c2) c2.selectionStart = b2, c2.selectionEnd = Math.min(a2, c2.value.length);
        else if (a2 = (b2 = c2.ownerDocument || document) && b2.defaultView || window, a2.getSelection) {
          a2 = a2.getSelection();
          var e2 = c2.textContent.length, f2 = Math.min(d2.start, e2);
          d2 = void 0 === d2.end ? f2 : Math.min(d2.end, e2);
          !a2.extend && f2 > d2 && (e2 = d2, d2 = f2, f2 = e2);
          e2 = Ke(c2, f2);
          var g2 = Ke(
            c2,
            d2
          );
          e2 && g2 && (1 !== a2.rangeCount || a2.anchorNode !== e2.node || a2.anchorOffset !== e2.offset || a2.focusNode !== g2.node || a2.focusOffset !== g2.offset) && (b2 = b2.createRange(), b2.setStart(e2.node, e2.offset), a2.removeAllRanges(), f2 > d2 ? (a2.addRange(b2), a2.extend(g2.node, g2.offset)) : (b2.setEnd(g2.node, g2.offset), a2.addRange(b2)));
        }
      }
      b2 = [];
      for (a2 = c2; a2 = a2.parentNode; ) 1 === a2.nodeType && b2.push({ element: a2, left: a2.scrollLeft, top: a2.scrollTop });
      "function" === typeof c2.focus && c2.focus();
      for (c2 = 0; c2 < b2.length; c2++) a2 = b2[c2], a2.element.scrollLeft = a2.left, a2.element.scrollTop = a2.top;
    }
  }
  var Pe = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = false;
  function Ue(a2, b2, c2) {
    var d2 = c2.window === c2 ? c2.document : 9 === c2.nodeType ? c2 : c2.ownerDocument;
    Te || null == Qe || Qe !== Xa(d2) || (d2 = Qe, "selectionStart" in d2 && Ne(d2) ? d2 = { start: d2.selectionStart, end: d2.selectionEnd } : (d2 = (d2.ownerDocument && d2.ownerDocument.defaultView || window).getSelection(), d2 = { anchorNode: d2.anchorNode, anchorOffset: d2.anchorOffset, focusNode: d2.focusNode, focusOffset: d2.focusOffset }), Se && Ie(Se, d2) || (Se = d2, d2 = oe(Re, "onSelect"), 0 < d2.length && (b2 = new td("onSelect", "select", null, b2, c2), a2.push({ event: b2, listeners: d2 }), b2.target = Qe)));
  }
  function Ve(a2, b2) {
    var c2 = {};
    c2[a2.toLowerCase()] = b2.toLowerCase();
    c2["Webkit" + a2] = "webkit" + b2;
    c2["Moz" + a2] = "moz" + b2;
    return c2;
  }
  var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") }, Xe = {}, Ye = {};
  ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
  function Ze(a2) {
    if (Xe[a2]) return Xe[a2];
    if (!We[a2]) return a2;
    var b2 = We[a2], c2;
    for (c2 in b2) if (b2.hasOwnProperty(c2) && c2 in Ye) return Xe[a2] = b2[c2];
    return a2;
  }
  var $e = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function ff(a2, b2) {
    df.set(a2, b2);
    fa(b2, [a2]);
  }
  for (var gf = 0; gf < ef.length; gf++) {
    var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
    ff(jf, "on" + kf);
  }
  ff($e, "onAnimationEnd");
  ff(af, "onAnimationIteration");
  ff(bf, "onAnimationStart");
  ff("dblclick", "onDoubleClick");
  ff("focusin", "onFocus");
  ff("focusout", "onBlur");
  ff(cf, "onTransitionEnd");
  ha("onMouseEnter", ["mouseout", "mouseover"]);
  ha("onMouseLeave", ["mouseout", "mouseover"]);
  ha("onPointerEnter", ["pointerout", "pointerover"]);
  ha("onPointerLeave", ["pointerout", "pointerover"]);
  fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
  fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
  fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
  fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
  fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
  fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
  function nf(a2, b2, c2) {
    var d2 = a2.type || "unknown-event";
    a2.currentTarget = c2;
    Ub(d2, b2, void 0, a2);
    a2.currentTarget = null;
  }
  function se(a2, b2) {
    b2 = 0 !== (b2 & 4);
    for (var c2 = 0; c2 < a2.length; c2++) {
      var d2 = a2[c2], e2 = d2.event;
      d2 = d2.listeners;
      a: {
        var f2 = void 0;
        if (b2) for (var g2 = d2.length - 1; 0 <= g2; g2--) {
          var h2 = d2[g2], k2 = h2.instance, l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e2.isPropagationStopped()) break a;
          nf(e2, h2, l2);
          f2 = k2;
        }
        else for (g2 = 0; g2 < d2.length; g2++) {
          h2 = d2[g2];
          k2 = h2.instance;
          l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e2.isPropagationStopped()) break a;
          nf(e2, h2, l2);
          f2 = k2;
        }
      }
    }
    if (Qb) throw a2 = Rb, Qb = false, Rb = null, a2;
  }
  function D(a2, b2) {
    var c2 = b2[of];
    void 0 === c2 && (c2 = b2[of] = /* @__PURE__ */ new Set());
    var d2 = a2 + "__bubble";
    c2.has(d2) || (pf(b2, a2, 2, false), c2.add(d2));
  }
  function qf(a2, b2, c2) {
    var d2 = 0;
    b2 && (d2 |= 4);
    pf(c2, a2, d2, b2);
  }
  var rf = "_reactListening" + Math.random().toString(36).slice(2);
  function sf(a2) {
    if (!a2[rf]) {
      a2[rf] = true;
      da.forEach(function(b3) {
        "selectionchange" !== b3 && (mf.has(b3) || qf(b3, false, a2), qf(b3, true, a2));
      });
      var b2 = 9 === a2.nodeType ? a2 : a2.ownerDocument;
      null === b2 || b2[rf] || (b2[rf] = true, qf("selectionchange", false, b2));
    }
  }
  function pf(a2, b2, c2, d2) {
    switch (jd(b2)) {
      case 1:
        var e2 = ed;
        break;
      case 4:
        e2 = gd;
        break;
      default:
        e2 = fd;
    }
    c2 = e2.bind(null, b2, c2, a2);
    e2 = void 0;
    !Lb || "touchstart" !== b2 && "touchmove" !== b2 && "wheel" !== b2 || (e2 = true);
    d2 ? void 0 !== e2 ? a2.addEventListener(b2, c2, { capture: true, passive: e2 }) : a2.addEventListener(b2, c2, true) : void 0 !== e2 ? a2.addEventListener(b2, c2, { passive: e2 }) : a2.addEventListener(b2, c2, false);
  }
  function hd(a2, b2, c2, d2, e2) {
    var f2 = d2;
    if (0 === (b2 & 1) && 0 === (b2 & 2) && null !== d2) a: for (; ; ) {
      if (null === d2) return;
      var g2 = d2.tag;
      if (3 === g2 || 4 === g2) {
        var h2 = d2.stateNode.containerInfo;
        if (h2 === e2 || 8 === h2.nodeType && h2.parentNode === e2) break;
        if (4 === g2) for (g2 = d2.return; null !== g2; ) {
          var k2 = g2.tag;
          if (3 === k2 || 4 === k2) {
            if (k2 = g2.stateNode.containerInfo, k2 === e2 || 8 === k2.nodeType && k2.parentNode === e2) return;
          }
          g2 = g2.return;
        }
        for (; null !== h2; ) {
          g2 = Wc(h2);
          if (null === g2) return;
          k2 = g2.tag;
          if (5 === k2 || 6 === k2) {
            d2 = f2 = g2;
            continue a;
          }
          h2 = h2.parentNode;
        }
      }
      d2 = d2.return;
    }
    Jb(function() {
      var d3 = f2, e3 = xb(c2), g3 = [];
      a: {
        var h3 = df.get(a2);
        if (void 0 !== h3) {
          var k3 = td, n2 = a2;
          switch (a2) {
            case "keypress":
              if (0 === od(c2)) break a;
            case "keydown":
            case "keyup":
              k3 = Rd;
              break;
            case "focusin":
              n2 = "focus";
              k3 = Fd;
              break;
            case "focusout":
              n2 = "blur";
              k3 = Fd;
              break;
            case "beforeblur":
            case "afterblur":
              k3 = Fd;
              break;
            case "click":
              if (2 === c2.button) break a;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              k3 = Bd;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              k3 = Dd;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              k3 = Vd;
              break;
            case $e:
            case af:
            case bf:
              k3 = Hd;
              break;
            case cf:
              k3 = Xd;
              break;
            case "scroll":
              k3 = vd;
              break;
            case "wheel":
              k3 = Zd;
              break;
            case "copy":
            case "cut":
            case "paste":
              k3 = Jd;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              k3 = Td;
          }
          var t2 = 0 !== (b2 & 4), J = !t2 && "scroll" === a2, x2 = t2 ? null !== h3 ? h3 + "Capture" : null : h3;
          t2 = [];
          for (var w2 = d3, u2; null !== w2; ) {
            u2 = w2;
            var F = u2.stateNode;
            5 === u2.tag && null !== F && (u2 = F, null !== x2 && (F = Kb(w2, x2), null != F && t2.push(tf(w2, F, u2))));
            if (J) break;
            w2 = w2.return;
          }
          0 < t2.length && (h3 = new k3(h3, n2, null, c2, e3), g3.push({ event: h3, listeners: t2 }));
        }
      }
      if (0 === (b2 & 7)) {
        a: {
          h3 = "mouseover" === a2 || "pointerover" === a2;
          k3 = "mouseout" === a2 || "pointerout" === a2;
          if (h3 && c2 !== wb && (n2 = c2.relatedTarget || c2.fromElement) && (Wc(n2) || n2[uf])) break a;
          if (k3 || h3) {
            h3 = e3.window === e3 ? e3 : (h3 = e3.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
            if (k3) {
              if (n2 = c2.relatedTarget || c2.toElement, k3 = d3, n2 = n2 ? Wc(n2) : null, null !== n2 && (J = Vb(n2), n2 !== J || 5 !== n2.tag && 6 !== n2.tag)) n2 = null;
            } else k3 = null, n2 = d3;
            if (k3 !== n2) {
              t2 = Bd;
              F = "onMouseLeave";
              x2 = "onMouseEnter";
              w2 = "mouse";
              if ("pointerout" === a2 || "pointerover" === a2) t2 = Td, F = "onPointerLeave", x2 = "onPointerEnter", w2 = "pointer";
              J = null == k3 ? h3 : ue(k3);
              u2 = null == n2 ? h3 : ue(n2);
              h3 = new t2(F, w2 + "leave", k3, c2, e3);
              h3.target = J;
              h3.relatedTarget = u2;
              F = null;
              Wc(e3) === d3 && (t2 = new t2(x2, w2 + "enter", n2, c2, e3), t2.target = u2, t2.relatedTarget = J, F = t2);
              J = F;
              if (k3 && n2) b: {
                t2 = k3;
                x2 = n2;
                w2 = 0;
                for (u2 = t2; u2; u2 = vf(u2)) w2++;
                u2 = 0;
                for (F = x2; F; F = vf(F)) u2++;
                for (; 0 < w2 - u2; ) t2 = vf(t2), w2--;
                for (; 0 < u2 - w2; ) x2 = vf(x2), u2--;
                for (; w2--; ) {
                  if (t2 === x2 || null !== x2 && t2 === x2.alternate) break b;
                  t2 = vf(t2);
                  x2 = vf(x2);
                }
                t2 = null;
              }
              else t2 = null;
              null !== k3 && wf(g3, h3, k3, t2, false);
              null !== n2 && null !== J && wf(g3, J, n2, t2, true);
            }
          }
        }
        a: {
          h3 = d3 ? ue(d3) : window;
          k3 = h3.nodeName && h3.nodeName.toLowerCase();
          if ("select" === k3 || "input" === k3 && "file" === h3.type) var na = ve;
          else if (me(h3)) if (we) na = Fe;
          else {
            na = De;
            var xa = Ce;
          }
          else (k3 = h3.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (na = Ee);
          if (na && (na = na(a2, d3))) {
            ne(g3, na, c2, e3);
            break a;
          }
          xa && xa(a2, h3, d3);
          "focusout" === a2 && (xa = h3._wrapperState) && xa.controlled && "number" === h3.type && cb(h3, "number", h3.value);
        }
        xa = d3 ? ue(d3) : window;
        switch (a2) {
          case "focusin":
            if (me(xa) || "true" === xa.contentEditable) Qe = xa, Re = d3, Se = null;
            break;
          case "focusout":
            Se = Re = Qe = null;
            break;
          case "mousedown":
            Te = true;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            Te = false;
            Ue(g3, c2, e3);
            break;
          case "selectionchange":
            if (Pe) break;
          case "keydown":
          case "keyup":
            Ue(g3, c2, e3);
        }
        var $a;
        if (ae) b: {
          switch (a2) {
            case "compositionstart":
              var ba = "onCompositionStart";
              break b;
            case "compositionend":
              ba = "onCompositionEnd";
              break b;
            case "compositionupdate":
              ba = "onCompositionUpdate";
              break b;
          }
          ba = void 0;
        }
        else ie ? ge(a2, c2) && (ba = "onCompositionEnd") : "keydown" === a2 && 229 === c2.keyCode && (ba = "onCompositionStart");
        ba && (de && "ko" !== c2.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e3, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa = oe(d3, ba), 0 < xa.length && (ba = new Ld(ba, a2, null, c2, e3), g3.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c2), null !== $a && (ba.data = $a))));
        if ($a = ce ? je(a2, c2) : ke(a2, c2)) d3 = oe(d3, "onBeforeInput"), 0 < d3.length && (e3 = new Ld("onBeforeInput", "beforeinput", null, c2, e3), g3.push({ event: e3, listeners: d3 }), e3.data = $a);
      }
      se(g3, b2);
    });
  }
  function tf(a2, b2, c2) {
    return { instance: a2, listener: b2, currentTarget: c2 };
  }
  function oe(a2, b2) {
    for (var c2 = b2 + "Capture", d2 = []; null !== a2; ) {
      var e2 = a2, f2 = e2.stateNode;
      5 === e2.tag && null !== f2 && (e2 = f2, f2 = Kb(a2, c2), null != f2 && d2.unshift(tf(a2, f2, e2)), f2 = Kb(a2, b2), null != f2 && d2.push(tf(a2, f2, e2)));
      a2 = a2.return;
    }
    return d2;
  }
  function vf(a2) {
    if (null === a2) return null;
    do
      a2 = a2.return;
    while (a2 && 5 !== a2.tag);
    return a2 ? a2 : null;
  }
  function wf(a2, b2, c2, d2, e2) {
    for (var f2 = b2._reactName, g2 = []; null !== c2 && c2 !== d2; ) {
      var h2 = c2, k2 = h2.alternate, l2 = h2.stateNode;
      if (null !== k2 && k2 === d2) break;
      5 === h2.tag && null !== l2 && (h2 = l2, e2 ? (k2 = Kb(c2, f2), null != k2 && g2.unshift(tf(c2, k2, h2))) : e2 || (k2 = Kb(c2, f2), null != k2 && g2.push(tf(c2, k2, h2))));
      c2 = c2.return;
    }
    0 !== g2.length && a2.push({ event: b2, listeners: g2 });
  }
  var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
  function zf(a2) {
    return ("string" === typeof a2 ? a2 : "" + a2).replace(xf, "\n").replace(yf, "");
  }
  function Af(a2, b2, c2) {
    b2 = zf(b2);
    if (zf(a2) !== b2 && c2) throw Error(p2(425));
  }
  function Bf() {
  }
  var Cf = null, Df = null;
  function Ef(a2, b2) {
    return "textarea" === a2 || "noscript" === a2 || "string" === typeof b2.children || "number" === typeof b2.children || "object" === typeof b2.dangerouslySetInnerHTML && null !== b2.dangerouslySetInnerHTML && null != b2.dangerouslySetInnerHTML.__html;
  }
  var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a2) {
    return Hf.resolve(null).then(a2).catch(If);
  } : Ff;
  function If(a2) {
    setTimeout(function() {
      throw a2;
    });
  }
  function Kf(a2, b2) {
    var c2 = b2, d2 = 0;
    do {
      var e2 = c2.nextSibling;
      a2.removeChild(c2);
      if (e2 && 8 === e2.nodeType) if (c2 = e2.data, "/$" === c2) {
        if (0 === d2) {
          a2.removeChild(e2);
          bd(b2);
          return;
        }
        d2--;
      } else "$" !== c2 && "$?" !== c2 && "$!" !== c2 || d2++;
      c2 = e2;
    } while (c2);
    bd(b2);
  }
  function Lf(a2) {
    for (; null != a2; a2 = a2.nextSibling) {
      var b2 = a2.nodeType;
      if (1 === b2 || 3 === b2) break;
      if (8 === b2) {
        b2 = a2.data;
        if ("$" === b2 || "$!" === b2 || "$?" === b2) break;
        if ("/$" === b2) return null;
      }
    }
    return a2;
  }
  function Mf(a2) {
    a2 = a2.previousSibling;
    for (var b2 = 0; a2; ) {
      if (8 === a2.nodeType) {
        var c2 = a2.data;
        if ("$" === c2 || "$!" === c2 || "$?" === c2) {
          if (0 === b2) return a2;
          b2--;
        } else "/$" === c2 && b2++;
      }
      a2 = a2.previousSibling;
    }
    return null;
  }
  var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
  function Wc(a2) {
    var b2 = a2[Of];
    if (b2) return b2;
    for (var c2 = a2.parentNode; c2; ) {
      if (b2 = c2[uf] || c2[Of]) {
        c2 = b2.alternate;
        if (null !== b2.child || null !== c2 && null !== c2.child) for (a2 = Mf(a2); null !== a2; ) {
          if (c2 = a2[Of]) return c2;
          a2 = Mf(a2);
        }
        return b2;
      }
      a2 = c2;
      c2 = a2.parentNode;
    }
    return null;
  }
  function Cb(a2) {
    a2 = a2[Of] || a2[uf];
    return !a2 || 5 !== a2.tag && 6 !== a2.tag && 13 !== a2.tag && 3 !== a2.tag ? null : a2;
  }
  function ue(a2) {
    if (5 === a2.tag || 6 === a2.tag) return a2.stateNode;
    throw Error(p2(33));
  }
  function Db(a2) {
    return a2[Pf] || null;
  }
  var Sf = [], Tf = -1;
  function Uf(a2) {
    return { current: a2 };
  }
  function E(a2) {
    0 > Tf || (a2.current = Sf[Tf], Sf[Tf] = null, Tf--);
  }
  function G(a2, b2) {
    Tf++;
    Sf[Tf] = a2.current;
    a2.current = b2;
  }
  var Vf = {}, H2 = Uf(Vf), Wf = Uf(false), Xf = Vf;
  function Yf(a2, b2) {
    var c2 = a2.type.contextTypes;
    if (!c2) return Vf;
    var d2 = a2.stateNode;
    if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b2) return d2.__reactInternalMemoizedMaskedChildContext;
    var e2 = {}, f2;
    for (f2 in c2) e2[f2] = b2[f2];
    d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = b2, a2.__reactInternalMemoizedMaskedChildContext = e2);
    return e2;
  }
  function Zf(a2) {
    a2 = a2.childContextTypes;
    return null !== a2 && void 0 !== a2;
  }
  function $f() {
    E(Wf);
    E(H2);
  }
  function ag(a2, b2, c2) {
    if (H2.current !== Vf) throw Error(p2(168));
    G(H2, b2);
    G(Wf, c2);
  }
  function bg(a2, b2, c2) {
    var d2 = a2.stateNode;
    b2 = b2.childContextTypes;
    if ("function" !== typeof d2.getChildContext) return c2;
    d2 = d2.getChildContext();
    for (var e2 in d2) if (!(e2 in b2)) throw Error(p2(108, Ra(a2) || "Unknown", e2));
    return A({}, c2, d2);
  }
  function cg(a2) {
    a2 = (a2 = a2.stateNode) && a2.__reactInternalMemoizedMergedChildContext || Vf;
    Xf = H2.current;
    G(H2, a2);
    G(Wf, Wf.current);
    return true;
  }
  function dg(a2, b2, c2) {
    var d2 = a2.stateNode;
    if (!d2) throw Error(p2(169));
    c2 ? (a2 = bg(a2, b2, Xf), d2.__reactInternalMemoizedMergedChildContext = a2, E(Wf), E(H2), G(H2, a2)) : E(Wf);
    G(Wf, c2);
  }
  var eg = null, fg = false, gg = false;
  function hg(a2) {
    null === eg ? eg = [a2] : eg.push(a2);
  }
  function ig(a2) {
    fg = true;
    hg(a2);
  }
  function jg() {
    if (!gg && null !== eg) {
      gg = true;
      var a2 = 0, b2 = C;
      try {
        var c2 = eg;
        for (C = 1; a2 < c2.length; a2++) {
          var d2 = c2[a2];
          do
            d2 = d2(true);
          while (null !== d2);
        }
        eg = null;
        fg = false;
      } catch (e2) {
        throw null !== eg && (eg = eg.slice(a2 + 1)), ac(fc, jg), e2;
      } finally {
        C = b2, gg = false;
      }
    }
    return null;
  }
  var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
  function tg(a2, b2) {
    kg[lg++] = ng;
    kg[lg++] = mg;
    mg = a2;
    ng = b2;
  }
  function ug(a2, b2, c2) {
    og[pg++] = rg;
    og[pg++] = sg;
    og[pg++] = qg;
    qg = a2;
    var d2 = rg;
    a2 = sg;
    var e2 = 32 - oc(d2) - 1;
    d2 &= ~(1 << e2);
    c2 += 1;
    var f2 = 32 - oc(b2) + e2;
    if (30 < f2) {
      var g2 = e2 - e2 % 5;
      f2 = (d2 & (1 << g2) - 1).toString(32);
      d2 >>= g2;
      e2 -= g2;
      rg = 1 << 32 - oc(b2) + e2 | c2 << e2 | d2;
      sg = f2 + a2;
    } else rg = 1 << f2 | c2 << e2 | d2, sg = a2;
  }
  function vg(a2) {
    null !== a2.return && (tg(a2, 1), ug(a2, 1, 0));
  }
  function wg(a2) {
    for (; a2 === mg; ) mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
    for (; a2 === qg; ) qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
  }
  var xg = null, yg = null, I = false, zg = null;
  function Ag(a2, b2) {
    var c2 = Bg(5, null, null, 0);
    c2.elementType = "DELETED";
    c2.stateNode = b2;
    c2.return = a2;
    b2 = a2.deletions;
    null === b2 ? (a2.deletions = [c2], a2.flags |= 16) : b2.push(c2);
  }
  function Cg(a2, b2) {
    switch (a2.tag) {
      case 5:
        var c2 = a2.type;
        b2 = 1 !== b2.nodeType || c2.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2;
        return null !== b2 ? (a2.stateNode = b2, xg = a2, yg = Lf(b2.firstChild), true) : false;
      case 6:
        return b2 = "" === a2.pendingProps || 3 !== b2.nodeType ? null : b2, null !== b2 ? (a2.stateNode = b2, xg = a2, yg = null, true) : false;
      case 13:
        return b2 = 8 !== b2.nodeType ? null : b2, null !== b2 ? (c2 = null !== qg ? { id: rg, overflow: sg } : null, a2.memoizedState = { dehydrated: b2, treeContext: c2, retryLane: 1073741824 }, c2 = Bg(18, null, null, 0), c2.stateNode = b2, c2.return = a2, a2.child = c2, xg = a2, yg = null, true) : false;
      default:
        return false;
    }
  }
  function Dg(a2) {
    return 0 !== (a2.mode & 1) && 0 === (a2.flags & 128);
  }
  function Eg(a2) {
    if (I) {
      var b2 = yg;
      if (b2) {
        var c2 = b2;
        if (!Cg(a2, b2)) {
          if (Dg(a2)) throw Error(p2(418));
          b2 = Lf(c2.nextSibling);
          var d2 = xg;
          b2 && Cg(a2, b2) ? Ag(d2, c2) : (a2.flags = a2.flags & -4097 | 2, I = false, xg = a2);
        }
      } else {
        if (Dg(a2)) throw Error(p2(418));
        a2.flags = a2.flags & -4097 | 2;
        I = false;
        xg = a2;
      }
    }
  }
  function Fg(a2) {
    for (a2 = a2.return; null !== a2 && 5 !== a2.tag && 3 !== a2.tag && 13 !== a2.tag; ) a2 = a2.return;
    xg = a2;
  }
  function Gg(a2) {
    if (a2 !== xg) return false;
    if (!I) return Fg(a2), I = true, false;
    var b2;
    (b2 = 3 !== a2.tag) && !(b2 = 5 !== a2.tag) && (b2 = a2.type, b2 = "head" !== b2 && "body" !== b2 && !Ef(a2.type, a2.memoizedProps));
    if (b2 && (b2 = yg)) {
      if (Dg(a2)) throw Hg(), Error(p2(418));
      for (; b2; ) Ag(a2, b2), b2 = Lf(b2.nextSibling);
    }
    Fg(a2);
    if (13 === a2.tag) {
      a2 = a2.memoizedState;
      a2 = null !== a2 ? a2.dehydrated : null;
      if (!a2) throw Error(p2(317));
      a: {
        a2 = a2.nextSibling;
        for (b2 = 0; a2; ) {
          if (8 === a2.nodeType) {
            var c2 = a2.data;
            if ("/$" === c2) {
              if (0 === b2) {
                yg = Lf(a2.nextSibling);
                break a;
              }
              b2--;
            } else "$" !== c2 && "$!" !== c2 && "$?" !== c2 || b2++;
          }
          a2 = a2.nextSibling;
        }
        yg = null;
      }
    } else yg = xg ? Lf(a2.stateNode.nextSibling) : null;
    return true;
  }
  function Hg() {
    for (var a2 = yg; a2; ) a2 = Lf(a2.nextSibling);
  }
  function Ig() {
    yg = xg = null;
    I = false;
  }
  function Jg(a2) {
    null === zg ? zg = [a2] : zg.push(a2);
  }
  var Kg = ua.ReactCurrentBatchConfig;
  function Lg(a2, b2, c2) {
    a2 = c2.ref;
    if (null !== a2 && "function" !== typeof a2 && "object" !== typeof a2) {
      if (c2._owner) {
        c2 = c2._owner;
        if (c2) {
          if (1 !== c2.tag) throw Error(p2(309));
          var d2 = c2.stateNode;
        }
        if (!d2) throw Error(p2(147, a2));
        var e2 = d2, f2 = "" + a2;
        if (null !== b2 && null !== b2.ref && "function" === typeof b2.ref && b2.ref._stringRef === f2) return b2.ref;
        b2 = function(a3) {
          var b3 = e2.refs;
          null === a3 ? delete b3[f2] : b3[f2] = a3;
        };
        b2._stringRef = f2;
        return b2;
      }
      if ("string" !== typeof a2) throw Error(p2(284));
      if (!c2._owner) throw Error(p2(290, a2));
    }
    return a2;
  }
  function Mg(a2, b2) {
    a2 = Object.prototype.toString.call(b2);
    throw Error(p2(31, "[object Object]" === a2 ? "object with keys {" + Object.keys(b2).join(", ") + "}" : a2));
  }
  function Ng(a2) {
    var b2 = a2._init;
    return b2(a2._payload);
  }
  function Og(a2) {
    function b2(b3, c3) {
      if (a2) {
        var d3 = b3.deletions;
        null === d3 ? (b3.deletions = [c3], b3.flags |= 16) : d3.push(c3);
      }
    }
    function c2(c3, d3) {
      if (!a2) return null;
      for (; null !== d3; ) b2(c3, d3), d3 = d3.sibling;
      return null;
    }
    function d2(a3, b3) {
      for (a3 = /* @__PURE__ */ new Map(); null !== b3; ) null !== b3.key ? a3.set(b3.key, b3) : a3.set(b3.index, b3), b3 = b3.sibling;
      return a3;
    }
    function e2(a3, b3) {
      a3 = Pg(a3, b3);
      a3.index = 0;
      a3.sibling = null;
      return a3;
    }
    function f2(b3, c3, d3) {
      b3.index = d3;
      if (!a2) return b3.flags |= 1048576, c3;
      d3 = b3.alternate;
      if (null !== d3) return d3 = d3.index, d3 < c3 ? (b3.flags |= 2, c3) : d3;
      b3.flags |= 2;
      return c3;
    }
    function g2(b3) {
      a2 && null === b3.alternate && (b3.flags |= 2);
      return b3;
    }
    function h2(a3, b3, c3, d3) {
      if (null === b3 || 6 !== b3.tag) return b3 = Qg(c3, a3.mode, d3), b3.return = a3, b3;
      b3 = e2(b3, c3);
      b3.return = a3;
      return b3;
    }
    function k2(a3, b3, c3, d3) {
      var f3 = c3.type;
      if (f3 === ya) return m2(a3, b3, c3.props.children, d3, c3.key);
      if (null !== b3 && (b3.elementType === f3 || "object" === typeof f3 && null !== f3 && f3.$$typeof === Ha && Ng(f3) === b3.type)) return d3 = e2(b3, c3.props), d3.ref = Lg(a3, b3, c3), d3.return = a3, d3;
      d3 = Rg(c3.type, c3.key, c3.props, null, a3.mode, d3);
      d3.ref = Lg(a3, b3, c3);
      d3.return = a3;
      return d3;
    }
    function l2(a3, b3, c3, d3) {
      if (null === b3 || 4 !== b3.tag || b3.stateNode.containerInfo !== c3.containerInfo || b3.stateNode.implementation !== c3.implementation) return b3 = Sg(c3, a3.mode, d3), b3.return = a3, b3;
      b3 = e2(b3, c3.children || []);
      b3.return = a3;
      return b3;
    }
    function m2(a3, b3, c3, d3, f3) {
      if (null === b3 || 7 !== b3.tag) return b3 = Tg(c3, a3.mode, d3, f3), b3.return = a3, b3;
      b3 = e2(b3, c3);
      b3.return = a3;
      return b3;
    }
    function q(a3, b3, c3) {
      if ("string" === typeof b3 && "" !== b3 || "number" === typeof b3) return b3 = Qg("" + b3, a3.mode, c3), b3.return = a3, b3;
      if ("object" === typeof b3 && null !== b3) {
        switch (b3.$$typeof) {
          case va:
            return c3 = Rg(b3.type, b3.key, b3.props, null, a3.mode, c3), c3.ref = Lg(a3, null, b3), c3.return = a3, c3;
          case wa:
            return b3 = Sg(b3, a3.mode, c3), b3.return = a3, b3;
          case Ha:
            var d3 = b3._init;
            return q(a3, d3(b3._payload), c3);
        }
        if (eb(b3) || Ka(b3)) return b3 = Tg(b3, a3.mode, c3, null), b3.return = a3, b3;
        Mg(a3, b3);
      }
      return null;
    }
    function r2(a3, b3, c3, d3) {
      var e3 = null !== b3 ? b3.key : null;
      if ("string" === typeof c3 && "" !== c3 || "number" === typeof c3) return null !== e3 ? null : h2(a3, b3, "" + c3, d3);
      if ("object" === typeof c3 && null !== c3) {
        switch (c3.$$typeof) {
          case va:
            return c3.key === e3 ? k2(a3, b3, c3, d3) : null;
          case wa:
            return c3.key === e3 ? l2(a3, b3, c3, d3) : null;
          case Ha:
            return e3 = c3._init, r2(
              a3,
              b3,
              e3(c3._payload),
              d3
            );
        }
        if (eb(c3) || Ka(c3)) return null !== e3 ? null : m2(a3, b3, c3, d3, null);
        Mg(a3, c3);
      }
      return null;
    }
    function y2(a3, b3, c3, d3, e3) {
      if ("string" === typeof d3 && "" !== d3 || "number" === typeof d3) return a3 = a3.get(c3) || null, h2(b3, a3, "" + d3, e3);
      if ("object" === typeof d3 && null !== d3) {
        switch (d3.$$typeof) {
          case va:
            return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, k2(b3, a3, d3, e3);
          case wa:
            return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, l2(b3, a3, d3, e3);
          case Ha:
            var f3 = d3._init;
            return y2(a3, b3, c3, f3(d3._payload), e3);
        }
        if (eb(d3) || Ka(d3)) return a3 = a3.get(c3) || null, m2(b3, a3, d3, e3, null);
        Mg(b3, d3);
      }
      return null;
    }
    function n2(e3, g3, h3, k3) {
      for (var l3 = null, m3 = null, u2 = g3, w2 = g3 = 0, x2 = null; null !== u2 && w2 < h3.length; w2++) {
        u2.index > w2 ? (x2 = u2, u2 = null) : x2 = u2.sibling;
        var n3 = r2(e3, u2, h3[w2], k3);
        if (null === n3) {
          null === u2 && (u2 = x2);
          break;
        }
        a2 && u2 && null === n3.alternate && b2(e3, u2);
        g3 = f2(n3, g3, w2);
        null === m3 ? l3 = n3 : m3.sibling = n3;
        m3 = n3;
        u2 = x2;
      }
      if (w2 === h3.length) return c2(e3, u2), I && tg(e3, w2), l3;
      if (null === u2) {
        for (; w2 < h3.length; w2++) u2 = q(e3, h3[w2], k3), null !== u2 && (g3 = f2(u2, g3, w2), null === m3 ? l3 = u2 : m3.sibling = u2, m3 = u2);
        I && tg(e3, w2);
        return l3;
      }
      for (u2 = d2(e3, u2); w2 < h3.length; w2++) x2 = y2(u2, e3, w2, h3[w2], k3), null !== x2 && (a2 && null !== x2.alternate && u2.delete(null === x2.key ? w2 : x2.key), g3 = f2(x2, g3, w2), null === m3 ? l3 = x2 : m3.sibling = x2, m3 = x2);
      a2 && u2.forEach(function(a3) {
        return b2(e3, a3);
      });
      I && tg(e3, w2);
      return l3;
    }
    function t2(e3, g3, h3, k3) {
      var l3 = Ka(h3);
      if ("function" !== typeof l3) throw Error(p2(150));
      h3 = l3.call(h3);
      if (null == h3) throw Error(p2(151));
      for (var u2 = l3 = null, m3 = g3, w2 = g3 = 0, x2 = null, n3 = h3.next(); null !== m3 && !n3.done; w2++, n3 = h3.next()) {
        m3.index > w2 ? (x2 = m3, m3 = null) : x2 = m3.sibling;
        var t3 = r2(e3, m3, n3.value, k3);
        if (null === t3) {
          null === m3 && (m3 = x2);
          break;
        }
        a2 && m3 && null === t3.alternate && b2(e3, m3);
        g3 = f2(t3, g3, w2);
        null === u2 ? l3 = t3 : u2.sibling = t3;
        u2 = t3;
        m3 = x2;
      }
      if (n3.done) return c2(
        e3,
        m3
      ), I && tg(e3, w2), l3;
      if (null === m3) {
        for (; !n3.done; w2++, n3 = h3.next()) n3 = q(e3, n3.value, k3), null !== n3 && (g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
        I && tg(e3, w2);
        return l3;
      }
      for (m3 = d2(e3, m3); !n3.done; w2++, n3 = h3.next()) n3 = y2(m3, e3, w2, n3.value, k3), null !== n3 && (a2 && null !== n3.alternate && m3.delete(null === n3.key ? w2 : n3.key), g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
      a2 && m3.forEach(function(a3) {
        return b2(e3, a3);
      });
      I && tg(e3, w2);
      return l3;
    }
    function J(a3, d3, f3, h3) {
      "object" === typeof f3 && null !== f3 && f3.type === ya && null === f3.key && (f3 = f3.props.children);
      if ("object" === typeof f3 && null !== f3) {
        switch (f3.$$typeof) {
          case va:
            a: {
              for (var k3 = f3.key, l3 = d3; null !== l3; ) {
                if (l3.key === k3) {
                  k3 = f3.type;
                  if (k3 === ya) {
                    if (7 === l3.tag) {
                      c2(a3, l3.sibling);
                      d3 = e2(l3, f3.props.children);
                      d3.return = a3;
                      a3 = d3;
                      break a;
                    }
                  } else if (l3.elementType === k3 || "object" === typeof k3 && null !== k3 && k3.$$typeof === Ha && Ng(k3) === l3.type) {
                    c2(a3, l3.sibling);
                    d3 = e2(l3, f3.props);
                    d3.ref = Lg(a3, l3, f3);
                    d3.return = a3;
                    a3 = d3;
                    break a;
                  }
                  c2(a3, l3);
                  break;
                } else b2(a3, l3);
                l3 = l3.sibling;
              }
              f3.type === ya ? (d3 = Tg(f3.props.children, a3.mode, h3, f3.key), d3.return = a3, a3 = d3) : (h3 = Rg(f3.type, f3.key, f3.props, null, a3.mode, h3), h3.ref = Lg(a3, d3, f3), h3.return = a3, a3 = h3);
            }
            return g2(a3);
          case wa:
            a: {
              for (l3 = f3.key; null !== d3; ) {
                if (d3.key === l3) if (4 === d3.tag && d3.stateNode.containerInfo === f3.containerInfo && d3.stateNode.implementation === f3.implementation) {
                  c2(a3, d3.sibling);
                  d3 = e2(d3, f3.children || []);
                  d3.return = a3;
                  a3 = d3;
                  break a;
                } else {
                  c2(a3, d3);
                  break;
                }
                else b2(a3, d3);
                d3 = d3.sibling;
              }
              d3 = Sg(f3, a3.mode, h3);
              d3.return = a3;
              a3 = d3;
            }
            return g2(a3);
          case Ha:
            return l3 = f3._init, J(a3, d3, l3(f3._payload), h3);
        }
        if (eb(f3)) return n2(a3, d3, f3, h3);
        if (Ka(f3)) return t2(a3, d3, f3, h3);
        Mg(a3, f3);
      }
      return "string" === typeof f3 && "" !== f3 || "number" === typeof f3 ? (f3 = "" + f3, null !== d3 && 6 === d3.tag ? (c2(a3, d3.sibling), d3 = e2(d3, f3), d3.return = a3, a3 = d3) : (c2(a3, d3), d3 = Qg(f3, a3.mode, h3), d3.return = a3, a3 = d3), g2(a3)) : c2(a3, d3);
    }
    return J;
  }
  var Ug = Og(true), Vg = Og(false), Wg = Uf(null), Xg = null, Yg = null, Zg = null;
  function $g() {
    Zg = Yg = Xg = null;
  }
  function ah(a2) {
    var b2 = Wg.current;
    E(Wg);
    a2._currentValue = b2;
  }
  function bh(a2, b2, c2) {
    for (; null !== a2; ) {
      var d2 = a2.alternate;
      (a2.childLanes & b2) !== b2 ? (a2.childLanes |= b2, null !== d2 && (d2.childLanes |= b2)) : null !== d2 && (d2.childLanes & b2) !== b2 && (d2.childLanes |= b2);
      if (a2 === c2) break;
      a2 = a2.return;
    }
  }
  function ch(a2, b2) {
    Xg = a2;
    Zg = Yg = null;
    a2 = a2.dependencies;
    null !== a2 && null !== a2.firstContext && (0 !== (a2.lanes & b2) && (dh = true), a2.firstContext = null);
  }
  function eh(a2) {
    var b2 = a2._currentValue;
    if (Zg !== a2) if (a2 = { context: a2, memoizedValue: b2, next: null }, null === Yg) {
      if (null === Xg) throw Error(p2(308));
      Yg = a2;
      Xg.dependencies = { lanes: 0, firstContext: a2 };
    } else Yg = Yg.next = a2;
    return b2;
  }
  var fh = null;
  function gh(a2) {
    null === fh ? fh = [a2] : fh.push(a2);
  }
  function hh(a2, b2, c2, d2) {
    var e2 = b2.interleaved;
    null === e2 ? (c2.next = c2, gh(b2)) : (c2.next = e2.next, e2.next = c2);
    b2.interleaved = c2;
    return ih(a2, d2);
  }
  function ih(a2, b2) {
    a2.lanes |= b2;
    var c2 = a2.alternate;
    null !== c2 && (c2.lanes |= b2);
    c2 = a2;
    for (a2 = a2.return; null !== a2; ) a2.childLanes |= b2, c2 = a2.alternate, null !== c2 && (c2.childLanes |= b2), c2 = a2, a2 = a2.return;
    return 3 === c2.tag ? c2.stateNode : null;
  }
  var jh = false;
  function kh(a2) {
    a2.updateQueue = { baseState: a2.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
  }
  function lh(a2, b2) {
    a2 = a2.updateQueue;
    b2.updateQueue === a2 && (b2.updateQueue = { baseState: a2.baseState, firstBaseUpdate: a2.firstBaseUpdate, lastBaseUpdate: a2.lastBaseUpdate, shared: a2.shared, effects: a2.effects });
  }
  function mh(a2, b2) {
    return { eventTime: a2, lane: b2, tag: 0, payload: null, callback: null, next: null };
  }
  function nh(a2, b2, c2) {
    var d2 = a2.updateQueue;
    if (null === d2) return null;
    d2 = d2.shared;
    if (0 !== (K & 2)) {
      var e2 = d2.pending;
      null === e2 ? b2.next = b2 : (b2.next = e2.next, e2.next = b2);
      d2.pending = b2;
      return ih(a2, c2);
    }
    e2 = d2.interleaved;
    null === e2 ? (b2.next = b2, gh(d2)) : (b2.next = e2.next, e2.next = b2);
    d2.interleaved = b2;
    return ih(a2, c2);
  }
  function oh(a2, b2, c2) {
    b2 = b2.updateQueue;
    if (null !== b2 && (b2 = b2.shared, 0 !== (c2 & 4194240))) {
      var d2 = b2.lanes;
      d2 &= a2.pendingLanes;
      c2 |= d2;
      b2.lanes = c2;
      Cc(a2, c2);
    }
  }
  function ph(a2, b2) {
    var c2 = a2.updateQueue, d2 = a2.alternate;
    if (null !== d2 && (d2 = d2.updateQueue, c2 === d2)) {
      var e2 = null, f2 = null;
      c2 = c2.firstBaseUpdate;
      if (null !== c2) {
        do {
          var g2 = { eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null };
          null === f2 ? e2 = f2 = g2 : f2 = f2.next = g2;
          c2 = c2.next;
        } while (null !== c2);
        null === f2 ? e2 = f2 = b2 : f2 = f2.next = b2;
      } else e2 = f2 = b2;
      c2 = { baseState: d2.baseState, firstBaseUpdate: e2, lastBaseUpdate: f2, shared: d2.shared, effects: d2.effects };
      a2.updateQueue = c2;
      return;
    }
    a2 = c2.lastBaseUpdate;
    null === a2 ? c2.firstBaseUpdate = b2 : a2.next = b2;
    c2.lastBaseUpdate = b2;
  }
  function qh(a2, b2, c2, d2) {
    var e2 = a2.updateQueue;
    jh = false;
    var f2 = e2.firstBaseUpdate, g2 = e2.lastBaseUpdate, h2 = e2.shared.pending;
    if (null !== h2) {
      e2.shared.pending = null;
      var k2 = h2, l2 = k2.next;
      k2.next = null;
      null === g2 ? f2 = l2 : g2.next = l2;
      g2 = k2;
      var m2 = a2.alternate;
      null !== m2 && (m2 = m2.updateQueue, h2 = m2.lastBaseUpdate, h2 !== g2 && (null === h2 ? m2.firstBaseUpdate = l2 : h2.next = l2, m2.lastBaseUpdate = k2));
    }
    if (null !== f2) {
      var q = e2.baseState;
      g2 = 0;
      m2 = l2 = k2 = null;
      h2 = f2;
      do {
        var r2 = h2.lane, y2 = h2.eventTime;
        if ((d2 & r2) === r2) {
          null !== m2 && (m2 = m2.next = {
            eventTime: y2,
            lane: 0,
            tag: h2.tag,
            payload: h2.payload,
            callback: h2.callback,
            next: null
          });
          a: {
            var n2 = a2, t2 = h2;
            r2 = b2;
            y2 = c2;
            switch (t2.tag) {
              case 1:
                n2 = t2.payload;
                if ("function" === typeof n2) {
                  q = n2.call(y2, q, r2);
                  break a;
                }
                q = n2;
                break a;
              case 3:
                n2.flags = n2.flags & -65537 | 128;
              case 0:
                n2 = t2.payload;
                r2 = "function" === typeof n2 ? n2.call(y2, q, r2) : n2;
                if (null === r2 || void 0 === r2) break a;
                q = A({}, q, r2);
                break a;
              case 2:
                jh = true;
            }
          }
          null !== h2.callback && 0 !== h2.lane && (a2.flags |= 64, r2 = e2.effects, null === r2 ? e2.effects = [h2] : r2.push(h2));
        } else y2 = { eventTime: y2, lane: r2, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, null === m2 ? (l2 = m2 = y2, k2 = q) : m2 = m2.next = y2, g2 |= r2;
        h2 = h2.next;
        if (null === h2) if (h2 = e2.shared.pending, null === h2) break;
        else r2 = h2, h2 = r2.next, r2.next = null, e2.lastBaseUpdate = r2, e2.shared.pending = null;
      } while (1);
      null === m2 && (k2 = q);
      e2.baseState = k2;
      e2.firstBaseUpdate = l2;
      e2.lastBaseUpdate = m2;
      b2 = e2.shared.interleaved;
      if (null !== b2) {
        e2 = b2;
        do
          g2 |= e2.lane, e2 = e2.next;
        while (e2 !== b2);
      } else null === f2 && (e2.shared.lanes = 0);
      rh |= g2;
      a2.lanes = g2;
      a2.memoizedState = q;
    }
  }
  function sh(a2, b2, c2) {
    a2 = b2.effects;
    b2.effects = null;
    if (null !== a2) for (b2 = 0; b2 < a2.length; b2++) {
      var d2 = a2[b2], e2 = d2.callback;
      if (null !== e2) {
        d2.callback = null;
        d2 = c2;
        if ("function" !== typeof e2) throw Error(p2(191, e2));
        e2.call(d2);
      }
    }
  }
  var th = {}, uh = Uf(th), vh = Uf(th), wh = Uf(th);
  function xh(a2) {
    if (a2 === th) throw Error(p2(174));
    return a2;
  }
  function yh(a2, b2) {
    G(wh, b2);
    G(vh, a2);
    G(uh, th);
    a2 = b2.nodeType;
    switch (a2) {
      case 9:
      case 11:
        b2 = (b2 = b2.documentElement) ? b2.namespaceURI : lb(null, "");
        break;
      default:
        a2 = 8 === a2 ? b2.parentNode : b2, b2 = a2.namespaceURI || null, a2 = a2.tagName, b2 = lb(b2, a2);
    }
    E(uh);
    G(uh, b2);
  }
  function zh() {
    E(uh);
    E(vh);
    E(wh);
  }
  function Ah(a2) {
    xh(wh.current);
    var b2 = xh(uh.current);
    var c2 = lb(b2, a2.type);
    b2 !== c2 && (G(vh, a2), G(uh, c2));
  }
  function Bh(a2) {
    vh.current === a2 && (E(uh), E(vh));
  }
  var L = Uf(0);
  function Ch(a2) {
    for (var b2 = a2; null !== b2; ) {
      if (13 === b2.tag) {
        var c2 = b2.memoizedState;
        if (null !== c2 && (c2 = c2.dehydrated, null === c2 || "$?" === c2.data || "$!" === c2.data)) return b2;
      } else if (19 === b2.tag && void 0 !== b2.memoizedProps.revealOrder) {
        if (0 !== (b2.flags & 128)) return b2;
      } else if (null !== b2.child) {
        b2.child.return = b2;
        b2 = b2.child;
        continue;
      }
      if (b2 === a2) break;
      for (; null === b2.sibling; ) {
        if (null === b2.return || b2.return === a2) return null;
        b2 = b2.return;
      }
      b2.sibling.return = b2.return;
      b2 = b2.sibling;
    }
    return null;
  }
  var Dh = [];
  function Eh() {
    for (var a2 = 0; a2 < Dh.length; a2++) Dh[a2]._workInProgressVersionPrimary = null;
    Dh.length = 0;
  }
  var Fh = ua.ReactCurrentDispatcher, Gh = ua.ReactCurrentBatchConfig, Hh = 0, M2 = null, N2 = null, O = null, Ih = false, Jh = false, Kh = 0, Lh = 0;
  function P() {
    throw Error(p2(321));
  }
  function Mh(a2, b2) {
    if (null === b2) return false;
    for (var c2 = 0; c2 < b2.length && c2 < a2.length; c2++) if (!He(a2[c2], b2[c2])) return false;
    return true;
  }
  function Nh(a2, b2, c2, d2, e2, f2) {
    Hh = f2;
    M2 = b2;
    b2.memoizedState = null;
    b2.updateQueue = null;
    b2.lanes = 0;
    Fh.current = null === a2 || null === a2.memoizedState ? Oh : Ph;
    a2 = c2(d2, e2);
    if (Jh) {
      f2 = 0;
      do {
        Jh = false;
        Kh = 0;
        if (25 <= f2) throw Error(p2(301));
        f2 += 1;
        O = N2 = null;
        b2.updateQueue = null;
        Fh.current = Qh;
        a2 = c2(d2, e2);
      } while (Jh);
    }
    Fh.current = Rh;
    b2 = null !== N2 && null !== N2.next;
    Hh = 0;
    O = N2 = M2 = null;
    Ih = false;
    if (b2) throw Error(p2(300));
    return a2;
  }
  function Sh() {
    var a2 = 0 !== Kh;
    Kh = 0;
    return a2;
  }
  function Th() {
    var a2 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    null === O ? M2.memoizedState = O = a2 : O = O.next = a2;
    return O;
  }
  function Uh() {
    if (null === N2) {
      var a2 = M2.alternate;
      a2 = null !== a2 ? a2.memoizedState : null;
    } else a2 = N2.next;
    var b2 = null === O ? M2.memoizedState : O.next;
    if (null !== b2) O = b2, N2 = a2;
    else {
      if (null === a2) throw Error(p2(310));
      N2 = a2;
      a2 = { memoizedState: N2.memoizedState, baseState: N2.baseState, baseQueue: N2.baseQueue, queue: N2.queue, next: null };
      null === O ? M2.memoizedState = O = a2 : O = O.next = a2;
    }
    return O;
  }
  function Vh(a2, b2) {
    return "function" === typeof b2 ? b2(a2) : b2;
  }
  function Wh(a2) {
    var b2 = Uh(), c2 = b2.queue;
    if (null === c2) throw Error(p2(311));
    c2.lastRenderedReducer = a2;
    var d2 = N2, e2 = d2.baseQueue, f2 = c2.pending;
    if (null !== f2) {
      if (null !== e2) {
        var g2 = e2.next;
        e2.next = f2.next;
        f2.next = g2;
      }
      d2.baseQueue = e2 = f2;
      c2.pending = null;
    }
    if (null !== e2) {
      f2 = e2.next;
      d2 = d2.baseState;
      var h2 = g2 = null, k2 = null, l2 = f2;
      do {
        var m2 = l2.lane;
        if ((Hh & m2) === m2) null !== k2 && (k2 = k2.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d2 = l2.hasEagerState ? l2.eagerState : a2(d2, l2.action);
        else {
          var q = {
            lane: m2,
            action: l2.action,
            hasEagerState: l2.hasEagerState,
            eagerState: l2.eagerState,
            next: null
          };
          null === k2 ? (h2 = k2 = q, g2 = d2) : k2 = k2.next = q;
          M2.lanes |= m2;
          rh |= m2;
        }
        l2 = l2.next;
      } while (null !== l2 && l2 !== f2);
      null === k2 ? g2 = d2 : k2.next = h2;
      He(d2, b2.memoizedState) || (dh = true);
      b2.memoizedState = d2;
      b2.baseState = g2;
      b2.baseQueue = k2;
      c2.lastRenderedState = d2;
    }
    a2 = c2.interleaved;
    if (null !== a2) {
      e2 = a2;
      do
        f2 = e2.lane, M2.lanes |= f2, rh |= f2, e2 = e2.next;
      while (e2 !== a2);
    } else null === e2 && (c2.lanes = 0);
    return [b2.memoizedState, c2.dispatch];
  }
  function Xh(a2) {
    var b2 = Uh(), c2 = b2.queue;
    if (null === c2) throw Error(p2(311));
    c2.lastRenderedReducer = a2;
    var d2 = c2.dispatch, e2 = c2.pending, f2 = b2.memoizedState;
    if (null !== e2) {
      c2.pending = null;
      var g2 = e2 = e2.next;
      do
        f2 = a2(f2, g2.action), g2 = g2.next;
      while (g2 !== e2);
      He(f2, b2.memoizedState) || (dh = true);
      b2.memoizedState = f2;
      null === b2.baseQueue && (b2.baseState = f2);
      c2.lastRenderedState = f2;
    }
    return [f2, d2];
  }
  function Yh() {
  }
  function Zh(a2, b2) {
    var c2 = M2, d2 = Uh(), e2 = b2(), f2 = !He(d2.memoizedState, e2);
    f2 && (d2.memoizedState = e2, dh = true);
    d2 = d2.queue;
    $h(ai.bind(null, c2, d2, a2), [a2]);
    if (d2.getSnapshot !== b2 || f2 || null !== O && O.memoizedState.tag & 1) {
      c2.flags |= 2048;
      bi(9, ci.bind(null, c2, d2, e2, b2), void 0, null);
      if (null === Q) throw Error(p2(349));
      0 !== (Hh & 30) || di(c2, b2, e2);
    }
    return e2;
  }
  function di(a2, b2, c2) {
    a2.flags |= 16384;
    a2 = { getSnapshot: b2, value: c2 };
    b2 = M2.updateQueue;
    null === b2 ? (b2 = { lastEffect: null, stores: null }, M2.updateQueue = b2, b2.stores = [a2]) : (c2 = b2.stores, null === c2 ? b2.stores = [a2] : c2.push(a2));
  }
  function ci(a2, b2, c2, d2) {
    b2.value = c2;
    b2.getSnapshot = d2;
    ei(b2) && fi(a2);
  }
  function ai(a2, b2, c2) {
    return c2(function() {
      ei(b2) && fi(a2);
    });
  }
  function ei(a2) {
    var b2 = a2.getSnapshot;
    a2 = a2.value;
    try {
      var c2 = b2();
      return !He(a2, c2);
    } catch (d2) {
      return true;
    }
  }
  function fi(a2) {
    var b2 = ih(a2, 1);
    null !== b2 && gi(b2, a2, 1, -1);
  }
  function hi(a2) {
    var b2 = Th();
    "function" === typeof a2 && (a2 = a2());
    b2.memoizedState = b2.baseState = a2;
    a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Vh, lastRenderedState: a2 };
    b2.queue = a2;
    a2 = a2.dispatch = ii.bind(null, M2, a2);
    return [b2.memoizedState, a2];
  }
  function bi(a2, b2, c2, d2) {
    a2 = { tag: a2, create: b2, destroy: c2, deps: d2, next: null };
    b2 = M2.updateQueue;
    null === b2 ? (b2 = { lastEffect: null, stores: null }, M2.updateQueue = b2, b2.lastEffect = a2.next = a2) : (c2 = b2.lastEffect, null === c2 ? b2.lastEffect = a2.next = a2 : (d2 = c2.next, c2.next = a2, a2.next = d2, b2.lastEffect = a2));
    return a2;
  }
  function ji() {
    return Uh().memoizedState;
  }
  function ki(a2, b2, c2, d2) {
    var e2 = Th();
    M2.flags |= a2;
    e2.memoizedState = bi(1 | b2, c2, void 0, void 0 === d2 ? null : d2);
  }
  function li(a2, b2, c2, d2) {
    var e2 = Uh();
    d2 = void 0 === d2 ? null : d2;
    var f2 = void 0;
    if (null !== N2) {
      var g2 = N2.memoizedState;
      f2 = g2.destroy;
      if (null !== d2 && Mh(d2, g2.deps)) {
        e2.memoizedState = bi(b2, c2, f2, d2);
        return;
      }
    }
    M2.flags |= a2;
    e2.memoizedState = bi(1 | b2, c2, f2, d2);
  }
  function mi(a2, b2) {
    return ki(8390656, 8, a2, b2);
  }
  function $h(a2, b2) {
    return li(2048, 8, a2, b2);
  }
  function ni(a2, b2) {
    return li(4, 2, a2, b2);
  }
  function oi(a2, b2) {
    return li(4, 4, a2, b2);
  }
  function pi(a2, b2) {
    if ("function" === typeof b2) return a2 = a2(), b2(a2), function() {
      b2(null);
    };
    if (null !== b2 && void 0 !== b2) return a2 = a2(), b2.current = a2, function() {
      b2.current = null;
    };
  }
  function qi(a2, b2, c2) {
    c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
    return li(4, 4, pi.bind(null, b2, a2), c2);
  }
  function ri() {
  }
  function si(a2, b2) {
    var c2 = Uh();
    b2 = void 0 === b2 ? null : b2;
    var d2 = c2.memoizedState;
    if (null !== d2 && null !== b2 && Mh(b2, d2[1])) return d2[0];
    c2.memoizedState = [a2, b2];
    return a2;
  }
  function ti(a2, b2) {
    var c2 = Uh();
    b2 = void 0 === b2 ? null : b2;
    var d2 = c2.memoizedState;
    if (null !== d2 && null !== b2 && Mh(b2, d2[1])) return d2[0];
    a2 = a2();
    c2.memoizedState = [a2, b2];
    return a2;
  }
  function ui(a2, b2, c2) {
    if (0 === (Hh & 21)) return a2.baseState && (a2.baseState = false, dh = true), a2.memoizedState = c2;
    He(c2, b2) || (c2 = yc(), M2.lanes |= c2, rh |= c2, a2.baseState = true);
    return b2;
  }
  function vi(a2, b2) {
    var c2 = C;
    C = 0 !== c2 && 4 > c2 ? c2 : 4;
    a2(true);
    var d2 = Gh.transition;
    Gh.transition = {};
    try {
      a2(false), b2();
    } finally {
      C = c2, Gh.transition = d2;
    }
  }
  function wi() {
    return Uh().memoizedState;
  }
  function xi(a2, b2, c2) {
    var d2 = yi(a2);
    c2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
    if (zi(a2)) Ai(b2, c2);
    else if (c2 = hh(a2, b2, c2, d2), null !== c2) {
      var e2 = R();
      gi(c2, a2, d2, e2);
      Bi(c2, b2, d2);
    }
  }
  function ii(a2, b2, c2) {
    var d2 = yi(a2), e2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
    if (zi(a2)) Ai(b2, e2);
    else {
      var f2 = a2.alternate;
      if (0 === a2.lanes && (null === f2 || 0 === f2.lanes) && (f2 = b2.lastRenderedReducer, null !== f2)) try {
        var g2 = b2.lastRenderedState, h2 = f2(g2, c2);
        e2.hasEagerState = true;
        e2.eagerState = h2;
        if (He(h2, g2)) {
          var k2 = b2.interleaved;
          null === k2 ? (e2.next = e2, gh(b2)) : (e2.next = k2.next, k2.next = e2);
          b2.interleaved = e2;
          return;
        }
      } catch (l2) {
      } finally {
      }
      c2 = hh(a2, b2, e2, d2);
      null !== c2 && (e2 = R(), gi(c2, a2, d2, e2), Bi(c2, b2, d2));
    }
  }
  function zi(a2) {
    var b2 = a2.alternate;
    return a2 === M2 || null !== b2 && b2 === M2;
  }
  function Ai(a2, b2) {
    Jh = Ih = true;
    var c2 = a2.pending;
    null === c2 ? b2.next = b2 : (b2.next = c2.next, c2.next = b2);
    a2.pending = b2;
  }
  function Bi(a2, b2, c2) {
    if (0 !== (c2 & 4194240)) {
      var d2 = b2.lanes;
      d2 &= a2.pendingLanes;
      c2 |= d2;
      b2.lanes = c2;
      Cc(a2, c2);
    }
  }
  var Rh = { readContext: eh, useCallback: P, useContext: P, useEffect: P, useImperativeHandle: P, useInsertionEffect: P, useLayoutEffect: P, useMemo: P, useReducer: P, useRef: P, useState: P, useDebugValue: P, useDeferredValue: P, useTransition: P, useMutableSource: P, useSyncExternalStore: P, useId: P, unstable_isNewReconciler: false }, Oh = { readContext: eh, useCallback: function(a2, b2) {
    Th().memoizedState = [a2, void 0 === b2 ? null : b2];
    return a2;
  }, useContext: eh, useEffect: mi, useImperativeHandle: function(a2, b2, c2) {
    c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
    return ki(
      4194308,
      4,
      pi.bind(null, b2, a2),
      c2
    );
  }, useLayoutEffect: function(a2, b2) {
    return ki(4194308, 4, a2, b2);
  }, useInsertionEffect: function(a2, b2) {
    return ki(4, 2, a2, b2);
  }, useMemo: function(a2, b2) {
    var c2 = Th();
    b2 = void 0 === b2 ? null : b2;
    a2 = a2();
    c2.memoizedState = [a2, b2];
    return a2;
  }, useReducer: function(a2, b2, c2) {
    var d2 = Th();
    b2 = void 0 !== c2 ? c2(b2) : b2;
    d2.memoizedState = d2.baseState = b2;
    a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a2, lastRenderedState: b2 };
    d2.queue = a2;
    a2 = a2.dispatch = xi.bind(null, M2, a2);
    return [d2.memoizedState, a2];
  }, useRef: function(a2) {
    var b2 = Th();
    a2 = { current: a2 };
    return b2.memoizedState = a2;
  }, useState: hi, useDebugValue: ri, useDeferredValue: function(a2) {
    return Th().memoizedState = a2;
  }, useTransition: function() {
    var a2 = hi(false), b2 = a2[0];
    a2 = vi.bind(null, a2[1]);
    Th().memoizedState = a2;
    return [b2, a2];
  }, useMutableSource: function() {
  }, useSyncExternalStore: function(a2, b2, c2) {
    var d2 = M2, e2 = Th();
    if (I) {
      if (void 0 === c2) throw Error(p2(407));
      c2 = c2();
    } else {
      c2 = b2();
      if (null === Q) throw Error(p2(349));
      0 !== (Hh & 30) || di(d2, b2, c2);
    }
    e2.memoizedState = c2;
    var f2 = { value: c2, getSnapshot: b2 };
    e2.queue = f2;
    mi(ai.bind(
      null,
      d2,
      f2,
      a2
    ), [a2]);
    d2.flags |= 2048;
    bi(9, ci.bind(null, d2, f2, c2, b2), void 0, null);
    return c2;
  }, useId: function() {
    var a2 = Th(), b2 = Q.identifierPrefix;
    if (I) {
      var c2 = sg;
      var d2 = rg;
      c2 = (d2 & ~(1 << 32 - oc(d2) - 1)).toString(32) + c2;
      b2 = ":" + b2 + "R" + c2;
      c2 = Kh++;
      0 < c2 && (b2 += "H" + c2.toString(32));
      b2 += ":";
    } else c2 = Lh++, b2 = ":" + b2 + "r" + c2.toString(32) + ":";
    return a2.memoizedState = b2;
  }, unstable_isNewReconciler: false }, Ph = {
    readContext: eh,
    useCallback: si,
    useContext: eh,
    useEffect: $h,
    useImperativeHandle: qi,
    useInsertionEffect: ni,
    useLayoutEffect: oi,
    useMemo: ti,
    useReducer: Wh,
    useRef: ji,
    useState: function() {
      return Wh(Vh);
    },
    useDebugValue: ri,
    useDeferredValue: function(a2) {
      var b2 = Uh();
      return ui(b2, N2.memoizedState, a2);
    },
    useTransition: function() {
      var a2 = Wh(Vh)[0], b2 = Uh().memoizedState;
      return [a2, b2];
    },
    useMutableSource: Yh,
    useSyncExternalStore: Zh,
    useId: wi,
    unstable_isNewReconciler: false
  }, Qh = { readContext: eh, useCallback: si, useContext: eh, useEffect: $h, useImperativeHandle: qi, useInsertionEffect: ni, useLayoutEffect: oi, useMemo: ti, useReducer: Xh, useRef: ji, useState: function() {
    return Xh(Vh);
  }, useDebugValue: ri, useDeferredValue: function(a2) {
    var b2 = Uh();
    return null === N2 ? b2.memoizedState = a2 : ui(b2, N2.memoizedState, a2);
  }, useTransition: function() {
    var a2 = Xh(Vh)[0], b2 = Uh().memoizedState;
    return [a2, b2];
  }, useMutableSource: Yh, useSyncExternalStore: Zh, useId: wi, unstable_isNewReconciler: false };
  function Ci(a2, b2) {
    if (a2 && a2.defaultProps) {
      b2 = A({}, b2);
      a2 = a2.defaultProps;
      for (var c2 in a2) void 0 === b2[c2] && (b2[c2] = a2[c2]);
      return b2;
    }
    return b2;
  }
  function Di(a2, b2, c2, d2) {
    b2 = a2.memoizedState;
    c2 = c2(d2, b2);
    c2 = null === c2 || void 0 === c2 ? b2 : A({}, b2, c2);
    a2.memoizedState = c2;
    0 === a2.lanes && (a2.updateQueue.baseState = c2);
  }
  var Ei = { isMounted: function(a2) {
    return (a2 = a2._reactInternals) ? Vb(a2) === a2 : false;
  }, enqueueSetState: function(a2, b2, c2) {
    a2 = a2._reactInternals;
    var d2 = R(), e2 = yi(a2), f2 = mh(d2, e2);
    f2.payload = b2;
    void 0 !== c2 && null !== c2 && (f2.callback = c2);
    b2 = nh(a2, f2, e2);
    null !== b2 && (gi(b2, a2, e2, d2), oh(b2, a2, e2));
  }, enqueueReplaceState: function(a2, b2, c2) {
    a2 = a2._reactInternals;
    var d2 = R(), e2 = yi(a2), f2 = mh(d2, e2);
    f2.tag = 1;
    f2.payload = b2;
    void 0 !== c2 && null !== c2 && (f2.callback = c2);
    b2 = nh(a2, f2, e2);
    null !== b2 && (gi(b2, a2, e2, d2), oh(b2, a2, e2));
  }, enqueueForceUpdate: function(a2, b2) {
    a2 = a2._reactInternals;
    var c2 = R(), d2 = yi(a2), e2 = mh(c2, d2);
    e2.tag = 2;
    void 0 !== b2 && null !== b2 && (e2.callback = b2);
    b2 = nh(a2, e2, d2);
    null !== b2 && (gi(b2, a2, d2, c2), oh(b2, a2, d2));
  } };
  function Fi(a2, b2, c2, d2, e2, f2, g2) {
    a2 = a2.stateNode;
    return "function" === typeof a2.shouldComponentUpdate ? a2.shouldComponentUpdate(d2, f2, g2) : b2.prototype && b2.prototype.isPureReactComponent ? !Ie(c2, d2) || !Ie(e2, f2) : true;
  }
  function Gi(a2, b2, c2) {
    var d2 = false, e2 = Vf;
    var f2 = b2.contextType;
    "object" === typeof f2 && null !== f2 ? f2 = eh(f2) : (e2 = Zf(b2) ? Xf : H2.current, d2 = b2.contextTypes, f2 = (d2 = null !== d2 && void 0 !== d2) ? Yf(a2, e2) : Vf);
    b2 = new b2(c2, f2);
    a2.memoizedState = null !== b2.state && void 0 !== b2.state ? b2.state : null;
    b2.updater = Ei;
    a2.stateNode = b2;
    b2._reactInternals = a2;
    d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = e2, a2.__reactInternalMemoizedMaskedChildContext = f2);
    return b2;
  }
  function Hi(a2, b2, c2, d2) {
    a2 = b2.state;
    "function" === typeof b2.componentWillReceiveProps && b2.componentWillReceiveProps(c2, d2);
    "function" === typeof b2.UNSAFE_componentWillReceiveProps && b2.UNSAFE_componentWillReceiveProps(c2, d2);
    b2.state !== a2 && Ei.enqueueReplaceState(b2, b2.state, null);
  }
  function Ii(a2, b2, c2, d2) {
    var e2 = a2.stateNode;
    e2.props = c2;
    e2.state = a2.memoizedState;
    e2.refs = {};
    kh(a2);
    var f2 = b2.contextType;
    "object" === typeof f2 && null !== f2 ? e2.context = eh(f2) : (f2 = Zf(b2) ? Xf : H2.current, e2.context = Yf(a2, f2));
    e2.state = a2.memoizedState;
    f2 = b2.getDerivedStateFromProps;
    "function" === typeof f2 && (Di(a2, b2, f2, c2), e2.state = a2.memoizedState);
    "function" === typeof b2.getDerivedStateFromProps || "function" === typeof e2.getSnapshotBeforeUpdate || "function" !== typeof e2.UNSAFE_componentWillMount && "function" !== typeof e2.componentWillMount || (b2 = e2.state, "function" === typeof e2.componentWillMount && e2.componentWillMount(), "function" === typeof e2.UNSAFE_componentWillMount && e2.UNSAFE_componentWillMount(), b2 !== e2.state && Ei.enqueueReplaceState(e2, e2.state, null), qh(a2, c2, e2, d2), e2.state = a2.memoizedState);
    "function" === typeof e2.componentDidMount && (a2.flags |= 4194308);
  }
  function Ji(a2, b2) {
    try {
      var c2 = "", d2 = b2;
      do
        c2 += Pa(d2), d2 = d2.return;
      while (d2);
      var e2 = c2;
    } catch (f2) {
      e2 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
    }
    return { value: a2, source: b2, stack: e2, digest: null };
  }
  function Ki(a2, b2, c2) {
    return { value: a2, source: null, stack: null != c2 ? c2 : null, digest: null != b2 ? b2 : null };
  }
  function Li(a2, b2) {
    try {
      console.error(b2.value);
    } catch (c2) {
      setTimeout(function() {
        throw c2;
      });
    }
  }
  var Mi = "function" === typeof WeakMap ? WeakMap : Map;
  function Ni(a2, b2, c2) {
    c2 = mh(-1, c2);
    c2.tag = 3;
    c2.payload = { element: null };
    var d2 = b2.value;
    c2.callback = function() {
      Oi || (Oi = true, Pi = d2);
      Li(a2, b2);
    };
    return c2;
  }
  function Qi(a2, b2, c2) {
    c2 = mh(-1, c2);
    c2.tag = 3;
    var d2 = a2.type.getDerivedStateFromError;
    if ("function" === typeof d2) {
      var e2 = b2.value;
      c2.payload = function() {
        return d2(e2);
      };
      c2.callback = function() {
        Li(a2, b2);
      };
    }
    var f2 = a2.stateNode;
    null !== f2 && "function" === typeof f2.componentDidCatch && (c2.callback = function() {
      Li(a2, b2);
      "function" !== typeof d2 && (null === Ri ? Ri = /* @__PURE__ */ new Set([this]) : Ri.add(this));
      var c3 = b2.stack;
      this.componentDidCatch(b2.value, { componentStack: null !== c3 ? c3 : "" });
    });
    return c2;
  }
  function Si(a2, b2, c2) {
    var d2 = a2.pingCache;
    if (null === d2) {
      d2 = a2.pingCache = new Mi();
      var e2 = /* @__PURE__ */ new Set();
      d2.set(b2, e2);
    } else e2 = d2.get(b2), void 0 === e2 && (e2 = /* @__PURE__ */ new Set(), d2.set(b2, e2));
    e2.has(c2) || (e2.add(c2), a2 = Ti.bind(null, a2, b2, c2), b2.then(a2, a2));
  }
  function Ui(a2) {
    do {
      var b2;
      if (b2 = 13 === a2.tag) b2 = a2.memoizedState, b2 = null !== b2 ? null !== b2.dehydrated ? true : false : true;
      if (b2) return a2;
      a2 = a2.return;
    } while (null !== a2);
    return null;
  }
  function Vi(a2, b2, c2, d2, e2) {
    if (0 === (a2.mode & 1)) return a2 === b2 ? a2.flags |= 65536 : (a2.flags |= 128, c2.flags |= 131072, c2.flags &= -52805, 1 === c2.tag && (null === c2.alternate ? c2.tag = 17 : (b2 = mh(-1, 1), b2.tag = 2, nh(c2, b2, 1))), c2.lanes |= 1), a2;
    a2.flags |= 65536;
    a2.lanes = e2;
    return a2;
  }
  var Wi = ua.ReactCurrentOwner, dh = false;
  function Xi(a2, b2, c2, d2) {
    b2.child = null === a2 ? Vg(b2, null, c2, d2) : Ug(b2, a2.child, c2, d2);
  }
  function Yi(a2, b2, c2, d2, e2) {
    c2 = c2.render;
    var f2 = b2.ref;
    ch(b2, e2);
    d2 = Nh(a2, b2, c2, d2, f2, e2);
    c2 = Sh();
    if (null !== a2 && !dh) return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e2, Zi(a2, b2, e2);
    I && c2 && vg(b2);
    b2.flags |= 1;
    Xi(a2, b2, d2, e2);
    return b2.child;
  }
  function $i(a2, b2, c2, d2, e2) {
    if (null === a2) {
      var f2 = c2.type;
      if ("function" === typeof f2 && !aj(f2) && void 0 === f2.defaultProps && null === c2.compare && void 0 === c2.defaultProps) return b2.tag = 15, b2.type = f2, bj(a2, b2, f2, d2, e2);
      a2 = Rg(c2.type, null, d2, b2, b2.mode, e2);
      a2.ref = b2.ref;
      a2.return = b2;
      return b2.child = a2;
    }
    f2 = a2.child;
    if (0 === (a2.lanes & e2)) {
      var g2 = f2.memoizedProps;
      c2 = c2.compare;
      c2 = null !== c2 ? c2 : Ie;
      if (c2(g2, d2) && a2.ref === b2.ref) return Zi(a2, b2, e2);
    }
    b2.flags |= 1;
    a2 = Pg(f2, d2);
    a2.ref = b2.ref;
    a2.return = b2;
    return b2.child = a2;
  }
  function bj(a2, b2, c2, d2, e2) {
    if (null !== a2) {
      var f2 = a2.memoizedProps;
      if (Ie(f2, d2) && a2.ref === b2.ref) if (dh = false, b2.pendingProps = d2 = f2, 0 !== (a2.lanes & e2)) 0 !== (a2.flags & 131072) && (dh = true);
      else return b2.lanes = a2.lanes, Zi(a2, b2, e2);
    }
    return cj(a2, b2, c2, d2, e2);
  }
  function dj(a2, b2, c2) {
    var d2 = b2.pendingProps, e2 = d2.children, f2 = null !== a2 ? a2.memoizedState : null;
    if ("hidden" === d2.mode) if (0 === (b2.mode & 1)) b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(ej, fj), fj |= c2;
    else {
      if (0 === (c2 & 1073741824)) return a2 = null !== f2 ? f2.baseLanes | c2 : c2, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = { baseLanes: a2, cachePool: null, transitions: null }, b2.updateQueue = null, G(ej, fj), fj |= a2, null;
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
      d2 = null !== f2 ? f2.baseLanes : c2;
      G(ej, fj);
      fj |= d2;
    }
    else null !== f2 ? (d2 = f2.baseLanes | c2, b2.memoizedState = null) : d2 = c2, G(ej, fj), fj |= d2;
    Xi(a2, b2, e2, c2);
    return b2.child;
  }
  function gj(a2, b2) {
    var c2 = b2.ref;
    if (null === a2 && null !== c2 || null !== a2 && a2.ref !== c2) b2.flags |= 512, b2.flags |= 2097152;
  }
  function cj(a2, b2, c2, d2, e2) {
    var f2 = Zf(c2) ? Xf : H2.current;
    f2 = Yf(b2, f2);
    ch(b2, e2);
    c2 = Nh(a2, b2, c2, d2, f2, e2);
    d2 = Sh();
    if (null !== a2 && !dh) return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e2, Zi(a2, b2, e2);
    I && d2 && vg(b2);
    b2.flags |= 1;
    Xi(a2, b2, c2, e2);
    return b2.child;
  }
  function hj(a2, b2, c2, d2, e2) {
    if (Zf(c2)) {
      var f2 = true;
      cg(b2);
    } else f2 = false;
    ch(b2, e2);
    if (null === b2.stateNode) ij(a2, b2), Gi(b2, c2, d2), Ii(b2, c2, d2, e2), d2 = true;
    else if (null === a2) {
      var g2 = b2.stateNode, h2 = b2.memoizedProps;
      g2.props = h2;
      var k2 = g2.context, l2 = c2.contextType;
      "object" === typeof l2 && null !== l2 ? l2 = eh(l2) : (l2 = Zf(c2) ? Xf : H2.current, l2 = Yf(b2, l2));
      var m2 = c2.getDerivedStateFromProps, q = "function" === typeof m2 || "function" === typeof g2.getSnapshotBeforeUpdate;
      q || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== d2 || k2 !== l2) && Hi(b2, g2, d2, l2);
      jh = false;
      var r2 = b2.memoizedState;
      g2.state = r2;
      qh(b2, d2, g2, e2);
      k2 = b2.memoizedState;
      h2 !== d2 || r2 !== k2 || Wf.current || jh ? ("function" === typeof m2 && (Di(b2, c2, m2, d2), k2 = b2.memoizedState), (h2 = jh || Fi(b2, c2, h2, d2, r2, k2, l2)) ? (q || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b2.flags |= 4194308)) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), b2.memoizedProps = d2, b2.memoizedState = k2), g2.props = d2, g2.state = k2, g2.context = l2, d2 = h2) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), d2 = false);
    } else {
      g2 = b2.stateNode;
      lh(a2, b2);
      h2 = b2.memoizedProps;
      l2 = b2.type === b2.elementType ? h2 : Ci(b2.type, h2);
      g2.props = l2;
      q = b2.pendingProps;
      r2 = g2.context;
      k2 = c2.contextType;
      "object" === typeof k2 && null !== k2 ? k2 = eh(k2) : (k2 = Zf(c2) ? Xf : H2.current, k2 = Yf(b2, k2));
      var y2 = c2.getDerivedStateFromProps;
      (m2 = "function" === typeof y2 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== q || r2 !== k2) && Hi(b2, g2, d2, k2);
      jh = false;
      r2 = b2.memoizedState;
      g2.state = r2;
      qh(b2, d2, g2, e2);
      var n2 = b2.memoizedState;
      h2 !== q || r2 !== n2 || Wf.current || jh ? ("function" === typeof y2 && (Di(b2, c2, y2, d2), n2 = b2.memoizedState), (l2 = jh || Fi(b2, c2, l2, d2, r2, n2, k2) || false) ? (m2 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(d2, n2, k2), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d2, n2, k2)), "function" === typeof g2.componentDidUpdate && (b2.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b2.flags |= 1024)) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 1024), b2.memoizedProps = d2, b2.memoizedState = n2), g2.props = d2, g2.state = n2, g2.context = k2, d2 = l2) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 1024), d2 = false);
    }
    return jj(a2, b2, c2, d2, f2, e2);
  }
  function jj(a2, b2, c2, d2, e2, f2) {
    gj(a2, b2);
    var g2 = 0 !== (b2.flags & 128);
    if (!d2 && !g2) return e2 && dg(b2, c2, false), Zi(a2, b2, f2);
    d2 = b2.stateNode;
    Wi.current = b2;
    var h2 = g2 && "function" !== typeof c2.getDerivedStateFromError ? null : d2.render();
    b2.flags |= 1;
    null !== a2 && g2 ? (b2.child = Ug(b2, a2.child, null, f2), b2.child = Ug(b2, null, h2, f2)) : Xi(a2, b2, h2, f2);
    b2.memoizedState = d2.state;
    e2 && dg(b2, c2, true);
    return b2.child;
  }
  function kj(a2) {
    var b2 = a2.stateNode;
    b2.pendingContext ? ag(a2, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && ag(a2, b2.context, false);
    yh(a2, b2.containerInfo);
  }
  function lj(a2, b2, c2, d2, e2) {
    Ig();
    Jg(e2);
    b2.flags |= 256;
    Xi(a2, b2, c2, d2);
    return b2.child;
  }
  var mj = { dehydrated: null, treeContext: null, retryLane: 0 };
  function nj(a2) {
    return { baseLanes: a2, cachePool: null, transitions: null };
  }
  function oj(a2, b2, c2) {
    var d2 = b2.pendingProps, e2 = L.current, f2 = false, g2 = 0 !== (b2.flags & 128), h2;
    (h2 = g2) || (h2 = null !== a2 && null === a2.memoizedState ? false : 0 !== (e2 & 2));
    if (h2) f2 = true, b2.flags &= -129;
    else if (null === a2 || null !== a2.memoizedState) e2 |= 1;
    G(L, e2 & 1);
    if (null === a2) {
      Eg(b2);
      a2 = b2.memoizedState;
      if (null !== a2 && (a2 = a2.dehydrated, null !== a2)) return 0 === (b2.mode & 1) ? b2.lanes = 1 : "$!" === a2.data ? b2.lanes = 8 : b2.lanes = 1073741824, null;
      g2 = d2.children;
      a2 = d2.fallback;
      return f2 ? (d2 = b2.mode, f2 = b2.child, g2 = { mode: "hidden", children: g2 }, 0 === (d2 & 1) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = g2) : f2 = pj(g2, d2, 0, null), a2 = Tg(a2, d2, c2, null), f2.return = b2, a2.return = b2, f2.sibling = a2, b2.child = f2, b2.child.memoizedState = nj(c2), b2.memoizedState = mj, a2) : qj(b2, g2);
    }
    e2 = a2.memoizedState;
    if (null !== e2 && (h2 = e2.dehydrated, null !== h2)) return rj(a2, b2, g2, d2, h2, e2, c2);
    if (f2) {
      f2 = d2.fallback;
      g2 = b2.mode;
      e2 = a2.child;
      h2 = e2.sibling;
      var k2 = { mode: "hidden", children: d2.children };
      0 === (g2 & 1) && b2.child !== e2 ? (d2 = b2.child, d2.childLanes = 0, d2.pendingProps = k2, b2.deletions = null) : (d2 = Pg(e2, k2), d2.subtreeFlags = e2.subtreeFlags & 14680064);
      null !== h2 ? f2 = Pg(h2, f2) : (f2 = Tg(f2, g2, c2, null), f2.flags |= 2);
      f2.return = b2;
      d2.return = b2;
      d2.sibling = f2;
      b2.child = d2;
      d2 = f2;
      f2 = b2.child;
      g2 = a2.child.memoizedState;
      g2 = null === g2 ? nj(c2) : { baseLanes: g2.baseLanes | c2, cachePool: null, transitions: g2.transitions };
      f2.memoizedState = g2;
      f2.childLanes = a2.childLanes & ~c2;
      b2.memoizedState = mj;
      return d2;
    }
    f2 = a2.child;
    a2 = f2.sibling;
    d2 = Pg(f2, { mode: "visible", children: d2.children });
    0 === (b2.mode & 1) && (d2.lanes = c2);
    d2.return = b2;
    d2.sibling = null;
    null !== a2 && (c2 = b2.deletions, null === c2 ? (b2.deletions = [a2], b2.flags |= 16) : c2.push(a2));
    b2.child = d2;
    b2.memoizedState = null;
    return d2;
  }
  function qj(a2, b2) {
    b2 = pj({ mode: "visible", children: b2 }, a2.mode, 0, null);
    b2.return = a2;
    return a2.child = b2;
  }
  function sj(a2, b2, c2, d2) {
    null !== d2 && Jg(d2);
    Ug(b2, a2.child, null, c2);
    a2 = qj(b2, b2.pendingProps.children);
    a2.flags |= 2;
    b2.memoizedState = null;
    return a2;
  }
  function rj(a2, b2, c2, d2, e2, f2, g2) {
    if (c2) {
      if (b2.flags & 256) return b2.flags &= -257, d2 = Ki(Error(p2(422))), sj(a2, b2, g2, d2);
      if (null !== b2.memoizedState) return b2.child = a2.child, b2.flags |= 128, null;
      f2 = d2.fallback;
      e2 = b2.mode;
      d2 = pj({ mode: "visible", children: d2.children }, e2, 0, null);
      f2 = Tg(f2, e2, g2, null);
      f2.flags |= 2;
      d2.return = b2;
      f2.return = b2;
      d2.sibling = f2;
      b2.child = d2;
      0 !== (b2.mode & 1) && Ug(b2, a2.child, null, g2);
      b2.child.memoizedState = nj(g2);
      b2.memoizedState = mj;
      return f2;
    }
    if (0 === (b2.mode & 1)) return sj(a2, b2, g2, null);
    if ("$!" === e2.data) {
      d2 = e2.nextSibling && e2.nextSibling.dataset;
      if (d2) var h2 = d2.dgst;
      d2 = h2;
      f2 = Error(p2(419));
      d2 = Ki(f2, d2, void 0);
      return sj(a2, b2, g2, d2);
    }
    h2 = 0 !== (g2 & a2.childLanes);
    if (dh || h2) {
      d2 = Q;
      if (null !== d2) {
        switch (g2 & -g2) {
          case 4:
            e2 = 2;
            break;
          case 16:
            e2 = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            e2 = 32;
            break;
          case 536870912:
            e2 = 268435456;
            break;
          default:
            e2 = 0;
        }
        e2 = 0 !== (e2 & (d2.suspendedLanes | g2)) ? 0 : e2;
        0 !== e2 && e2 !== f2.retryLane && (f2.retryLane = e2, ih(a2, e2), gi(d2, a2, e2, -1));
      }
      tj();
      d2 = Ki(Error(p2(421)));
      return sj(a2, b2, g2, d2);
    }
    if ("$?" === e2.data) return b2.flags |= 128, b2.child = a2.child, b2 = uj.bind(null, a2), e2._reactRetry = b2, null;
    a2 = f2.treeContext;
    yg = Lf(e2.nextSibling);
    xg = b2;
    I = true;
    zg = null;
    null !== a2 && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a2.id, sg = a2.overflow, qg = b2);
    b2 = qj(b2, d2.children);
    b2.flags |= 4096;
    return b2;
  }
  function vj(a2, b2, c2) {
    a2.lanes |= b2;
    var d2 = a2.alternate;
    null !== d2 && (d2.lanes |= b2);
    bh(a2.return, b2, c2);
  }
  function wj(a2, b2, c2, d2, e2) {
    var f2 = a2.memoizedState;
    null === f2 ? a2.memoizedState = { isBackwards: b2, rendering: null, renderingStartTime: 0, last: d2, tail: c2, tailMode: e2 } : (f2.isBackwards = b2, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d2, f2.tail = c2, f2.tailMode = e2);
  }
  function xj(a2, b2, c2) {
    var d2 = b2.pendingProps, e2 = d2.revealOrder, f2 = d2.tail;
    Xi(a2, b2, d2.children, c2);
    d2 = L.current;
    if (0 !== (d2 & 2)) d2 = d2 & 1 | 2, b2.flags |= 128;
    else {
      if (null !== a2 && 0 !== (a2.flags & 128)) a: for (a2 = b2.child; null !== a2; ) {
        if (13 === a2.tag) null !== a2.memoizedState && vj(a2, c2, b2);
        else if (19 === a2.tag) vj(a2, c2, b2);
        else if (null !== a2.child) {
          a2.child.return = a2;
          a2 = a2.child;
          continue;
        }
        if (a2 === b2) break a;
        for (; null === a2.sibling; ) {
          if (null === a2.return || a2.return === b2) break a;
          a2 = a2.return;
        }
        a2.sibling.return = a2.return;
        a2 = a2.sibling;
      }
      d2 &= 1;
    }
    G(L, d2);
    if (0 === (b2.mode & 1)) b2.memoizedState = null;
    else switch (e2) {
      case "forwards":
        c2 = b2.child;
        for (e2 = null; null !== c2; ) a2 = c2.alternate, null !== a2 && null === Ch(a2) && (e2 = c2), c2 = c2.sibling;
        c2 = e2;
        null === c2 ? (e2 = b2.child, b2.child = null) : (e2 = c2.sibling, c2.sibling = null);
        wj(b2, false, e2, c2, f2);
        break;
      case "backwards":
        c2 = null;
        e2 = b2.child;
        for (b2.child = null; null !== e2; ) {
          a2 = e2.alternate;
          if (null !== a2 && null === Ch(a2)) {
            b2.child = e2;
            break;
          }
          a2 = e2.sibling;
          e2.sibling = c2;
          c2 = e2;
          e2 = a2;
        }
        wj(b2, true, c2, null, f2);
        break;
      case "together":
        wj(b2, false, null, null, void 0);
        break;
      default:
        b2.memoizedState = null;
    }
    return b2.child;
  }
  function ij(a2, b2) {
    0 === (b2.mode & 1) && null !== a2 && (a2.alternate = null, b2.alternate = null, b2.flags |= 2);
  }
  function Zi(a2, b2, c2) {
    null !== a2 && (b2.dependencies = a2.dependencies);
    rh |= b2.lanes;
    if (0 === (c2 & b2.childLanes)) return null;
    if (null !== a2 && b2.child !== a2.child) throw Error(p2(153));
    if (null !== b2.child) {
      a2 = b2.child;
      c2 = Pg(a2, a2.pendingProps);
      b2.child = c2;
      for (c2.return = b2; null !== a2.sibling; ) a2 = a2.sibling, c2 = c2.sibling = Pg(a2, a2.pendingProps), c2.return = b2;
      c2.sibling = null;
    }
    return b2.child;
  }
  function yj(a2, b2, c2) {
    switch (b2.tag) {
      case 3:
        kj(b2);
        Ig();
        break;
      case 5:
        Ah(b2);
        break;
      case 1:
        Zf(b2.type) && cg(b2);
        break;
      case 4:
        yh(b2, b2.stateNode.containerInfo);
        break;
      case 10:
        var d2 = b2.type._context, e2 = b2.memoizedProps.value;
        G(Wg, d2._currentValue);
        d2._currentValue = e2;
        break;
      case 13:
        d2 = b2.memoizedState;
        if (null !== d2) {
          if (null !== d2.dehydrated) return G(L, L.current & 1), b2.flags |= 128, null;
          if (0 !== (c2 & b2.child.childLanes)) return oj(a2, b2, c2);
          G(L, L.current & 1);
          a2 = Zi(a2, b2, c2);
          return null !== a2 ? a2.sibling : null;
        }
        G(L, L.current & 1);
        break;
      case 19:
        d2 = 0 !== (c2 & b2.childLanes);
        if (0 !== (a2.flags & 128)) {
          if (d2) return xj(a2, b2, c2);
          b2.flags |= 128;
        }
        e2 = b2.memoizedState;
        null !== e2 && (e2.rendering = null, e2.tail = null, e2.lastEffect = null);
        G(L, L.current);
        if (d2) break;
        else return null;
      case 22:
      case 23:
        return b2.lanes = 0, dj(a2, b2, c2);
    }
    return Zi(a2, b2, c2);
  }
  var zj, Aj, Bj, Cj;
  zj = function(a2, b2) {
    for (var c2 = b2.child; null !== c2; ) {
      if (5 === c2.tag || 6 === c2.tag) a2.appendChild(c2.stateNode);
      else if (4 !== c2.tag && null !== c2.child) {
        c2.child.return = c2;
        c2 = c2.child;
        continue;
      }
      if (c2 === b2) break;
      for (; null === c2.sibling; ) {
        if (null === c2.return || c2.return === b2) return;
        c2 = c2.return;
      }
      c2.sibling.return = c2.return;
      c2 = c2.sibling;
    }
  };
  Aj = function() {
  };
  Bj = function(a2, b2, c2, d2) {
    var e2 = a2.memoizedProps;
    if (e2 !== d2) {
      a2 = b2.stateNode;
      xh(uh.current);
      var f2 = null;
      switch (c2) {
        case "input":
          e2 = Ya(a2, e2);
          d2 = Ya(a2, d2);
          f2 = [];
          break;
        case "select":
          e2 = A({}, e2, { value: void 0 });
          d2 = A({}, d2, { value: void 0 });
          f2 = [];
          break;
        case "textarea":
          e2 = gb(a2, e2);
          d2 = gb(a2, d2);
          f2 = [];
          break;
        default:
          "function" !== typeof e2.onClick && "function" === typeof d2.onClick && (a2.onclick = Bf);
      }
      ub(c2, d2);
      var g2;
      c2 = null;
      for (l2 in e2) if (!d2.hasOwnProperty(l2) && e2.hasOwnProperty(l2) && null != e2[l2]) if ("style" === l2) {
        var h2 = e2[l2];
        for (g2 in h2) h2.hasOwnProperty(g2) && (c2 || (c2 = {}), c2[g2] = "");
      } else "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
      for (l2 in d2) {
        var k2 = d2[l2];
        h2 = null != e2 ? e2[l2] : void 0;
        if (d2.hasOwnProperty(l2) && k2 !== h2 && (null != k2 || null != h2)) if ("style" === l2) if (h2) {
          for (g2 in h2) !h2.hasOwnProperty(g2) || k2 && k2.hasOwnProperty(g2) || (c2 || (c2 = {}), c2[g2] = "");
          for (g2 in k2) k2.hasOwnProperty(g2) && h2[g2] !== k2[g2] && (c2 || (c2 = {}), c2[g2] = k2[g2]);
        } else c2 || (f2 || (f2 = []), f2.push(
          l2,
          c2
        )), c2 = k2;
        else "dangerouslySetInnerHTML" === l2 ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k2 && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : "children" === l2 ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l2, "" + k2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea.hasOwnProperty(l2) ? (null != k2 && "onScroll" === l2 && D("scroll", a2), f2 || h2 === k2 || (f2 = [])) : (f2 = f2 || []).push(l2, k2));
      }
      c2 && (f2 = f2 || []).push("style", c2);
      var l2 = f2;
      if (b2.updateQueue = l2) b2.flags |= 4;
    }
  };
  Cj = function(a2, b2, c2, d2) {
    c2 !== d2 && (b2.flags |= 4);
  };
  function Dj(a2, b2) {
    if (!I) switch (a2.tailMode) {
      case "hidden":
        b2 = a2.tail;
        for (var c2 = null; null !== b2; ) null !== b2.alternate && (c2 = b2), b2 = b2.sibling;
        null === c2 ? a2.tail = null : c2.sibling = null;
        break;
      case "collapsed":
        c2 = a2.tail;
        for (var d2 = null; null !== c2; ) null !== c2.alternate && (d2 = c2), c2 = c2.sibling;
        null === d2 ? b2 || null === a2.tail ? a2.tail = null : a2.tail.sibling = null : d2.sibling = null;
    }
  }
  function S2(a2) {
    var b2 = null !== a2.alternate && a2.alternate.child === a2.child, c2 = 0, d2 = 0;
    if (b2) for (var e2 = a2.child; null !== e2; ) c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags & 14680064, d2 |= e2.flags & 14680064, e2.return = a2, e2 = e2.sibling;
    else for (e2 = a2.child; null !== e2; ) c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags, d2 |= e2.flags, e2.return = a2, e2 = e2.sibling;
    a2.subtreeFlags |= d2;
    a2.childLanes = c2;
    return b2;
  }
  function Ej(a2, b2, c2) {
    var d2 = b2.pendingProps;
    wg(b2);
    switch (b2.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return S2(b2), null;
      case 1:
        return Zf(b2.type) && $f(), S2(b2), null;
      case 3:
        d2 = b2.stateNode;
        zh();
        E(Wf);
        E(H2);
        Eh();
        d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null);
        if (null === a2 || null === a2.child) Gg(b2) ? b2.flags |= 4 : null === a2 || a2.memoizedState.isDehydrated && 0 === (b2.flags & 256) || (b2.flags |= 1024, null !== zg && (Fj(zg), zg = null));
        Aj(a2, b2);
        S2(b2);
        return null;
      case 5:
        Bh(b2);
        var e2 = xh(wh.current);
        c2 = b2.type;
        if (null !== a2 && null != b2.stateNode) Bj(a2, b2, c2, d2, e2), a2.ref !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
        else {
          if (!d2) {
            if (null === b2.stateNode) throw Error(p2(166));
            S2(b2);
            return null;
          }
          a2 = xh(uh.current);
          if (Gg(b2)) {
            d2 = b2.stateNode;
            c2 = b2.type;
            var f2 = b2.memoizedProps;
            d2[Of] = b2;
            d2[Pf] = f2;
            a2 = 0 !== (b2.mode & 1);
            switch (c2) {
              case "dialog":
                D("cancel", d2);
                D("close", d2);
                break;
              case "iframe":
              case "object":
              case "embed":
                D("load", d2);
                break;
              case "video":
              case "audio":
                for (e2 = 0; e2 < lf.length; e2++) D(lf[e2], d2);
                break;
              case "source":
                D("error", d2);
                break;
              case "img":
              case "image":
              case "link":
                D(
                  "error",
                  d2
                );
                D("load", d2);
                break;
              case "details":
                D("toggle", d2);
                break;
              case "input":
                Za(d2, f2);
                D("invalid", d2);
                break;
              case "select":
                d2._wrapperState = { wasMultiple: !!f2.multiple };
                D("invalid", d2);
                break;
              case "textarea":
                hb(d2, f2), D("invalid", d2);
            }
            ub(c2, f2);
            e2 = null;
            for (var g2 in f2) if (f2.hasOwnProperty(g2)) {
              var h2 = f2[g2];
              "children" === g2 ? "string" === typeof h2 ? d2.textContent !== h2 && (true !== f2.suppressHydrationWarning && Af(d2.textContent, h2, a2), e2 = ["children", h2]) : "number" === typeof h2 && d2.textContent !== "" + h2 && (true !== f2.suppressHydrationWarning && Af(
                d2.textContent,
                h2,
                a2
              ), e2 = ["children", "" + h2]) : ea.hasOwnProperty(g2) && null != h2 && "onScroll" === g2 && D("scroll", d2);
            }
            switch (c2) {
              case "input":
                Va(d2);
                db(d2, f2, true);
                break;
              case "textarea":
                Va(d2);
                jb(d2);
                break;
              case "select":
              case "option":
                break;
              default:
                "function" === typeof f2.onClick && (d2.onclick = Bf);
            }
            d2 = e2;
            b2.updateQueue = d2;
            null !== d2 && (b2.flags |= 4);
          } else {
            g2 = 9 === e2.nodeType ? e2 : e2.ownerDocument;
            "http://www.w3.org/1999/xhtml" === a2 && (a2 = kb(c2));
            "http://www.w3.org/1999/xhtml" === a2 ? "script" === c2 ? (a2 = g2.createElement("div"), a2.innerHTML = "<script><\/script>", a2 = a2.removeChild(a2.firstChild)) : "string" === typeof d2.is ? a2 = g2.createElement(c2, { is: d2.is }) : (a2 = g2.createElement(c2), "select" === c2 && (g2 = a2, d2.multiple ? g2.multiple = true : d2.size && (g2.size = d2.size))) : a2 = g2.createElementNS(a2, c2);
            a2[Of] = b2;
            a2[Pf] = d2;
            zj(a2, b2, false, false);
            b2.stateNode = a2;
            a: {
              g2 = vb(c2, d2);
              switch (c2) {
                case "dialog":
                  D("cancel", a2);
                  D("close", a2);
                  e2 = d2;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  D("load", a2);
                  e2 = d2;
                  break;
                case "video":
                case "audio":
                  for (e2 = 0; e2 < lf.length; e2++) D(lf[e2], a2);
                  e2 = d2;
                  break;
                case "source":
                  D("error", a2);
                  e2 = d2;
                  break;
                case "img":
                case "image":
                case "link":
                  D(
                    "error",
                    a2
                  );
                  D("load", a2);
                  e2 = d2;
                  break;
                case "details":
                  D("toggle", a2);
                  e2 = d2;
                  break;
                case "input":
                  Za(a2, d2);
                  e2 = Ya(a2, d2);
                  D("invalid", a2);
                  break;
                case "option":
                  e2 = d2;
                  break;
                case "select":
                  a2._wrapperState = { wasMultiple: !!d2.multiple };
                  e2 = A({}, d2, { value: void 0 });
                  D("invalid", a2);
                  break;
                case "textarea":
                  hb(a2, d2);
                  e2 = gb(a2, d2);
                  D("invalid", a2);
                  break;
                default:
                  e2 = d2;
              }
              ub(c2, e2);
              h2 = e2;
              for (f2 in h2) if (h2.hasOwnProperty(f2)) {
                var k2 = h2[f2];
                "style" === f2 ? sb(a2, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && nb(a2, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c2 || "" !== k2) && ob(a2, k2) : "number" === typeof k2 && ob(a2, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ea.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && D("scroll", a2) : null != k2 && ta(a2, f2, k2, g2));
              }
              switch (c2) {
                case "input":
                  Va(a2);
                  db(a2, d2, false);
                  break;
                case "textarea":
                  Va(a2);
                  jb(a2);
                  break;
                case "option":
                  null != d2.value && a2.setAttribute("value", "" + Sa(d2.value));
                  break;
                case "select":
                  a2.multiple = !!d2.multiple;
                  f2 = d2.value;
                  null != f2 ? fb(a2, !!d2.multiple, f2, false) : null != d2.defaultValue && fb(
                    a2,
                    !!d2.multiple,
                    d2.defaultValue,
                    true
                  );
                  break;
                default:
                  "function" === typeof e2.onClick && (a2.onclick = Bf);
              }
              switch (c2) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  d2 = !!d2.autoFocus;
                  break a;
                case "img":
                  d2 = true;
                  break a;
                default:
                  d2 = false;
              }
            }
            d2 && (b2.flags |= 4);
          }
          null !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
        }
        S2(b2);
        return null;
      case 6:
        if (a2 && null != b2.stateNode) Cj(a2, b2, a2.memoizedProps, d2);
        else {
          if ("string" !== typeof d2 && null === b2.stateNode) throw Error(p2(166));
          c2 = xh(wh.current);
          xh(uh.current);
          if (Gg(b2)) {
            d2 = b2.stateNode;
            c2 = b2.memoizedProps;
            d2[Of] = b2;
            if (f2 = d2.nodeValue !== c2) {
              if (a2 = xg, null !== a2) switch (a2.tag) {
                case 3:
                  Af(d2.nodeValue, c2, 0 !== (a2.mode & 1));
                  break;
                case 5:
                  true !== a2.memoizedProps.suppressHydrationWarning && Af(d2.nodeValue, c2, 0 !== (a2.mode & 1));
              }
            }
            f2 && (b2.flags |= 4);
          } else d2 = (9 === c2.nodeType ? c2 : c2.ownerDocument).createTextNode(d2), d2[Of] = b2, b2.stateNode = d2;
        }
        S2(b2);
        return null;
      case 13:
        E(L);
        d2 = b2.memoizedState;
        if (null === a2 || null !== a2.memoizedState && null !== a2.memoizedState.dehydrated) {
          if (I && null !== yg && 0 !== (b2.mode & 1) && 0 === (b2.flags & 128)) Hg(), Ig(), b2.flags |= 98560, f2 = false;
          else if (f2 = Gg(b2), null !== d2 && null !== d2.dehydrated) {
            if (null === a2) {
              if (!f2) throw Error(p2(318));
              f2 = b2.memoizedState;
              f2 = null !== f2 ? f2.dehydrated : null;
              if (!f2) throw Error(p2(317));
              f2[Of] = b2;
            } else Ig(), 0 === (b2.flags & 128) && (b2.memoizedState = null), b2.flags |= 4;
            S2(b2);
            f2 = false;
          } else null !== zg && (Fj(zg), zg = null), f2 = true;
          if (!f2) return b2.flags & 65536 ? b2 : null;
        }
        if (0 !== (b2.flags & 128)) return b2.lanes = c2, b2;
        d2 = null !== d2;
        d2 !== (null !== a2 && null !== a2.memoizedState) && d2 && (b2.child.flags |= 8192, 0 !== (b2.mode & 1) && (null === a2 || 0 !== (L.current & 1) ? 0 === T && (T = 3) : tj()));
        null !== b2.updateQueue && (b2.flags |= 4);
        S2(b2);
        return null;
      case 4:
        return zh(), Aj(a2, b2), null === a2 && sf(b2.stateNode.containerInfo), S2(b2), null;
      case 10:
        return ah(b2.type._context), S2(b2), null;
      case 17:
        return Zf(b2.type) && $f(), S2(b2), null;
      case 19:
        E(L);
        f2 = b2.memoizedState;
        if (null === f2) return S2(b2), null;
        d2 = 0 !== (b2.flags & 128);
        g2 = f2.rendering;
        if (null === g2) if (d2) Dj(f2, false);
        else {
          if (0 !== T || null !== a2 && 0 !== (a2.flags & 128)) for (a2 = b2.child; null !== a2; ) {
            g2 = Ch(a2);
            if (null !== g2) {
              b2.flags |= 128;
              Dj(f2, false);
              d2 = g2.updateQueue;
              null !== d2 && (b2.updateQueue = d2, b2.flags |= 4);
              b2.subtreeFlags = 0;
              d2 = c2;
              for (c2 = b2.child; null !== c2; ) f2 = c2, a2 = d2, f2.flags &= 14680066, g2 = f2.alternate, null === g2 ? (f2.childLanes = 0, f2.lanes = a2, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a2 = g2.dependencies, f2.dependencies = null === a2 ? null : { lanes: a2.lanes, firstContext: a2.firstContext }), c2 = c2.sibling;
              G(L, L.current & 1 | 2);
              return b2.child;
            }
            a2 = a2.sibling;
          }
          null !== f2.tail && B() > Gj && (b2.flags |= 128, d2 = true, Dj(f2, false), b2.lanes = 4194304);
        }
        else {
          if (!d2) if (a2 = Ch(g2), null !== a2) {
            if (b2.flags |= 128, d2 = true, c2 = a2.updateQueue, null !== c2 && (b2.updateQueue = c2, b2.flags |= 4), Dj(f2, true), null === f2.tail && "hidden" === f2.tailMode && !g2.alternate && !I) return S2(b2), null;
          } else 2 * B() - f2.renderingStartTime > Gj && 1073741824 !== c2 && (b2.flags |= 128, d2 = true, Dj(f2, false), b2.lanes = 4194304);
          f2.isBackwards ? (g2.sibling = b2.child, b2.child = g2) : (c2 = f2.last, null !== c2 ? c2.sibling = g2 : b2.child = g2, f2.last = g2);
        }
        if (null !== f2.tail) return b2 = f2.tail, f2.rendering = b2, f2.tail = b2.sibling, f2.renderingStartTime = B(), b2.sibling = null, c2 = L.current, G(L, d2 ? c2 & 1 | 2 : c2 & 1), b2;
        S2(b2);
        return null;
      case 22:
      case 23:
        return Hj(), d2 = null !== b2.memoizedState, null !== a2 && null !== a2.memoizedState !== d2 && (b2.flags |= 8192), d2 && 0 !== (b2.mode & 1) ? 0 !== (fj & 1073741824) && (S2(b2), b2.subtreeFlags & 6 && (b2.flags |= 8192)) : S2(b2), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(p2(156, b2.tag));
  }
  function Ij(a2, b2) {
    wg(b2);
    switch (b2.tag) {
      case 1:
        return Zf(b2.type) && $f(), a2 = b2.flags, a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
      case 3:
        return zh(), E(Wf), E(H2), Eh(), a2 = b2.flags, 0 !== (a2 & 65536) && 0 === (a2 & 128) ? (b2.flags = a2 & -65537 | 128, b2) : null;
      case 5:
        return Bh(b2), null;
      case 13:
        E(L);
        a2 = b2.memoizedState;
        if (null !== a2 && null !== a2.dehydrated) {
          if (null === b2.alternate) throw Error(p2(340));
          Ig();
        }
        a2 = b2.flags;
        return a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
      case 19:
        return E(L), null;
      case 4:
        return zh(), null;
      case 10:
        return ah(b2.type._context), null;
      case 22:
      case 23:
        return Hj(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var Jj = false, U = false, Kj = "function" === typeof WeakSet ? WeakSet : Set, V = null;
  function Lj(a2, b2) {
    var c2 = a2.ref;
    if (null !== c2) if ("function" === typeof c2) try {
      c2(null);
    } catch (d2) {
      W(a2, b2, d2);
    }
    else c2.current = null;
  }
  function Mj(a2, b2, c2) {
    try {
      c2();
    } catch (d2) {
      W(a2, b2, d2);
    }
  }
  var Nj = false;
  function Oj(a2, b2) {
    Cf = dd;
    a2 = Me();
    if (Ne(a2)) {
      if ("selectionStart" in a2) var c2 = { start: a2.selectionStart, end: a2.selectionEnd };
      else a: {
        c2 = (c2 = a2.ownerDocument) && c2.defaultView || window;
        var d2 = c2.getSelection && c2.getSelection();
        if (d2 && 0 !== d2.rangeCount) {
          c2 = d2.anchorNode;
          var e2 = d2.anchorOffset, f2 = d2.focusNode;
          d2 = d2.focusOffset;
          try {
            c2.nodeType, f2.nodeType;
          } catch (F) {
            c2 = null;
            break a;
          }
          var g2 = 0, h2 = -1, k2 = -1, l2 = 0, m2 = 0, q = a2, r2 = null;
          b: for (; ; ) {
            for (var y2; ; ) {
              q !== c2 || 0 !== e2 && 3 !== q.nodeType || (h2 = g2 + e2);
              q !== f2 || 0 !== d2 && 3 !== q.nodeType || (k2 = g2 + d2);
              3 === q.nodeType && (g2 += q.nodeValue.length);
              if (null === (y2 = q.firstChild)) break;
              r2 = q;
              q = y2;
            }
            for (; ; ) {
              if (q === a2) break b;
              r2 === c2 && ++l2 === e2 && (h2 = g2);
              r2 === f2 && ++m2 === d2 && (k2 = g2);
              if (null !== (y2 = q.nextSibling)) break;
              q = r2;
              r2 = q.parentNode;
            }
            q = y2;
          }
          c2 = -1 === h2 || -1 === k2 ? null : { start: h2, end: k2 };
        } else c2 = null;
      }
      c2 = c2 || { start: 0, end: 0 };
    } else c2 = null;
    Df = { focusedElem: a2, selectionRange: c2 };
    dd = false;
    for (V = b2; null !== V; ) if (b2 = V, a2 = b2.child, 0 !== (b2.subtreeFlags & 1028) && null !== a2) a2.return = b2, V = a2;
    else for (; null !== V; ) {
      b2 = V;
      try {
        var n2 = b2.alternate;
        if (0 !== (b2.flags & 1024)) switch (b2.tag) {
          case 0:
          case 11:
          case 15:
            break;
          case 1:
            if (null !== n2) {
              var t2 = n2.memoizedProps, J = n2.memoizedState, x2 = b2.stateNode, w2 = x2.getSnapshotBeforeUpdate(b2.elementType === b2.type ? t2 : Ci(b2.type, t2), J);
              x2.__reactInternalSnapshotBeforeUpdate = w2;
            }
            break;
          case 3:
            var u2 = b2.stateNode.containerInfo;
            1 === u2.nodeType ? u2.textContent = "" : 9 === u2.nodeType && u2.documentElement && u2.removeChild(u2.documentElement);
            break;
          case 5:
          case 6:
          case 4:
          case 17:
            break;
          default:
            throw Error(p2(163));
        }
      } catch (F) {
        W(b2, b2.return, F);
      }
      a2 = b2.sibling;
      if (null !== a2) {
        a2.return = b2.return;
        V = a2;
        break;
      }
      V = b2.return;
    }
    n2 = Nj;
    Nj = false;
    return n2;
  }
  function Pj(a2, b2, c2) {
    var d2 = b2.updateQueue;
    d2 = null !== d2 ? d2.lastEffect : null;
    if (null !== d2) {
      var e2 = d2 = d2.next;
      do {
        if ((e2.tag & a2) === a2) {
          var f2 = e2.destroy;
          e2.destroy = void 0;
          void 0 !== f2 && Mj(b2, c2, f2);
        }
        e2 = e2.next;
      } while (e2 !== d2);
    }
  }
  function Qj(a2, b2) {
    b2 = b2.updateQueue;
    b2 = null !== b2 ? b2.lastEffect : null;
    if (null !== b2) {
      var c2 = b2 = b2.next;
      do {
        if ((c2.tag & a2) === a2) {
          var d2 = c2.create;
          c2.destroy = d2();
        }
        c2 = c2.next;
      } while (c2 !== b2);
    }
  }
  function Rj(a2) {
    var b2 = a2.ref;
    if (null !== b2) {
      var c2 = a2.stateNode;
      switch (a2.tag) {
        case 5:
          a2 = c2;
          break;
        default:
          a2 = c2;
      }
      "function" === typeof b2 ? b2(a2) : b2.current = a2;
    }
  }
  function Sj(a2) {
    var b2 = a2.alternate;
    null !== b2 && (a2.alternate = null, Sj(b2));
    a2.child = null;
    a2.deletions = null;
    a2.sibling = null;
    5 === a2.tag && (b2 = a2.stateNode, null !== b2 && (delete b2[Of], delete b2[Pf], delete b2[of], delete b2[Qf], delete b2[Rf]));
    a2.stateNode = null;
    a2.return = null;
    a2.dependencies = null;
    a2.memoizedProps = null;
    a2.memoizedState = null;
    a2.pendingProps = null;
    a2.stateNode = null;
    a2.updateQueue = null;
  }
  function Tj(a2) {
    return 5 === a2.tag || 3 === a2.tag || 4 === a2.tag;
  }
  function Uj(a2) {
    a: for (; ; ) {
      for (; null === a2.sibling; ) {
        if (null === a2.return || Tj(a2.return)) return null;
        a2 = a2.return;
      }
      a2.sibling.return = a2.return;
      for (a2 = a2.sibling; 5 !== a2.tag && 6 !== a2.tag && 18 !== a2.tag; ) {
        if (a2.flags & 2) continue a;
        if (null === a2.child || 4 === a2.tag) continue a;
        else a2.child.return = a2, a2 = a2.child;
      }
      if (!(a2.flags & 2)) return a2.stateNode;
    }
  }
  function Vj(a2, b2, c2) {
    var d2 = a2.tag;
    if (5 === d2 || 6 === d2) a2 = a2.stateNode, b2 ? 8 === c2.nodeType ? c2.parentNode.insertBefore(a2, b2) : c2.insertBefore(a2, b2) : (8 === c2.nodeType ? (b2 = c2.parentNode, b2.insertBefore(a2, c2)) : (b2 = c2, b2.appendChild(a2)), c2 = c2._reactRootContainer, null !== c2 && void 0 !== c2 || null !== b2.onclick || (b2.onclick = Bf));
    else if (4 !== d2 && (a2 = a2.child, null !== a2)) for (Vj(a2, b2, c2), a2 = a2.sibling; null !== a2; ) Vj(a2, b2, c2), a2 = a2.sibling;
  }
  function Wj(a2, b2, c2) {
    var d2 = a2.tag;
    if (5 === d2 || 6 === d2) a2 = a2.stateNode, b2 ? c2.insertBefore(a2, b2) : c2.appendChild(a2);
    else if (4 !== d2 && (a2 = a2.child, null !== a2)) for (Wj(a2, b2, c2), a2 = a2.sibling; null !== a2; ) Wj(a2, b2, c2), a2 = a2.sibling;
  }
  var X = null, Xj = false;
  function Yj(a2, b2, c2) {
    for (c2 = c2.child; null !== c2; ) Zj(a2, b2, c2), c2 = c2.sibling;
  }
  function Zj(a2, b2, c2) {
    if (lc && "function" === typeof lc.onCommitFiberUnmount) try {
      lc.onCommitFiberUnmount(kc, c2);
    } catch (h2) {
    }
    switch (c2.tag) {
      case 5:
        U || Lj(c2, b2);
      case 6:
        var d2 = X, e2 = Xj;
        X = null;
        Yj(a2, b2, c2);
        X = d2;
        Xj = e2;
        null !== X && (Xj ? (a2 = X, c2 = c2.stateNode, 8 === a2.nodeType ? a2.parentNode.removeChild(c2) : a2.removeChild(c2)) : X.removeChild(c2.stateNode));
        break;
      case 18:
        null !== X && (Xj ? (a2 = X, c2 = c2.stateNode, 8 === a2.nodeType ? Kf(a2.parentNode, c2) : 1 === a2.nodeType && Kf(a2, c2), bd(a2)) : Kf(X, c2.stateNode));
        break;
      case 4:
        d2 = X;
        e2 = Xj;
        X = c2.stateNode.containerInfo;
        Xj = true;
        Yj(a2, b2, c2);
        X = d2;
        Xj = e2;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!U && (d2 = c2.updateQueue, null !== d2 && (d2 = d2.lastEffect, null !== d2))) {
          e2 = d2 = d2.next;
          do {
            var f2 = e2, g2 = f2.destroy;
            f2 = f2.tag;
            void 0 !== g2 && (0 !== (f2 & 2) ? Mj(c2, b2, g2) : 0 !== (f2 & 4) && Mj(c2, b2, g2));
            e2 = e2.next;
          } while (e2 !== d2);
        }
        Yj(a2, b2, c2);
        break;
      case 1:
        if (!U && (Lj(c2, b2), d2 = c2.stateNode, "function" === typeof d2.componentWillUnmount)) try {
          d2.props = c2.memoizedProps, d2.state = c2.memoizedState, d2.componentWillUnmount();
        } catch (h2) {
          W(c2, b2, h2);
        }
        Yj(a2, b2, c2);
        break;
      case 21:
        Yj(a2, b2, c2);
        break;
      case 22:
        c2.mode & 1 ? (U = (d2 = U) || null !== c2.memoizedState, Yj(a2, b2, c2), U = d2) : Yj(a2, b2, c2);
        break;
      default:
        Yj(a2, b2, c2);
    }
  }
  function ak(a2) {
    var b2 = a2.updateQueue;
    if (null !== b2) {
      a2.updateQueue = null;
      var c2 = a2.stateNode;
      null === c2 && (c2 = a2.stateNode = new Kj());
      b2.forEach(function(b3) {
        var d2 = bk.bind(null, a2, b3);
        c2.has(b3) || (c2.add(b3), b3.then(d2, d2));
      });
    }
  }
  function ck(a2, b2) {
    var c2 = b2.deletions;
    if (null !== c2) for (var d2 = 0; d2 < c2.length; d2++) {
      var e2 = c2[d2];
      try {
        var f2 = a2, g2 = b2, h2 = g2;
        a: for (; null !== h2; ) {
          switch (h2.tag) {
            case 5:
              X = h2.stateNode;
              Xj = false;
              break a;
            case 3:
              X = h2.stateNode.containerInfo;
              Xj = true;
              break a;
            case 4:
              X = h2.stateNode.containerInfo;
              Xj = true;
              break a;
          }
          h2 = h2.return;
        }
        if (null === X) throw Error(p2(160));
        Zj(f2, g2, e2);
        X = null;
        Xj = false;
        var k2 = e2.alternate;
        null !== k2 && (k2.return = null);
        e2.return = null;
      } catch (l2) {
        W(e2, b2, l2);
      }
    }
    if (b2.subtreeFlags & 12854) for (b2 = b2.child; null !== b2; ) dk(b2, a2), b2 = b2.sibling;
  }
  function dk(a2, b2) {
    var c2 = a2.alternate, d2 = a2.flags;
    switch (a2.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        ck(b2, a2);
        ek(a2);
        if (d2 & 4) {
          try {
            Pj(3, a2, a2.return), Qj(3, a2);
          } catch (t2) {
            W(a2, a2.return, t2);
          }
          try {
            Pj(5, a2, a2.return);
          } catch (t2) {
            W(a2, a2.return, t2);
          }
        }
        break;
      case 1:
        ck(b2, a2);
        ek(a2);
        d2 & 512 && null !== c2 && Lj(c2, c2.return);
        break;
      case 5:
        ck(b2, a2);
        ek(a2);
        d2 & 512 && null !== c2 && Lj(c2, c2.return);
        if (a2.flags & 32) {
          var e2 = a2.stateNode;
          try {
            ob(e2, "");
          } catch (t2) {
            W(a2, a2.return, t2);
          }
        }
        if (d2 & 4 && (e2 = a2.stateNode, null != e2)) {
          var f2 = a2.memoizedProps, g2 = null !== c2 ? c2.memoizedProps : f2, h2 = a2.type, k2 = a2.updateQueue;
          a2.updateQueue = null;
          if (null !== k2) try {
            "input" === h2 && "radio" === f2.type && null != f2.name && ab(e2, f2);
            vb(h2, g2);
            var l2 = vb(h2, f2);
            for (g2 = 0; g2 < k2.length; g2 += 2) {
              var m2 = k2[g2], q = k2[g2 + 1];
              "style" === m2 ? sb(e2, q) : "dangerouslySetInnerHTML" === m2 ? nb(e2, q) : "children" === m2 ? ob(e2, q) : ta(e2, m2, q, l2);
            }
            switch (h2) {
              case "input":
                bb(e2, f2);
                break;
              case "textarea":
                ib(e2, f2);
                break;
              case "select":
                var r2 = e2._wrapperState.wasMultiple;
                e2._wrapperState.wasMultiple = !!f2.multiple;
                var y2 = f2.value;
                null != y2 ? fb(e2, !!f2.multiple, y2, false) : r2 !== !!f2.multiple && (null != f2.defaultValue ? fb(
                  e2,
                  !!f2.multiple,
                  f2.defaultValue,
                  true
                ) : fb(e2, !!f2.multiple, f2.multiple ? [] : "", false));
            }
            e2[Pf] = f2;
          } catch (t2) {
            W(a2, a2.return, t2);
          }
        }
        break;
      case 6:
        ck(b2, a2);
        ek(a2);
        if (d2 & 4) {
          if (null === a2.stateNode) throw Error(p2(162));
          e2 = a2.stateNode;
          f2 = a2.memoizedProps;
          try {
            e2.nodeValue = f2;
          } catch (t2) {
            W(a2, a2.return, t2);
          }
        }
        break;
      case 3:
        ck(b2, a2);
        ek(a2);
        if (d2 & 4 && null !== c2 && c2.memoizedState.isDehydrated) try {
          bd(b2.containerInfo);
        } catch (t2) {
          W(a2, a2.return, t2);
        }
        break;
      case 4:
        ck(b2, a2);
        ek(a2);
        break;
      case 13:
        ck(b2, a2);
        ek(a2);
        e2 = a2.child;
        e2.flags & 8192 && (f2 = null !== e2.memoizedState, e2.stateNode.isHidden = f2, !f2 || null !== e2.alternate && null !== e2.alternate.memoizedState || (fk = B()));
        d2 & 4 && ak(a2);
        break;
      case 22:
        m2 = null !== c2 && null !== c2.memoizedState;
        a2.mode & 1 ? (U = (l2 = U) || m2, ck(b2, a2), U = l2) : ck(b2, a2);
        ek(a2);
        if (d2 & 8192) {
          l2 = null !== a2.memoizedState;
          if ((a2.stateNode.isHidden = l2) && !m2 && 0 !== (a2.mode & 1)) for (V = a2, m2 = a2.child; null !== m2; ) {
            for (q = V = m2; null !== V; ) {
              r2 = V;
              y2 = r2.child;
              switch (r2.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Pj(4, r2, r2.return);
                  break;
                case 1:
                  Lj(r2, r2.return);
                  var n2 = r2.stateNode;
                  if ("function" === typeof n2.componentWillUnmount) {
                    d2 = r2;
                    c2 = r2.return;
                    try {
                      b2 = d2, n2.props = b2.memoizedProps, n2.state = b2.memoizedState, n2.componentWillUnmount();
                    } catch (t2) {
                      W(d2, c2, t2);
                    }
                  }
                  break;
                case 5:
                  Lj(r2, r2.return);
                  break;
                case 22:
                  if (null !== r2.memoizedState) {
                    gk(q);
                    continue;
                  }
              }
              null !== y2 ? (y2.return = r2, V = y2) : gk(q);
            }
            m2 = m2.sibling;
          }
          a: for (m2 = null, q = a2; ; ) {
            if (5 === q.tag) {
              if (null === m2) {
                m2 = q;
                try {
                  e2 = q.stateNode, l2 ? (f2 = e2.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h2 = q.stateNode, k2 = q.memoizedProps.style, g2 = void 0 !== k2 && null !== k2 && k2.hasOwnProperty("display") ? k2.display : null, h2.style.display = rb("display", g2));
                } catch (t2) {
                  W(a2, a2.return, t2);
                }
              }
            } else if (6 === q.tag) {
              if (null === m2) try {
                q.stateNode.nodeValue = l2 ? "" : q.memoizedProps;
              } catch (t2) {
                W(a2, a2.return, t2);
              }
            } else if ((22 !== q.tag && 23 !== q.tag || null === q.memoizedState || q === a2) && null !== q.child) {
              q.child.return = q;
              q = q.child;
              continue;
            }
            if (q === a2) break a;
            for (; null === q.sibling; ) {
              if (null === q.return || q.return === a2) break a;
              m2 === q && (m2 = null);
              q = q.return;
            }
            m2 === q && (m2 = null);
            q.sibling.return = q.return;
            q = q.sibling;
          }
        }
        break;
      case 19:
        ck(b2, a2);
        ek(a2);
        d2 & 4 && ak(a2);
        break;
      case 21:
        break;
      default:
        ck(
          b2,
          a2
        ), ek(a2);
    }
  }
  function ek(a2) {
    var b2 = a2.flags;
    if (b2 & 2) {
      try {
        a: {
          for (var c2 = a2.return; null !== c2; ) {
            if (Tj(c2)) {
              var d2 = c2;
              break a;
            }
            c2 = c2.return;
          }
          throw Error(p2(160));
        }
        switch (d2.tag) {
          case 5:
            var e2 = d2.stateNode;
            d2.flags & 32 && (ob(e2, ""), d2.flags &= -33);
            var f2 = Uj(a2);
            Wj(a2, f2, e2);
            break;
          case 3:
          case 4:
            var g2 = d2.stateNode.containerInfo, h2 = Uj(a2);
            Vj(a2, h2, g2);
            break;
          default:
            throw Error(p2(161));
        }
      } catch (k2) {
        W(a2, a2.return, k2);
      }
      a2.flags &= -3;
    }
    b2 & 4096 && (a2.flags &= -4097);
  }
  function hk(a2, b2, c2) {
    V = a2;
    ik(a2);
  }
  function ik(a2, b2, c2) {
    for (var d2 = 0 !== (a2.mode & 1); null !== V; ) {
      var e2 = V, f2 = e2.child;
      if (22 === e2.tag && d2) {
        var g2 = null !== e2.memoizedState || Jj;
        if (!g2) {
          var h2 = e2.alternate, k2 = null !== h2 && null !== h2.memoizedState || U;
          h2 = Jj;
          var l2 = U;
          Jj = g2;
          if ((U = k2) && !l2) for (V = e2; null !== V; ) g2 = V, k2 = g2.child, 22 === g2.tag && null !== g2.memoizedState ? jk(e2) : null !== k2 ? (k2.return = g2, V = k2) : jk(e2);
          for (; null !== f2; ) V = f2, ik(f2), f2 = f2.sibling;
          V = e2;
          Jj = h2;
          U = l2;
        }
        kk(a2);
      } else 0 !== (e2.subtreeFlags & 8772) && null !== f2 ? (f2.return = e2, V = f2) : kk(a2);
    }
  }
  function kk(a2) {
    for (; null !== V; ) {
      var b2 = V;
      if (0 !== (b2.flags & 8772)) {
        var c2 = b2.alternate;
        try {
          if (0 !== (b2.flags & 8772)) switch (b2.tag) {
            case 0:
            case 11:
            case 15:
              U || Qj(5, b2);
              break;
            case 1:
              var d2 = b2.stateNode;
              if (b2.flags & 4 && !U) if (null === c2) d2.componentDidMount();
              else {
                var e2 = b2.elementType === b2.type ? c2.memoizedProps : Ci(b2.type, c2.memoizedProps);
                d2.componentDidUpdate(e2, c2.memoizedState, d2.__reactInternalSnapshotBeforeUpdate);
              }
              var f2 = b2.updateQueue;
              null !== f2 && sh(b2, f2, d2);
              break;
            case 3:
              var g2 = b2.updateQueue;
              if (null !== g2) {
                c2 = null;
                if (null !== b2.child) switch (b2.child.tag) {
                  case 5:
                    c2 = b2.child.stateNode;
                    break;
                  case 1:
                    c2 = b2.child.stateNode;
                }
                sh(b2, g2, c2);
              }
              break;
            case 5:
              var h2 = b2.stateNode;
              if (null === c2 && b2.flags & 4) {
                c2 = h2;
                var k2 = b2.memoizedProps;
                switch (b2.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    k2.autoFocus && c2.focus();
                    break;
                  case "img":
                    k2.src && (c2.src = k2.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (null === b2.memoizedState) {
                var l2 = b2.alternate;
                if (null !== l2) {
                  var m2 = l2.memoizedState;
                  if (null !== m2) {
                    var q = m2.dehydrated;
                    null !== q && bd(q);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(p2(163));
          }
          U || b2.flags & 512 && Rj(b2);
        } catch (r2) {
          W(b2, b2.return, r2);
        }
      }
      if (b2 === a2) {
        V = null;
        break;
      }
      c2 = b2.sibling;
      if (null !== c2) {
        c2.return = b2.return;
        V = c2;
        break;
      }
      V = b2.return;
    }
  }
  function gk(a2) {
    for (; null !== V; ) {
      var b2 = V;
      if (b2 === a2) {
        V = null;
        break;
      }
      var c2 = b2.sibling;
      if (null !== c2) {
        c2.return = b2.return;
        V = c2;
        break;
      }
      V = b2.return;
    }
  }
  function jk(a2) {
    for (; null !== V; ) {
      var b2 = V;
      try {
        switch (b2.tag) {
          case 0:
          case 11:
          case 15:
            var c2 = b2.return;
            try {
              Qj(4, b2);
            } catch (k2) {
              W(b2, c2, k2);
            }
            break;
          case 1:
            var d2 = b2.stateNode;
            if ("function" === typeof d2.componentDidMount) {
              var e2 = b2.return;
              try {
                d2.componentDidMount();
              } catch (k2) {
                W(b2, e2, k2);
              }
            }
            var f2 = b2.return;
            try {
              Rj(b2);
            } catch (k2) {
              W(b2, f2, k2);
            }
            break;
          case 5:
            var g2 = b2.return;
            try {
              Rj(b2);
            } catch (k2) {
              W(b2, g2, k2);
            }
        }
      } catch (k2) {
        W(b2, b2.return, k2);
      }
      if (b2 === a2) {
        V = null;
        break;
      }
      var h2 = b2.sibling;
      if (null !== h2) {
        h2.return = b2.return;
        V = h2;
        break;
      }
      V = b2.return;
    }
  }
  var lk = Math.ceil, mk = ua.ReactCurrentDispatcher, nk = ua.ReactCurrentOwner, ok = ua.ReactCurrentBatchConfig, K = 0, Q = null, Y = null, Z = 0, fj = 0, ej = Uf(0), T = 0, pk = null, rh = 0, qk = 0, rk = 0, sk = null, tk = null, fk = 0, Gj = Infinity, uk = null, Oi = false, Pi = null, Ri = null, vk = false, wk = null, xk = 0, yk = 0, zk = null, Ak = -1, Bk = 0;
  function R() {
    return 0 !== (K & 6) ? B() : -1 !== Ak ? Ak : Ak = B();
  }
  function yi(a2) {
    if (0 === (a2.mode & 1)) return 1;
    if (0 !== (K & 2) && 0 !== Z) return Z & -Z;
    if (null !== Kg.transition) return 0 === Bk && (Bk = yc()), Bk;
    a2 = C;
    if (0 !== a2) return a2;
    a2 = window.event;
    a2 = void 0 === a2 ? 16 : jd(a2.type);
    return a2;
  }
  function gi(a2, b2, c2, d2) {
    if (50 < yk) throw yk = 0, zk = null, Error(p2(185));
    Ac(a2, c2, d2);
    if (0 === (K & 2) || a2 !== Q) a2 === Q && (0 === (K & 2) && (qk |= c2), 4 === T && Ck(a2, Z)), Dk(a2, d2), 1 === c2 && 0 === K && 0 === (b2.mode & 1) && (Gj = B() + 500, fg && jg());
  }
  function Dk(a2, b2) {
    var c2 = a2.callbackNode;
    wc(a2, b2);
    var d2 = uc(a2, a2 === Q ? Z : 0);
    if (0 === d2) null !== c2 && bc(c2), a2.callbackNode = null, a2.callbackPriority = 0;
    else if (b2 = d2 & -d2, a2.callbackPriority !== b2) {
      null != c2 && bc(c2);
      if (1 === b2) 0 === a2.tag ? ig(Ek.bind(null, a2)) : hg(Ek.bind(null, a2)), Jf(function() {
        0 === (K & 6) && jg();
      }), c2 = null;
      else {
        switch (Dc(d2)) {
          case 1:
            c2 = fc;
            break;
          case 4:
            c2 = gc;
            break;
          case 16:
            c2 = hc;
            break;
          case 536870912:
            c2 = jc;
            break;
          default:
            c2 = hc;
        }
        c2 = Fk(c2, Gk.bind(null, a2));
      }
      a2.callbackPriority = b2;
      a2.callbackNode = c2;
    }
  }
  function Gk(a2, b2) {
    Ak = -1;
    Bk = 0;
    if (0 !== (K & 6)) throw Error(p2(327));
    var c2 = a2.callbackNode;
    if (Hk() && a2.callbackNode !== c2) return null;
    var d2 = uc(a2, a2 === Q ? Z : 0);
    if (0 === d2) return null;
    if (0 !== (d2 & 30) || 0 !== (d2 & a2.expiredLanes) || b2) b2 = Ik(a2, d2);
    else {
      b2 = d2;
      var e2 = K;
      K |= 2;
      var f2 = Jk();
      if (Q !== a2 || Z !== b2) uk = null, Gj = B() + 500, Kk(a2, b2);
      do
        try {
          Lk();
          break;
        } catch (h2) {
          Mk(a2, h2);
        }
      while (1);
      $g();
      mk.current = f2;
      K = e2;
      null !== Y ? b2 = 0 : (Q = null, Z = 0, b2 = T);
    }
    if (0 !== b2) {
      2 === b2 && (e2 = xc(a2), 0 !== e2 && (d2 = e2, b2 = Nk(a2, e2)));
      if (1 === b2) throw c2 = pk, Kk(a2, 0), Ck(a2, d2), Dk(a2, B()), c2;
      if (6 === b2) Ck(a2, d2);
      else {
        e2 = a2.current.alternate;
        if (0 === (d2 & 30) && !Ok(e2) && (b2 = Ik(a2, d2), 2 === b2 && (f2 = xc(a2), 0 !== f2 && (d2 = f2, b2 = Nk(a2, f2))), 1 === b2)) throw c2 = pk, Kk(a2, 0), Ck(a2, d2), Dk(a2, B()), c2;
        a2.finishedWork = e2;
        a2.finishedLanes = d2;
        switch (b2) {
          case 0:
          case 1:
            throw Error(p2(345));
          case 2:
            Pk(a2, tk, uk);
            break;
          case 3:
            Ck(a2, d2);
            if ((d2 & 130023424) === d2 && (b2 = fk + 500 - B(), 10 < b2)) {
              if (0 !== uc(a2, 0)) break;
              e2 = a2.suspendedLanes;
              if ((e2 & d2) !== d2) {
                R();
                a2.pingedLanes |= a2.suspendedLanes & e2;
                break;
              }
              a2.timeoutHandle = Ff(Pk.bind(null, a2, tk, uk), b2);
              break;
            }
            Pk(a2, tk, uk);
            break;
          case 4:
            Ck(a2, d2);
            if ((d2 & 4194240) === d2) break;
            b2 = a2.eventTimes;
            for (e2 = -1; 0 < d2; ) {
              var g2 = 31 - oc(d2);
              f2 = 1 << g2;
              g2 = b2[g2];
              g2 > e2 && (e2 = g2);
              d2 &= ~f2;
            }
            d2 = e2;
            d2 = B() - d2;
            d2 = (120 > d2 ? 120 : 480 > d2 ? 480 : 1080 > d2 ? 1080 : 1920 > d2 ? 1920 : 3e3 > d2 ? 3e3 : 4320 > d2 ? 4320 : 1960 * lk(d2 / 1960)) - d2;
            if (10 < d2) {
              a2.timeoutHandle = Ff(Pk.bind(null, a2, tk, uk), d2);
              break;
            }
            Pk(a2, tk, uk);
            break;
          case 5:
            Pk(a2, tk, uk);
            break;
          default:
            throw Error(p2(329));
        }
      }
    }
    Dk(a2, B());
    return a2.callbackNode === c2 ? Gk.bind(null, a2) : null;
  }
  function Nk(a2, b2) {
    var c2 = sk;
    a2.current.memoizedState.isDehydrated && (Kk(a2, b2).flags |= 256);
    a2 = Ik(a2, b2);
    2 !== a2 && (b2 = tk, tk = c2, null !== b2 && Fj(b2));
    return a2;
  }
  function Fj(a2) {
    null === tk ? tk = a2 : tk.push.apply(tk, a2);
  }
  function Ok(a2) {
    for (var b2 = a2; ; ) {
      if (b2.flags & 16384) {
        var c2 = b2.updateQueue;
        if (null !== c2 && (c2 = c2.stores, null !== c2)) for (var d2 = 0; d2 < c2.length; d2++) {
          var e2 = c2[d2], f2 = e2.getSnapshot;
          e2 = e2.value;
          try {
            if (!He(f2(), e2)) return false;
          } catch (g2) {
            return false;
          }
        }
      }
      c2 = b2.child;
      if (b2.subtreeFlags & 16384 && null !== c2) c2.return = b2, b2 = c2;
      else {
        if (b2 === a2) break;
        for (; null === b2.sibling; ) {
          if (null === b2.return || b2.return === a2) return true;
          b2 = b2.return;
        }
        b2.sibling.return = b2.return;
        b2 = b2.sibling;
      }
    }
    return true;
  }
  function Ck(a2, b2) {
    b2 &= ~rk;
    b2 &= ~qk;
    a2.suspendedLanes |= b2;
    a2.pingedLanes &= ~b2;
    for (a2 = a2.expirationTimes; 0 < b2; ) {
      var c2 = 31 - oc(b2), d2 = 1 << c2;
      a2[c2] = -1;
      b2 &= ~d2;
    }
  }
  function Ek(a2) {
    if (0 !== (K & 6)) throw Error(p2(327));
    Hk();
    var b2 = uc(a2, 0);
    if (0 === (b2 & 1)) return Dk(a2, B()), null;
    var c2 = Ik(a2, b2);
    if (0 !== a2.tag && 2 === c2) {
      var d2 = xc(a2);
      0 !== d2 && (b2 = d2, c2 = Nk(a2, d2));
    }
    if (1 === c2) throw c2 = pk, Kk(a2, 0), Ck(a2, b2), Dk(a2, B()), c2;
    if (6 === c2) throw Error(p2(345));
    a2.finishedWork = a2.current.alternate;
    a2.finishedLanes = b2;
    Pk(a2, tk, uk);
    Dk(a2, B());
    return null;
  }
  function Qk(a2, b2) {
    var c2 = K;
    K |= 1;
    try {
      return a2(b2);
    } finally {
      K = c2, 0 === K && (Gj = B() + 500, fg && jg());
    }
  }
  function Rk(a2) {
    null !== wk && 0 === wk.tag && 0 === (K & 6) && Hk();
    var b2 = K;
    K |= 1;
    var c2 = ok.transition, d2 = C;
    try {
      if (ok.transition = null, C = 1, a2) return a2();
    } finally {
      C = d2, ok.transition = c2, K = b2, 0 === (K & 6) && jg();
    }
  }
  function Hj() {
    fj = ej.current;
    E(ej);
  }
  function Kk(a2, b2) {
    a2.finishedWork = null;
    a2.finishedLanes = 0;
    var c2 = a2.timeoutHandle;
    -1 !== c2 && (a2.timeoutHandle = -1, Gf(c2));
    if (null !== Y) for (c2 = Y.return; null !== c2; ) {
      var d2 = c2;
      wg(d2);
      switch (d2.tag) {
        case 1:
          d2 = d2.type.childContextTypes;
          null !== d2 && void 0 !== d2 && $f();
          break;
        case 3:
          zh();
          E(Wf);
          E(H2);
          Eh();
          break;
        case 5:
          Bh(d2);
          break;
        case 4:
          zh();
          break;
        case 13:
          E(L);
          break;
        case 19:
          E(L);
          break;
        case 10:
          ah(d2.type._context);
          break;
        case 22:
        case 23:
          Hj();
      }
      c2 = c2.return;
    }
    Q = a2;
    Y = a2 = Pg(a2.current, null);
    Z = fj = b2;
    T = 0;
    pk = null;
    rk = qk = rh = 0;
    tk = sk = null;
    if (null !== fh) {
      for (b2 = 0; b2 < fh.length; b2++) if (c2 = fh[b2], d2 = c2.interleaved, null !== d2) {
        c2.interleaved = null;
        var e2 = d2.next, f2 = c2.pending;
        if (null !== f2) {
          var g2 = f2.next;
          f2.next = e2;
          d2.next = g2;
        }
        c2.pending = d2;
      }
      fh = null;
    }
    return a2;
  }
  function Mk(a2, b2) {
    do {
      var c2 = Y;
      try {
        $g();
        Fh.current = Rh;
        if (Ih) {
          for (var d2 = M2.memoizedState; null !== d2; ) {
            var e2 = d2.queue;
            null !== e2 && (e2.pending = null);
            d2 = d2.next;
          }
          Ih = false;
        }
        Hh = 0;
        O = N2 = M2 = null;
        Jh = false;
        Kh = 0;
        nk.current = null;
        if (null === c2 || null === c2.return) {
          T = 1;
          pk = b2;
          Y = null;
          break;
        }
        a: {
          var f2 = a2, g2 = c2.return, h2 = c2, k2 = b2;
          b2 = Z;
          h2.flags |= 32768;
          if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
            var l2 = k2, m2 = h2, q = m2.tag;
            if (0 === (m2.mode & 1) && (0 === q || 11 === q || 15 === q)) {
              var r2 = m2.alternate;
              r2 ? (m2.updateQueue = r2.updateQueue, m2.memoizedState = r2.memoizedState, m2.lanes = r2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
            }
            var y2 = Ui(g2);
            if (null !== y2) {
              y2.flags &= -257;
              Vi(y2, g2, h2, f2, b2);
              y2.mode & 1 && Si(f2, l2, b2);
              b2 = y2;
              k2 = l2;
              var n2 = b2.updateQueue;
              if (null === n2) {
                var t2 = /* @__PURE__ */ new Set();
                t2.add(k2);
                b2.updateQueue = t2;
              } else n2.add(k2);
              break a;
            } else {
              if (0 === (b2 & 1)) {
                Si(f2, l2, b2);
                tj();
                break a;
              }
              k2 = Error(p2(426));
            }
          } else if (I && h2.mode & 1) {
            var J = Ui(g2);
            if (null !== J) {
              0 === (J.flags & 65536) && (J.flags |= 256);
              Vi(J, g2, h2, f2, b2);
              Jg(Ji(k2, h2));
              break a;
            }
          }
          f2 = k2 = Ji(k2, h2);
          4 !== T && (T = 2);
          null === sk ? sk = [f2] : sk.push(f2);
          f2 = g2;
          do {
            switch (f2.tag) {
              case 3:
                f2.flags |= 65536;
                b2 &= -b2;
                f2.lanes |= b2;
                var x2 = Ni(f2, k2, b2);
                ph(f2, x2);
                break a;
              case 1:
                h2 = k2;
                var w2 = f2.type, u2 = f2.stateNode;
                if (0 === (f2.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u2 && "function" === typeof u2.componentDidCatch && (null === Ri || !Ri.has(u2)))) {
                  f2.flags |= 65536;
                  b2 &= -b2;
                  f2.lanes |= b2;
                  var F = Qi(f2, h2, b2);
                  ph(f2, F);
                  break a;
                }
            }
            f2 = f2.return;
          } while (null !== f2);
        }
        Sk(c2);
      } catch (na) {
        b2 = na;
        Y === c2 && null !== c2 && (Y = c2 = c2.return);
        continue;
      }
      break;
    } while (1);
  }
  function Jk() {
    var a2 = mk.current;
    mk.current = Rh;
    return null === a2 ? Rh : a2;
  }
  function tj() {
    if (0 === T || 3 === T || 2 === T) T = 4;
    null === Q || 0 === (rh & 268435455) && 0 === (qk & 268435455) || Ck(Q, Z);
  }
  function Ik(a2, b2) {
    var c2 = K;
    K |= 2;
    var d2 = Jk();
    if (Q !== a2 || Z !== b2) uk = null, Kk(a2, b2);
    do
      try {
        Tk();
        break;
      } catch (e2) {
        Mk(a2, e2);
      }
    while (1);
    $g();
    K = c2;
    mk.current = d2;
    if (null !== Y) throw Error(p2(261));
    Q = null;
    Z = 0;
    return T;
  }
  function Tk() {
    for (; null !== Y; ) Uk(Y);
  }
  function Lk() {
    for (; null !== Y && !cc(); ) Uk(Y);
  }
  function Uk(a2) {
    var b2 = Vk(a2.alternate, a2, fj);
    a2.memoizedProps = a2.pendingProps;
    null === b2 ? Sk(a2) : Y = b2;
    nk.current = null;
  }
  function Sk(a2) {
    var b2 = a2;
    do {
      var c2 = b2.alternate;
      a2 = b2.return;
      if (0 === (b2.flags & 32768)) {
        if (c2 = Ej(c2, b2, fj), null !== c2) {
          Y = c2;
          return;
        }
      } else {
        c2 = Ij(c2, b2);
        if (null !== c2) {
          c2.flags &= 32767;
          Y = c2;
          return;
        }
        if (null !== a2) a2.flags |= 32768, a2.subtreeFlags = 0, a2.deletions = null;
        else {
          T = 6;
          Y = null;
          return;
        }
      }
      b2 = b2.sibling;
      if (null !== b2) {
        Y = b2;
        return;
      }
      Y = b2 = a2;
    } while (null !== b2);
    0 === T && (T = 5);
  }
  function Pk(a2, b2, c2) {
    var d2 = C, e2 = ok.transition;
    try {
      ok.transition = null, C = 1, Wk(a2, b2, c2, d2);
    } finally {
      ok.transition = e2, C = d2;
    }
    return null;
  }
  function Wk(a2, b2, c2, d2) {
    do
      Hk();
    while (null !== wk);
    if (0 !== (K & 6)) throw Error(p2(327));
    c2 = a2.finishedWork;
    var e2 = a2.finishedLanes;
    if (null === c2) return null;
    a2.finishedWork = null;
    a2.finishedLanes = 0;
    if (c2 === a2.current) throw Error(p2(177));
    a2.callbackNode = null;
    a2.callbackPriority = 0;
    var f2 = c2.lanes | c2.childLanes;
    Bc(a2, f2);
    a2 === Q && (Y = Q = null, Z = 0);
    0 === (c2.subtreeFlags & 2064) && 0 === (c2.flags & 2064) || vk || (vk = true, Fk(hc, function() {
      Hk();
      return null;
    }));
    f2 = 0 !== (c2.flags & 15990);
    if (0 !== (c2.subtreeFlags & 15990) || f2) {
      f2 = ok.transition;
      ok.transition = null;
      var g2 = C;
      C = 1;
      var h2 = K;
      K |= 4;
      nk.current = null;
      Oj(a2, c2);
      dk(c2, a2);
      Oe(Df);
      dd = !!Cf;
      Df = Cf = null;
      a2.current = c2;
      hk(c2);
      dc();
      K = h2;
      C = g2;
      ok.transition = f2;
    } else a2.current = c2;
    vk && (vk = false, wk = a2, xk = e2);
    f2 = a2.pendingLanes;
    0 === f2 && (Ri = null);
    mc(c2.stateNode);
    Dk(a2, B());
    if (null !== b2) for (d2 = a2.onRecoverableError, c2 = 0; c2 < b2.length; c2++) e2 = b2[c2], d2(e2.value, { componentStack: e2.stack, digest: e2.digest });
    if (Oi) throw Oi = false, a2 = Pi, Pi = null, a2;
    0 !== (xk & 1) && 0 !== a2.tag && Hk();
    f2 = a2.pendingLanes;
    0 !== (f2 & 1) ? a2 === zk ? yk++ : (yk = 0, zk = a2) : yk = 0;
    jg();
    return null;
  }
  function Hk() {
    if (null !== wk) {
      var a2 = Dc(xk), b2 = ok.transition, c2 = C;
      try {
        ok.transition = null;
        C = 16 > a2 ? 16 : a2;
        if (null === wk) var d2 = false;
        else {
          a2 = wk;
          wk = null;
          xk = 0;
          if (0 !== (K & 6)) throw Error(p2(331));
          var e2 = K;
          K |= 4;
          for (V = a2.current; null !== V; ) {
            var f2 = V, g2 = f2.child;
            if (0 !== (V.flags & 16)) {
              var h2 = f2.deletions;
              if (null !== h2) {
                for (var k2 = 0; k2 < h2.length; k2++) {
                  var l2 = h2[k2];
                  for (V = l2; null !== V; ) {
                    var m2 = V;
                    switch (m2.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Pj(8, m2, f2);
                    }
                    var q = m2.child;
                    if (null !== q) q.return = m2, V = q;
                    else for (; null !== V; ) {
                      m2 = V;
                      var r2 = m2.sibling, y2 = m2.return;
                      Sj(m2);
                      if (m2 === l2) {
                        V = null;
                        break;
                      }
                      if (null !== r2) {
                        r2.return = y2;
                        V = r2;
                        break;
                      }
                      V = y2;
                    }
                  }
                }
                var n2 = f2.alternate;
                if (null !== n2) {
                  var t2 = n2.child;
                  if (null !== t2) {
                    n2.child = null;
                    do {
                      var J = t2.sibling;
                      t2.sibling = null;
                      t2 = J;
                    } while (null !== t2);
                  }
                }
                V = f2;
              }
            }
            if (0 !== (f2.subtreeFlags & 2064) && null !== g2) g2.return = f2, V = g2;
            else b: for (; null !== V; ) {
              f2 = V;
              if (0 !== (f2.flags & 2048)) switch (f2.tag) {
                case 0:
                case 11:
                case 15:
                  Pj(9, f2, f2.return);
              }
              var x2 = f2.sibling;
              if (null !== x2) {
                x2.return = f2.return;
                V = x2;
                break b;
              }
              V = f2.return;
            }
          }
          var w2 = a2.current;
          for (V = w2; null !== V; ) {
            g2 = V;
            var u2 = g2.child;
            if (0 !== (g2.subtreeFlags & 2064) && null !== u2) u2.return = g2, V = u2;
            else b: for (g2 = w2; null !== V; ) {
              h2 = V;
              if (0 !== (h2.flags & 2048)) try {
                switch (h2.tag) {
                  case 0:
                  case 11:
                  case 15:
                    Qj(9, h2);
                }
              } catch (na) {
                W(h2, h2.return, na);
              }
              if (h2 === g2) {
                V = null;
                break b;
              }
              var F = h2.sibling;
              if (null !== F) {
                F.return = h2.return;
                V = F;
                break b;
              }
              V = h2.return;
            }
          }
          K = e2;
          jg();
          if (lc && "function" === typeof lc.onPostCommitFiberRoot) try {
            lc.onPostCommitFiberRoot(kc, a2);
          } catch (na) {
          }
          d2 = true;
        }
        return d2;
      } finally {
        C = c2, ok.transition = b2;
      }
    }
    return false;
  }
  function Xk(a2, b2, c2) {
    b2 = Ji(c2, b2);
    b2 = Ni(a2, b2, 1);
    a2 = nh(a2, b2, 1);
    b2 = R();
    null !== a2 && (Ac(a2, 1, b2), Dk(a2, b2));
  }
  function W(a2, b2, c2) {
    if (3 === a2.tag) Xk(a2, a2, c2);
    else for (; null !== b2; ) {
      if (3 === b2.tag) {
        Xk(b2, a2, c2);
        break;
      } else if (1 === b2.tag) {
        var d2 = b2.stateNode;
        if ("function" === typeof b2.type.getDerivedStateFromError || "function" === typeof d2.componentDidCatch && (null === Ri || !Ri.has(d2))) {
          a2 = Ji(c2, a2);
          a2 = Qi(b2, a2, 1);
          b2 = nh(b2, a2, 1);
          a2 = R();
          null !== b2 && (Ac(b2, 1, a2), Dk(b2, a2));
          break;
        }
      }
      b2 = b2.return;
    }
  }
  function Ti(a2, b2, c2) {
    var d2 = a2.pingCache;
    null !== d2 && d2.delete(b2);
    b2 = R();
    a2.pingedLanes |= a2.suspendedLanes & c2;
    Q === a2 && (Z & c2) === c2 && (4 === T || 3 === T && (Z & 130023424) === Z && 500 > B() - fk ? Kk(a2, 0) : rk |= c2);
    Dk(a2, b2);
  }
  function Yk(a2, b2) {
    0 === b2 && (0 === (a2.mode & 1) ? b2 = 1 : (b2 = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
    var c2 = R();
    a2 = ih(a2, b2);
    null !== a2 && (Ac(a2, b2, c2), Dk(a2, c2));
  }
  function uj(a2) {
    var b2 = a2.memoizedState, c2 = 0;
    null !== b2 && (c2 = b2.retryLane);
    Yk(a2, c2);
  }
  function bk(a2, b2) {
    var c2 = 0;
    switch (a2.tag) {
      case 13:
        var d2 = a2.stateNode;
        var e2 = a2.memoizedState;
        null !== e2 && (c2 = e2.retryLane);
        break;
      case 19:
        d2 = a2.stateNode;
        break;
      default:
        throw Error(p2(314));
    }
    null !== d2 && d2.delete(b2);
    Yk(a2, c2);
  }
  var Vk;
  Vk = function(a2, b2, c2) {
    if (null !== a2) if (a2.memoizedProps !== b2.pendingProps || Wf.current) dh = true;
    else {
      if (0 === (a2.lanes & c2) && 0 === (b2.flags & 128)) return dh = false, yj(a2, b2, c2);
      dh = 0 !== (a2.flags & 131072) ? true : false;
    }
    else dh = false, I && 0 !== (b2.flags & 1048576) && ug(b2, ng, b2.index);
    b2.lanes = 0;
    switch (b2.tag) {
      case 2:
        var d2 = b2.type;
        ij(a2, b2);
        a2 = b2.pendingProps;
        var e2 = Yf(b2, H2.current);
        ch(b2, c2);
        e2 = Nh(null, b2, d2, a2, e2, c2);
        var f2 = Sh();
        b2.flags |= 1;
        "object" === typeof e2 && null !== e2 && "function" === typeof e2.render && void 0 === e2.$$typeof ? (b2.tag = 1, b2.memoizedState = null, b2.updateQueue = null, Zf(d2) ? (f2 = true, cg(b2)) : f2 = false, b2.memoizedState = null !== e2.state && void 0 !== e2.state ? e2.state : null, kh(b2), e2.updater = Ei, b2.stateNode = e2, e2._reactInternals = b2, Ii(b2, d2, a2, c2), b2 = jj(null, b2, d2, true, f2, c2)) : (b2.tag = 0, I && f2 && vg(b2), Xi(null, b2, e2, c2), b2 = b2.child);
        return b2;
      case 16:
        d2 = b2.elementType;
        a: {
          ij(a2, b2);
          a2 = b2.pendingProps;
          e2 = d2._init;
          d2 = e2(d2._payload);
          b2.type = d2;
          e2 = b2.tag = Zk(d2);
          a2 = Ci(d2, a2);
          switch (e2) {
            case 0:
              b2 = cj(null, b2, d2, a2, c2);
              break a;
            case 1:
              b2 = hj(null, b2, d2, a2, c2);
              break a;
            case 11:
              b2 = Yi(null, b2, d2, a2, c2);
              break a;
            case 14:
              b2 = $i(null, b2, d2, Ci(d2.type, a2), c2);
              break a;
          }
          throw Error(p2(
            306,
            d2,
            ""
          ));
        }
        return b2;
      case 0:
        return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Ci(d2, e2), cj(a2, b2, d2, e2, c2);
      case 1:
        return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Ci(d2, e2), hj(a2, b2, d2, e2, c2);
      case 3:
        a: {
          kj(b2);
          if (null === a2) throw Error(p2(387));
          d2 = b2.pendingProps;
          f2 = b2.memoizedState;
          e2 = f2.element;
          lh(a2, b2);
          qh(b2, d2, null, c2);
          var g2 = b2.memoizedState;
          d2 = g2.element;
          if (f2.isDehydrated) if (f2 = { element: d2, isDehydrated: false, cache: g2.cache, pendingSuspenseBoundaries: g2.pendingSuspenseBoundaries, transitions: g2.transitions }, b2.updateQueue.baseState = f2, b2.memoizedState = f2, b2.flags & 256) {
            e2 = Ji(Error(p2(423)), b2);
            b2 = lj(a2, b2, d2, c2, e2);
            break a;
          } else if (d2 !== e2) {
            e2 = Ji(Error(p2(424)), b2);
            b2 = lj(a2, b2, d2, c2, e2);
            break a;
          } else for (yg = Lf(b2.stateNode.containerInfo.firstChild), xg = b2, I = true, zg = null, c2 = Vg(b2, null, d2, c2), b2.child = c2; c2; ) c2.flags = c2.flags & -3 | 4096, c2 = c2.sibling;
          else {
            Ig();
            if (d2 === e2) {
              b2 = Zi(a2, b2, c2);
              break a;
            }
            Xi(a2, b2, d2, c2);
          }
          b2 = b2.child;
        }
        return b2;
      case 5:
        return Ah(b2), null === a2 && Eg(b2), d2 = b2.type, e2 = b2.pendingProps, f2 = null !== a2 ? a2.memoizedProps : null, g2 = e2.children, Ef(d2, e2) ? g2 = null : null !== f2 && Ef(d2, f2) && (b2.flags |= 32), gj(a2, b2), Xi(a2, b2, g2, c2), b2.child;
      case 6:
        return null === a2 && Eg(b2), null;
      case 13:
        return oj(a2, b2, c2);
      case 4:
        return yh(b2, b2.stateNode.containerInfo), d2 = b2.pendingProps, null === a2 ? b2.child = Ug(b2, null, d2, c2) : Xi(a2, b2, d2, c2), b2.child;
      case 11:
        return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Ci(d2, e2), Yi(a2, b2, d2, e2, c2);
      case 7:
        return Xi(a2, b2, b2.pendingProps, c2), b2.child;
      case 8:
        return Xi(a2, b2, b2.pendingProps.children, c2), b2.child;
      case 12:
        return Xi(a2, b2, b2.pendingProps.children, c2), b2.child;
      case 10:
        a: {
          d2 = b2.type._context;
          e2 = b2.pendingProps;
          f2 = b2.memoizedProps;
          g2 = e2.value;
          G(Wg, d2._currentValue);
          d2._currentValue = g2;
          if (null !== f2) if (He(f2.value, g2)) {
            if (f2.children === e2.children && !Wf.current) {
              b2 = Zi(a2, b2, c2);
              break a;
            }
          } else for (f2 = b2.child, null !== f2 && (f2.return = b2); null !== f2; ) {
            var h2 = f2.dependencies;
            if (null !== h2) {
              g2 = f2.child;
              for (var k2 = h2.firstContext; null !== k2; ) {
                if (k2.context === d2) {
                  if (1 === f2.tag) {
                    k2 = mh(-1, c2 & -c2);
                    k2.tag = 2;
                    var l2 = f2.updateQueue;
                    if (null !== l2) {
                      l2 = l2.shared;
                      var m2 = l2.pending;
                      null === m2 ? k2.next = k2 : (k2.next = m2.next, m2.next = k2);
                      l2.pending = k2;
                    }
                  }
                  f2.lanes |= c2;
                  k2 = f2.alternate;
                  null !== k2 && (k2.lanes |= c2);
                  bh(
                    f2.return,
                    c2,
                    b2
                  );
                  h2.lanes |= c2;
                  break;
                }
                k2 = k2.next;
              }
            } else if (10 === f2.tag) g2 = f2.type === b2.type ? null : f2.child;
            else if (18 === f2.tag) {
              g2 = f2.return;
              if (null === g2) throw Error(p2(341));
              g2.lanes |= c2;
              h2 = g2.alternate;
              null !== h2 && (h2.lanes |= c2);
              bh(g2, c2, b2);
              g2 = f2.sibling;
            } else g2 = f2.child;
            if (null !== g2) g2.return = f2;
            else for (g2 = f2; null !== g2; ) {
              if (g2 === b2) {
                g2 = null;
                break;
              }
              f2 = g2.sibling;
              if (null !== f2) {
                f2.return = g2.return;
                g2 = f2;
                break;
              }
              g2 = g2.return;
            }
            f2 = g2;
          }
          Xi(a2, b2, e2.children, c2);
          b2 = b2.child;
        }
        return b2;
      case 9:
        return e2 = b2.type, d2 = b2.pendingProps.children, ch(b2, c2), e2 = eh(e2), d2 = d2(e2), b2.flags |= 1, Xi(a2, b2, d2, c2), b2.child;
      case 14:
        return d2 = b2.type, e2 = Ci(d2, b2.pendingProps), e2 = Ci(d2.type, e2), $i(a2, b2, d2, e2, c2);
      case 15:
        return bj(a2, b2, b2.type, b2.pendingProps, c2);
      case 17:
        return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Ci(d2, e2), ij(a2, b2), b2.tag = 1, Zf(d2) ? (a2 = true, cg(b2)) : a2 = false, ch(b2, c2), Gi(b2, d2, e2), Ii(b2, d2, e2, c2), jj(null, b2, d2, true, a2, c2);
      case 19:
        return xj(a2, b2, c2);
      case 22:
        return dj(a2, b2, c2);
    }
    throw Error(p2(156, b2.tag));
  };
  function Fk(a2, b2) {
    return ac(a2, b2);
  }
  function $k(a2, b2, c2, d2) {
    this.tag = a2;
    this.key = c2;
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
    this.index = 0;
    this.ref = null;
    this.pendingProps = b2;
    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
    this.mode = d2;
    this.subtreeFlags = this.flags = 0;
    this.deletions = null;
    this.childLanes = this.lanes = 0;
    this.alternate = null;
  }
  function Bg(a2, b2, c2, d2) {
    return new $k(a2, b2, c2, d2);
  }
  function aj(a2) {
    a2 = a2.prototype;
    return !(!a2 || !a2.isReactComponent);
  }
  function Zk(a2) {
    if ("function" === typeof a2) return aj(a2) ? 1 : 0;
    if (void 0 !== a2 && null !== a2) {
      a2 = a2.$$typeof;
      if (a2 === Da) return 11;
      if (a2 === Ga) return 14;
    }
    return 2;
  }
  function Pg(a2, b2) {
    var c2 = a2.alternate;
    null === c2 ? (c2 = Bg(a2.tag, b2, a2.key, a2.mode), c2.elementType = a2.elementType, c2.type = a2.type, c2.stateNode = a2.stateNode, c2.alternate = a2, a2.alternate = c2) : (c2.pendingProps = b2, c2.type = a2.type, c2.flags = 0, c2.subtreeFlags = 0, c2.deletions = null);
    c2.flags = a2.flags & 14680064;
    c2.childLanes = a2.childLanes;
    c2.lanes = a2.lanes;
    c2.child = a2.child;
    c2.memoizedProps = a2.memoizedProps;
    c2.memoizedState = a2.memoizedState;
    c2.updateQueue = a2.updateQueue;
    b2 = a2.dependencies;
    c2.dependencies = null === b2 ? null : { lanes: b2.lanes, firstContext: b2.firstContext };
    c2.sibling = a2.sibling;
    c2.index = a2.index;
    c2.ref = a2.ref;
    return c2;
  }
  function Rg(a2, b2, c2, d2, e2, f2) {
    var g2 = 2;
    d2 = a2;
    if ("function" === typeof a2) aj(a2) && (g2 = 1);
    else if ("string" === typeof a2) g2 = 5;
    else a: switch (a2) {
      case ya:
        return Tg(c2.children, e2, f2, b2);
      case za:
        g2 = 8;
        e2 |= 8;
        break;
      case Aa:
        return a2 = Bg(12, c2, b2, e2 | 2), a2.elementType = Aa, a2.lanes = f2, a2;
      case Ea:
        return a2 = Bg(13, c2, b2, e2), a2.elementType = Ea, a2.lanes = f2, a2;
      case Fa:
        return a2 = Bg(19, c2, b2, e2), a2.elementType = Fa, a2.lanes = f2, a2;
      case Ia:
        return pj(c2, e2, f2, b2);
      default:
        if ("object" === typeof a2 && null !== a2) switch (a2.$$typeof) {
          case Ba:
            g2 = 10;
            break a;
          case Ca:
            g2 = 9;
            break a;
          case Da:
            g2 = 11;
            break a;
          case Ga:
            g2 = 14;
            break a;
          case Ha:
            g2 = 16;
            d2 = null;
            break a;
        }
        throw Error(p2(130, null == a2 ? a2 : typeof a2, ""));
    }
    b2 = Bg(g2, c2, b2, e2);
    b2.elementType = a2;
    b2.type = d2;
    b2.lanes = f2;
    return b2;
  }
  function Tg(a2, b2, c2, d2) {
    a2 = Bg(7, a2, d2, b2);
    a2.lanes = c2;
    return a2;
  }
  function pj(a2, b2, c2, d2) {
    a2 = Bg(22, a2, d2, b2);
    a2.elementType = Ia;
    a2.lanes = c2;
    a2.stateNode = { isHidden: false };
    return a2;
  }
  function Qg(a2, b2, c2) {
    a2 = Bg(6, a2, null, b2);
    a2.lanes = c2;
    return a2;
  }
  function Sg(a2, b2, c2) {
    b2 = Bg(4, null !== a2.children ? a2.children : [], a2.key, b2);
    b2.lanes = c2;
    b2.stateNode = { containerInfo: a2.containerInfo, pendingChildren: null, implementation: a2.implementation };
    return b2;
  }
  function al(a2, b2, c2, d2, e2) {
    this.tag = b2;
    this.containerInfo = a2;
    this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
    this.timeoutHandle = -1;
    this.callbackNode = this.pendingContext = this.context = null;
    this.callbackPriority = 0;
    this.eventTimes = zc(0);
    this.expirationTimes = zc(-1);
    this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
    this.entanglements = zc(0);
    this.identifierPrefix = d2;
    this.onRecoverableError = e2;
    this.mutableSourceEagerHydrationData = null;
  }
  function bl(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
    a2 = new al(a2, b2, c2, h2, k2);
    1 === b2 ? (b2 = 1, true === f2 && (b2 |= 8)) : b2 = 0;
    f2 = Bg(3, null, null, b2);
    a2.current = f2;
    f2.stateNode = a2;
    f2.memoizedState = { element: d2, isDehydrated: c2, cache: null, transitions: null, pendingSuspenseBoundaries: null };
    kh(f2);
    return a2;
  }
  function cl(a2, b2, c2) {
    var d2 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
    return { $$typeof: wa, key: null == d2 ? null : "" + d2, children: a2, containerInfo: b2, implementation: c2 };
  }
  function dl(a2) {
    if (!a2) return Vf;
    a2 = a2._reactInternals;
    a: {
      if (Vb(a2) !== a2 || 1 !== a2.tag) throw Error(p2(170));
      var b2 = a2;
      do {
        switch (b2.tag) {
          case 3:
            b2 = b2.stateNode.context;
            break a;
          case 1:
            if (Zf(b2.type)) {
              b2 = b2.stateNode.__reactInternalMemoizedMergedChildContext;
              break a;
            }
        }
        b2 = b2.return;
      } while (null !== b2);
      throw Error(p2(171));
    }
    if (1 === a2.tag) {
      var c2 = a2.type;
      if (Zf(c2)) return bg(a2, c2, b2);
    }
    return b2;
  }
  function el(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
    a2 = bl(c2, d2, true, a2, e2, f2, g2, h2, k2);
    a2.context = dl(null);
    c2 = a2.current;
    d2 = R();
    e2 = yi(c2);
    f2 = mh(d2, e2);
    f2.callback = void 0 !== b2 && null !== b2 ? b2 : null;
    nh(c2, f2, e2);
    a2.current.lanes = e2;
    Ac(a2, e2, d2);
    Dk(a2, d2);
    return a2;
  }
  function fl(a2, b2, c2, d2) {
    var e2 = b2.current, f2 = R(), g2 = yi(e2);
    c2 = dl(c2);
    null === b2.context ? b2.context = c2 : b2.pendingContext = c2;
    b2 = mh(f2, g2);
    b2.payload = { element: a2 };
    d2 = void 0 === d2 ? null : d2;
    null !== d2 && (b2.callback = d2);
    a2 = nh(e2, b2, g2);
    null !== a2 && (gi(a2, e2, g2, f2), oh(a2, e2, g2));
    return g2;
  }
  function gl(a2) {
    a2 = a2.current;
    if (!a2.child) return null;
    switch (a2.child.tag) {
      case 5:
        return a2.child.stateNode;
      default:
        return a2.child.stateNode;
    }
  }
  function hl(a2, b2) {
    a2 = a2.memoizedState;
    if (null !== a2 && null !== a2.dehydrated) {
      var c2 = a2.retryLane;
      a2.retryLane = 0 !== c2 && c2 < b2 ? c2 : b2;
    }
  }
  function il(a2, b2) {
    hl(a2, b2);
    (a2 = a2.alternate) && hl(a2, b2);
  }
  function jl() {
    return null;
  }
  var kl = "function" === typeof reportError ? reportError : function(a2) {
    console.error(a2);
  };
  function ll(a2) {
    this._internalRoot = a2;
  }
  ml.prototype.render = ll.prototype.render = function(a2) {
    var b2 = this._internalRoot;
    if (null === b2) throw Error(p2(409));
    fl(a2, b2, null, null);
  };
  ml.prototype.unmount = ll.prototype.unmount = function() {
    var a2 = this._internalRoot;
    if (null !== a2) {
      this._internalRoot = null;
      var b2 = a2.containerInfo;
      Rk(function() {
        fl(null, a2, null, null);
      });
      b2[uf] = null;
    }
  };
  function ml(a2) {
    this._internalRoot = a2;
  }
  ml.prototype.unstable_scheduleHydration = function(a2) {
    if (a2) {
      var b2 = Hc();
      a2 = { blockedOn: null, target: a2, priority: b2 };
      for (var c2 = 0; c2 < Qc.length && 0 !== b2 && b2 < Qc[c2].priority; c2++) ;
      Qc.splice(c2, 0, a2);
      0 === c2 && Vc(a2);
    }
  };
  function nl(a2) {
    return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType);
  }
  function ol(a2) {
    return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType && (8 !== a2.nodeType || " react-mount-point-unstable " !== a2.nodeValue));
  }
  function pl() {
  }
  function ql(a2, b2, c2, d2, e2) {
    if (e2) {
      if ("function" === typeof d2) {
        var f2 = d2;
        d2 = function() {
          var a3 = gl(g2);
          f2.call(a3);
        };
      }
      var g2 = el(b2, d2, a2, 0, null, false, false, "", pl);
      a2._reactRootContainer = g2;
      a2[uf] = g2.current;
      sf(8 === a2.nodeType ? a2.parentNode : a2);
      Rk();
      return g2;
    }
    for (; e2 = a2.lastChild; ) a2.removeChild(e2);
    if ("function" === typeof d2) {
      var h2 = d2;
      d2 = function() {
        var a3 = gl(k2);
        h2.call(a3);
      };
    }
    var k2 = bl(a2, 0, false, null, null, false, false, "", pl);
    a2._reactRootContainer = k2;
    a2[uf] = k2.current;
    sf(8 === a2.nodeType ? a2.parentNode : a2);
    Rk(function() {
      fl(b2, k2, c2, d2);
    });
    return k2;
  }
  function rl(a2, b2, c2, d2, e2) {
    var f2 = c2._reactRootContainer;
    if (f2) {
      var g2 = f2;
      if ("function" === typeof e2) {
        var h2 = e2;
        e2 = function() {
          var a3 = gl(g2);
          h2.call(a3);
        };
      }
      fl(b2, g2, a2, e2);
    } else g2 = ql(c2, b2, a2, e2, d2);
    return gl(g2);
  }
  Ec = function(a2) {
    switch (a2.tag) {
      case 3:
        var b2 = a2.stateNode;
        if (b2.current.memoizedState.isDehydrated) {
          var c2 = tc(b2.pendingLanes);
          0 !== c2 && (Cc(b2, c2 | 1), Dk(b2, B()), 0 === (K & 6) && (Gj = B() + 500, jg()));
        }
        break;
      case 13:
        Rk(function() {
          var b3 = ih(a2, 1);
          if (null !== b3) {
            var c3 = R();
            gi(b3, a2, 1, c3);
          }
        }), il(a2, 1);
    }
  };
  Fc = function(a2) {
    if (13 === a2.tag) {
      var b2 = ih(a2, 134217728);
      if (null !== b2) {
        var c2 = R();
        gi(b2, a2, 134217728, c2);
      }
      il(a2, 134217728);
    }
  };
  Gc = function(a2) {
    if (13 === a2.tag) {
      var b2 = yi(a2), c2 = ih(a2, b2);
      if (null !== c2) {
        var d2 = R();
        gi(c2, a2, b2, d2);
      }
      il(a2, b2);
    }
  };
  Hc = function() {
    return C;
  };
  Ic = function(a2, b2) {
    var c2 = C;
    try {
      return C = a2, b2();
    } finally {
      C = c2;
    }
  };
  yb = function(a2, b2, c2) {
    switch (b2) {
      case "input":
        bb(a2, c2);
        b2 = c2.name;
        if ("radio" === c2.type && null != b2) {
          for (c2 = a2; c2.parentNode; ) c2 = c2.parentNode;
          c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]');
          for (b2 = 0; b2 < c2.length; b2++) {
            var d2 = c2[b2];
            if (d2 !== a2 && d2.form === a2.form) {
              var e2 = Db(d2);
              if (!e2) throw Error(p2(90));
              Wa(d2);
              bb(d2, e2);
            }
          }
        }
        break;
      case "textarea":
        ib(a2, c2);
        break;
      case "select":
        b2 = c2.value, null != b2 && fb(a2, !!c2.multiple, b2, false);
    }
  };
  Gb = Qk;
  Hb = Rk;
  var sl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Qk] }, tl = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" };
  var ul = { bundleType: tl.bundleType, version: tl.version, rendererPackageName: tl.rendererPackageName, rendererConfig: tl.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a2) {
    a2 = Zb(a2);
    return null === a2 ? null : a2.stateNode;
  }, findFiberByHostInstance: tl.findFiberByHostInstance || jl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
  if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
    var vl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!vl.isDisabled && vl.supportsFiber) try {
      kc = vl.inject(ul), lc = vl;
    } catch (a2) {
    }
  }
  reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl;
  reactDom_production_min.createPortal = function(a2, b2) {
    var c2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
    if (!nl(b2)) throw Error(p2(200));
    return cl(a2, b2, null, c2);
  };
  reactDom_production_min.createRoot = function(a2, b2) {
    if (!nl(a2)) throw Error(p2(299));
    var c2 = false, d2 = "", e2 = kl;
    null !== b2 && void 0 !== b2 && (true === b2.unstable_strictMode && (c2 = true), void 0 !== b2.identifierPrefix && (d2 = b2.identifierPrefix), void 0 !== b2.onRecoverableError && (e2 = b2.onRecoverableError));
    b2 = bl(a2, 1, false, null, null, c2, false, d2, e2);
    a2[uf] = b2.current;
    sf(8 === a2.nodeType ? a2.parentNode : a2);
    return new ll(b2);
  };
  reactDom_production_min.findDOMNode = function(a2) {
    if (null == a2) return null;
    if (1 === a2.nodeType) return a2;
    var b2 = a2._reactInternals;
    if (void 0 === b2) {
      if ("function" === typeof a2.render) throw Error(p2(188));
      a2 = Object.keys(a2).join(",");
      throw Error(p2(268, a2));
    }
    a2 = Zb(b2);
    a2 = null === a2 ? null : a2.stateNode;
    return a2;
  };
  reactDom_production_min.flushSync = function(a2) {
    return Rk(a2);
  };
  reactDom_production_min.hydrate = function(a2, b2, c2) {
    if (!ol(b2)) throw Error(p2(200));
    return rl(null, a2, b2, true, c2);
  };
  reactDom_production_min.hydrateRoot = function(a2, b2, c2) {
    if (!nl(a2)) throw Error(p2(405));
    var d2 = null != c2 && c2.hydratedSources || null, e2 = false, f2 = "", g2 = kl;
    null !== c2 && void 0 !== c2 && (true === c2.unstable_strictMode && (e2 = true), void 0 !== c2.identifierPrefix && (f2 = c2.identifierPrefix), void 0 !== c2.onRecoverableError && (g2 = c2.onRecoverableError));
    b2 = el(b2, null, a2, 1, null != c2 ? c2 : null, e2, false, f2, g2);
    a2[uf] = b2.current;
    sf(a2);
    if (d2) for (a2 = 0; a2 < d2.length; a2++) c2 = d2[a2], e2 = c2._getVersion, e2 = e2(c2._source), null == b2.mutableSourceEagerHydrationData ? b2.mutableSourceEagerHydrationData = [c2, e2] : b2.mutableSourceEagerHydrationData.push(
      c2,
      e2
    );
    return new ml(b2);
  };
  reactDom_production_min.render = function(a2, b2, c2) {
    if (!ol(b2)) throw Error(p2(200));
    return rl(null, a2, b2, false, c2);
  };
  reactDom_production_min.unmountComponentAtNode = function(a2) {
    if (!ol(a2)) throw Error(p2(40));
    return a2._reactRootContainer ? (Rk(function() {
      rl(null, null, a2, false, function() {
        a2._reactRootContainer = null;
        a2[uf] = null;
      });
    }), true) : false;
  };
  reactDom_production_min.unstable_batchedUpdates = Qk;
  reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a2, b2, c2, d2) {
    if (!ol(c2)) throw Error(p2(200));
    if (null == a2 || void 0 === a2._reactInternals) throw Error(p2(38));
    return rl(a2, b2, c2, false, d2);
  };
  reactDom_production_min.version = "18.3.1-next-f1338f8080-20240426";
  return reactDom_production_min;
}
var hasRequiredReactDom;
function requireReactDom() {
  if (hasRequiredReactDom) return reactDom.exports;
  hasRequiredReactDom = 1;
  function checkDCE() {
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
      return;
    }
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (err) {
      console.error(err);
    }
  }
  {
    checkDCE();
    reactDom.exports = requireReactDom_production_min();
  }
  return reactDom.exports;
}
var hasRequiredClient;
function requireClient() {
  if (hasRequiredClient) return client;
  hasRequiredClient = 1;
  var m2 = requireReactDom();
  {
    client.createRoot = m2.createRoot;
    client.hydrateRoot = m2.hydrateRoot;
  }
  return client;
}
var clientExports = requireClient();
const ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs(clientExports);
var reactExports = requireReact();
const sampleCharacter = {
  id: "pj-1",
  nom: { nomcomplet: "Test Hero", prenom: "Aryn", surnom: "the Blue" },
  age: 25,
  sexe: "H",
  taille: 175,
  poids: 70,
  langues: ["commun"],
  alignement: "Neutral Good",
  raceId: "human",
  backgroundId: "veteran-de-guerre",
  classe: {
    1: { classeId: "fighter", subclasseId: "champion", niveau: 1 }
  },
  niveauGlobal: 1,
  xp: 0,
  dv: 10,
  maitriseBonus: 2,
  pvActuels: 12,
  pvTmp: 0,
  nivFatigueActuel: 0,
  nivFatigueMax: 3,
  actionIds: ["melee-strike", "dash"],
  reactionIds: [],
  combatStats: {
    level: 1,
    mods: { modFOR: 3, modDEX: 2, modCON: 2, modINT: 0, modSAG: 1, modCHA: 0 },
    maxHp: 12,
    armorClass: 16,
    attackBonus: 5,
    maxAttacksPerTurn: 1,
    actionsPerTurn: 1,
    bonusActionsPerTurn: 1,
    actionRules: { forbidSecondAttack: true },
    resources: {}
  },
  caracs: {
    force: { FOR: 16, modFOR: 3 },
    dexterite: { DEX: 14, modDEX: 2 },
    constitution: { CON: 14, modCON: 2 },
    intelligence: { INT: 10, modINT: 0 },
    sagesse: { SAG: 12, modSAG: 1 },
    charisme: { CHA: 10, modCHA: 0 }
  },
  movementModes: { walk: 6 },
  visionProfile: {
    shape: "cone",
    range: 100,
    apertureDeg: 180,
    lightVision: "normal"
  },
  appearance: {
    spriteKey: "character",
    tokenScale: 100
  },
  // Competences / expertises use technical ids (no accents).
  competences: [],
  expertises: [],
  initiative: "modDEX",
  besoin: [],
  percPassive: 11,
  proficiencies: {
    weapons: ["simple", "martiale"],
    armors: [],
    tools: []
  },
  savingThrows: ["force", "constitution"],
  inspiration: false,
  notes: "",
  argent: {
    cuivre: 0,
    argent: 0,
    or: 10,
    platine: 0
  },
  materielSlots: {
    corps: null,
    tete: null,
    gants: null,
    bottes: null,
    ceinture_gauche: null,
    ceinture_droite: null,
    dos_gauche: null,
    dos_droit: null,
    anneau_1: null,
    anneau_2: null,
    collier: null,
    bijou_1: null,
    bijou_2: null,
    paquetage: null,
    ceinture_bourse_1: null,
    ceinture_bourse_2: null
  },
  armesDefaut: {
    main_droite: "epee-longue",
    main_gauche: "dague",
    mains: null
  },
  inventoryItems: [],
  descriptionPersonnage: {
    bio: "Test hero for the mini-game.",
    physique: "Athletic human in light armor, posture calme et vigilante.",
    personnalite: "Calm and determined.",
    objectifs: "Explore the test dungeon.",
    relations: "",
    defauts: "Too reckless."
  },
  profileDetails: {
    visage: "Traits marques, regard concentre",
    cheveux: "Cheveux bruns courts",
    yeux: "Yeux verts",
    silhouette: "Silhouette athletique"
  },
  choiceSelections: {
    statsBase: {
      FOR: 16,
      DEX: 14,
      CON: 14,
      INT: 10,
      SAG: 12,
      CHA: 10
    }
  },
  creationLocks: {},
  classLocks: { primary: false, secondary: false },
  progressionHistory: [],
  spellcastingState: {
    totalCasterLevel: 0,
    slots: {},
    sources: {},
    slotJustifications: []
  },
  derived: {
    grants: {
      traits: [],
      features: [],
      feats: [],
      skills: [],
      tools: [],
      languages: [],
      spells: []
    }
  }
};
const ORIENTATION_TO_DEG = {
  right: 0,
  "up-right": 45,
  up: 90,
  "up-left": 135,
  left: 180,
  "down-left": 225,
  down: 270,
  "down-right": 315
};
function orientationToRotationDeg(orientation) {
  return ORIENTATION_TO_DEG[orientation];
}
function orientationFromRotationDeg(rotation) {
  const raw = typeof rotation === "number" && Number.isFinite(rotation) ? rotation : 0;
  let deg = raw % 360;
  if (deg < 0) deg += 360;
  const rounded = Math.round(deg / 45) * 45;
  const normalized = (rounded + 360) % 360;
  switch (normalized) {
    case 45:
      return "down-right";
    case 90:
      return "down";
    case 135:
      return "down-left";
    case 180:
      return "left";
    case 225:
      return "up-left";
    case 270:
      return "up";
    case 315:
      return "up-right";
    default:
      return "right";
  }
}
function getDefaultOrientationForToken(token) {
  if (token.facing) return token.facing;
  return token.type === "player" ? "right" : "left";
}
function getTokenFootprintSpec(token) {
  const spec = token.footprint;
  if (spec && spec.kind === "rect") {
    const width = Math.max(1, Math.floor(spec.width));
    const height = Math.max(1, Math.floor(spec.height));
    return { kind: "rect", width, height };
  }
  if (spec && spec.kind === "cells") {
    const cells = Array.isArray(spec.cells) ? spec.cells.filter(Boolean) : [];
    if (cells.length > 0) return { kind: "cells", cells };
  }
  return { kind: "rect", width: 1, height: 1 };
}
function rotatePoint$1(x2, y2, orientation) {
  const angle = ORIENTATION_TO_DEG[orientation] * Math.PI / 180;
  const cos = Math.cos(angle);
  const sin = Math.sin(angle);
  return {
    x: x2 * cos + y2 * sin,
    y: -x2 * sin + y2 * cos
  };
}
function rotateCell(cell, orientation) {
  const rotated = rotatePoint$1(cell.x, cell.y, orientation);
  return { x: Math.round(rotated.x), y: Math.round(rotated.y) };
}
function rasterizeRotatedRect(width, height, orientation) {
  const w2 = Math.max(1, Math.floor(width));
  const h2 = Math.max(1, Math.floor(height));
  const startX = -Math.floor(w2 / 2) - 0.5;
  const startY = -Math.floor(h2 / 2) - 0.5;
  const endX = startX + w2;
  const endY = startY + h2;
  const corners = [
    rotatePoint$1(startX, startY, orientation),
    rotatePoint$1(endX, startY, orientation),
    rotatePoint$1(endX, endY, orientation),
    rotatePoint$1(startX, endY, orientation)
  ];
  let minX = Number.POSITIVE_INFINITY;
  let maxX = Number.NEGATIVE_INFINITY;
  let minY = Number.POSITIVE_INFINITY;
  let maxY = Number.NEGATIVE_INFINITY;
  for (const c2 of corners) {
    minX = Math.min(minX, c2.x);
    maxX = Math.max(maxX, c2.x);
    minY = Math.min(minY, c2.y);
    maxY = Math.max(maxY, c2.y);
  }
  const angle = ORIENTATION_TO_DEG[orientation] * Math.PI / 180;
  const cos = Math.cos(angle);
  const sin = Math.sin(angle);
  const cells = [];
  const eps = 1e-6;
  for (let y2 = Math.floor(minY); y2 <= Math.ceil(maxY); y2++) {
    for (let x2 = Math.floor(minX); x2 <= Math.ceil(maxX); x2++) {
      const lx = x2 * cos - y2 * sin;
      const ly = x2 * sin + y2 * cos;
      if (lx + eps < startX || lx - eps > endX) continue;
      if (ly + eps < startY || ly - eps > endY) continue;
      cells.push({ x: x2, y: y2 });
    }
  }
  return cells;
}
function getFootprintCells(spec, orientation) {
  if (spec.kind === "rect") {
    const cells = rasterizeRotatedRect(spec.width, spec.height, orientation);
    const unique2 = /* @__PURE__ */ new Map();
    for (const c2 of cells) {
      unique2.set(`${c2.x},${c2.y}`, c2);
    }
    return Array.from(unique2.values());
  }
  const rotated = spec.cells.map((cell) => rotateCell(cell, orientation));
  const unique = /* @__PURE__ */ new Map();
  for (const c2 of rotated) {
    unique.set(`${c2.x},${c2.y}`, c2);
  }
  return Array.from(unique.values());
}
function getFootprintCellsAt(pivot, spec, orientation) {
  const rel = getFootprintCells(spec, orientation);
  return rel.map((c2) => ({ x: pivot.x + c2.x, y: pivot.y + c2.y }));
}
function getTokenOccupiedCells(token) {
  const spec = getTokenFootprintSpec(token);
  const orientation = getDefaultOrientationForToken(token);
  return getFootprintCellsAt({ x: token.x, y: token.y }, spec, orientation);
}
function getTokenOccupiedCellsAt(token, pivot) {
  const spec = getTokenFootprintSpec(token);
  const orientation = getDefaultOrientationForToken(token);
  return getFootprintCellsAt(pivot, spec, orientation);
}
function chebyshevDistance(a2, b2) {
  return Math.max(Math.abs(a2.x - b2.x), Math.abs(a2.y - b2.y));
}
function distanceToCells(point, cells) {
  if (!cells.length) return Number.POSITIVE_INFINITY;
  let best = Number.POSITIVE_INFINITY;
  for (const c2 of cells) {
    const d2 = chebyshevDistance(point, c2);
    if (d2 < best) best = d2;
  }
  return best;
}
function distanceBetweenCells(a2, b2) {
  if (!a2.length || !b2.length) return Number.POSITIVE_INFINITY;
  let best = Number.POSITIVE_INFINITY;
  for (const ca of a2) {
    for (const cb of b2) {
      const d2 = chebyshevDistance(ca, cb);
      if (d2 < best) best = d2;
    }
  }
  return best;
}
function getClosestCellToPoint(point, cells) {
  if (!cells.length) return null;
  let best = cells[0];
  let bestDist = chebyshevDistance(point, best);
  for (const c2 of cells) {
    const d2 = chebyshevDistance(point, c2);
    if (d2 < bestDist) {
      bestDist = d2;
      best = c2;
    }
  }
  return best;
}
function getClosestFootprintCellToPoint(point, token) {
  const cells = getTokenOccupiedCells(token);
  return getClosestCellToPoint(point, cells);
}
const CELL_SIZE_M = 1.5;
function metersToCells(meters) {
  if (!Number.isFinite(meters)) return 0;
  return Math.max(0, Math.round(meters / CELL_SIZE_M));
}
function cellsToMeters(cells) {
  if (!Number.isFinite(cells)) return 0;
  return cells * CELL_SIZE_M;
}
const GRID_COLS = 12;
const GRID_ROWS = 8;
const TILE_SIZE = 64;
const BOARD_BACKGROUND_COLOR = 1841961;
function isCellInsideBoard(x2, y2) {
  return x2 >= 0 && x2 < GRID_COLS && y2 >= 0 && y2 < GRID_ROWS;
}
function getBoardWidth(cols) {
  return Math.max(1, Math.floor(cols)) * TILE_SIZE;
}
function getBoardHeight(rows) {
  return Math.max(1, Math.floor(rows)) * TILE_SIZE;
}
function isCellInsideGrid(x2, y2, cols, rows) {
  return x2 >= 0 && x2 < cols && y2 >= 0 && y2 < rows;
}
function gridToScreenForGrid(x2, y2, cols, rows) {
  const clampedX = Math.max(0, Math.min(cols - 1, Math.floor(x2)));
  const clampedY = Math.max(0, Math.min(rows - 1, Math.floor(y2)));
  return {
    x: clampedX * TILE_SIZE + TILE_SIZE / 2,
    y: clampedY * TILE_SIZE + TILE_SIZE / 2
  };
}
const GRID_SNAP_EPS = 1e-4;
function screenToGridForGrid(screenX, screenY, cols, rows) {
  const gx = Math.floor((screenX + GRID_SNAP_EPS) / TILE_SIZE);
  const gy = Math.floor((screenY + GRID_SNAP_EPS) / TILE_SIZE);
  return {
    x: Math.max(0, Math.min(cols - 1, gx)),
    y: Math.max(0, Math.min(rows - 1, gy))
  };
}
function allowCell(x2, y2, options) {
  const playable = (options == null ? void 0 : options.playableCells) ?? null;
  if (playable && playable.size > 0) {
    return playable.has(`${x2},${y2}`);
  }
  const grid = (options == null ? void 0 : options.grid) ?? null;
  if (grid) {
    return isCellInsideGrid(x2, y2, grid.cols, grid.rows);
  }
  return isCellInsideBoard(x2, y2);
}
function generateCircleEffect(id2, cx, cy, radius, options) {
  const cells = [];
  for (let dy = -radius; dy <= radius; dy++) {
    for (let dx = -radius; dx <= radius; dx++) {
      const x2 = cx + dx;
      const y2 = cy + dy;
      if (!allowCell(x2, y2, options)) continue;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist <= radius + 0.01) {
        cells.push({ x: x2, y: y2 });
      }
    }
  }
  return { id: id2, type: "circle", cells };
}
function generateRectangleEffect(id2, cx, cy, width, height, options) {
  const cells = [];
  const halfW = Math.floor(width / 2);
  const halfH = Math.floor(height / 2);
  for (let y2 = cy - halfH; y2 <= cy + halfH; y2++) {
    for (let x2 = cx - halfW; x2 <= cx + halfW; x2++) {
      if (!allowCell(x2, y2, options)) continue;
      cells.push({ x: x2, y: y2 });
    }
  }
  return { id: id2, type: "rectangle", cells };
}
function generateConeEffect(id2, cx, cy, range, direction, apertureDeg, options) {
  const cells = [];
  const angle = typeof apertureDeg === "number" && apertureDeg > 0 ? Math.min(180, apertureDeg) : 90;
  const halfAngleRad = angle * Math.PI / 360;
  const cosMin = Math.cos(halfAngleRad);
  const dirVector = (() => {
    switch (direction) {
      case "up":
        return { x: 0, y: -1 };
      case "down":
        return { x: 0, y: 1 };
      case "left":
        return { x: -1, y: 0 };
      case "right":
        return { x: 1, y: 0 };
      case "up-left":
        return { x: -1, y: -1 };
      case "up-right":
        return { x: 1, y: -1 };
      case "down-left":
        return { x: -1, y: 1 };
      case "down-right":
        return { x: 1, y: 1 };
      default:
        return { x: 1, y: 0 };
    }
  })();
  const dirLen = Math.hypot(dirVector.x, dirVector.y);
  for (let dy = -range; dy <= range; dy++) {
    for (let dx = -range; dx <= range; dx++) {
      if (dx === 0 && dy === 0) continue;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist > range + 1e-6) continue;
      const dot = dirVector.x * dx + dirVector.y * dy;
      const cosTheta = dot / (dirLen * dist);
      if (cosTheta < cosMin) continue;
      const x2 = cx + dx;
      const y2 = cy + dy;
      if (!allowCell(x2, y2, options)) continue;
      cells.push({ x: x2, y: y2 });
    }
  }
  return { id: id2, type: "cone", cells };
}
function normalizeWallEdge(params) {
  const { x: x2, y: y2, dir } = params;
  if (dir === "W" && x2 > 0) return { x: x2 - 1, y: y2, dir: "E" };
  if (dir === "N" && y2 > 0) return { x: x2, y: y2 - 1, dir: "S" };
  return { x: x2, y: y2, dir };
}
function wallEdgeKey(x2, y2, dir) {
  const norm2 = normalizeWallEdge({ x: x2, y: y2, dir });
  return `${norm2.x},${norm2.y},${norm2.dir}`;
}
function wallEdgeKeyForSegment(segment) {
  return wallEdgeKey(segment.x, segment.y, segment.dir);
}
function getAdjacentCellsForEdge(params) {
  const { x: x2, y: y2, dir } = params;
  switch (dir) {
    case "N":
      return { a: { x: x2, y: y2 - 1 }, b: { x: x2, y: y2 } };
    case "S":
      return { a: { x: x2, y: y2 }, b: { x: x2, y: y2 + 1 } };
    case "W":
      return { a: { x: x2 - 1, y: y2 }, b: { x: x2, y: y2 } };
    case "E":
    default:
      return { a: { x: x2, y: y2 }, b: { x: x2 + 1, y: y2 } };
  }
}
function edgeBetweenCells(from, to) {
  const dx = to.x - from.x;
  const dy = to.y - from.y;
  if (dx === 1 && dy === 0) return { x: from.x, y: from.y, dir: "E" };
  if (dx === -1 && dy === 0) return { x: to.x, y: to.y, dir: "E" };
  if (dx === 0 && dy === 1) return { x: from.x, y: from.y, dir: "S" };
  if (dx === 0 && dy === -1) return { x: to.x, y: to.y, dir: "S" };
  return null;
}
function buildWallEdgeSets(walls) {
  const movement2 = /* @__PURE__ */ new Set();
  const attacks = /* @__PURE__ */ new Set();
  const vision2 = /* @__PURE__ */ new Map();
  for (const seg of walls) {
    const key2 = wallEdgeKeyForSegment(seg);
    if (seg.kind === "door" && seg.state === "open") continue;
    movement2.add(key2);
    attacks.add(key2);
    vision2.set(key2, seg);
  }
  return { movement: movement2, vision: vision2, attacks };
}
function isEdgeBlockedForMovement(from, to, movementEdges) {
  const edge = edgeBetweenCells(from, to);
  if (!edge) return false;
  const key2 = wallEdgeKey(edge.x, edge.y, edge.dir);
  return movementEdges.has(key2);
}
function isEdgeBlockingVision(from, to, observer, visionEdges) {
  const edge = edgeBetweenCells(from, to);
  if (!edge) return false;
  const key2 = wallEdgeKey(edge.x, edge.y, edge.dir);
  const seg = visionEdges.get(key2);
  if (!seg) return false;
  if (seg.kind === "door" && seg.state === "open") return false;
  if (seg.kind === "low") {
    const cells = getAdjacentCellsForEdge(edge);
    const isAdjacent = cells.a.x === observer.x && cells.a.y === observer.y || cells.b.x === observer.x && cells.b.y === observer.y;
    if (isAdjacent) return false;
  }
  return true;
}
function computeClosedCells(params) {
  const { cols, rows } = params;
  const playable = params.playableCells ?? null;
  const edgeBlocks = /* @__PURE__ */ new Set();
  for (const seg of params.walls) {
    const blocks = seg.kind === "wall" || seg.kind === "door" && seg.state !== "open";
    if (!blocks) continue;
    edgeBlocks.add(wallEdgeKeyForSegment(seg));
  }
  const inside = (x2, y2) => x2 >= 0 && y2 >= 0 && x2 < cols && y2 < rows;
  const isPlayable2 = (x2, y2) => {
    if (!inside(x2, y2)) return false;
    if (!playable || playable.size === 0) return true;
    return playable.has(`${x2},${y2}`);
  };
  const visited = /* @__PURE__ */ new Set();
  const queue = [];
  for (let x2 = 0; x2 < cols; x2++) {
    for (const y2 of [0, rows - 1]) {
      if (!isPlayable2(x2, y2)) continue;
      const k2 = `${x2},${y2}`;
      if (visited.has(k2)) continue;
      visited.add(k2);
      queue.push({ x: x2, y: y2 });
    }
  }
  for (let y2 = 0; y2 < rows; y2++) {
    for (const x2 of [0, cols - 1]) {
      if (!isPlayable2(x2, y2)) continue;
      const k2 = `${x2},${y2}`;
      if (visited.has(k2)) continue;
      visited.add(k2);
      queue.push({ x: x2, y: y2 });
    }
  }
  const dirs = [
    { x: 1, y: 0 },
    { x: -1, y: 0 },
    { x: 0, y: 1 },
    { x: 0, y: -1 }
  ];
  while (queue.length) {
    const cur = queue.shift();
    for (const d2 of dirs) {
      const nx = cur.x + d2.x;
      const ny = cur.y + d2.y;
      if (!isPlayable2(nx, ny)) continue;
      const edge = edgeBetweenCells(cur, { x: nx, y: ny });
      if (edge) {
        const edgeKey = wallEdgeKey(edge.x, edge.y, edge.dir);
        if (edgeBlocks.has(edgeKey)) continue;
      }
      const k2 = `${nx},${ny}`;
      if (visited.has(k2)) continue;
      visited.add(k2);
      queue.push({ x: nx, y: ny });
    }
  }
  const closed = /* @__PURE__ */ new Set();
  for (let y2 = 0; y2 < rows; y2++) {
    for (let x2 = 0; x2 < cols; x2++) {
      if (!isPlayable2(x2, y2)) continue;
      const k2 = `${x2},${y2}`;
      if (!visited.has(k2)) closed.add(k2);
    }
  }
  return closed;
}
function key$4(x2, y2) {
  return `${x2},${y2}`;
}
function lineCells(a2, b2) {
  const cells = [];
  let x0 = Math.round(a2.x);
  let y0 = Math.round(a2.y);
  const x1 = Math.round(b2.x);
  const y1 = Math.round(b2.y);
  const dx = Math.abs(x1 - x0);
  const dy = Math.abs(y1 - y0);
  const sx = x0 < x1 ? 1 : -1;
  const sy = y0 < y1 ? 1 : -1;
  let err = dx - dy;
  while (true) {
    cells.push({ x: x0, y: y0 });
    if (x0 === x1 && y0 === y1) break;
    const e2 = 2 * err;
    if (e2 > -dy) {
      err -= dy;
      x0 += sx;
    }
    if (e2 < dx) {
      err += dx;
      y0 += sy;
    }
  }
  return cells;
}
function lineCellsSupercover(a2, b2) {
  const cells = [];
  const x0 = a2.x + 0.5;
  const y0 = a2.y + 0.5;
  const x1 = b2.x + 0.5;
  const y1 = b2.y + 0.5;
  const dx = x1 - x0;
  const dy = y1 - y0;
  const stepX = dx > 0 ? 1 : dx < 0 ? -1 : 0;
  const stepY = dy > 0 ? 1 : dy < 0 ? -1 : 0;
  let x2 = Math.floor(x0);
  let y2 = Math.floor(y0);
  const endX = Math.floor(x1);
  const endY = Math.floor(y1);
  let tMaxX;
  let tMaxY;
  let tDeltaX;
  let tDeltaY;
  if (dx === 0) {
    tMaxX = Number.POSITIVE_INFINITY;
    tDeltaX = Number.POSITIVE_INFINITY;
  } else {
    const nextX = stepX > 0 ? Math.floor(x0) + 1 : Math.floor(x0);
    tMaxX = (nextX - x0) / dx;
    tDeltaX = 1 / Math.abs(dx);
  }
  if (dy === 0) {
    tMaxY = Number.POSITIVE_INFINITY;
    tDeltaY = Number.POSITIVE_INFINITY;
  } else {
    const nextY = stepY > 0 ? Math.floor(y0) + 1 : Math.floor(y0);
    tMaxY = (nextY - y0) / dy;
    tDeltaY = 1 / Math.abs(dy);
  }
  cells.push({ x: x2, y: y2 });
  while (x2 !== endX || y2 !== endY) {
    if (tMaxX < tMaxY) {
      tMaxX += tDeltaX;
      x2 += stepX;
    } else {
      tMaxY += tDeltaY;
      y2 += stepY;
    }
    cells.push({ x: x2, y: y2 });
  }
  return cells;
}
function hasLineOfEffect(from, to, blockedCells, wallVisionEdges) {
  const hasCells = blockedCells && blockedCells.size > 0;
  const hasWalls = wallVisionEdges && wallVisionEdges.size > 0;
  if (!hasCells && !hasWalls) return true;
  const cells = lineCells(from, to);
  for (let i2 = 1; i2 < cells.length - 1; i2++) {
    const c2 = cells[i2];
    if (hasCells && blockedCells.has(key$4(c2.x, c2.y))) return false;
  }
  if (hasWalls) {
    for (let i2 = 1; i2 < cells.length; i2++) {
      const prev = cells[i2 - 1] ?? from;
      const c2 = cells[i2];
      if (isEdgeBlockingVision(prev, c2, from, wallVisionEdges)) return false;
      const dx = c2.x - prev.x;
      const dy = c2.y - prev.y;
      if (dx !== 0 && dy !== 0) {
        const stepX = { x: prev.x + dx, y: prev.y };
        const stepY = { x: prev.x, y: prev.y + dy };
        if (isEdgeBlockingVision(prev, stepX, from, wallVisionEdges)) return false;
        if (isEdgeBlockingVision(prev, stepY, from, wallVisionEdges)) return false;
        if (isEdgeBlockingVision(stepX, c2, from, wallVisionEdges)) return false;
        if (isEdgeBlockingVision(stepY, c2, from, wallVisionEdges)) return false;
      }
    }
  }
  return true;
}
function hasLineOfSight(from, to, blockedCells, wallVisionEdges) {
  const hasCells = blockedCells && blockedCells.size > 0;
  const hasWalls = wallVisionEdges && wallVisionEdges.size > 0;
  if (!hasCells && !hasWalls) return true;
  const cells = lineCellsSupercover(from, to);
  for (let i2 = 1; i2 < cells.length - 1; i2++) {
    const c2 = cells[i2];
    if (hasCells && blockedCells.has(key$4(c2.x, c2.y))) return false;
  }
  if (hasWalls) {
    for (let i2 = 1; i2 < cells.length; i2++) {
      const prev = cells[i2 - 1] ?? from;
      const c2 = cells[i2];
      if (isEdgeBlockingVision(prev, c2, from, wallVisionEdges)) return false;
      const dx = c2.x - prev.x;
      const dy = c2.y - prev.y;
      if (dx !== 0 && dy !== 0) {
        const stepX = { x: prev.x + dx, y: prev.y };
        const stepY = { x: prev.x, y: prev.y + dy };
        if (isEdgeBlockingVision(prev, stepX, from, wallVisionEdges)) return false;
        if (isEdgeBlockingVision(prev, stepY, from, wallVisionEdges)) return false;
        if (isEdgeBlockingVision(stepX, c2, from, wallVisionEdges)) return false;
        if (isEdgeBlockingVision(stepY, c2, from, wallVisionEdges)) return false;
      }
    }
  }
  return true;
}
const LIGHT_LEVEL_BRIGHT_MIN = 0.7;
const LIGHT_LEVEL_SHADOW_MIN = 0.35;
function clamp01(value2) {
  return Math.max(0, Math.min(1, value2));
}
function key$3(x2, y2) {
  return `${x2},${y2}`;
}
function computeLightLevels(params) {
  const {
    grid,
    mapLight = null,
    lightSources = null,
    obstacleVisionCells = null,
    wallVisionEdges = null,
    closedCells = null,
    roofOpenCells = null,
    ambientBlockThreshold = LIGHT_LEVEL_BRIGHT_MIN
  } = params;
  const levels = new Array(grid.cols * grid.rows).fill(0);
  const baseLightAt = (x2, y2) => {
    if (!mapLight || mapLight.length === 0) return 1;
    const idx = y2 * grid.cols + x2;
    const value2 = mapLight[idx];
    return Number.isFinite(value2) ? clamp01(value2) : 1;
  };
  const sources2 = Array.isArray(lightSources) ? lightSources : [];
  const hasBlocks = obstacleVisionCells && obstacleVisionCells.size > 0 || wallVisionEdges && wallVisionEdges.size > 0;
  for (let y2 = 0; y2 < grid.rows; y2++) {
    for (let x2 = 0; x2 < grid.cols; x2++) {
      let ambient = baseLightAt(x2, y2);
      if (ambient >= ambientBlockThreshold && (closedCells == null ? void 0 : closedCells.has(key$3(x2, y2))) && !(roofOpenCells == null ? void 0 : roofOpenCells.has(key$3(x2, y2)))) {
        ambient = 0;
      }
      let light2 = ambient;
      for (const source2 of sources2) {
        const dx = x2 - source2.x;
        const dy = y2 - source2.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist > source2.radius) continue;
        if (hasBlocks) {
          const hasLos = hasLineOfSight(
            { x: source2.x, y: source2.y },
            { x: x2, y: y2 },
            obstacleVisionCells ?? null,
            wallVisionEdges ?? null
          );
          if (!hasLos) continue;
        }
        light2 = Math.max(light2, 1);
      }
      levels[y2 * grid.cols + x2] = clamp01(light2);
    }
  }
  return levels;
}
function computeLightTints(params) {
  const { grid, lightSources = null, obstacleVisionCells = null, wallVisionEdges = null } = params;
  const colors = new Array(grid.cols * grid.rows).fill(0);
  const strength = new Array(grid.cols * grid.rows).fill(0);
  const sources2 = Array.isArray(lightSources) ? lightSources : [];
  if (sources2.length === 0) return { colors, strength };
  const hasBlocks = obstacleVisionCells && obstacleVisionCells.size > 0 || wallVisionEdges && wallVisionEdges.size > 0;
  for (let y2 = 0; y2 < grid.rows; y2++) {
    for (let x2 = 0; x2 < grid.cols; x2++) {
      let sumR = 0;
      let sumG = 0;
      let sumB = 0;
      let total = 0;
      for (const source2 of sources2) {
        if (typeof source2.color !== "number") continue;
        const dx = x2 - source2.x;
        const dy = y2 - source2.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist > source2.radius) continue;
        if (hasBlocks) {
          const hasLos = hasLineOfSight(
            { x: source2.x, y: source2.y },
            { x: x2, y: y2 },
            obstacleVisionCells ?? null,
            wallVisionEdges ?? null
          );
          if (!hasLos) continue;
        }
        const weight2 = clamp01(1 - dist / Math.max(1, source2.radius));
        const color = source2.color;
        const r2 = color >> 16 & 255;
        const g2 = color >> 8 & 255;
        const b2 = color & 255;
        sumR += r2 * weight2;
        sumG += g2 * weight2;
        sumB += b2 * weight2;
        total += weight2;
      }
      const idx = y2 * grid.cols + x2;
      if (total > 0) {
        const r2 = Math.round(sumR / total);
        const g2 = Math.round(sumG / total);
        const b2 = Math.round(sumB / total);
        colors[idx] = r2 << 16 | g2 << 8 | b2;
        strength[idx] = clamp01(total);
      }
    }
  }
  return { colors, strength };
}
function resolveLightVisionMode(mode) {
  if (mode === "lowlight" || mode === "darkvision") return mode;
  return "normal";
}
function isLightVisible(light2, mode) {
  if (mode === "darkvision") return true;
  return light2 >= LIGHT_LEVEL_SHADOW_MIN;
}
const DEFAULT_VISION_RANGE = 150;
const DEFAULT_CONE_VISION = {
  shape: "cone",
  range: DEFAULT_VISION_RANGE,
  apertureDeg: 180
};
function getFacingForToken(token) {
  if (token.facing) {
    return token.facing;
  }
  if (token.type === "player") {
    return "right";
  }
  return "left";
}
function getVisionProfileForToken(token) {
  if (token.visionProfile) {
    return token.visionProfile;
  }
  return DEFAULT_CONE_VISION;
}
function computeVisionEffectForToken(token, playableCells) {
  const profile = getVisionProfileForToken(token);
  const facing = getFacingForToken(token);
  const id2 = `vision-${token.id}`;
  const rangeCells = metersToCells(profile.range);
  if (rangeCells <= 0) {
    return {
      id: id2,
      type: profile.shape === "circle" ? "circle" : "cone",
      cells: []
    };
  }
  if (profile.shape === "circle") {
    return generateCircleEffect(id2, token.x, token.y, rangeCells, {
      playableCells: playableCells ?? null
    });
  }
  return generateConeEffect(
    id2,
    token.x,
    token.y,
    rangeCells,
    facing,
    profile.apertureDeg,
    { playableCells: playableCells ?? null }
  );
}
function key$2(pos) {
  return `${pos.x},${pos.y}`;
}
function getLightVisionMode(profile) {
  if (profile.lightVision) return resolveLightVisionMode(profile.lightVision);
  if (profile.canSeeInDark) return "darkvision";
  return "normal";
}
function getLightAt(lightLevels, grid, x2, y2) {
  if (!lightLevels || !grid) return null;
  if (x2 < 0 || y2 < 0 || x2 >= grid.cols || y2 >= grid.rows) return null;
  const idx = y2 * grid.cols + x2;
  return typeof lightLevels[idx] === "number" ? lightLevels[idx] : null;
}
function isCellVisible(observer, cell, opaqueCells, playableCells, wallVisionEdges, lightLevels, grid) {
  if (playableCells && playableCells.size > 0) {
    if (!playableCells.has(key$2(cell))) return false;
    if (!playableCells.has(key$2({ x: observer.x, y: observer.y }))) return false;
  }
  const effect = computeVisionEffectForToken(observer, playableCells ?? null);
  if (!effect.cells.length) return false;
  const cellKey = key$2(cell);
  for (const c2 of effect.cells) {
    if (playableCells && playableCells.size > 0 && !playableCells.has(key$2(c2))) {
      continue;
    }
    if (key$2(c2) === cellKey) {
      const hasOpaque = Boolean(opaqueCells && opaqueCells.size > 0);
      const hasWalls = Boolean(wallVisionEdges && wallVisionEdges.size > 0);
      const hasLos = !hasOpaque && !hasWalls ? true : hasLineOfSight(
        { x: observer.x, y: observer.y },
        { x: cell.x, y: cell.y },
        opaqueCells,
        wallVisionEdges ?? null
      );
      if (!hasLos) return false;
      if (cell.x === observer.x && cell.y === observer.y) return true;
      const light2 = getLightAt(lightLevels, grid ?? null, cell.x, cell.y);
      if (light2 === null) return true;
      const mode = getLightVisionMode(getVisionProfileForToken(observer));
      return isLightVisible(light2, mode);
    }
  }
  return false;
}
function getEntitiesInVision(observer, allTokens, opaqueCells, playableCells, wallVisionEdges, lightLevels, grid) {
  const effect = computeVisionEffectForToken(observer, playableCells ?? null);
  if (!effect.cells.length) return [];
  const cells = /* @__PURE__ */ new Set();
  for (const cell of effect.cells) {
    const k2 = key$2(cell);
    if (playableCells && playableCells.size > 0 && !playableCells.has(k2)) continue;
    cells.add(k2);
  }
  const lightMode = getLightVisionMode(getVisionProfileForToken(observer));
  const candidates = allTokens.filter((t2) => {
    if (t2.id === observer.id || t2.hp <= 0) return false;
    const footprint2 = getTokenOccupiedCells(t2);
    return footprint2.some((c2) => {
      if (!cells.has(key$2(c2))) return false;
      const light2 = getLightAt(lightLevels, grid ?? null, c2.x, c2.y);
      if (light2 === null) return true;
      return isLightVisible(light2, lightMode);
    });
  });
  const filteredByPlayable = playableCells && playableCells.size > 0 ? candidates.filter(
    (t2) => getTokenOccupiedCells(t2).some((c2) => playableCells.has(key$2(c2)))
  ) : candidates;
  const hasOpaque = Boolean(opaqueCells && opaqueCells.size > 0);
  const hasWalls = Boolean(wallVisionEdges && wallVisionEdges.size > 0);
  if (!hasOpaque && !hasWalls) return filteredByPlayable;
  return filteredByPlayable.filter((t2) => {
    const targetCell = getClosestFootprintCellToPoint({ x: observer.x, y: observer.y }, t2) ?? { x: t2.x, y: t2.y };
    return hasLineOfSight(
      { x: observer.x, y: observer.y },
      targetCell,
      opaqueCells,
      wallVisionEdges ?? null
    );
  });
}
function isTargetVisible(observer, target, allTokens, opaqueCells, playableCells, wallVisionEdges, lightLevels, grid) {
  if (target.hp <= 0) return false;
  if (playableCells && playableCells.size > 0) {
    const targetCells = getTokenOccupiedCells(target);
    if (!targetCells.some((c2) => playableCells.has(key$2(c2)))) return false;
    if (!playableCells.has(key$2({ x: observer.x, y: observer.y }))) return false;
  }
  const visibles = getEntitiesInVision(
    observer,
    allTokens,
    opaqueCells,
    playableCells,
    wallVisionEdges,
    lightLevels,
    grid
  );
  const inCone = visibles.some((t2) => t2.id === target.id);
  if (!inCone) return false;
  return true;
}
function isInsideBounds(x2, y2, grid, playableCells) {
  if (grid && !isCellInsideGrid(x2, y2, grid.cols, grid.rows)) return false;
  if (playableCells && playableCells.size > 0) return playableCells.has(`${x2},${y2}`);
  return true;
}
function setVisibility(map, x2, y2, level2) {
  const k2 = `${x2},${y2}`;
  const prev = map.get(k2) ?? 0;
  if (level2 > prev) map.set(k2, level2);
}
function computeShadowcastVisibility(params) {
  const {
    origin,
    range,
    grid = null,
    playableCells = null,
    opaqueCells = null
  } = params;
  const result = /* @__PURE__ */ new Map();
  if (range <= 0) return result;
  const isOpaque = (x2, y2) => Boolean(opaqueCells && opaqueCells.has(`${x2},${y2}`));
  const castLight = (row, start, end, radius, xx, xy, yx, yy) => {
    if (start < end) return;
    let newStart = start;
    let blocked = false;
    for (let dist = row; dist <= radius && !blocked; dist++) {
      let dx = -dist - 1;
      let dy = -dist;
      while (dx <= 0) {
        dx += 1;
        const mx = origin.x + dx * xx + dy * xy;
        const my = origin.y + dx * yx + dy * yy;
        const lSlope = (dx - 0.5) / (dy + 0.5);
        const rSlope = (dx + 0.5) / (dy - 0.5);
        if (start < rSlope) {
          continue;
        }
        if (end > lSlope) {
          break;
        }
        if (!isInsideBounds(mx, my, grid, playableCells)) {
          continue;
        }
        if (dx * dx + dy * dy <= radius * radius) {
          const opaque2 = isOpaque(mx, my);
          setVisibility(result, mx, my, opaque2 ? 1 : 2);
        }
        const opaque = isOpaque(mx, my);
        if (blocked) {
          if (opaque) {
            newStart = rSlope;
            continue;
          }
          blocked = false;
          start = newStart;
        } else if (opaque && dist < radius) {
          blocked = true;
          castLight(dist + 1, start, lSlope, radius, xx, xy, yx, yy);
          newStart = rSlope;
        }
      }
    }
  };
  setVisibility(result, origin.x, origin.y, 2);
  const transforms = [
    [1, 0, 0, 1],
    [0, 1, 1, 0],
    [-1, 0, 0, 1],
    [0, -1, 1, 0],
    [-1, 0, 0, -1],
    [0, -1, -1, 0],
    [1, 0, 0, -1],
    [0, 1, -1, 0]
  ];
  for (const [xx, xy, yx, yy] of transforms) {
    castLight(1, 1, 0, range, xx, xy, yx, yy);
  }
  return result;
}
function computeVisibilityLevelsForToken(params) {
  const {
    token,
    playableCells = null,
    grid = null,
    opaqueCells = null,
    wallVisionEdges = null
  } = params;
  const profile = getVisionProfileForToken(token);
  const facing = getFacingForToken(token);
  const range = Math.max(0, Math.floor(profile.range ?? 0));
  if (range <= 0) return /* @__PURE__ */ new Map();
  const base = computeShadowcastVisibility({
    origin: { x: token.x, y: token.y },
    range,
    grid,
    playableCells,
    opaqueCells
  });
  if (profile.shape === "circle") {
    if (!wallVisionEdges || wallVisionEdges.size === 0) return base;
    const filtered2 = /* @__PURE__ */ new Map();
    for (const [k2, v2] of base.entries()) {
      const [x2, y2] = k2.split(",").map(Number);
      if (hasLineOfSight(
        { x: token.x, y: token.y },
        { x: x2, y: y2 },
        opaqueCells ?? null,
        wallVisionEdges
      )) {
        filtered2.set(k2, v2);
      }
    }
    return filtered2;
  }
  const cone = generateConeEffect(
    `cone-${token.id}`,
    token.x,
    token.y,
    range,
    facing,
    profile.apertureDeg,
    { playableCells }
  );
  const allowed = new Set(cone.cells.map((c2) => `${c2.x},${c2.y}`));
  allowed.add(`${token.x},${token.y}`);
  const filtered = /* @__PURE__ */ new Map();
  for (const [k2, v2] of base.entries()) {
    if (!allowed.has(k2)) continue;
    const [x2, y2] = k2.split(",").map(Number);
    if (hasLineOfSight(
      { x: token.x, y: token.y },
      { x: x2, y: y2 },
      opaqueCells ?? null,
      wallVisionEdges
    )) {
      filtered.set(k2, v2);
    }
  }
  return filtered;
}
function clamp$5(value2, min, max) {
  return Math.max(min, Math.min(max, value2));
}
function gridDistance$1(a2, b2) {
  return Math.max(Math.abs(a2.x - b2.x), Math.abs(a2.y - b2.y));
}
function distanceBetweenTokens(a2, b2) {
  const aCells = getTokenOccupiedCells(a2);
  const bCells = getTokenOccupiedCells(b2);
  return cellsToMeters(distanceBetweenCells(aCells, bCells));
}
function distanceFromPointToToken(point, token) {
  const cells = getTokenOccupiedCells(token);
  return cellsToMeters(distanceToCells(point, cells));
}
function isTokenDead(token) {
  return token.hp <= 0;
}
function canEnemySeePlayer(enemy, playerToken, allTokens, opaqueCells, playableCells, wallVisionEdges, lightLevels, grid) {
  if (isTokenDead(enemy) || isTokenDead(playerToken)) return false;
  return isTargetVisible(
    enemy,
    playerToken,
    allTokens,
    opaqueCells,
    playableCells,
    wallVisionEdges ?? null,
    lightLevels ?? null,
    grid ?? null
  );
}
function computeFacingTowards(from, to) {
  const dx = to.x - from.x;
  const dy = to.y - from.y;
  if (dx === 0 && dy === 0) {
    return "right";
  }
  if (dx === 0) {
    return dy >= 0 ? "down" : "up";
  }
  if (dy === 0) {
    return dx >= 0 ? "right" : "left";
  }
  if (dx > 0 && dy > 0) return "down-right";
  if (dx > 0 && dy < 0) return "up-right";
  if (dx < 0 && dy > 0) return "down-left";
  return "up-left";
}
function getLevelFromContext(ctx) {
  var _a, _b;
  const level2 = Number(((_a = ctx.actor.combatStats) == null ? void 0 : _a.level) ?? ((_b = ctx.sampleCharacter) == null ? void 0 : _b.niveauGlobal) ?? 1);
  return Number.isFinite(level2) ? level2 : 1;
}
function getProficiencyBonus$1(level2) {
  if (level2 <= 4) return 2;
  if (level2 <= 8) return 3;
  if (level2 <= 12) return 4;
  if (level2 <= 16) return 5;
  return 6;
}
function resolveNumberVar(varName, ctx) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B, _C, _D, _E, _F, _G, _H, _I, _J, _K, _L, _M, _N, _O, _P, _Q;
  const actor = ctx.actor;
  const stats = actor.combatStats;
  const token = varName.toLowerCase();
  const computeModFromScore = (score) => {
    if (!Number.isFinite(score)) return 0;
    return Math.floor((Number(score) - 10) / 2);
  };
  const pickNumber = (...values) => {
    for (const value2 of values) {
      if (typeof value2 === "number" && Number.isFinite(value2)) return value2;
    }
    return 0;
  };
  if (token === "attackbonus") {
    return typeof (stats == null ? void 0 : stats.attackBonus) === "number" ? stats.attackBonus : 0;
  }
  if (token === "moverange") {
    return typeof (stats == null ? void 0 : stats.moveRange) === "number" ? stats.moveRange : typeof actor.moveRange === "number" ? actor.moveRange : typeof ((_a = actor.movementProfile) == null ? void 0 : _a.speed) === "number" ? actor.movementProfile.speed : 0;
  }
  if (token === "level" || token === "niveau") {
    return getLevelFromContext(ctx);
  }
  if (token === "proficiencybonus" || token === "maitrisebonus") {
    return getProficiencyBonus$1(getLevelFromContext(ctx));
  }
  if (token === "modfor") {
    const mod = pickNumber(
      (_b = stats == null ? void 0 : stats.mods) == null ? void 0 : _b.modFOR,
      (_e = (_d = (_c = ctx.sampleCharacter) == null ? void 0 : _c.caracs) == null ? void 0 : _d.force) == null ? void 0 : _e.modFOR,
      computeModFromScore((_h = (_g = (_f = ctx.sampleCharacter) == null ? void 0 : _f.caracs) == null ? void 0 : _g.force) == null ? void 0 : _h.FOR)
    );
    return Number.isFinite(mod) ? mod : 0;
  }
  if (token === "moddex") {
    const mod = pickNumber(
      (_i = stats == null ? void 0 : stats.mods) == null ? void 0 : _i.modDEX,
      (_l = (_k = (_j = ctx.sampleCharacter) == null ? void 0 : _j.caracs) == null ? void 0 : _k.dexterite) == null ? void 0 : _l.modDEX,
      computeModFromScore((_o = (_n = (_m = ctx.sampleCharacter) == null ? void 0 : _m.caracs) == null ? void 0 : _n.dexterite) == null ? void 0 : _o.DEX)
    );
    return Number.isFinite(mod) ? mod : 0;
  }
  if (token === "modcon") {
    const mod = pickNumber(
      (_p = stats == null ? void 0 : stats.mods) == null ? void 0 : _p.modCON,
      (_s = (_r = (_q = ctx.sampleCharacter) == null ? void 0 : _q.caracs) == null ? void 0 : _r.constitution) == null ? void 0 : _s.modCON,
      computeModFromScore((_v = (_u = (_t = ctx.sampleCharacter) == null ? void 0 : _t.caracs) == null ? void 0 : _u.constitution) == null ? void 0 : _v.CON)
    );
    return Number.isFinite(mod) ? mod : 0;
  }
  if (token === "modint") {
    const mod = pickNumber(
      (_w = stats == null ? void 0 : stats.mods) == null ? void 0 : _w.modINT,
      (_z = (_y = (_x = ctx.sampleCharacter) == null ? void 0 : _x.caracs) == null ? void 0 : _y.intelligence) == null ? void 0 : _z.modINT,
      computeModFromScore((_C = (_B = (_A = ctx.sampleCharacter) == null ? void 0 : _A.caracs) == null ? void 0 : _B.intelligence) == null ? void 0 : _C.INT)
    );
    return Number.isFinite(mod) ? mod : 0;
  }
  if (token === "modsag") {
    const mod = pickNumber(
      (_D = stats == null ? void 0 : stats.mods) == null ? void 0 : _D.modSAG,
      (_G = (_F = (_E = ctx.sampleCharacter) == null ? void 0 : _E.caracs) == null ? void 0 : _F.sagesse) == null ? void 0 : _G.modSAG,
      computeModFromScore((_J = (_I = (_H = ctx.sampleCharacter) == null ? void 0 : _H.caracs) == null ? void 0 : _I.sagesse) == null ? void 0 : _J.SAG)
    );
    return Number.isFinite(mod) ? mod : 0;
  }
  if (token === "modcha") {
    const mod = pickNumber(
      (_K = stats == null ? void 0 : stats.mods) == null ? void 0 : _K.modCHA,
      (_N = (_M = (_L = ctx.sampleCharacter) == null ? void 0 : _L.caracs) == null ? void 0 : _M.charisme) == null ? void 0 : _N.modCHA,
      computeModFromScore((_Q = (_P = (_O = ctx.sampleCharacter) == null ? void 0 : _O.caracs) == null ? void 0 : _P.charisme) == null ? void 0 : _Q.CHA)
    );
    return Number.isFinite(mod) ? mod : 0;
  }
  return null;
}
function resolveFormula(formula, ctx) {
  const raw = String(formula ?? "");
  if (!raw.trim()) return "0";
  return raw.replace(/[A-Za-z_][A-Za-z0-9_]*/g, (token) => {
    const value2 = resolveNumberVar(token, ctx);
    return value2 === null ? token : String(value2);
  });
}
const types$d = ["./brute.json", "./archer.json", "./assassin.json", "./ghost.json"];
const enemyTypesIndex = {
  types: types$d
};
const id$37 = "brute";
const label$2t = "Brute";
const description$I = "Frontliner robuste qui avance pour engager le joueur.";
const aiRole$3 = "brute";
const actions$4 = ["move", "melee-strike"];
const reactionIds$3 = ["opportunity-attack"];
const armesDefaut$3 = { "main_droite": "hache-bataille", "main_gauche": null, "mains": null };
const proficiencies$5 = { "weapons": ["martiale"], "armors": [] };
const combatProfile$3 = { "primaryStyle": "melee", "allowedStyles": ["melee"], "preferredAbilities": ["FOR"], "preferredRangeMin": 1.5, "preferredRangeMax": 1.5, "intelligence": 1, "awareness": 1, "tactics": ["hold_line"] };
const behavior$9 = { "preferredRangeMin": 1.5, "preferredRangeMax": 1.5, "panicRange": 0 };
const speechProfile$3 = { "raceOrOrigin": "Brute mercenaire", "register": "familier", "tone": ["agressif", "direct", "impatient"], "vocabulary": ["charge", "ecrase", "avance", "finissons-en"], "quirks": ["phrases courtes", "menaces simples"], "taboos": ["pas de modernisme", "pas de meta-jeu"] };
const combatStats$3 = { "level": 1, "mods": { "modFOR": 0, "modDEX": 0, "modCON": 0, "modINT": 0, "modSAG": 0, "modCHA": 0 }, "maxHp": 10, "armorClass": 14, "attackBonus": 0, "maxAttacksPerTurn": 2, "actionsPerTurn": 1, "bonusActionsPerTurn": 0, "resources": {} };
const spellcastingState$3 = { "totalCasterLevel": 0, "slots": {}, "sources": {}, "slotJustifications": [] };
const appearance$t = { "spriteKey": "brute", "tokenScale": 100 };
const movementModes$3 = { "walk": 4.5 };
const movement$5 = { "type": "ground", "speed": 4.5, "canPassThroughWalls": false, "canPassThroughEntities": false, "canStopOnOccupiedTile": false };
const vision$5 = { "shape": "cone", "range": 150, "apertureDeg": 180, "canSeeInDark": false, "lightVision": "normal" };
const bruteType = {
  id: id$37,
  label: label$2t,
  description: description$I,
  aiRole: aiRole$3,
  actions: actions$4,
  reactionIds: reactionIds$3,
  armesDefaut: armesDefaut$3,
  proficiencies: proficiencies$5,
  combatProfile: combatProfile$3,
  behavior: behavior$9,
  speechProfile: speechProfile$3,
  combatStats: combatStats$3,
  spellcastingState: spellcastingState$3,
  appearance: appearance$t,
  movementModes: movementModes$3,
  movement: movement$5,
  vision: vision$5
};
const id$36 = "archer";
const label$2s = "Archer";
const description$H = "Tireur qui prefere garder une distance de securite avant de frapper.";
const aiRole$2 = "archer";
const actions$3 = ["move", "bow-shot", "melee-strike"];
const reactionIds$2 = ["guard-strike"];
const armesDefaut$2 = { "main_droite": "arc-long", "main_gauche": null, "mains": null };
const proficiencies$4 = { "weapons": ["martiale"], "armors": [] };
const combatProfile$2 = { "primaryStyle": "ranged", "allowedStyles": ["ranged", "melee"], "preferredAbilities": ["DEX"], "preferredRangeMin": 4.5, "preferredRangeMax": 9, "avoidRangeMin": 0, "avoidRangeMax": 3, "intelligence": 1, "awareness": 1, "tactics": ["avoid_opportunity", "poke_from_range"] };
const behavior$8 = { "preferredRangeMin": 4.5, "preferredRangeMax": 9, "panicRange": 3 };
const speechProfile$2 = { "raceOrOrigin": "Archer de bande", "register": "neutre", "tone": ["tactique", "moqueur", "vigilant"], "vocabulary": ["a couvert", "recule", "je l'ai en vue", "distance"], "quirks": ["annonce ce qu'il voit", "donne des consignes courtes"], "taboos": ["pas de modernisme", "pas de meta-jeu"] };
const combatStats$2 = { "level": 1, "mods": { "modFOR": 0, "modDEX": 0, "modCON": 0, "modINT": 0, "modSAG": 0, "modCHA": 0 }, "maxHp": 7, "armorClass": 13, "attackBonus": 0, "maxAttacksPerTurn": 1, "actionsPerTurn": 1, "bonusActionsPerTurn": 0, "resources": {} };
const spellcastingState$2 = { "totalCasterLevel": 0, "slots": {}, "sources": {}, "slotJustifications": [] };
const appearance$s = { "spriteKey": "archer", "tokenScale": 100 };
const movementModes$2 = { "walk": 3 };
const movement$4 = { "type": "ground", "speed": 3, "canPassThroughWalls": false, "canPassThroughEntities": false, "canStopOnOccupiedTile": false };
const vision$4 = { "shape": "cone", "range": 150, "apertureDeg": 180, "canSeeInDark": false, "lightVision": "normal" };
const archerType = {
  id: id$36,
  label: label$2s,
  description: description$H,
  aiRole: aiRole$2,
  actions: actions$3,
  reactionIds: reactionIds$2,
  armesDefaut: armesDefaut$2,
  proficiencies: proficiencies$4,
  combatProfile: combatProfile$2,
  behavior: behavior$8,
  speechProfile: speechProfile$2,
  combatStats: combatStats$2,
  spellcastingState: spellcastingState$2,
  appearance: appearance$s,
  movementModes: movementModes$2,
  movement: movement$4,
  vision: vision$4
};
const id$35 = "assassin";
const label$2r = "Assassin";
const description$G = "Frappeur rapide qui cherche a se rapprocher pour porter un coup decisif.";
const aiRole$1 = "assassin";
const actions$2 = ["move", "melee-strike"];
const reactionIds$1 = ["opportunity-attack"];
const armesDefaut$1 = { "main_droite": "dague", "main_gauche": null, "mains": null };
const proficiencies$3 = { "weapons": ["simple"], "armors": [] };
const combatProfile$1 = { "primaryStyle": "melee", "allowedStyles": ["melee"], "preferredAbilities": ["DEX"], "preferredRangeMin": 1.5, "preferredRangeMax": 1.5, "intelligence": 2, "awareness": 1, "tactics": ["flank", "avoid_opportunity"] };
const behavior$7 = { "preferredRangeMin": 1.5, "preferredRangeMax": 1.5, "panicRange": 0 };
const speechProfile$1 = { "raceOrOrigin": "Assassin", "register": "soutenu", "tone": ["froid", "tranchant", "calme"], "vocabulary": ["silence", "cible", "dans l'ombre", "fin"], "quirks": ["parle peu", "phrases courtes et precises"], "taboos": ["pas de modernisme", "pas de meta-jeu"] };
const combatStats$1 = { "level": 1, "mods": { "modFOR": 0, "modDEX": 0, "modCON": 0, "modINT": 0, "modSAG": 0, "modCHA": 0 }, "maxHp": 6, "armorClass": 15, "attackBonus": 0, "maxAttacksPerTurn": 1, "actionsPerTurn": 1, "bonusActionsPerTurn": 0, "resources": {} };
const spellcastingState$1 = { "totalCasterLevel": 0, "slots": {}, "sources": {}, "slotJustifications": [] };
const appearance$r = { "spriteKey": "assassin", "tokenScale": 100 };
const movementModes$1 = { "walk": 4.5 };
const movement$3 = { "type": "ground", "speed": 4.5, "canPassThroughWalls": false, "canPassThroughEntities": true, "canStopOnOccupiedTile": false };
const vision$3 = { "shape": "cone", "range": 150, "apertureDeg": 180, "canSeeInDark": false, "lightVision": "normal" };
const assassinType = {
  id: id$35,
  label: label$2r,
  description: description$G,
  aiRole: aiRole$1,
  actions: actions$2,
  reactionIds: reactionIds$1,
  armesDefaut: armesDefaut$1,
  proficiencies: proficiencies$3,
  combatProfile: combatProfile$1,
  behavior: behavior$7,
  speechProfile: speechProfile$1,
  combatStats: combatStats$1,
  spellcastingState: spellcastingState$1,
  appearance: appearance$r,
  movementModes: movementModes$1,
  movement: movement$3,
  vision: vision$3
};
const id$34 = "ghost";
const label$2q = "Fantome";
const description$F = "Esprit intangible capable de traverser les autres creatures.";
const aiRole = "ghost";
const actions$1 = ["move", "melee-strike"];
const reactionIds = ["guard-strike"];
const armesDefaut = { "main_droite": null, "main_gauche": null, "mains": null };
const proficiencies$2 = { "weapons": [], "armors": [] };
const combatProfile = { "primaryStyle": "melee", "allowedStyles": ["melee"], "preferredAbilities": ["SAG"], "preferredRangeMin": 1.5, "preferredRangeMax": 1.5, "intelligence": 1, "awareness": 1, "tactics": ["haunt"] };
const behavior$6 = { "preferredRangeMin": 1.5, "preferredRangeMax": 1.5, "panicRange": 0 };
const speechProfile = { "raceOrOrigin": "Esprit vengeur", "register": "soutenu", "tone": ["cryptique", "mena??ant", "surnaturel"], "vocabulary": ["je te sens", "au-dela", "froideur", "souffle"], "quirks": ["parle en images", "phrases etranges mais courtes"], "taboos": ["pas de modernisme", "pas de meta-jeu"] };
const combatStats = { "level": 1, "mods": { "modFOR": 0, "modDEX": 0, "modCON": 0, "modINT": 0, "modSAG": 0, "modCHA": 0 }, "maxHp": 8, "armorClass": 12, "attackBonus": 0, "maxAttacksPerTurn": 1, "actionsPerTurn": 1, "bonusActionsPerTurn": 0, "resources": {} };
const spellcastingState = { "totalCasterLevel": 0, "slots": {}, "sources": {}, "slotJustifications": [] };
const appearance$q = { "spriteKey": "ghost", "tokenScale": 100 };
const movementModes = { "ghost": 6 };
const movement$2 = { "type": "ghost", "speed": 6, "canPassThroughWalls": true, "canPassThroughEntities": true, "canStopOnOccupiedTile": false };
const vision$2 = { "shape": "circle", "range": 150, "canSeeInDark": true, "lightVision": "darkvision" };
const ghostType = {
  id: id$34,
  label: label$2q,
  description: description$F,
  aiRole,
  actions: actions$1,
  reactionIds,
  armesDefaut,
  proficiencies: proficiencies$2,
  combatProfile,
  behavior: behavior$6,
  speechProfile,
  combatStats,
  spellcastingState,
  appearance: appearance$q,
  movementModes,
  movement: movement$2,
  vision: vision$2
};
const types$c = ["./fence-wood.json", "./tree-oak.json", "./bush.json", "./log.json", "./rock.json", "./rubble.json", "./stalagmite.json", "./barrel-wood.json", "./crate-wood.json", "./table-wood.json", "./chair-wood.json", "./statue-stone.json", "./torch-wall.json", "./brazier.json", "./fire-only.json", "./pillar-stone.json", "./stairs-stone.json", "./charette-wood.json"];
const obstaclesIndex = {
  types: types$c
};
const id$33 = "fence-wood";
const label$2p = "Cloture en bois";
const category$1Q = "structure";
const tags$2F = ["fence", "wood", "structure"];
const blocking$n = { "movement": true, "vision": false, "attacks": false };
const durability$n = { "destructible": true, "maxHp": 8, "ac": 10 };
const variants$n = [{ "id": "1", "label": "Segment 1", "footprint": [{ "x": 0, "y": 0 }], "rotatable": true }, { "id": "2", "label": "Segment 2", "footprint": [{ "x": 0, "y": 0 }, { "x": 1, "y": 0 }], "rotatable": true }];
const appearance$p = { "spriteKey": "obstacle:fence-wood", "heightClass": "low", "tokenScale": { "min": 80, "default": 100, "max": 150 } };
const spawnRules$g = { "weight": 2, "cluster": { "min": 1, "max": 6 }, "shapeHint": "line", "avoidNearTokens": true };
const fenceWood = {
  id: id$33,
  label: label$2p,
  category: category$1Q,
  tags: tags$2F,
  blocking: blocking$n,
  durability: durability$n,
  variants: variants$n,
  appearance: appearance$p,
  spawnRules: spawnRules$g
};
const id$32 = "tree-oak";
const label$2o = "Chne";
const category$1P = "vegetation";
const tags$2E = ["tree", "vegetation", "wood"];
const blocking$m = { "movement": true, "vision": true, "attacks": true };
const durability$m = { "destructible": true, "maxHp": 22, "ac": 12 };
const variants$m = [{ "id": "base", "label": "Tronc", "footprint": [{ "x": 0, "y": 0 }], "rotatable": true }];
const appearance$o = { "randomRotation": true, "paletteId": "default", "palettes": { "default": { "layers": { "canopy": { "alpha": 0.6, "tintRange": { "dark": 3107631, "light": 7323487 } }, "trunk": { "tintRange": { "dark": 5978654, "light": 9132587 } } } }, "autumn": { "layers": { "canopy": { "alpha": 0.75, "tintRange": { "dark": 10709547, "light": 15778138 } }, "trunk": { "tintRange": { "dark": 5978654, "light": 9132587 } } } }, "leafless": { "layers": { "canopy": { "alpha": 0.75, "visible": false } } } }, "spriteGrid": { "tilesX": 3, "tilesY": 3 }, "shadowSpriteLeafy": "obstacle:tree-oak-canopy-shadow", "shadowSpriteLeafless": "obstacle:tree-oak-trunk-shadow", "shadowMode": "tall", "heightClass": "tall", "shadowStretch": 1, "layers": [{ "id": "trunk", "spriteKey": "obstacle:tree-oak-trunk" }, { "id": "canopy", "spriteKey": "obstacle:tree-oak-canopy", "z": 1, "renderLayer": "overhead", "visible": "hideWhenTokenBelow" }], "tokenScale": { "min": 80, "default": 90, "max": 100 } };
const spawnRules$f = { "weight": 6, "cluster": { "min": 1, "max": 5 }, "shapeHint": "scatter", "avoidNearTokens": true };
const treeOak = {
  id: id$32,
  label: label$2o,
  category: category$1P,
  tags: tags$2E,
  blocking: blocking$m,
  durability: durability$m,
  variants: variants$m,
  appearance: appearance$o,
  spawnRules: spawnRules$f
};
const id$31 = "bush";
const label$2n = "Buisson";
const category$1O = "vegetation";
const tags$2D = ["bush", "vegetation", "nature"];
const blocking$l = { "movement": true, "vision": false, "attacks": false };
const durability$l = { "destructible": true, "maxHp": 5, "ac": 10 };
const variants$l = [{ "id": "base", "label": "Buisson", "footprint": [{ "x": 0, "y": 0 }], "rotatable": true }];
const appearance$n = { "randomRotation": true, "heightClass": "low", "shadowStretch": 1.2, "paletteId": "default", "palettes": { "default": { "layers": { "bush": { "tintRange": { "dark": 2926900, "light": 7063940 } } } }, "autumn": { "layers": { "bush": { "tintRange": { "dark": 10246534, "light": 15243711 } } } }, "leafless": { "layers": { "bush": { "tintRange": { "dark": 5723992, "light": 10790052 } } } } }, "layers": [{ "id": "bush", "spriteKey": "obstacle:bush" }], "tokenScale": { "min": 100, "default": 120, "max": 135 } };
const spawnRules$e = { "weight": 4, "cluster": { "min": 1, "max": 6 }, "shapeHint": "scatter", "avoidNearTokens": true };
const bush = {
  id: id$31,
  label: label$2n,
  category: category$1O,
  tags: tags$2D,
  blocking: blocking$l,
  durability: durability$l,
  variants: variants$l,
  appearance: appearance$n,
  spawnRules: spawnRules$e
};
const id$30 = "log";
const label$2m = "Tronc";
const category$1N = "prop";
const tags$2C = ["log", "wood", "prop"];
const blocking$k = { "movement": true, "vision": false, "attacks": false };
const durability$k = { "destructible": true, "maxHp": 10, "ac": 11 };
const variants$k = [{ "id": "base", "label": "Tronc", "footprint": [{ "x": 0, "y": 0 }, { "x": 1, "y": 0 }, { "x": 2, "y": 0 }, { "x": 3, "y": 0 }, { "x": 4, "y": 0 }], "rotatable": true }];
const appearance$m = { "randomRotation": true, "spriteKey": "obstacle:log", "spriteGrid": { "tilesX": 5, "tilesY": 1 }, "heightClass": "low" };
const spawnRules$d = { "weight": 2, "cluster": { "min": 1, "max": 3 }, "shapeHint": "scatter", "avoidNearTokens": true };
const log = {
  id: id$30,
  label: label$2m,
  category: category$1N,
  tags: tags$2C,
  blocking: blocking$k,
  durability: durability$k,
  variants: variants$k,
  appearance: appearance$m,
  spawnRules: spawnRules$d
};
const id$2$ = "rock";
const label$2l = "Roche";
const category$1M = "structure";
const tags$2B = ["rock", "stone", "structure"];
const blocking$j = { "movement": true, "vision": true, "attacks": true };
const durability$j = { "destructible": true, "maxHp": 18, "ac": 13 };
const variants$j = [{ "id": "base", "label": "Roche", "footprint": [{ "x": 0, "y": 0 }], "rotatable": true }];
const appearance$l = { "randomRotation": true, "spriteKey": "obstacle:rock", "tokenScale": { "min": 80, "default": 100, "max": 150 } };
const spawnRules$c = { "weight": 3, "cluster": { "min": 1, "max": 3 }, "shapeHint": "scatter", "avoidNearTokens": true };
const rock = {
  id: id$2$,
  label: label$2l,
  category: category$1M,
  tags: tags$2B,
  blocking: blocking$j,
  durability: durability$j,
  variants: variants$j,
  appearance: appearance$l,
  spawnRules: spawnRules$c
};
const id$2_ = "rubble";
const label$2k = "Gravats";
const category$1L = "prop";
const tags$2A = ["rubble", "stone", "prop"];
const blocking$i = { "movement": true, "vision": false, "attacks": false };
const durability$i = { "destructible": true, "maxHp": 8, "ac": 11 };
const variants$i = [{ "id": "base", "label": "Gravats", "footprint": [{ "x": 0, "y": 0 }], "rotatable": true }];
const appearance$k = { "randomRotation": true, "spriteKey": "obstacle:rubble", "heightClass": "low", "tokenScale": { "min": 80, "default": 100, "max": 150 } };
const spawnRules$b = { "weight": 2, "cluster": { "min": 1, "max": 4 }, "shapeHint": "scatter", "avoidNearTokens": true };
const rubble = {
  id: id$2_,
  label: label$2k,
  category: category$1L,
  tags: tags$2A,
  blocking: blocking$i,
  durability: durability$i,
  variants: variants$i,
  appearance: appearance$k,
  spawnRules: spawnRules$b
};
const id$2Z = "stalagmite";
const label$2j = "Stalagmite";
const category$1K = "structure";
const tags$2z = ["stalagmite", "cave", "stone", "structure"];
const blocking$h = { "movement": true, "vision": true, "attacks": true };
const durability$h = { "destructible": true, "maxHp": 16, "ac": 13 };
const variants$h = [{ "id": "base", "label": "Stalagmite", "footprint": [{ "x": 0, "y": 0 }], "rotatable": true }];
const appearance$j = { "randomRotation": true, "spriteKey": "obstacle:stalagmite", "heightClass": "tall", "tokenScale": { "min": 80, "default": 100, "max": 150 } };
const spawnRules$a = { "weight": 2, "cluster": { "min": 1, "max": 4 }, "shapeHint": "scatter", "avoidNearTokens": true };
const stalagmite = {
  id: id$2Z,
  label: label$2j,
  category: category$1K,
  tags: tags$2z,
  blocking: blocking$h,
  durability: durability$h,
  variants: variants$h,
  appearance: appearance$j,
  spawnRules: spawnRules$a
};
const id$2Y = "barrel-wood";
const label$2i = "Tonneau";
const category$1J = "prop";
const tags$2y = ["barrel", "wood", "prop"];
const blocking$g = { "movement": true, "vision": false, "attacks": false };
const durability$g = { "destructible": true, "maxHp": 8, "ac": 10 };
const variants$g = [{ "id": "base", "label": "Tonneau", "footprint": [{ "x": 0, "y": 0 }], "rotatable": true }];
const appearance$i = { "spriteKey": "obstacle:barrel-wood", "tokenScale": { "min": 40, "default": 50, "max": 55 } };
const spawnRules$9 = { "weight": 1, "cluster": { "min": 1, "max": 3 }, "shapeHint": "scatter", "avoidNearTokens": true };
const barrelWood = {
  id: id$2Y,
  label: label$2i,
  category: category$1J,
  tags: tags$2y,
  blocking: blocking$g,
  durability: durability$g,
  variants: variants$g,
  appearance: appearance$i,
  spawnRules: spawnRules$9
};
const id$2X = "crate-wood";
const label$2h = "Caisse";
const category$1I = "prop";
const tags$2x = ["crate", "wood", "prop"];
const blocking$f = { "movement": true, "vision": false, "attacks": false };
const durability$f = { "destructible": true, "maxHp": 6, "ac": 10 };
const variants$f = [{ "id": "base", "label": "Caisse", "footprint": [{ "x": 0, "y": 0 }], "rotatable": true }];
const appearance$h = { "spriteKey": "obstacle:crate-wood", "tokenScale": { "min": 80, "default": 100, "max": 150 } };
const spawnRules$8 = { "weight": 3, "cluster": { "min": 1, "max": 4 }, "shapeHint": "scatter", "avoidNearTokens": true };
const crateWood = {
  id: id$2X,
  label: label$2h,
  category: category$1I,
  tags: tags$2x,
  blocking: blocking$f,
  durability: durability$f,
  variants: variants$f,
  appearance: appearance$h,
  spawnRules: spawnRules$8
};
const id$2W = "table-wood";
const label$2g = "Table";
const category$1H = "prop";
const tags$2w = ["table", "wood", "prop"];
const blocking$e = { "movement": true, "vision": false, "attacks": false };
const durability$e = { "destructible": true, "maxHp": 10, "ac": 11 };
const variants$e = [{ "id": "base", "label": "Table", "footprint": [{ "x": 0, "y": 0 }, { "x": 0, "y": 1 }], "rotatable": true }];
const appearance$g = { "spriteKey": "obstacle:table-wood", "heightClass": "medium", "shadowStretch": 1.2 };
const spawnRules$7 = { "weight": 2, "cluster": { "min": 1, "max": 3 }, "shapeHint": "room", "avoidNearTokens": true };
const tableWood = {
  id: id$2W,
  label: label$2g,
  category: category$1H,
  tags: tags$2w,
  blocking: blocking$e,
  durability: durability$e,
  variants: variants$e,
  appearance: appearance$g,
  spawnRules: spawnRules$7
};
const id$2V = "chair-wood";
const label$2f = "Chaise";
const category$1G = "prop";
const tags$2v = ["chair", "wood", "prop"];
const blocking$d = { "movement": true, "vision": false, "attacks": false };
const durability$d = { "destructible": true, "maxHp": 4, "ac": 10 };
const variants$d = [{ "id": "base", "label": "Chaise", "footprint": [{ "x": 0, "y": 0 }], "rotatable": true }];
const appearance$f = { "spriteKey": "obstacle:chair-wood", "heightClass": "low" };
const spawnRules$6 = { "weight": 2, "cluster": { "min": 1, "max": 4 }, "shapeHint": "room", "avoidNearTokens": true };
const chairWood = {
  id: id$2V,
  label: label$2f,
  category: category$1G,
  tags: tags$2v,
  blocking: blocking$d,
  durability: durability$d,
  variants: variants$d,
  appearance: appearance$f,
  spawnRules: spawnRules$6
};
const id$2U = "statue-stone";
const label$2e = "Statue de pierre";
const category$1F = "prop";
const tags$2u = ["statue", "stone", "prop"];
const blocking$c = { "movement": true, "vision": true, "attacks": true };
const durability$c = { "destructible": true, "maxHp": 20, "ac": 14 };
const variants$c = [{ "id": "base", "label": "Statue", "footprint": [{ "x": 0, "y": 0 }], "rotatable": true }];
const appearance$e = { "spriteKey": "obstacle:statue-stone", "heightClass": "tall", "tokenScale": { "min": 80, "default": 100, "max": 150 } };
const spawnRules$5 = { "weight": 1, "cluster": { "min": 1, "max": 2 }, "shapeHint": "room", "avoidNearTokens": true };
const statueStone = {
  id: id$2U,
  label: label$2e,
  category: category$1F,
  tags: tags$2u,
  blocking: blocking$c,
  durability: durability$c,
  variants: variants$c,
  appearance: appearance$e,
  spawnRules: spawnRules$5
};
const id$2T = "torch-wall";
const label$2d = "Torche murale";
const category$1E = "structure";
const tags$2t = ["torch", "fire", "structure"];
const blocking$b = { "movement": false, "vision": false, "attacks": false };
const durability$b = { "destructible": true, "maxHp": 3, "ac": 10 };
const variants$b = [{ "id": "base", "label": "Torche", "footprint": [{ "x": 0, "y": 0 }], "rotatable": true }];
const appearance$d = { "layers": [{ "id": "flame", "spriteKey": "effect:fire", "animationSpeed": 0.2, "scale": 0.55 }], "heightClass": "low", "tokenScale": { "min": 80, "default": 100, "max": 150 } };
const spawnRules$4 = { "weight": 1, "cluster": { "min": 1, "max": 4 }, "shapeHint": "line", "avoidNearTokens": false };
const torchWall = {
  id: id$2T,
  label: label$2d,
  category: category$1E,
  tags: tags$2t,
  blocking: blocking$b,
  durability: durability$b,
  variants: variants$b,
  appearance: appearance$d,
  spawnRules: spawnRules$4
};
const id$2S = "brazier";
const label$2c = "Brasero";
const category$1D = "prop";
const tags$2s = ["brazier", "fire", "prop"];
const blocking$a = { "movement": true, "vision": false, "attacks": false };
const durability$a = { "destructible": true, "maxHp": 6, "ac": 10 };
const variants$a = [{ "id": "base", "label": "Brasero", "footprint": [{ "x": 0, "y": 0 }], "rotatable": true }];
const appearance$c = { "layers": [{ "id": "base", "spriteKey": "obstacle:brazier" }, { "id": "flame", "spriteKey": "effect:fire", "animationSpeed": 0.2, "scale": 0.8 }], "tokenScale": { "default": 80 } };
const litByDefault = true;
const interactions = [{ "id": "brazier-light", "label": "Allumer", "kind": "toggle", "cost": "bonus", "setLit": true }, { "id": "brazier-extinguish", "label": "Eteindre", "kind": "toggle", "cost": "bonus", "setLit": false }];
const spawnRules$3 = { "weight": 1, "cluster": { "min": 1, "max": 2 }, "shapeHint": "room", "avoidNearTokens": true };
const brazier = {
  id: id$2S,
  label: label$2c,
  category: category$1D,
  tags: tags$2s,
  blocking: blocking$a,
  durability: durability$a,
  variants: variants$a,
  appearance: appearance$c,
  litByDefault,
  interactions,
  spawnRules: spawnRules$3
};
const id$2R = "fire-only";
const label$2b = "Feu (test)";
const category$1C = "effect";
const tags$2r = ["fire", "effect"];
const blocking$9 = { "movement": false, "vision": false, "attacks": false };
const durability$9 = { "destructible": false, "maxHp": 1 };
const variants$9 = [{ "id": "base", "label": "Feu", "footprint": [{ "x": 0, "y": 0 }], "rotatable": false }];
const appearance$b = { "layers": [{ "id": "flame", "spriteKey": "effect:fire", "animationSpeed": 0.2, "scale": 0.9 }], "heightClass": "low" };
const fireOnly = {
  id: id$2R,
  label: label$2b,
  category: category$1C,
  tags: tags$2r,
  blocking: blocking$9,
  durability: durability$9,
  variants: variants$9,
  appearance: appearance$b
};
const id$2Q = "pillar-stone";
const label$2a = "Pilier de pierre";
const category$1B = "structure";
const tags$2q = ["pillar", "stone", "structure"];
const blocking$8 = { "movement": true, "vision": true, "attacks": true };
const durability$8 = { "destructible": true, "maxHp": 28, "ac": 14 };
const variants$8 = [{ "id": "base", "label": "Pilier", "footprint": [{ "x": 0, "y": 0 }], "rotatable": true }];
const appearance$a = { "spriteKey": "obstacle:pillar-stone", "heightClass": "tall", "tokenScale": { "min": 80, "default": 100, "max": 150 } };
const spawnRules$2 = { "weight": 2, "cluster": { "min": 1, "max": 2 }, "shapeHint": "scatter", "avoidNearTokens": true };
const pillarStone = {
  id: id$2Q,
  label: label$2a,
  category: category$1B,
  tags: tags$2q,
  blocking: blocking$8,
  durability: durability$8,
  variants: variants$8,
  appearance: appearance$a,
  spawnRules: spawnRules$2
};
const id$2P = "stairs-stone";
const label$29 = "Escalier";
const category$1A = "structure";
const tags$2p = ["stairs", "connector"];
const blocking$7 = { "movement": false, "vision": false, "attacks": false };
const durability$7 = { "destructible": false, "maxHp": 1 };
const variants$7 = [{ "id": "base", "label": "Base", "footprint": [{ "x": 0, "y": 0 }], "rotatable": true }];
const appearance$9 = { "heightClass": "low" };
const spawnRules$1 = { "weight": 0, "cluster": { "min": 1, "max": 1 }, "avoidNearTokens": false };
const connects = { "from": 0, "to": 1 };
const stairsStone = {
  id: id$2P,
  label: label$29,
  category: category$1A,
  tags: tags$2p,
  blocking: blocking$7,
  durability: durability$7,
  variants: variants$7,
  appearance: appearance$9,
  spawnRules: spawnRules$1,
  connects
};
const id$2O = "charette-wood";
const label$28 = "Charette";
const category$1z = "prop";
const tags$2o = ["prop"];
const blocking$6 = { "movement": true, "vision": false, "attacks": false };
const durability$6 = { "destructible": true, "maxHp": 18, "ac": 10 };
const variants$6 = [{ "id": "base", "label": "Base", "footprint": [{ "x": -1, "y": -1 }, { "x": 0, "y": -1 }, { "x": -1, "y": 0 }, { "x": 0, "y": 0 }, { "x": -1, "y": 1 }, { "x": 0, "y": 1 }], "rotatable": true }];
const appearance$8 = { "spriteKey": "obstacle:charette-wood", "tint": 13395558, "heightClass": "medium", "shadowStretch": 1.4, "spriteGrid": { "tilesX": 2, "tilesY": 3 }, "tokenScale": { "min": 90, "default": 110, "max": 140 } };
const spawnRules = { "weight": 1, "cluster": { "min": 1, "max": 1 }, "avoidNearTokens": true };
const charetteWood = {
  id: id$2O,
  label: label$28,
  category: category$1z,
  tags: tags$2o,
  blocking: blocking$6,
  durability: durability$6,
  variants: variants$6,
  appearance: appearance$8,
  spawnRules
};
const OBSTACLE_TYPE_MODULES = {
  "./fence-wood.json": fenceWood,
  "./tree-oak.json": treeOak,
  "./bush.json": bush,
  "./log.json": log,
  "./rock.json": rock,
  "./rubble.json": rubble,
  "./stalagmite.json": stalagmite,
  "./barrel-wood.json": barrelWood,
  "./crate-wood.json": crateWood,
  "./table-wood.json": tableWood,
  "./chair-wood.json": chairWood,
  "./statue-stone.json": statueStone,
  "./torch-wall.json": torchWall,
  "./brazier.json": brazier,
  "./fire-only.json": fireOnly,
  "./pillar-stone.json": pillarStone,
  "./stairs-stone.json": stairsStone,
  "./charette-wood.json": charetteWood
};
function loadObstacleTypesFromIndex() {
  const indexed = Array.isArray(obstaclesIndex.types) ? obstaclesIndex.types : [];
  const loaded = [];
  for (const path2 of indexed) {
    const mod = OBSTACLE_TYPE_MODULES[path2];
    if (mod) {
      loaded.push(mod);
    } else {
      console.warn("[obstacle-types] Type path missing in bundle:", path2);
    }
  }
  if (loaded.length === 0) {
    console.warn("[obstacle-types] No obstacle types loaded from index.json");
  }
  return loaded;
}
const types$b = ["./fire.json", "./melee-slash.json"];
const effectsIndex = {
  types: types$b
};
const id$2N = "fire";
const label$27 = "Feu";
const tags$2n = ["fire", "hazard"];
const appearance$7 = { "spriteKey": "effect:fire", "animationSpeed": 0.2, "animationLoop": true, "scaleRange": { "min": 0.8, "max": 1.15 }, "tintRange": { "dark": 16742912, "light": 16768256 }, "alphaRange": { "min": 0.85, "max": 1 } };
const placement = { "blockedFloorTags": ["liquid"], "avoidLiquid": true };
const hazard = { "damageFormula": "1d4", "statusRoll": { "die": 20, "trigger": 1, "statusId": "burning" }, "onTraverse": true };
const light = { "radius": 3, "color": 16756045 };
const fire = {
  id: id$2N,
  label: label$27,
  tags: tags$2n,
  appearance: appearance$7,
  placement,
  hazard,
  light
};
const id$2M = "melee-slash";
const label$26 = "Entaille";
const tags$2m = ["attack", "melee"];
const appearance$6 = { "spriteKey": "effect:sword", "animationSpeed": 0.32, "animationLoop": false, "targetSize": 128, "scale": 1, "alpha": 1 };
const durationMs = 420;
const meleeSlash = {
  id: id$2M,
  label: label$26,
  tags: tags$2m,
  appearance: appearance$6,
  durationMs
};
const EFFECT_TYPE_MODULES = {
  "./fire.json": fire,
  "./melee-slash.json": meleeSlash
};
function loadEffectTypesFromIndex() {
  const indexed = Array.isArray(effectsIndex.types) ? effectsIndex.types : [];
  const loaded = [];
  for (const path2 of indexed) {
    const mod = EFFECT_TYPE_MODULES[path2];
    if (mod) {
      loaded.push(mod);
    } else {
      console.warn("[effect-types] Type path missing in bundle:", path2);
    }
  }
  if (loaded.length === 0) {
    console.warn("[effect-types] No effect types loaded from index.json");
  }
  return loaded;
}
const types$a = ["./burning.json", "./frightened.json", "./incapacitated.json", "./killer-mark.json", "./prone.json"];
const statusIndex = {
  types: types$a
};
const id$2L = "burning";
const label$25 = "En feu";
const durationTurns$4 = 3;
const damagePerTurnFormula = "1d4";
const burning = {
  id: id$2L,
  label: label$25,
  durationTurns: durationTurns$4,
  damagePerTurnFormula
};
const id$2K = "FRIGHTENED";
const label$24 = "Effraye";
const durationTurns$3 = 10;
const frightened = {
  id: id$2K,
  label: label$24,
  durationTurns: durationTurns$3
};
const id$2J = "INCAPACITATED";
const label$23 = "Incapable d'agir";
const durationTurns$2 = 10;
const incapacitated = {
  id: id$2J,
  label: label$23,
  durationTurns: durationTurns$2
};
const id$2I = "killer-mark";
const label$22 = "Marque du tueur";
const durationTurns$1 = 9999;
const persistUntilDeath = true;
const killerMark = {
  id: id$2I,
  label: label$22,
  durationTurns: durationTurns$1,
  persistUntilDeath
};
const id$2H = "prone";
const label$21 = "A terre";
const durationTurns = 1;
const prone = {
  id: id$2H,
  label: label$21,
  durationTurns
};
const STATUS_TYPE_MODULES = {
  "./burning.json": burning,
  "./frightened.json": frightened,
  "./incapacitated.json": incapacitated,
  "./killer-mark.json": killerMark,
  "./prone.json": prone
};
function loadStatusTypesFromIndex() {
  const indexed = Array.isArray(statusIndex.types) ? statusIndex.types : [];
  const loaded = [];
  for (const path2 of indexed) {
    const mod = STATUS_TYPE_MODULES[path2];
    if (mod) {
      loaded.push(mod);
    } else {
      console.warn("[passifs] Type path missing in bundle:", path2);
    }
  }
  if (loaded.length === 0) {
    console.warn("[passifs] No status types loaded from index.json");
  }
  return loaded;
}
const id$2G = "balm-of-peace";
const label$20 = "Balm of Peace";
const summary$1c = "Move without opportunity attacks and heal allies you pass.";
const kind$y = "action";
const tags$2l = ["cleric", "domain", "peace", "channel-divinity"];
const grants$I = [{ "kind": "action", "ids": ["balm-of-peace"], "source": "balm-of-peace" }];
const rules$y = { "text": "Action. Uses Channel Divinity. You move, healing allies you pass." };
const __vite_glob_0_0$4 = {
  id: id$2G,
  label: label$20,
  summary: summary$1c,
  kind: kind$y,
  tags: tags$2l,
  grants: grants$I,
  rules: rules$y
};
const id$2F = "channel-divinity";
const label$1$ = "Conduit divin";
const summary$1b = "Canalisez l'energie divine un nombre limite de fois par repos.";
const kind$x = "resource";
const tags$2k = ["cleric", "resource"];
const grants$H = [{ "kind": "resource", "ids": ["channel-divinity"], "source": "channel-divinity", "meta": { "maxByLevel": { "2": 2, "6": 3, "18": 4 }, "scale": { "basis": "class", "classId": "cleric" }, "recharge": "short_rest" } }];
const rules$x = { "text": "Vous recupererez 1 usage au repos court et tous les usages au repos long." };
const __vite_glob_0_1$2 = {
  id: id$2F,
  label: label$1$,
  summary: summary$1b,
  kind: kind$x,
  tags: tags$2k,
  grants: grants$H,
  rules: rules$x
};
const id$2E = "divine-intervention";
const label$1_ = "Divine Intervention";
const summary$1a = "Call on your deity for aid once per rest.";
const kind$w = "feature";
const tags$2j = ["cleric"];
const grants$G = [];
const rules$w = { "text": "At higher levels, intervention succeeds automatically." };
const __vite_glob_0_2$3 = {
  id: id$2E,
  label: label$1_,
  summary: summary$1a,
  kind: kind$w,
  tags: tags$2j,
  grants: grants$G,
  rules: rules$w
};
const id$2D = "divine-order";
const label$1Z = "Ordre divin";
const summary$19 = "Vous vous consacrez a un role sacre: Protecteur ou Thaumaturge.";
const kind$v = "feature";
const tags$2i = ["cleric"];
const grants$F = [];
const rules$v = { "text": "Protecteur: maitrise des armes martiales et armures lourdes. Thaumaturge: un sort mineur de clerc supplementaire et bonus aux jets d'Intelligence (Arcanes/Religion) egal au modificateur de Sagesse (minimum +1)." };
const __vite_glob_0_3$3 = {
  id: id$2D,
  label: label$1Z,
  summary: summary$19,
  kind: kind$v,
  tags: tags$2i,
  grants: grants$F,
  rules: rules$v
};
const id$2C = "divine-spark";
const label$1Y = "Etincelle divine";
const summary$18 = "Effet de Conduit divin: soin ou degats necrotiques/radiants.";
const kind$u = "action";
const tags$2h = ["cleric", "channel-divinity"];
const grants$E = [{ "kind": "action", "ids": ["divine-spark-heal", "divine-spark-radiant", "divine-spark-necrotic"], "source": "divine-spark" }];
const rules$u = { "text": "Action Magie, portee 9 m. Soin de la cible (heal) ou jet de Constitution pour moitie des degats (radiant/necrotique) en cas de reussite. Les degats/soins evoluent avec le niveau de clerc." };
const __vite_glob_0_4$2 = {
  id: id$2C,
  label: label$1Y,
  summary: summary$18,
  kind: kind$u,
  tags: tags$2h,
  grants: grants$E,
  rules: rules$u
};
const id$2B = "expansive-bond";
const label$1X = "Expansive Bond";
const summary$17 = "Linked allies share damage and gain broad resistance.";
const kind$t = "passive";
const tags$2g = ["cleric", "domain", "peace"];
const grants$D = [];
const rules$t = { "text": "Linked allies gain broad resistance and improved damage sharing." };
const __vite_glob_0_5$1 = {
  id: id$2B,
  label: label$1X,
  summary: summary$17,
  kind: kind$t,
  tags: tags$2g,
  grants: grants$D,
  rules: rules$t
};
const id$2A = "peace-bond";
const label$1W = "Peace Bond";
const summary$16 = "Link allies to share support bonuses.";
const kind$s = "passive";
const tags$2f = ["cleric", "domain", "peace"];
const grants$C = [];
const rules$s = { "text": "Linked allies gain +1d4 once per turn to an attack, check, or save. No concentration.", "triggers": [{ "event": "on_roll", "notes": "Applies once per turn to linked allies within range." }] };
const __vite_glob_0_6$1 = {
  id: id$2A,
  label: label$1W,
  summary: summary$16,
  kind: kind$s,
  tags: tags$2f,
  grants: grants$C,
  rules: rules$s
};
const id$2z = "protective-bond";
const label$1V = "Protective Bond";
const summary$15 = "Linked ally can teleport and take damage for another ally.";
const kind$r = "reaction";
const tags$2e = ["cleric", "domain", "peace"];
const grants$B = [{ "kind": "reaction", "ids": ["protective-bond"], "source": "protective-bond" }];
const rules$r = { "text": "Reaction when a linked ally takes damage. Teleport and take damage instead." };
const __vite_glob_0_7$1 = {
  id: id$2z,
  label: label$1V,
  summary: summary$15,
  kind: kind$r,
  tags: tags$2e,
  grants: grants$B,
  rules: rules$r
};
const id$2y = "turn-undead";
const label$1U = "Renvoi des morts-vivants";
const summary$14 = "Effet de Conduit divin qui repousse les morts-vivants.";
const kind$q = "action";
const tags$2d = ["cleric", "channel-divinity"];
const grants$A = [{ "kind": "action", "ids": ["turn-undead"], "source": "turn-undead" }];
const rules$q = { "text": "Action Magie. Les morts-vivants dans 9 m font un JS Sagesse, sinon ils sont Effrayes et Incapables d'agir pendant 1 minute.", "triggers": [{ "event": "on_action", "notes": "Uses Channel Divinity resource." }] };
const __vite_glob_0_8$1 = {
  id: id$2y,
  label: label$1U,
  summary: summary$14,
  kind: kind$q,
  tags: tags$2d,
  grants: grants$A,
  rules: rules$q
};
const id$2x = "action-surge-2";
const label$1T = "Fougue (2)";
const summary$13 = "Deux utilisations de Fougue entre repos.";
const kind$p = "feature";
const tags$2c = ["fighter"];
const grants$z = [];
const rules$p = { "text": "A partir du niveau 17 de Guerrier, Fougue peut etre utilisee deux fois entre repos." };
const __vite_glob_0_9$1 = {
  id: id$2x,
  label: label$1T,
  summary: summary$13,
  kind: kind$p,
  tags: tags$2c,
  grants: grants$z,
  rules: rules$p
};
const id$2w = "action-surge";
const label$1S = "Fougue";
const summary$12 = "Action supplementaire lors du tour.";
const kind$o = "resource";
const tags$2b = ["fighter", "resource"];
const grants$y = [{ "kind": "action", "ids": ["action-surge"], "source": "action-surge" }, { "kind": "resource", "ids": ["action-surge"], "source": "action-surge", "meta": { "maxByLevel": { "2": 1, "17": 2 }, "scale": { "basis": "class", "classId": "fighter" }, "recharge": "short_rest" } }];
const rules$o = { "text": "Permet de prendre une action supplementaire (hors action Magie selon les regles retenues)." };
const __vite_glob_0_10 = {
  id: id$2w,
  label: label$1S,
  summary: summary$12,
  kind: kind$o,
  tags: tags$2b,
  grants: grants$y,
  rules: rules$o
};
const id$2v = "arcane-charge";
const label$1R = "Charge arcanique";
const summary$11 = "Teleportation breve lors de l'utilisation de Fougue.";
const kind$n = "feature";
const tags$2a = ["fighter", "eldritch-knight", "movement"];
const grants$x = [];
const rules$n = { "text": "Quand vous utilisez Fougue, vous pouvez vous teleporter sur une courte distance." };
const __vite_glob_0_11 = {
  id: id$2v,
  label: label$1R,
  summary: summary$11,
  kind: kind$n,
  tags: tags$2a,
  grants: grants$x,
  rules: rules$n
};
const id$2u = "eldritch-knight-spellcasting";
const label$1Q = "Magie de Chevalier Occulte";
const summary$10 = "Acces a la magie de magicien avec progression tierce.";
const kind$m = "feature";
const tags$29 = ["fighter", "eldritch-knight", "spellcasting"];
const grants$w = [];
const rules$m = { "text": "La magie utilise INT et suit les regles de lanceur tiers du Chevalier Occulte." };
const __vite_glob_0_12 = {
  id: id$2u,
  label: label$1Q,
  summary: summary$10,
  kind: kind$m,
  tags: tags$29,
  grants: grants$w,
  rules: rules$m
};
const id$2t = "eldritch-strike";
const label$1P = "Frappe eldritch";
const summary$$ = "Desavantage au prochain JS contre votre sort.";
const kind$l = "feature";
const tags$28 = ["fighter", "eldritch-knight"];
const grants$v = [];
const rules$l = { "text": "Une creature touchee au corps a corps subit un desavantage au prochain jet de sauvegarde contre un sort que vous lancez." };
const __vite_glob_0_13 = {
  id: id$2t,
  label: label$1P,
  summary: summary$$,
  kind: kind$l,
  tags: tags$28,
  grants: grants$v,
  rules: rules$l
};
const id$2s = "extra-attack-2";
const label$1O = "Attaque supplementaire (2)";
const summary$_ = "Trois attaques lors de l'action Attaque.";
const kind$k = "feature";
const tags$27 = ["fighter", "martial"];
const grants$u = [];
const rules$k = { "text": "Vous pouvez attaquer trois fois lorsque vous prenez l'action Attaque." };
const __vite_glob_0_14 = {
  id: id$2s,
  label: label$1O,
  summary: summary$_,
  kind: kind$k,
  tags: tags$27,
  grants: grants$u,
  rules: rules$k
};
const id$2r = "extra-attack-3";
const label$1N = "Attaque supplementaire (3)";
const summary$Z = "Quatre attaques lors de l'action Attaque.";
const kind$j = "feature";
const tags$26 = ["fighter", "martial"];
const grants$t = [];
const rules$j = { "text": "Au niveau 20 de Guerrier, vous pouvez attaquer quatre fois avec l'action Attaque." };
const __vite_glob_0_15 = {
  id: id$2r,
  label: label$1N,
  summary: summary$Z,
  kind: kind$j,
  tags: tags$26,
  grants: grants$t,
  rules: rules$j
};
const id$2q = "extra-attack";
const label$1M = "Attaque supplementaire";
const summary$Y = "Deux attaques lors de l'action Attaque.";
const kind$i = "feature";
const tags$25 = ["fighter", "martial"];
const grants$s = [];
const rules$i = { "text": "Vous pouvez attaquer deux fois lorsque vous prenez l'action Attaque." };
const __vite_glob_0_16 = {
  id: id$2q,
  label: label$1M,
  summary: summary$Y,
  kind: kind$i,
  tags: tags$25,
  grants: grants$s,
  rules: rules$i
};
const id$2p = "improved-war-magic";
const label$1L = "Maitre de la magie de guerre";
const summary$X = "Apres un sort, attaque d'arme en action bonus.";
const kind$h = "feature";
const tags$24 = ["fighter", "eldritch-knight"];
const grants$r = [];
const rules$h = { "text": "Apres avoir lance un sort, vous pouvez effectuer une attaque d'arme en action bonus." };
const __vite_glob_0_17 = {
  id: id$2p,
  label: label$1L,
  summary: summary$X,
  kind: kind$h,
  tags: tags$24,
  grants: grants$r,
  rules: rules$h
};
const id$2o = "indomitable-2";
const label$1K = "Inflexible (2)";
const summary$W = "Deux utilisations d'Inflexible entre repos longs.";
const kind$g = "feature";
const tags$23 = ["fighter"];
const grants$q = [];
const rules$g = { "text": "A partir du niveau 13 de Guerrier, Inflexible offre 2 utilisations." };
const __vite_glob_0_18 = {
  id: id$2o,
  label: label$1K,
  summary: summary$W,
  kind: kind$g,
  tags: tags$23,
  grants: grants$q,
  rules: rules$g
};
const id$2n = "indomitable-3";
const label$1J = "Inflexible (3)";
const summary$V = "Trois utilisations d'Inflexible entre repos longs.";
const kind$f = "feature";
const tags$22 = ["fighter"];
const grants$p = [];
const rules$f = { "text": "A partir du niveau 17 de Guerrier, Inflexible offre 3 utilisations." };
const __vite_glob_0_19 = {
  id: id$2n,
  label: label$1J,
  summary: summary$V,
  kind: kind$f,
  tags: tags$22,
  grants: grants$p,
  rules: rules$f
};
const id$2m = "indomitable";
const label$1I = "Inflexible";
const summary$U = "Relance d'un jet de sauvegarde rate.";
const kind$e = "resource";
const tags$21 = ["fighter", "resource"];
const grants$o = [{ "kind": "action", "ids": ["indomitable"], "source": "indomitable" }, { "kind": "resource", "ids": ["indomitable"], "source": "indomitable", "meta": { "maxByLevel": { "9": 1, "13": 2, "17": 3 }, "scale": { "basis": "class", "classId": "fighter" }, "recharge": "long_rest" } }];
const rules$e = { "text": "Permet de relancer un jet de sauvegarde rate avec bonus de niveau de Guerrier." };
const __vite_glob_0_20 = {
  id: id$2m,
  label: label$1I,
  summary: summary$U,
  kind: kind$e,
  tags: tags$21,
  grants: grants$o,
  rules: rules$e
};
const id$2l = "second-wind-feature";
const label$1H = "Second souffle";
const summary$T = "Reserve de recuperation physique et mentale.";
const kind$d = "resource";
const tags$20 = ["fighter", "resource"];
const grants$n = [{ "kind": "resource", "ids": ["second-wind"], "source": "second-wind-feature", "meta": { "maxByLevel": { "1": 2, "4": 3, "10": 4 }, "scale": { "basis": "class", "classId": "fighter" }, "recharge": "short_rest" } }];
const rules$d = { "text": "Utilisable en action bonus pour recuperer des PV. Recuperation partielle au repos court et complete au repos long." };
const __vite_glob_0_21 = {
  id: id$2l,
  label: label$1H,
  summary: summary$T,
  kind: kind$d,
  tags: tags$20,
  grants: grants$n,
  rules: rules$d
};
const id$2k = "tactical-mastery";
const label$1G = "Botte tactique";
const summary$S = "Flexibilite de bottes lors d'une attaque.";
const kind$c = "feature";
const tags$1$ = ["fighter", "martial"];
const grants$m = [];
const rules$c = { "text": "Lors d'une attaque avec arme maitrisee, une botte peut etre remplacee par Poussee, Sape ou Ralentissement." };
const __vite_glob_0_22 = {
  id: id$2k,
  label: label$1G,
  summary: summary$S,
  kind: kind$c,
  tags: tags$1$,
  grants: grants$m,
  rules: rules$c
};
const id$2j = "tactical-mind";
const label$1F = "Sens tactique";
const summary$R = "Renforce les jets de caracteristique en depensant un usage de Second souffle.";
const kind$b = "feature";
const tags$1_ = ["fighter"];
const grants$l = [];
const rules$b = { "text": "En cas d'echec a un jet de caracteristique, depensez Second souffle pour ajouter 1d10." };
const __vite_glob_0_23 = {
  id: id$2j,
  label: label$1F,
  summary: summary$R,
  kind: kind$b,
  tags: tags$1_,
  grants: grants$l,
  rules: rules$b
};
const id$2i = "tactical-shift";
const label$1E = "Decalage tactique";
const summary$Q = "Mobilite bonus lors de l'activation de Second souffle.";
const kind$a = "feature";
const tags$1Z = ["fighter", "movement"];
const grants$k = [];
const rules$a = { "text": "Lors de l'activation de Second souffle, deplacement jusqu'a la moitie de la vitesse sans opportunite." };
const __vite_glob_0_24 = {
  id: id$2i,
  label: label$1E,
  summary: summary$Q,
  kind: kind$a,
  tags: tags$1Z,
  grants: grants$k,
  rules: rules$a
};
const id$2h = "war-magic";
const label$1D = "Magie de guerre";
const summary$P = "Apres un cantrip, attaque d'arme en action bonus.";
const kind$9 = "feature";
const tags$1Y = ["fighter", "eldritch-knight"];
const grants$j = [];
const rules$9 = { "text": "Apres avoir lance un sort mineur, vous pouvez effectuer une attaque d'arme en action bonus." };
const __vite_glob_0_25 = {
  id: id$2h,
  label: label$1D,
  summary: summary$P,
  kind: kind$9,
  tags: tags$1Y,
  grants: grants$j,
  rules: rules$9
};
const id$2g = "weapon-mastery";
const label$1C = "Bottes d arme";
const summary$O = "Acces aux bottes d'armes selon les maitrises choisies.";
const kind$8 = "feature";
const tags$1X = ["fighter", "martial"];
const grants$i = [];
const rules$8 = { "text": "Choisissez trois bottes d'armes. Vous pouvez utiliser une botte quand l'arme utilisee porte aussi cette mastery.", "choices": [{ "key": "masteries", "title": "Bottes d'armes", "count": 3, "options": [{ "id": "coup-double", "label": "Coup double", "summary": "Permet une attaque legere supplementaire selon la regle de la mastery.", "grants": [{ "kind": "weaponMastery", "ids": ["coup-double"] }] }, { "id": "ecorchure", "label": "Ecorchure", "summary": "Ajoute l'effet Ecorchure sur les attaques eligibles.", "grants": [{ "kind": "weaponMastery", "ids": ["ecorchure"] }] }, { "id": "enchainement", "label": "Enchainement", "summary": "Permet un enchainement d'attaque sur les situations eligibles.", "grants": [{ "kind": "weaponMastery", "ids": ["enchainement"] }] }, { "id": "ouverture", "label": "Ouverture", "summary": "Expose la cible pour un suivi offensif.", "grants": [{ "kind": "weaponMastery", "ids": ["ouverture"] }] }, { "id": "poussee", "label": "Poussee", "summary": "Repousse la cible si les conditions sont reunies.", "grants": [{ "kind": "weaponMastery", "ids": ["poussee"] }] }, { "id": "ralentissement", "label": "Ralentissement", "summary": "Reduit la mobilite de la cible.", "grants": [{ "kind": "weaponMastery", "ids": ["ralentissement"] }] }, { "id": "renversement", "label": "Renversement", "summary": "Tente de renverser la cible sur une frappe eligibile.", "grants": [{ "kind": "weaponMastery", "ids": ["renversement"] }] }, { "id": "sape", "label": "Sape", "summary": "Affaiblit la defense de la cible.", "grants": [{ "kind": "weaponMastery", "ids": ["sape"] }] }] }] };
const __vite_glob_0_26 = {
  id: id$2g,
  label: label$1C,
  summary: summary$O,
  kind: kind$8,
  tags: tags$1X,
  grants: grants$i,
  rules: rules$8
};
const model$1 = "../models/feature-model.json";
const features = ["./cleric/divine-order.json", "./cleric/channel-divinity.json", "./cleric/divine-spark.json", "./cleric/turn-undead.json", "./cleric/divine-intervention.json", "./cleric/peace-bond.json", "./cleric/balm-of-peace.json", "./cleric/protective-bond.json", "./cleric/expansive-bond.json", "./shared/fighting-style.json", "./shared/fighting-style-archery.json", "./shared/fighting-style-defense.json", "./shared/fighting-style-dueling.json", "./shared/fighting-style-great-weapon-fighting.json", "./shared/fighting-style-interception.json", "./shared/fighting-style-protection.json", "./shared/fighting-style-two-weapon-fighting.json", "./fighter/second-wind-feature.json", "./fighter/weapon-mastery.json", "./fighter/action-surge.json", "./fighter/tactical-mind.json", "./fighter/extra-attack.json", "./fighter/tactical-shift.json", "./fighter/indomitable.json", "./fighter/tactical-mastery.json", "./fighter/extra-attack-2.json", "./fighter/indomitable-2.json", "./fighter/action-surge-2.json", "./fighter/indomitable-3.json", "./fighter/extra-attack-3.json", "./fighter/eldritch-knight-spellcasting.json", "./fighter/war-magic.json", "./fighter/eldritch-strike.json", "./fighter/arcane-charge.json", "./fighter/improved-war-magic.json"];
const featuresIndex = {
  model: model$1,
  features
};
const id$2f = "fighting-style-archery";
const label$1B = "Style de combat: Archerie";
const summary$N = "Vous gagnez un bonus de +2 aux jets d'attaque effectues avec des armes a distance.";
const kind$7 = "feature";
const tags$1W = ["fighting-style"];
const grants$h = [];
const rules$7 = { "text": "Tant que vous utilisez une arme a distance, vos jets d'attaque gagnent +2.", "modifiers": [{ "applyTo": "attack", "value": 2, "when": { "actionCategory": "attack", "weaponCategory": "distance" } }] };
const __vite_glob_0_28 = {
  id: id$2f,
  label: label$1B,
  summary: summary$N,
  kind: kind$7,
  tags: tags$1W,
  grants: grants$h,
  rules: rules$7
};
const id$2e = "fighting-style-defense";
const label$1A = "Style de combat: Defense";
const summary$M = "Vous gagnez +1 a la CA tant que vous portez une armure.";
const kind$6 = "feature";
const tags$1V = ["fighting-style"];
const grants$g = [];
const rules$6 = { "text": "Tant que vous portez une armure, votre classe d'armure augmente de 1.", "modifiers": [{ "applyTo": "combatStat", "stat": "armorClass", "value": 1, "when": { "requiresArmor": true } }] };
const __vite_glob_0_29 = {
  id: id$2e,
  label: label$1A,
  summary: summary$M,
  kind: kind$6,
  tags: tags$1V,
  grants: grants$g,
  rules: rules$6
};
const id$2d = "fighting-style-dueling";
const label$1z = "Style de combat: Duel";
const summary$L = "Vous gagnez +2 aux degats quand vous maniez une arme de melee a une main.";
const kind$5 = "feature";
const tags$1U = ["fighting-style"];
const grants$f = [];
const rules$5 = { "text": "Quand vous maniez une arme de melee a une main et aucune autre arme, vos degats gagnent +2.", "modifiers": [{ "applyTo": "damage", "value": 2, "when": { "actionCategory": "attack", "weaponCategories": ["melee", "polyvalent"], "weaponTwoHanded": false, "requiresNoOffhandWeapon": true } }] };
const __vite_glob_0_30 = {
  id: id$2d,
  label: label$1z,
  summary: summary$L,
  kind: kind$5,
  tags: tags$1U,
  grants: grants$f,
  rules: rules$5
};
const id$2c = "fighting-style-great-weapon-fighting";
const label$1y = "Style de combat: Combat a deux mains";
const summary$K = "Vous pouvez relancer certains des de degats d'arme a deux mains.";
const kind$4 = "feature";
const tags$1T = ["fighting-style"];
const grants$e = [];
const rules$4 = { "text": "Quand vous lancez les degats d'une arme maniee a deux mains, vous pouvez relancer les resultats 1 ou 2 selon la regle de style.", "modifiers": [{ "applyTo": "damageReroll", "value": 2, "when": { "actionCategory": "attack", "weaponCategories": ["melee", "polyvalent"], "weaponTwoHanded": true } }] };
const __vite_glob_0_31 = {
  id: id$2c,
  label: label$1y,
  summary: summary$K,
  kind: kind$4,
  tags: tags$1T,
  grants: grants$e,
  rules: rules$4
};
const id$2b = "fighting-style-interception";
const label$1x = "Style de combat: Interception";
const summary$J = "Vous pouvez reduire les degats infliges a un allie proche via une reaction.";
const kind$3 = "feature";
const tags$1S = ["fighting-style"];
const grants$d = [];
const rules$3 = { "text": "Quand une creature que vous voyez touche un allie proche, vous pouvez utiliser votre reaction pour reduire les degats.", "reactionModifiers": [{ "event": "incomingAttackHit", "mode": "reduceDamage", "formula": "1d10 + proficiencyBonus", "uiMessage": "Style Interception: degats reduits sur l'allie.", "when": { "actionCategory": "attack", "targetMustBeAlly": true, "targetMustNotBeSelf": true, "targetVisible": true, "maxDistanceToTarget": 1.5 } }] };
const __vite_glob_0_32 = {
  id: id$2b,
  label: label$1x,
  summary: summary$J,
  kind: kind$3,
  tags: tags$1S,
  grants: grants$d,
  rules: rules$3
};
const id$2a = "fighting-style-protection";
const label$1w = "Style de combat: Protection";
const summary$I = "Vous pouvez imposer un desavantage sur une attaque visant un allie proche.";
const kind$2 = "feature";
const tags$1R = ["fighting-style"];
const grants$c = [];
const rules$2 = { "text": "Quand une creature attaque une cible autre que vous a proximite, vous pouvez utiliser votre reaction pour lui imposer un desavantage.", "reactionModifiers": [{ "event": "incomingAttack", "mode": "imposeDisadvantage", "uiMessage": "Style Protection: desavantage impose a l'attaque ennemie.", "when": { "actionCategory": "attack", "targetMustBeAlly": true, "targetMustNotBeSelf": true, "targetVisible": true, "maxDistanceToTarget": 1.5, "requiresShield": true } }] };
const __vite_glob_0_33 = {
  id: id$2a,
  label: label$1w,
  summary: summary$I,
  kind: kind$2,
  tags: tags$1R,
  grants: grants$c,
  rules: rules$2
};
const id$29 = "fighting-style-two-weapon-fighting";
const label$1v = "Style de combat: Combat a deux armes";
const summary$H = "Vous ajoutez votre modificateur de caracteristique aux degats de l'attaque secondaire.";
const kind$1 = "feature";
const tags$1Q = ["fighting-style"];
const grants$b = [];
const rules$1 = { "text": "Quand vous combattez avec deux armes, vous ajoutez votre modificateur de caracteristique aux degats de la seconde attaque.", "secondaryAttackPolicy": { "mode": "addAbilityModToDamage", "ability": "auto", "when": { "actionCategory": "attack", "actionCostType": "bonus", "requiresOffhandWeapon": true, "weaponLight": true } } };
const __vite_glob_0_34 = {
  id: id$29,
  label: label$1v,
  summary: summary$H,
  kind: kind$1,
  tags: tags$1Q,
  grants: grants$b,
  rules: rules$1
};
const id$28 = "fighting-style";
const label$1u = "Style de combat";
const summary$G = "Choix d'un style martial specialise.";
const kind = "feature";
const tags$1P = ["fighting-style"];
const grants$a = [];
const rules = { "text": "Choisissez un style de combat. Le style peut etre remplace lors d'un gain de niveau dans une classe qui accorde ce choix.", "choices": [{ "key": "style", "title": "Style de combat", "count": 1, "options": [{ "id": "archery", "label": "Archerie", "summary": "+2 aux jets d'attaque avec armes a distance.", "grants": [{ "kind": "feature", "ids": ["fighting-style-archery"] }] }, { "id": "defense", "label": "Defense", "summary": "+1 a la CA quand vous portez une armure.", "grants": [{ "kind": "feature", "ids": ["fighting-style-defense"] }] }, { "id": "dueling", "label": "Duel", "summary": "+2 degats avec une arme de melee tenue a une main.", "grants": [{ "kind": "feature", "ids": ["fighting-style-dueling"] }] }, { "id": "great-weapon-fighting", "label": "Combat a deux mains", "summary": "Relance conditionnelle des degats d'arme a deux mains.", "grants": [{ "kind": "feature", "ids": ["fighting-style-great-weapon-fighting"] }] }, { "id": "interception", "label": "Interception", "summary": "Reaction pour reduire les degats subis par un allie proche.", "grants": [{ "kind": "feature", "ids": ["fighting-style-interception"] }] }, { "id": "protection", "label": "Protection", "summary": "Desavantage impose a une attaque contre un allie proche.", "grants": [{ "kind": "feature", "ids": ["fighting-style-protection"] }] }, { "id": "two-weapon-fighting", "label": "Combat a deux armes", "summary": "Ajout du modificateur de caracteristique aux degats de la seconde arme.", "grants": [{ "kind": "feature", "ids": ["fighting-style-two-weapon-fighting"] }] }] }] };
const __vite_glob_0_35 = {
  id: id$28,
  label: label$1u,
  summary: summary$G,
  kind,
  tags: tags$1P,
  grants: grants$a,
  rules
};
const FEATURE_MODULES = /* @__PURE__ */ Object.assign({
  "../data/features/cleric/balm-of-peace.json": __vite_glob_0_0$4,
  "../data/features/cleric/channel-divinity.json": __vite_glob_0_1$2,
  "../data/features/cleric/divine-intervention.json": __vite_glob_0_2$3,
  "../data/features/cleric/divine-order.json": __vite_glob_0_3$3,
  "../data/features/cleric/divine-spark.json": __vite_glob_0_4$2,
  "../data/features/cleric/expansive-bond.json": __vite_glob_0_5$1,
  "../data/features/cleric/peace-bond.json": __vite_glob_0_6$1,
  "../data/features/cleric/protective-bond.json": __vite_glob_0_7$1,
  "../data/features/cleric/turn-undead.json": __vite_glob_0_8$1,
  "../data/features/fighter/action-surge-2.json": __vite_glob_0_9$1,
  "../data/features/fighter/action-surge.json": __vite_glob_0_10,
  "../data/features/fighter/arcane-charge.json": __vite_glob_0_11,
  "../data/features/fighter/eldritch-knight-spellcasting.json": __vite_glob_0_12,
  "../data/features/fighter/eldritch-strike.json": __vite_glob_0_13,
  "../data/features/fighter/extra-attack-2.json": __vite_glob_0_14,
  "../data/features/fighter/extra-attack-3.json": __vite_glob_0_15,
  "../data/features/fighter/extra-attack.json": __vite_glob_0_16,
  "../data/features/fighter/improved-war-magic.json": __vite_glob_0_17,
  "../data/features/fighter/indomitable-2.json": __vite_glob_0_18,
  "../data/features/fighter/indomitable-3.json": __vite_glob_0_19,
  "../data/features/fighter/indomitable.json": __vite_glob_0_20,
  "../data/features/fighter/second-wind-feature.json": __vite_glob_0_21,
  "../data/features/fighter/tactical-mastery.json": __vite_glob_0_22,
  "../data/features/fighter/tactical-mind.json": __vite_glob_0_23,
  "../data/features/fighter/tactical-shift.json": __vite_glob_0_24,
  "../data/features/fighter/war-magic.json": __vite_glob_0_25,
  "../data/features/fighter/weapon-mastery.json": __vite_glob_0_26,
  "../data/features/index.json": featuresIndex,
  "../data/features/shared/fighting-style-archery.json": __vite_glob_0_28,
  "../data/features/shared/fighting-style-defense.json": __vite_glob_0_29,
  "../data/features/shared/fighting-style-dueling.json": __vite_glob_0_30,
  "../data/features/shared/fighting-style-great-weapon-fighting.json": __vite_glob_0_31,
  "../data/features/shared/fighting-style-interception.json": __vite_glob_0_32,
  "../data/features/shared/fighting-style-protection.json": __vite_glob_0_33,
  "../data/features/shared/fighting-style-two-weapon-fighting.json": __vite_glob_0_34,
  "../data/features/shared/fighting-style.json": __vite_glob_0_35
});
function toIndexPath$1(globPath) {
  return globPath.replace("../data/features/", "./");
}
function loadFeatureTypesFromIndex() {
  const indexed = Array.isArray(featuresIndex.features) ? featuresIndex.features : [];
  const loaded = [];
  for (const path2 of indexed) {
    const globPath = `../data/features/${path2.replace(/^\.\//, "")}`;
    const mod = FEATURE_MODULES[globPath];
    if (mod) {
      loaded.push(mod);
    } else {
      const available = Object.keys(FEATURE_MODULES).map(toIndexPath$1);
      console.warn("[features] Type path missing in bundle:", path2, {
        availableCount: available.length
      });
    }
  }
  if (loaded.length === 0) {
    console.warn("[features] No features loaded from index.json");
  }
  return loaded;
}
const types$9 = ["./wall-stone.json", "./wall-stone-door.json", "./wall-wood.json", "./wall-wood-door.json", "./low-wall-stone.json", "./low-wall-wood.json"];
const wallsIndex = {
  types: types$9
};
const id$27 = "wall-stone";
const label$1t = "Mur de pierre";
const category$1y = "wall";
const tags$1O = ["wall", "stone"];
const blocking$5 = { "movement": true, "vision": true, "attacks": true };
const durability$5 = { "destructible": true, "maxHp": 35, "ac": 15 };
const variants$5 = [{ "id": "1", "label": "Segment 1", "footprint": [{ "x": 0, "y": 0 }], "rotatable": false }, { "id": "2", "label": "Segment 2", "footprint": [{ "x": 0, "y": 0 }, { "x": 1, "y": 0 }], "rotatable": true }, { "id": "3", "label": "Segment 3", "footprint": [{ "x": 0, "y": 0 }, { "x": 1, "y": 0 }, { "x": 2, "y": 0 }], "rotatable": true }];
const appearance$5 = { "textureKey": "wall:walloldsimple", "heightClass": "tall" };
const behavior$5 = { "kind": "solid" };
const wallStone = {
  id: id$27,
  label: label$1t,
  category: category$1y,
  tags: tags$1O,
  blocking: blocking$5,
  durability: durability$5,
  variants: variants$5,
  appearance: appearance$5,
  behavior: behavior$5
};
const id$26 = "wall-stone-door";
const label$1s = "Mur de pierre (porte)";
const category$1x = "wall";
const tags$1N = ["wall", "stone", "door"];
const blocking$4 = { "movement": true, "vision": true, "attacks": true };
const durability$4 = { "destructible": true, "maxHp": 30, "ac": 15 };
const variants$4 = [{ "id": "1", "label": "Segment 1", "footprint": [{ "x": 0, "y": 0 }], "rotatable": false }];
const appearance$4 = { "textureKey": "wall:wallolddoor", "heightClass": "tall" };
const behavior$4 = { "kind": "door", "interactions": [{ "id": "open", "label": "Ouvrir", "kind": "open", "cost": "bonus" }, { "id": "break", "label": "Defoncer", "kind": "break", "cost": "action", "forceDc": 15, "damageFraction": 0.5 }] };
const wallStoneDoor = {
  id: id$26,
  label: label$1s,
  category: category$1x,
  tags: tags$1N,
  blocking: blocking$4,
  durability: durability$4,
  variants: variants$4,
  appearance: appearance$4,
  behavior: behavior$4
};
const id$25 = "wall-wood";
const label$1r = "Mur en bois";
const category$1w = "wall";
const tags$1M = ["wall", "wood"];
const blocking$3 = { "movement": true, "vision": true, "attacks": true };
const durability$3 = { "destructible": true, "maxHp": 22, "ac": 12 };
const variants$3 = [{ "id": "1", "label": "Segment 1", "footprint": [{ "x": 0, "y": 0 }], "rotatable": false }, { "id": "2", "label": "Segment 2", "footprint": [{ "x": 0, "y": 0 }, { "x": 1, "y": 0 }], "rotatable": true }, { "id": "3", "label": "Segment 3", "footprint": [{ "x": 0, "y": 0 }, { "x": 1, "y": 0 }, { "x": 2, "y": 0 }], "rotatable": true }];
const appearance$3 = { "textureKey": "wall:texture-plate", "heightClass": "tall" };
const behavior$3 = { "kind": "solid" };
const wallWood = {
  id: id$25,
  label: label$1r,
  category: category$1w,
  tags: tags$1M,
  blocking: blocking$3,
  durability: durability$3,
  variants: variants$3,
  appearance: appearance$3,
  behavior: behavior$3
};
const id$24 = "wall-wood-door";
const label$1q = "Mur en bois (porte)";
const category$1v = "wall";
const tags$1L = ["wall", "wood", "door"];
const blocking$2 = { "movement": true, "vision": true, "attacks": true };
const durability$2 = { "destructible": true, "maxHp": 14, "ac": 12 };
const variants$2 = [{ "id": "1", "label": "Segment 1", "footprint": [{ "x": 0, "y": 0 }], "rotatable": false }];
const appearance$2 = { "textureKey": "wall:texture-plate", "heightClass": "tall" };
const behavior$2 = { "kind": "door", "interactions": [{ "id": "open", "label": "Ouvrir", "kind": "open", "cost": "bonus" }, { "id": "break", "label": "Defoncer", "kind": "break", "cost": "action", "forceDc": 12, "damageFraction": 0.5 }] };
const wallWoodDoor = {
  id: id$24,
  label: label$1q,
  category: category$1v,
  tags: tags$1L,
  blocking: blocking$2,
  durability: durability$2,
  variants: variants$2,
  appearance: appearance$2,
  behavior: behavior$2
};
const id$23 = "low-wall-stone";
const label$1p = "Muret de pierre";
const category$1u = "wall";
const tags$1K = ["wall", "stone", "low"];
const blocking$1 = { "movement": true, "vision": false, "attacks": false };
const durability$1 = { "destructible": true, "maxHp": 18, "ac": 13 };
const variants$1 = [{ "id": "1", "label": "Segment 1", "footprint": [{ "x": 0, "y": 0 }], "rotatable": false }, { "id": "2", "label": "Segment 2", "footprint": [{ "x": 0, "y": 0 }, { "x": 1, "y": 0 }], "rotatable": true }];
const appearance$1 = { "textureKey": "wall:walloldsimple", "heightClass": "low" };
const behavior$1 = { "kind": "solid" };
const lowWallStone = {
  id: id$23,
  label: label$1p,
  category: category$1u,
  tags: tags$1K,
  blocking: blocking$1,
  durability: durability$1,
  variants: variants$1,
  appearance: appearance$1,
  behavior: behavior$1
};
const id$22 = "low-wall-wood";
const label$1o = "Muret en bois";
const category$1t = "wall";
const tags$1J = ["wall", "wood", "low"];
const blocking = { "movement": true, "vision": false, "attacks": false };
const durability = { "destructible": true, "maxHp": 12, "ac": 11 };
const variants = [{ "id": "1", "label": "Segment 1", "footprint": [{ "x": 0, "y": 0 }], "rotatable": false }, { "id": "2", "label": "Segment 2", "footprint": [{ "x": 0, "y": 0 }, { "x": 1, "y": 0 }], "rotatable": true }];
const appearance = { "textureKey": "wall:texture-plate", "heightClass": "low" };
const behavior = { "kind": "solid" };
const lowWallWood = {
  id: id$22,
  label: label$1o,
  category: category$1t,
  tags: tags$1J,
  blocking,
  durability,
  variants,
  appearance,
  behavior
};
const WALL_TYPE_MODULES = {
  "./wall-stone.json": wallStone,
  "./wall-stone-door.json": wallStoneDoor,
  "./wall-wood.json": wallWood,
  "./wall-wood-door.json": wallWoodDoor,
  "./low-wall-stone.json": lowWallStone,
  "./low-wall-wood.json": lowWallWood
};
function loadWallTypesFromIndex() {
  const indexed = Array.isArray(wallsIndex.types) ? wallsIndex.types : [];
  const loaded = [];
  for (const path2 of indexed) {
    const mod = WALL_TYPE_MODULES[path2];
    if (mod) {
      loaded.push(mod);
    } else {
      console.warn("[wall-types] Type path missing in bundle:", path2);
    }
  }
  if (loaded.length === 0) {
    console.warn("[wall-types] No wall types loaded from index.json");
  }
  return loaded;
}
const id$21 = "guard-strike";
const name$10 = "Guard Strike";
const summary$F = "Strike a hostile that enters your reach.";
const uiMessage$1 = "Vous avez subi une attaque de garde.";
const uiMessageMiss$4 = "Vous avez evite une attaque de garde.";
const trigger$2 = { "event": "movement.enter_reach", "source": "hostile" };
const conditions$t = [{ "type": "ACTOR_ALIVE", "reason": "Reactor must be alive." }, { "type": "REACTION_AVAILABLE", "reason": "Reaction already used." }];
const action$2 = { "id": "reaction-guard-strike", "name": "Guard Strike", "summary": "Prepared strike when a hostile closes in.", "category": "reaction", "actionCost": { "actionType": "reaction", "movementCost": 0 }, "targeting": { "target": "hostile", "range": { "min": 0, "max": 1.5, "shape": "SPHERE" }, "maxTargets": 1, "requiresLos": true }, "usage": { "perTurn": 1, "perEncounter": null, "resource": null }, "conditions": [{ "type": "TARGET_ALIVE", "target": "primary", "reason": "Target must be alive." }], "attack": { "bonus": 4, "critRange": 20 }, "damage": { "formula": "1d4 + modFOR", "critRule": "double-dice", "damageType": "PIERCING" }, "tags": ["reaction", "melee", "guard"], "ops": { "onHit": [{ "op": "DealDamage", "target": "primary", "formula": "1d4 + modFOR", "damageType": "PIERCING" }], "onResolve": [{ "op": "LogEvent", "message": "Guard strike triggered." }] } };
const tags$1I = ["reaction"];
const __vite_glob_0_0$3 = {
  id: id$21,
  name: name$10,
  summary: summary$F,
  uiMessage: uiMessage$1,
  uiMessageMiss: uiMessageMiss$4,
  trigger: trigger$2,
  conditions: conditions$t,
  action: action$2,
  tags: tags$1I
};
const model = "../models/reaction-model.json";
const reactions = ["./opportunity-attack.json", "./guard-strike.json", "./killer-instinct.json"];
const reactionsIndex = {
  model,
  reactions
};
const id$20 = "killer-instinct";
const name$$ = "Instinct de tueur";
const summary$E = "Marque la premiere cible visible et accorde l'avantage jusqu'a sa mort.";
const trigger$1 = { "event": "visibility.first_seen", "source": "enemy" };
const conditions$s = [{ "type": "ACTOR_ALIVE", "reason": "Reactor must be alive." }, { "type": "REACTION_UNUSED_COMBAT", "reason": "Deja utilise ce combat." }, { "type": "TARGET_ALIVE", "reason": "Target must be alive." }, { "type": "TARGET_FIRST_SEEN", "reason": "Target already revealed." }, { "type": "TARGET_IS_CLOSEST_VISIBLE", "reason": "Target not closest." }];
const action$1 = { "id": "reaction-killer-instinct", "name": "Instinct de tueur", "summary": "Marquer la cible pour avantage permanent.", "category": "reaction", "actionCost": { "actionType": "reaction", "movementCost": 0 }, "targeting": { "target": "hostile", "range": { "min": 0, "max": 148.5, "shape": "SPHERE" }, "maxTargets": 1, "requiresLos": true }, "usage": { "perTurn": 1, "perEncounter": null, "resource": null }, "conditions": [], "tags": ["reaction", "passive"], "ops": { "onResolve": [{ "op": "SetKillerInstinctTarget", "target": "primary" }, { "op": "LogEvent", "message": "Instinct de tueur: cible marquee." }] } };
const tags$1H = ["reaction", "visibility"];
const __vite_glob_0_2$2 = {
  id: id$20,
  name: name$$,
  summary: summary$E,
  trigger: trigger$1,
  conditions: conditions$s,
  action: action$1,
  tags: tags$1H
};
const id$1$ = "opportunity-attack";
const name$_ = "Opportunity Attack";
const summary$D = "Strike a hostile that leaves your reach.";
const uiMessage = "Vous avez subi une attaque d opportunite.";
const uiMessageMiss$3 = "Vous avez evite une attaque d opportunite.";
const trigger = { "event": "movement.leave_reach", "source": "hostile" };
const conditions$r = [{ "type": "ACTOR_ALIVE", "reason": "Reactor must be alive." }, { "type": "REACTION_AVAILABLE", "reason": "Reaction already used." }, { "type": "TARGET_VISIBLE", "reason": "Target not visible." }];
const action = { "id": "reaction-opportunity-attack", "name": "Opportunity Attack", "summary": "Melee strike triggered by a fleeing target.", "category": "reaction", "actionCost": { "actionType": "reaction", "movementCost": 0 }, "targeting": { "target": "hostile", "range": { "min": 0, "max": 1.5, "shape": "SPHERE" }, "maxTargets": 1, "requiresLos": true }, "usage": { "perTurn": 1, "perEncounter": null, "resource": null }, "conditions": [{ "type": "TARGET_ALIVE", "target": "primary", "reason": "Target must be alive." }], "attack": { "bonus": 5, "critRange": 20 }, "damage": { "formula": "1d4 + modFOR", "critRule": "double-dice", "damageType": "SLASHING" }, "resolution": { "kind": "ATTACK_ROLL", "bonus": 5, "critRange": 20, "critRule": "double-dice" }, "ops": { "onHit": [{ "op": "DealDamage", "target": "primary", "formula": "1d4 + modFOR", "damageType": "SLASHING" }, { "op": "DealDamage", "target": "primary", "formula": "1d4 + modFOR", "damageType": "SLASHING" }], "onResolve": [{ "op": "LogEvent", "message": "Opportunity attack triggered." }] }, "tags": ["reaction", "melee", "opportunity"] };
const tags$1G = ["reaction"];
const __vite_glob_0_3$2 = {
  id: id$1$,
  name: name$_,
  summary: summary$D,
  uiMessage,
  uiMessageMiss: uiMessageMiss$3,
  trigger,
  conditions: conditions$r,
  action,
  tags: tags$1G
};
const REACTION_MODULES = /* @__PURE__ */ Object.assign({
  "../data/reactions/guard-strike.json": __vite_glob_0_0$3,
  "../data/reactions/index.json": reactionsIndex,
  "../data/reactions/killer-instinct.json": __vite_glob_0_2$2,
  "../data/reactions/opportunity-attack.json": __vite_glob_0_3$2
});
function toIndexPath(globPath) {
  return globPath.replace("../data/reactions/", "./");
}
function loadReactionTypesFromIndex() {
  const indexed = Array.isArray(reactionsIndex.reactions) ? reactionsIndex.reactions : [];
  const loaded = [];
  for (const path2 of indexed) {
    const globPath = `../data/reactions/${path2.replace(/^\.\//, "")}`;
    const mod = REACTION_MODULES[globPath];
    if (mod) {
      loaded.push(mod);
    } else {
      const available = Object.keys(REACTION_MODULES).map(toIndexPath);
      console.warn("[reactions] Type path missing in bundle:", path2, {
        availableCount: available.length
      });
    }
  }
  if (loaded.length === 0) {
    console.warn("[reactions] No reaction types loaded from index.json");
  }
  return loaded;
}
const DAMAGE_TYPE_ALIASES = {
  slashing: "SLASHING",
  tranchant: "SLASHING",
  piercing: "PIERCING",
  perforant: "PIERCING",
  bludgeoning: "BLUDGEONING",
  contondant: "BLUDGEONING",
  fire: "FIRE",
  feu: "FIRE",
  cold: "COLD",
  froid: "COLD",
  acid: "ACID",
  acide: "ACID",
  lightning: "LIGHTNING",
  foudre: "LIGHTNING",
  poison: "POISON",
  thunder: "THUNDER",
  tonnerre: "THUNDER",
  force: "FORCE",
  radiant: "RADIANT",
  necrotic: "NECROTIC",
  necrotique: "NECROTIC",
  psychic: "PSYCHIC",
  psychique: "PSYCHIC"
};
function normalizeKey(value2) {
  return value2.trim().toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "");
}
function normalizeDamageType(value2) {
  if (!value2) return null;
  const key2 = normalizeKey(String(value2));
  return DAMAGE_TYPE_ALIASES[key2] ?? null;
}
const types$8 = ["./martiale/arc-long-cendre.json", "./martiale/arc-long.json", "./martiale/epee-longue-brasiere.json", "./martiale/epee-longue.json", "./martiale/hache-bataille-incandescente.json", "./martiale/hache-bataille.json", "./monastique/baton.json", "./monastique/kama.json", "./monastique/nunchaku.json", "./simple/arc-court.json", "./simple/arme-endommagee.json", "./simple/dague.json", "./simple/massue.json", "./simple/petit-couteau.json", "./speciale/arbalete-repetee.json", "./speciale/epee-elfique.json", "./speciale/fouet-demon.json"];
const weaponsIndex = {
  types: types$8
};
const id$1_ = "arc-long-cendre";
const name$Z = "Arc long des Cendres";
const label$1n = "Arc long des Cendres";
const type$R = "arme";
const subtype$m = "martiale";
const category$1s = "distance";
const descriptionCourte$m = "Arc martial dont les fleches laissent une traine de braise.";
const descriptionLongue$m = "Un arc long grave de motifs de cendre, ideal pour tester les degats elementaires.";
const allowStack$m = false;
const harmonisable$G = false;
const focalisateur$g = false;
const weight$M = 1.5;
const size$p = 1.2;
const value$M = { "gold": 160, "silver": 0, "copper": 0, "platinum": 0 };
const rarity$m = "rare";
const tags$1F = ["arme", "distance", "piercing", "fire", "wood"];
const weaponMastery$6 = ["ralentissement"];
const grants$9 = [{ "kind": "bonus", "inline": [{ "id": "bonus-arc-cendre-for-1", "label": "+1 modFOR", "summary": "Bonus de Force tant que l'arme est equipee.", "stat": "modFOR", "value": 1, "mode": "add", "tags": ["equip", "weapon", "test"], "requirements": [], "source": { "book": "HOME", "page": 0 } }] }];
const properties$g = { "finesse": false, "light": false, "heavy": true, "twoHanded": true, "reach": 0, "versatile": null, "thrown": null, "ammunition": true, "loading": false, "reload": null, "range": { "normal": 36, "long": 144 }, "special": null };
const attack$l = { "mod": "mod.DEX", "bonus": "bonus_maitrise" };
const damage$l = { "dice": "1d8", "damageType": "piercing" };
const extraDamage$2 = [{ "dice": "1d4", "damageType": "fire", "when": "onHit" }];
const effectOnHit$g = { "mod": "mod.DEX", "damage": "1d8", "damageType": "piercing" };
const MartialeArcLongCendre = {
  id: id$1_,
  name: name$Z,
  label: label$1n,
  type: type$R,
  subtype: subtype$m,
  category: category$1s,
  descriptionCourte: descriptionCourte$m,
  descriptionLongue: descriptionLongue$m,
  allowStack: allowStack$m,
  harmonisable: harmonisable$G,
  focalisateur: focalisateur$g,
  weight: weight$M,
  size: size$p,
  value: value$M,
  rarity: rarity$m,
  tags: tags$1F,
  weaponMastery: weaponMastery$6,
  grants: grants$9,
  properties: properties$g,
  attack: attack$l,
  damage: damage$l,
  extraDamage: extraDamage$2,
  effectOnHit: effectOnHit$g
};
const id$1Z = "arc-long";
const name$Y = "Arc long";
const type$Q = "arme";
const subtype$l = "martiale";
const category$1r = "distance";
const descriptionCourte$l = "Arc puissant a longue portee.";
const descriptionLongue$l = "";
const allowStack$l = false;
const harmonisable$F = false;
const focalisateur$f = false;
const weight$L = 1.5;
const size$o = 1.2;
const value$L = { "gold": 50, "silver": 0, "copper": 0, "platinum": 0 };
const rarity$l = "commune";
const tags$1E = ["arme", "distance", "piercing", "wood"];
const weaponMastery$5 = ["ralentissement"];
const properties$f = { "finesse": false, "light": false, "heavy": true, "twoHanded": true, "reach": 0, "versatile": null, "thrown": null, "ammunition": true, "loading": false, "reload": null, "range": { "normal": 36, "long": 144 }, "special": null };
const attack$k = { "mod": "mod.DEX", "bonus": "bonus_maitrise" };
const damage$k = { "dice": "1d8", "damageType": "piercing" };
const effectOnHit$f = { "mod": "mod.DEX", "damage": "1d8", "damageType": "piercing" };
const label$1m = "Arc long";
const MartialeArcLong = {
  id: id$1Z,
  name: name$Y,
  type: type$Q,
  subtype: subtype$l,
  category: category$1r,
  descriptionCourte: descriptionCourte$l,
  descriptionLongue: descriptionLongue$l,
  allowStack: allowStack$l,
  harmonisable: harmonisable$F,
  focalisateur: focalisateur$f,
  weight: weight$L,
  size: size$o,
  value: value$L,
  rarity: rarity$l,
  tags: tags$1E,
  weaponMastery: weaponMastery$5,
  properties: properties$f,
  attack: attack$k,
  damage: damage$k,
  effectOnHit: effectOnHit$f,
  label: label$1m
};
const id$1Y = "epee-longue-brasiere";
const name$X = "Epee longue de la Brasiere";
const label$1l = "Epee longue de la Brasiere";
const type$P = "arme";
const subtype$k = "martiale";
const category$1q = "melee";
const descriptionCourte$k = "Lame martiale chauffee par des runes de braise.";
const descriptionLongue$k = "Une epee longue renforcee par des sigils incandescents.";
const allowStack$k = false;
const harmonisable$E = false;
const focalisateur$e = false;
const weight$K = 1.5;
const size$n = 1;
const value$K = { "gold": 120, "silver": 0, "copper": 0, "platinum": 0 };
const rarity$k = "rare";
const tags$1D = ["arme", "melee", "slashing", "fire", "metal"];
const weaponMastery$4 = ["ouverture"];
const grants$8 = [{ "kind": "bonus", "inline": [{ "id": "bonus-epee-brasiere-for-1", "label": "+1 modFOR", "summary": "Bonus de Force tant que l'arme est equipee.", "stat": "modFOR", "value": 1, "mode": "add", "tags": ["equip", "weapon", "test"], "requirements": [], "source": { "book": "HOME", "page": 0 } }] }];
const properties$e = { "finesse": false, "light": false, "heavy": false, "twoHanded": false, "reach": 1.5, "versatile": "1d10", "thrown": null, "ammunition": false, "loading": false, "reload": null, "range": { "normal": 1.5, "long": 1.5 }, "special": null };
const attack$j = { "mod": "mod.FOR", "bonus": "bonus_maitrise" };
const damage$j = { "dice": "1d8", "damageType": "slashing" };
const extraDamage$1 = [{ "dice": "1d4", "damageType": "fire", "when": "onHit" }];
const effectOnHit$e = { "mod": "mod.FOR", "damage": "1d8", "damageType": "slashing" };
const MartialeEpeeLongueBrasiere = {
  id: id$1Y,
  name: name$X,
  label: label$1l,
  type: type$P,
  subtype: subtype$k,
  category: category$1q,
  descriptionCourte: descriptionCourte$k,
  descriptionLongue: descriptionLongue$k,
  allowStack: allowStack$k,
  harmonisable: harmonisable$E,
  focalisateur: focalisateur$e,
  weight: weight$K,
  size: size$n,
  value: value$K,
  rarity: rarity$k,
  tags: tags$1D,
  weaponMastery: weaponMastery$4,
  grants: grants$8,
  properties: properties$e,
  attack: attack$j,
  damage: damage$j,
  extraDamage: extraDamage$1,
  effectOnHit: effectOnHit$e
};
const id$1X = "epee-longue";
const name$W = "Epee longue";
const type$O = "arme";
const subtype$j = "martiale";
const category$1p = "melee";
const descriptionCourte$j = "Lame d'acier polyvalente, classique.";
const descriptionLongue$j = "";
const allowStack$j = false;
const harmonisable$D = false;
const focalisateur$d = false;
const weight$J = 1.5;
const size$m = 1;
const value$J = { "gold": 15, "silver": 0, "copper": 0, "platinum": 0 };
const rarity$j = "commune";
const tags$1C = ["arme", "melee", "slashing", "metal"];
const weaponMastery$3 = ["ouverture"];
const properties$d = { "finesse": false, "light": false, "heavy": false, "twoHanded": false, "reach": 1.5, "versatile": "1d10", "thrown": null, "ammunition": false, "loading": false, "reload": null, "range": { "normal": 1.5, "long": 1.5 }, "special": null };
const attack$i = { "mod": "mod.FOR", "bonus": "bonus_maitrise" };
const damage$i = { "dice": "1d8", "damageType": "slashing" };
const effectOnHit$d = { "mod": "mod.FOR", "damage": "1d8", "damageType": "slashing" };
const label$1k = "Epee longue";
const MartialeEpeeLongue = {
  id: id$1X,
  name: name$W,
  type: type$O,
  subtype: subtype$j,
  category: category$1p,
  descriptionCourte: descriptionCourte$j,
  descriptionLongue: descriptionLongue$j,
  allowStack: allowStack$j,
  harmonisable: harmonisable$D,
  focalisateur: focalisateur$d,
  weight: weight$J,
  size: size$m,
  value: value$J,
  rarity: rarity$j,
  tags: tags$1C,
  weaponMastery: weaponMastery$3,
  properties: properties$d,
  attack: attack$i,
  damage: damage$i,
  effectOnHit: effectOnHit$d,
  label: label$1k
};
const id$1W = "hache-bataille-incandescente";
const name$V = "Hache de bataille incandescente";
const label$1j = "Hache de bataille incandescente";
const type$N = "arme";
const subtype$i = "martiale";
const category$1o = "melee";
const descriptionCourte$i = "Une hache martiale qui embrase ses impacts.";
const descriptionLongue$i = "Sa tete de hache accumule une chaleur rougeoyante avant l'impact.";
const allowStack$i = false;
const harmonisable$C = false;
const focalisateur$c = false;
const weight$I = 2;
const size$l = 1;
const value$I = { "gold": 140, "silver": 0, "copper": 0, "platinum": 0 };
const rarity$i = "rare";
const tags$1B = ["arme", "melee", "slashing", "fire", "metal"];
const weaponMastery$2 = ["renversement"];
const grants$7 = [{ "kind": "bonus", "inline": [{ "id": "bonus-hache-incandescente-for-1", "label": "+1 modFOR", "summary": "Bonus de Force tant que l'arme est equipee.", "stat": "modFOR", "value": 1, "mode": "add", "tags": ["equip", "weapon", "test"], "requirements": [], "source": { "book": "HOME", "page": 0 } }] }];
const properties$c = { "finesse": false, "light": false, "heavy": false, "twoHanded": false, "reach": 1.5, "versatile": "1d10", "thrown": null, "ammunition": false, "loading": false, "reload": null, "range": { "normal": 1.5, "long": 1.5 }, "special": null };
const attack$h = { "mod": "mod.FOR", "bonus": "bonus_maitrise" };
const damage$h = { "dice": "1d8", "damageType": "slashing" };
const extraDamage = [{ "dice": "1d6", "damageType": "fire", "when": "onCrit" }];
const effectOnHit$c = { "mod": "mod.FOR", "damage": "1d8", "damageType": "slashing" };
const MartialeHacheBatailleIncandescente = {
  id: id$1W,
  name: name$V,
  label: label$1j,
  type: type$N,
  subtype: subtype$i,
  category: category$1o,
  descriptionCourte: descriptionCourte$i,
  descriptionLongue: descriptionLongue$i,
  allowStack: allowStack$i,
  harmonisable: harmonisable$C,
  focalisateur: focalisateur$c,
  weight: weight$I,
  size: size$l,
  value: value$I,
  rarity: rarity$i,
  tags: tags$1B,
  weaponMastery: weaponMastery$2,
  grants: grants$7,
  properties: properties$c,
  attack: attack$h,
  damage: damage$h,
  extraDamage,
  effectOnHit: effectOnHit$c
};
const id$1V = "hache-bataille";
const name$U = "Hache de bataille";
const type$M = "arme";
const subtype$h = "martiale";
const category$1n = "melee";
const descriptionCourte$h = "Hache lourde a double tranchant.";
const descriptionLongue$h = "";
const allowStack$h = false;
const harmonisable$B = false;
const focalisateur$b = false;
const weight$H = 2;
const size$k = 1;
const value$H = { "gold": 10, "silver": 0, "copper": 0, "platinum": 0 };
const rarity$h = "commune";
const tags$1A = ["arme", "melee", "slashing", "metal"];
const weaponMastery$1 = ["renversement"];
const properties$b = { "finesse": false, "light": false, "heavy": false, "twoHanded": false, "reach": 1.5, "versatile": "1d10", "thrown": null, "ammunition": false, "loading": false, "reload": null, "range": { "normal": 1.5, "long": 1.5 }, "special": null };
const attack$g = { "mod": "mod.FOR", "bonus": "bonus_maitrise" };
const damage$g = { "dice": "1d8", "damageType": "slashing" };
const effectOnHit$b = { "mod": "mod.FOR", "damage": "1d8", "damageType": "slashing" };
const label$1i = "Hache de bataille";
const MartialeHacheBataille = {
  id: id$1V,
  name: name$U,
  type: type$M,
  subtype: subtype$h,
  category: category$1n,
  descriptionCourte: descriptionCourte$h,
  descriptionLongue: descriptionLongue$h,
  allowStack: allowStack$h,
  harmonisable: harmonisable$B,
  focalisateur: focalisateur$b,
  weight: weight$H,
  size: size$k,
  value: value$H,
  rarity: rarity$h,
  tags: tags$1A,
  weaponMastery: weaponMastery$1,
  properties: properties$b,
  attack: attack$g,
  damage: damage$g,
  effectOnHit: effectOnHit$b,
  label: label$1i
};
const id$1U = "baton";
const name$T = "Baton";
const type$L = "arme";
const subtype$g = "monastique";
const category$1m = "melee";
const descriptionCourte$g = "Baton d'entrainement, polyvalent.";
const descriptionLongue$g = "";
const allowStack$g = false;
const harmonisable$A = false;
const focalisateur$a = false;
const weight$G = 1;
const size$j = 1.2;
const value$G = { "gold": 1, "silver": 0, "copper": 0, "platinum": 0 };
const rarity$g = "commune";
const tags$1z = ["arme", "melee", "bludgeoning", "wood"];
const properties$a = { "finesse": false, "light": false, "heavy": false, "twoHanded": true, "reach": 1.5, "versatile": "1d8", "thrown": null, "ammunition": false, "loading": false, "reload": null, "range": { "normal": 1.5, "long": 1.5 }, "special": "monastic" };
const attack$f = { "mod": "mod.FOR", "bonus": "bonus_maitrise" };
const damage$f = { "dice": "1d6", "damageType": "bludgeoning" };
const effectOnHit$a = { "mod": "mod.FOR", "damage": "1d6", "damageType": "bludgeoning" };
const label$1h = "Baton";
const MonastiqueBaton = {
  id: id$1U,
  name: name$T,
  type: type$L,
  subtype: subtype$g,
  category: category$1m,
  descriptionCourte: descriptionCourte$g,
  descriptionLongue: descriptionLongue$g,
  allowStack: allowStack$g,
  harmonisable: harmonisable$A,
  focalisateur: focalisateur$a,
  weight: weight$G,
  size: size$j,
  value: value$G,
  rarity: rarity$g,
  tags: tags$1z,
  properties: properties$a,
  attack: attack$f,
  damage: damage$f,
  effectOnHit: effectOnHit$a,
  label: label$1h
};
const id$1T = "kama";
const name$S = "Kama";
const type$K = "arme";
const subtype$f = "monastique";
const category$1l = "melee";
const descriptionCourte$f = "Faucille courte pour combat rapproche.";
const descriptionLongue$f = "";
const allowStack$f = false;
const harmonisable$z = false;
const focalisateur$9 = false;
const weight$F = 0.7;
const size$i = 0.6;
const value$F = { "gold": 2, "silver": 0, "copper": 0, "platinum": 0 };
const rarity$f = "commune";
const tags$1y = ["arme", "melee", "slashing", "metal"];
const properties$9 = { "finesse": true, "light": true, "heavy": false, "twoHanded": false, "reach": 1.5, "versatile": null, "thrown": null, "ammunition": false, "loading": false, "reload": null, "range": { "normal": 1.5, "long": 1.5 }, "special": "monastic" };
const attack$e = { "mod": "mod.DEX", "bonus": "bonus_maitrise" };
const damage$e = { "dice": "1d6", "damageType": "slashing" };
const effectOnHit$9 = { "mod": "mod.DEX", "damage": "1d6", "damageType": "slashing" };
const label$1g = "Kama";
const MonastiqueKama = {
  id: id$1T,
  name: name$S,
  type: type$K,
  subtype: subtype$f,
  category: category$1l,
  descriptionCourte: descriptionCourte$f,
  descriptionLongue: descriptionLongue$f,
  allowStack: allowStack$f,
  harmonisable: harmonisable$z,
  focalisateur: focalisateur$9,
  weight: weight$F,
  size: size$i,
  value: value$F,
  rarity: rarity$f,
  tags: tags$1y,
  properties: properties$9,
  attack: attack$e,
  damage: damage$e,
  effectOnHit: effectOnHit$9,
  label: label$1g
};
const id$1S = "nunchaku";
const name$R = "Nunchaku";
const type$J = "arme";
const subtype$e = "monastique";
const category$1k = "melee";
const descriptionCourte$e = "Arme souple en bois relie par une corde.";
const descriptionLongue$e = "";
const allowStack$e = false;
const harmonisable$y = false;
const focalisateur$8 = false;
const weight$E = 0.8;
const size$h = 0.8;
const value$E = { "gold": 3, "silver": 0, "copper": 0, "platinum": 0 };
const rarity$e = "commune";
const tags$1x = ["arme", "melee", "bludgeoning", "wood"];
const properties$8 = { "finesse": true, "light": true, "heavy": false, "twoHanded": false, "reach": 1.5, "versatile": null, "thrown": null, "ammunition": false, "loading": false, "reload": null, "range": { "normal": 1.5, "long": 1.5 }, "special": "monastic" };
const attack$d = { "mod": "mod.DEX", "bonus": "bonus_maitrise" };
const damage$d = { "dice": "1d6", "damageType": "bludgeoning" };
const effectOnHit$8 = { "mod": "mod.DEX", "damage": "1d6", "damageType": "bludgeoning" };
const label$1f = "Nunchaku";
const MonastiqueNunchaku = {
  id: id$1S,
  name: name$R,
  type: type$J,
  subtype: subtype$e,
  category: category$1k,
  descriptionCourte: descriptionCourte$e,
  descriptionLongue: descriptionLongue$e,
  allowStack: allowStack$e,
  harmonisable: harmonisable$y,
  focalisateur: focalisateur$8,
  weight: weight$E,
  size: size$h,
  value: value$E,
  rarity: rarity$e,
  tags: tags$1x,
  properties: properties$8,
  attack: attack$d,
  damage: damage$d,
  effectOnHit: effectOnHit$8,
  label: label$1f
};
const id$1R = "arc-court";
const name$Q = "Arc court";
const type$I = "arme";
const subtype$d = "simple";
const category$1j = "distance";
const descriptionCourte$d = "Arc leger a courte portee.";
const descriptionLongue$d = "";
const allowStack$d = false;
const harmonisable$x = false;
const focalisateur$7 = false;
const weight$D = 1;
const size$g = 1;
const value$D = { "gold": 25, "silver": 0, "copper": 0, "platinum": 0 };
const rarity$d = "commune";
const tags$1w = ["arme", "distance", "piercing", "wood"];
const properties$7 = { "finesse": false, "light": false, "heavy": false, "twoHanded": true, "reach": 0, "versatile": null, "thrown": null, "ammunition": true, "loading": false, "reload": null, "range": { "normal": 24, "long": 96 }, "special": null };
const attack$c = { "mod": "mod.DEX", "bonus": "bonus_maitrise" };
const damage$c = { "dice": "1d6", "damageType": "piercing" };
const effectOnHit$7 = { "mod": "mod.DEX", "damage": "1d6", "damageType": "piercing" };
const label$1e = "Arc court";
const SimpleArcCourt = {
  id: id$1R,
  name: name$Q,
  type: type$I,
  subtype: subtype$d,
  category: category$1j,
  descriptionCourte: descriptionCourte$d,
  descriptionLongue: descriptionLongue$d,
  allowStack: allowStack$d,
  harmonisable: harmonisable$x,
  focalisateur: focalisateur$7,
  weight: weight$D,
  size: size$g,
  value: value$D,
  rarity: rarity$d,
  tags: tags$1w,
  properties: properties$7,
  attack: attack$c,
  damage: damage$c,
  effectOnHit: effectOnHit$7,
  label: label$1e
};
const id$1Q = "obj_arme_endommagee";
const name$P = "Arme endommagee";
const type$H = "arme";
const subtype$c = "simple";
const category$1i = "melee";
const descriptionCourte$c = "Une arme simple ou martiale abimee, utilisable pour l'histoire.";
const descriptionLongue$c = "";
const allowStack$c = false;
const harmonisable$w = false;
const focalisateur$6 = false;
const weight$C = 2;
const size$f = 0.8;
const value$C = { "gold": 0, "silver": 5, "copper": 0, "platinum": 0 };
const rarity$c = "commune";
const tags$1v = ["arme", "melee", "endommagee", "metal"];
const properties$6 = { "finesse": false, "light": false, "heavy": false, "twoHanded": false, "reach": 1.5, "versatile": null, "thrown": null, "ammunition": false, "loading": false, "reload": null, "range": { "normal": 1.5, "long": 1.5 }, "special": "abimee" };
const attack$b = { "mod": "mod.FOR", "bonus": "bonus_maitrise" };
const damage$b = { "dice": "1d4", "damageType": "slashing" };
const effectOnHit$6 = { "mod": "mod.FOR", "damage": "1d4", "damageType": "slashing" };
const label$1d = "Arme endommageehhhhhhy";
const SimpleArmeEndommagee = {
  id: id$1Q,
  name: name$P,
  type: type$H,
  subtype: subtype$c,
  category: category$1i,
  descriptionCourte: descriptionCourte$c,
  descriptionLongue: descriptionLongue$c,
  allowStack: allowStack$c,
  harmonisable: harmonisable$w,
  focalisateur: focalisateur$6,
  weight: weight$C,
  size: size$f,
  value: value$C,
  rarity: rarity$c,
  tags: tags$1v,
  properties: properties$6,
  attack: attack$b,
  damage: damage$b,
  effectOnHit: effectOnHit$6,
  label: label$1d
};
const id$1P = "dague";
const name$O = "Dague";
const type$G = "arme";
const subtype$b = "simple";
const category$1h = "melee";
const descriptionCourte$b = "Lame courte et legere, facile a dissimuler.";
const descriptionLongue$b = "";
const allowStack$b = false;
const harmonisable$v = false;
const focalisateur$5 = false;
const weight$B = 0.5;
const size$e = 0.4;
const value$B = { "gold": 2, "silver": 0, "copper": 0, "platinum": 0 };
const rarity$b = "commune";
const tags$1u = ["arme", "melee", "piercing", "jet", "metal"];
const properties$5 = { "finesse": true, "light": true, "heavy": false, "twoHanded": false, "reach": 1.5, "versatile": null, "thrown": { "normal": 6, "long": 18 }, "ammunition": false, "loading": false, "reload": null, "range": { "normal": 1.5, "long": 1.5 }, "special": null };
const attack$a = { "mod": "mod.DEX", "bonus": "bonus_maitrise" };
const damage$a = { "dice": "1d4", "damageType": "piercing" };
const effectOnHit$5 = { "mod": "mod.DEX", "damage": "1d4", "damageType": "piercing" };
const label$1c = "Dague";
const SimpleDague = {
  id: id$1P,
  name: name$O,
  type: type$G,
  subtype: subtype$b,
  category: category$1h,
  descriptionCourte: descriptionCourte$b,
  descriptionLongue: descriptionLongue$b,
  allowStack: allowStack$b,
  harmonisable: harmonisable$v,
  focalisateur: focalisateur$5,
  weight: weight$B,
  size: size$e,
  value: value$B,
  rarity: rarity$b,
  tags: tags$1u,
  properties: properties$5,
  attack: attack$a,
  damage: damage$a,
  effectOnHit: effectOnHit$5,
  label: label$1c
};
const id$1O = "massue";
const name$N = "Massue";
const type$F = "arme";
const subtype$a = "simple";
const category$1g = "melee";
const descriptionCourte$a = "Baton lourd renforce, frappe contondante.";
const descriptionLongue$a = "";
const allowStack$a = false;
const harmonisable$u = false;
const focalisateur$4 = false;
const weight$A = 1.8;
const size$d = 1;
const value$A = { "gold": 1, "silver": 0, "copper": 0, "platinum": 0 };
const rarity$a = "commune";
const tags$1t = ["arme", "melee", "bludgeoning", "wood"];
const properties$4 = { "finesse": false, "light": false, "heavy": false, "twoHanded": false, "reach": 1.5, "versatile": null, "thrown": null, "ammunition": false, "loading": false, "reload": null, "range": { "normal": 1.5, "long": 1.5 }, "special": null };
const attack$9 = { "mod": "mod.FOR", "bonus": "bonus_maitrise" };
const damage$9 = { "dice": "1d6", "damageType": "bludgeoning" };
const effectOnHit$4 = { "mod": "mod.FOR", "damage": "1d6", "damageType": "bludgeoning" };
const label$1b = "Massue";
const SimpleMassue = {
  id: id$1O,
  name: name$N,
  type: type$F,
  subtype: subtype$a,
  category: category$1g,
  descriptionCourte: descriptionCourte$a,
  descriptionLongue: descriptionLongue$a,
  allowStack: allowStack$a,
  harmonisable: harmonisable$u,
  focalisateur: focalisateur$4,
  weight: weight$A,
  size: size$d,
  value: value$A,
  rarity: rarity$a,
  tags: tags$1t,
  properties: properties$4,
  attack: attack$9,
  damage: damage$9,
  effectOnHit: effectOnHit$4,
  label: label$1b
};
const id$1N = "obj_petit_couteau";
const name$M = "Petit couteau";
const type$E = "arme";
const subtype$9 = "simple";
const category$1f = "melee";
const descriptionCourte$9 = "Petit couteau utilitaire, pas une arme de combat principale.";
const descriptionLongue$9 = "";
const allowStack$9 = false;
const harmonisable$t = false;
const focalisateur$3 = false;
const weight$z = 0.5;
const size$c = 0.3;
const value$z = { "gold": 0, "silver": 2, "copper": 0, "platinum": 0 };
const rarity$9 = "commune";
const tags$1s = ["arme", "melee", "slashing", "improvise"];
const weaponMastery = ["coup_double"];
const properties$3 = { "finesse": true, "light": true, "heavy": false, "twoHanded": false, "reach": 1.5, "versatile": null, "thrown": { "normal": 6, "long": 18 }, "ammunition": false, "loading": false, "reload": null, "range": { "normal": 1.5, "long": 1.5 }, "special": "utilitaire" };
const attack$8 = { "mod": "mod.DEX", "bonus": "bonus_maitrise" };
const damage$8 = { "dice": "1d4", "damageType": "slashing" };
const effectOnHit$3 = { "mod": "mod.DEX", "damage": "1d4", "damageType": "slashing" };
const label$1a = "Petit couteau";
const SimplePetitCouteau = {
  id: id$1N,
  name: name$M,
  type: type$E,
  subtype: subtype$9,
  category: category$1f,
  descriptionCourte: descriptionCourte$9,
  descriptionLongue: descriptionLongue$9,
  allowStack: allowStack$9,
  harmonisable: harmonisable$t,
  focalisateur: focalisateur$3,
  weight: weight$z,
  size: size$c,
  value: value$z,
  rarity: rarity$9,
  tags: tags$1s,
  weaponMastery,
  properties: properties$3,
  attack: attack$8,
  damage: damage$8,
  effectOnHit: effectOnHit$3,
  label: label$1a
};
const id$1M = "arbalete-repetee";
const name$L = "Arbalete repetee";
const type$D = "arme";
const subtype$8 = "speciale";
const category$1e = "distance";
const descriptionCourte$8 = "Arbalete a charge rapide.";
const descriptionLongue$8 = "";
const allowStack$8 = false;
const harmonisable$s = false;
const focalisateur$2 = false;
const weight$y = 2.2;
const size$b = 1.1;
const value$y = { "gold": 120, "silver": 0, "copper": 0, "platinum": 0 };
const rarity$8 = "rare";
const tags$1r = ["arme", "distance", "piercing", "wood", "metal"];
const properties$2 = { "finesse": false, "light": false, "heavy": true, "twoHanded": true, "reach": 0, "versatile": null, "thrown": null, "ammunition": true, "loading": true, "reload": 5, "range": { "normal": 30, "long": 120 }, "special": "repetition" };
const attack$7 = { "mod": "mod.DEX", "bonus": "bonus_maitrise" };
const damage$7 = { "dice": "1d8", "damageType": "piercing" };
const effectOnHit$2 = { "mod": "mod.DEX", "damage": "1d8", "damageType": "piercing" };
const label$19 = "Arbalete repetee";
const SpecialeArbaleteRepetee = {
  id: id$1M,
  name: name$L,
  type: type$D,
  subtype: subtype$8,
  category: category$1e,
  descriptionCourte: descriptionCourte$8,
  descriptionLongue: descriptionLongue$8,
  allowStack: allowStack$8,
  harmonisable: harmonisable$s,
  focalisateur: focalisateur$2,
  weight: weight$y,
  size: size$b,
  value: value$y,
  rarity: rarity$8,
  tags: tags$1r,
  properties: properties$2,
  attack: attack$7,
  damage: damage$7,
  effectOnHit: effectOnHit$2,
  label: label$19
};
const id$1L = "epee-elfique";
const name$K = "Epee elfique";
const type$C = "arme";
const subtype$7 = "speciale";
const category$1d = "melee";
const descriptionCourte$7 = "Lame fine et precise, forgee par les elfes.";
const descriptionLongue$7 = "";
const allowStack$7 = false;
const harmonisable$r = false;
const focalisateur$1 = false;
const weight$x = 1.2;
const size$a = 1;
const value$x = { "gold": 75, "silver": 0, "copper": 0, "platinum": 0 };
const rarity$7 = "rare";
const tags$1q = ["arme", "melee", "slashing", "metal"];
const properties$1 = { "finesse": true, "light": false, "heavy": false, "twoHanded": false, "reach": 1.5, "versatile": null, "thrown": null, "ammunition": false, "loading": false, "reload": null, "range": { "normal": 1.5, "long": 1.5 }, "special": "precision" };
const attack$6 = { "mod": "mod.DEX", "bonus": "bonus_maitrise" };
const damage$6 = { "dice": "1d8", "damageType": "slashing" };
const effectOnHit$1 = { "mod": "mod.DEX", "damage": "1d8", "damageType": "slashing" };
const label$18 = "Epee elfique";
const SpecialeEpeeElfique = {
  id: id$1L,
  name: name$K,
  type: type$C,
  subtype: subtype$7,
  category: category$1d,
  descriptionCourte: descriptionCourte$7,
  descriptionLongue: descriptionLongue$7,
  allowStack: allowStack$7,
  harmonisable: harmonisable$r,
  focalisateur: focalisateur$1,
  weight: weight$x,
  size: size$a,
  value: value$x,
  rarity: rarity$7,
  tags: tags$1q,
  properties: properties$1,
  attack: attack$6,
  damage: damage$6,
  effectOnHit: effectOnHit$1,
  label: label$18
};
const id$1K = "fouet-demon";
const name$J = "Fouet demon";
const type$B = "arme";
const subtype$6 = "speciale";
const category$1c = "melee";
const descriptionCourte$6 = "Fouet d'arme a portee etrange.";
const descriptionLongue$6 = "";
const allowStack$6 = false;
const harmonisable$q = false;
const focalisateur = false;
const weight$w = 1;
const size$9 = 1.3;
const value$w = { "gold": 90, "silver": 0, "copper": 0, "platinum": 0 };
const rarity$6 = "rare";
const tags$1p = ["arme", "melee", "slashing", "leather"];
const properties = { "finesse": true, "light": false, "heavy": false, "twoHanded": false, "reach": 3, "versatile": null, "thrown": null, "ammunition": false, "loading": false, "reload": null, "range": { "normal": 3, "long": 3 }, "special": "reach" };
const attack$5 = { "mod": "mod.DEX", "bonus": "bonus_maitrise" };
const damage$5 = { "dice": "1d6", "damageType": "slashing" };
const effectOnHit = { "mod": "mod.DEX", "damage": "1d6", "damageType": "slashing" };
const label$17 = "Fouet demon";
const SpecialeFouetDemon = {
  id: id$1K,
  name: name$J,
  type: type$B,
  subtype: subtype$6,
  category: category$1c,
  descriptionCourte: descriptionCourte$6,
  descriptionLongue: descriptionLongue$6,
  allowStack: allowStack$6,
  harmonisable: harmonisable$q,
  focalisateur,
  weight: weight$w,
  size: size$9,
  value: value$w,
  rarity: rarity$6,
  tags: tags$1p,
  properties,
  attack: attack$5,
  damage: damage$5,
  effectOnHit,
  label: label$17
};
const WEAPON_MODULES = {
  "./martiale/arc-long-cendre.json": MartialeArcLongCendre,
  "./martiale/arc-long.json": MartialeArcLong,
  "./martiale/epee-longue-brasiere.json": MartialeEpeeLongueBrasiere,
  "./martiale/epee-longue.json": MartialeEpeeLongue,
  "./martiale/hache-bataille-incandescente.json": MartialeHacheBatailleIncandescente,
  "./martiale/hache-bataille.json": MartialeHacheBataille,
  "./monastique/baton.json": MonastiqueBaton,
  "./monastique/kama.json": MonastiqueKama,
  "./monastique/nunchaku.json": MonastiqueNunchaku,
  "./simple/arc-court.json": SimpleArcCourt,
  "./simple/arme-endommagee.json": SimpleArmeEndommagee,
  "./simple/dague.json": SimpleDague,
  "./simple/massue.json": SimpleMassue,
  "./simple/petit-couteau.json": SimplePetitCouteau,
  "./speciale/arbalete-repetee.json": SpecialeArbaleteRepetee,
  "./speciale/epee-elfique.json": SpecialeEpeeElfique,
  "./speciale/fouet-demon.json": SpecialeFouetDemon
};
function normalizeWeaponDamageTypes(def) {
  const damage2 = def.damage;
  const effectOnHit2 = def.effectOnHit;
  const damageTypeId = normalizeDamageType((damage2 == null ? void 0 : damage2.damageType) ?? null);
  const onHitDamageTypeId = normalizeDamageType((effectOnHit2 == null ? void 0 : effectOnHit2.damageType) ?? null);
  if ((damage2 == null ? void 0 : damage2.damageType) && !damageTypeId) {
    console.warn(
      "[weapon-types] Unknown damage type for weapon:",
      def.id,
      "->",
      damage2.damageType
    );
  }
  if ((effectOnHit2 == null ? void 0 : effectOnHit2.damageType) && !onHitDamageTypeId) {
    console.warn(
      "[weapon-types] Unknown on-hit damage type for weapon:",
      def.id,
      "->",
      effectOnHit2.damageType
    );
  }
  return {
    ...def,
    damage: damage2 ? {
      ...damage2,
      damageTypeId
    } : damage2,
    effectOnHit: effectOnHit2 ? {
      ...effectOnHit2,
      damageTypeId: onHitDamageTypeId
    } : effectOnHit2
  };
}
function loadWeaponTypesFromIndex() {
  const indexed = Array.isArray(weaponsIndex.types) ? weaponsIndex.types : [];
  const loaded = [];
  for (const path2 of indexed) {
    const mod = WEAPON_MODULES[path2];
    if (mod) {
      loaded.push(normalizeWeaponDamageTypes(mod));
    } else {
      console.warn("[weapon-types] Type path missing in bundle:", path2);
    }
  }
  if (loaded.length === 0) {
    console.warn("[weapon-types] No weapons loaded from index.json");
  }
  return loaded;
}
const types$7 = ["./human.json", "./elf.json", "./dwarf.json"];
const racesIndex = {
  types: types$7
};
const id$1J = "human";
const label$16 = "Humain";
const description$E = "Polyvalent et adaptable, l'humain apprend vite et s'integre partout.";
const besoin$2 = [];
const actionIds$2 = ["melee-strike", "dash"];
const size$8 = "medium";
const speed$2 = 6;
const traits$5 = [{ "id": "adaptable", "label": "Adaptable", "description": "Choisit une competence au choix." }];
const grants$6 = [{ "kind": "trait", "ids": ["adaptable"] }];
const human = {
  id: id$1J,
  label: label$16,
  description: description$E,
  besoin: besoin$2,
  actionIds: actionIds$2,
  size: size$8,
  speed: speed$2,
  traits: traits$5,
  grants: grants$6
};
const id$1I = "elf";
const label$15 = "Elfe";
const description$D = "Grace et perception affutee, l'elfe a une affinite naturelle avec la magie.";
const besoin$1 = [];
const actionIds$1 = ["melee-strike", "dash"];
const size$7 = "medium";
const speed$1 = 6;
const vision$1 = { "mode": "darkvision", "range": 60 };
const traits$4 = [{ "id": "keen_senses", "label": "Sens aiguises", "description": "Avantage sur les tests de Perception basee sur la vue ou l'ouie." }];
const grants$5 = [{ "kind": "trait", "ids": ["keen_senses"] }];
const elf = {
  id: id$1I,
  label: label$15,
  description: description$D,
  besoin: besoin$1,
  actionIds: actionIds$1,
  size: size$7,
  speed: speed$1,
  vision: vision$1,
  traits: traits$4,
  grants: grants$5
};
const id$1H = "dwarf";
const label$14 = "Nain";
const description$C = "Robuste et endurant, le nain excelle dans la defense et le travail du metal.";
const besoin = [];
const actionIds = ["melee-strike", "dash"];
const size$6 = "medium";
const speed = 5;
const vision = { "mode": "darkvision", "range": 60 };
const traits$3 = [{ "id": "dwarven_resilience", "label": "Endurance naine", "description": "Avantage contre le poison et resistance aux degats de poison." }];
const grants$4 = [{ "kind": "trait", "ids": ["dwarven_resilience"] }];
const dwarf$1 = {
  id: id$1H,
  label: label$14,
  description: description$C,
  besoin,
  actionIds,
  size: size$6,
  speed,
  vision,
  traits: traits$3,
  grants: grants$4
};
const RACE_MODULES = {
  "./human.json": human,
  "./elf.json": elf,
  "./dwarf.json": dwarf$1
};
function loadRaceTypesFromIndex() {
  const indexed = Array.isArray(racesIndex.types) ? racesIndex.types : [];
  const loaded = [];
  for (const path2 of indexed) {
    const mod = RACE_MODULES[path2];
    if (mod) {
      loaded.push(mod);
    } else {
      console.warn("[race-types] Type path missing in bundle:", path2);
    }
  }
  if (loaded.length === 0) {
    console.warn("[race-types] No races loaded from index.json");
  }
  return loaded;
}
const types$6 = ["./Clerc/class.json", "./Clerc/peace-domain.json", "./Guerrier/class.json", "./Guerrier/eldritch-knight.json"];
const classesIndex = {
  types: types$6
};
const id$1G = "cleric";
const label$13 = "Clerc";
const description$B = "Un guide spirituel capable de soigner et de canaliser la puissance divine.";
const hitDie$1 = 8;
const subclassLevel$1 = 1;
const subclassIds$1 = ["peace-domain"];
const proficiencies$1 = { "weapons": ["simple"], "armors": ["legere", "intermediaire", "bouclier"] };
const equipment$3 = ["obj_symbole_sacre"];
const spellcasting$1 = { "ability": "SAG", "preparation": "prepared", "storage": "memory", "focusTypes": ["holy_symbol"], "spellFilterTags": ["cleric"], "freePreparedFromGrants": true, "casterProgression": "full", "slotsByLevel": { "1": [2, 0, 0, 0, 0, 0, 0, 0, 0], "2": [3, 0, 0, 0, 0, 0, 0, 0, 0], "3": [4, 2, 0, 0, 0, 0, 0, 0, 0], "4": [4, 3, 0, 0, 0, 0, 0, 0, 0], "5": [4, 3, 2, 0, 0, 0, 0, 0, 0], "6": [4, 3, 3, 0, 0, 0, 0, 0, 0], "7": [4, 3, 3, 1, 0, 0, 0, 0, 0], "8": [4, 3, 3, 2, 0, 0, 0, 0, 0], "9": [4, 3, 3, 3, 1, 0, 0, 0, 0], "10": [4, 3, 3, 3, 2, 0, 0, 0, 0], "11": [4, 3, 3, 3, 2, 1, 0, 0, 0], "12": [4, 3, 3, 3, 2, 1, 0, 0, 0], "13": [4, 3, 3, 3, 2, 1, 1, 0, 0], "14": [4, 3, 3, 3, 2, 1, 1, 0, 0], "15": [4, 3, 3, 3, 2, 1, 1, 1, 0], "16": [4, 3, 3, 3, 2, 1, 1, 1, 0], "17": [4, 3, 3, 3, 2, 1, 1, 1, 1], "18": [4, 3, 3, 3, 3, 1, 1, 1, 1], "19": [4, 3, 3, 3, 3, 2, 1, 1, 1], "20": [4, 3, 3, 3, 3, 2, 2, 1, 1] } };
const progression$3 = { "1": { "grants": [{ "kind": "feature", "ids": ["divine-order"] }], "description": "Ordre divin (Protecteur ou Thaumaturge) et lancement de sorts geres ailleurs." }, "2": { "grants": [{ "kind": "feature", "ids": ["channel-divinity"] }, { "kind": "feature", "ids": ["divine-spark"] }, { "kind": "feature", "ids": ["turn-undead"] }], "description": "Conduit divin: Etincelle divine et Renvoi des morts-vivants." }, "4": { "grants": [{ "kind": "bonus", "ids": ["asi-or-feat"] }], "description": "Amelioration de caracteristiques ou choix de don." }, "8": { "grants": [{ "kind": "bonus", "ids": ["asi-or-feat"] }], "description": "Amelioration de caracteristiques ou choix de don." }, "10": { "grants": [{ "kind": "feature", "ids": ["divine-intervention"] }], "description": "Intervention divine." }, "12": { "grants": [{ "kind": "bonus", "ids": ["asi-or-feat"] }], "description": "Amelioration de caracteristiques ou choix de don." }, "16": { "grants": [{ "kind": "bonus", "ids": ["asi-or-feat"] }], "description": "Amelioration de caracteristiques ou choix de don." }, "19": { "grants": [{ "kind": "bonus", "ids": ["asi-or-feat"] }], "description": "Amelioration de caracteristiques choix de don." }, "20": { "grants": [{ "kind": "feature", "ids": ["divine-intervention"] }], "description": "Intervention divine amelioree." } };
const ClercClass = {
  id: id$1G,
  label: label$13,
  description: description$B,
  hitDie: hitDie$1,
  subclassLevel: subclassLevel$1,
  subclassIds: subclassIds$1,
  proficiencies: proficiencies$1,
  equipment: equipment$3,
  spellcasting: spellcasting$1,
  progression: progression$3
};
const id$1F = "peace-domain";
const classId$1 = "cleric";
const label$12 = "Domaine de la Paix";
const description$A = "Lien divin entre allies, soutien defensif et magie de protection.";
const progression$2 = { "1": { "grants": [{ "kind": "feature", "ids": ["peace-bond"] }, { "kind": "spell", "ids": ["heroism", "sanctuary", "rayon-de-feu"] }], "description": "Lien de paix et sorts disponibles : Heroisme, Sanctuaire, Rayon de feu." }, "2": { "grants": [{ "kind": "feature", "ids": ["balm-of-peace"] }], "description": "Baume de la paix." }, "3": { "grants": [{ "kind": "spell", "ids": ["aid", "warding-bond", "vague-ardente"] }], "description": "Sorts disponibles : Aide, Lien protecteur, Vague ardente." }, "5": { "grants": [{ "kind": "spell", "ids": ["beacon-of-hope", "sending"] }], "description": "Sorts disponibles : Flamme d'espoir, Message." }, "6": { "grants": [{ "kind": "feature", "ids": ["protective-bond"] }], "description": "Lien protecteur." }, "7": { "grants": [{ "kind": "spell", "ids": ["aura-of-purity", "resilient-sphere"] }], "description": "Sorts disponibles : Aura de purete, Sphere resiliente." }, "9": { "grants": [{ "kind": "spell", "ids": ["greater-restoration", "rarys-telepathic-bond"] }], "description": "Sorts disponibles : Restauration superieure, Lien telepathique de Rary." }, "17": { "grants": [{ "kind": "feature", "ids": ["expansive-bond"] }], "description": "Lien expansif." } };
const ClercPeaceDomain = {
  id: id$1F,
  classId: classId$1,
  label: label$12,
  description: description$A,
  progression: progression$2
};
const id$1E = "fighter";
const label$11 = "Guerrier";
const description$z = "Un combattant maitre des armes, robuste et polyvalent sur le champ de bataille.";
const hitDie = 10;
const subclassLevel = 3;
const subclassIds = ["eldritch-knight"];
const proficiencies = { "weapons": ["simple", "martiale"], "armors": ["legere", "intermediaire", "lourde", "bouclier"] };
const progression$1 = { "1": { "grants": [{ "kind": "feature", "ids": ["fighting-style"] }, { "kind": "feature", "ids": ["second-wind-feature"] }, { "kind": "action", "ids": ["second-wind"] }, { "kind": "feature", "ids": ["weapon-mastery"] }], "description": "Style de combat, Second souffle et Bottes d arme." }, "2": { "grants": [{ "kind": "feature", "ids": ["action-surge"] }, { "kind": "feature", "ids": ["tactical-mind"] }], "description": "Fougue et Sens tactique." }, "3": { "grants": [], "description": "Acces a la sous-classe de Guerrier." }, "4": { "grants": [{ "kind": "bonus", "ids": ["asi-or-feat"] }], "description": "Amelioration de caracteristiques ou choix de don." }, "5": { "grants": [{ "kind": "feature", "ids": ["extra-attack"] }, { "kind": "feature", "ids": ["tactical-shift"] }], "description": "Attaque supplementaire et Decalage tactique." }, "6": { "grants": [{ "kind": "bonus", "ids": ["asi-or-feat"] }], "description": "Amelioration de caracteristiques ou choix de don." }, "7": { "grants": [], "description": "Capacite de sous-classe." }, "8": { "grants": [{ "kind": "bonus", "ids": ["asi-or-feat"] }], "description": "Amelioration de caracteristiques ou choix de don." }, "9": { "grants": [{ "kind": "feature", "ids": ["indomitable"] }, { "kind": "feature", "ids": ["tactical-mastery"] }], "description": "Inflexible et Botte tactique." }, "10": { "grants": [], "description": "Capacite de sous-classe." }, "11": { "grants": [{ "kind": "feature", "ids": ["extra-attack-2"] }], "description": "Attaque supplementaire (2)." }, "12": { "grants": [{ "kind": "bonus", "ids": ["asi-or-feat"] }], "description": "Amelioration de caracteristiques ou choix de don." }, "13": { "grants": [{ "kind": "feature", "ids": ["indomitable-2"] }], "description": "Inflexible (2 utilisations)." }, "14": { "grants": [{ "kind": "bonus", "ids": ["asi-or-feat"] }], "description": "Amelioration de caracteristiques ou choix de don." }, "15": { "grants": [], "description": "Capacite de sous-classe." }, "16": { "grants": [{ "kind": "bonus", "ids": ["asi-or-feat"] }], "description": "Amelioration de caracteristiques ou choix de don." }, "17": { "grants": [{ "kind": "feature", "ids": ["action-surge-2"] }, { "kind": "feature", "ids": ["indomitable-3"] }], "description": "Fougue (2 utilisations) et Inflexible (3 utilisations)." }, "18": { "grants": [], "description": "Capacite de sous-classe." }, "19": { "grants": [{ "kind": "bonus", "ids": ["asi-or-feat"] }], "description": "Amelioration de caracteristiques ou choix de don." }, "20": { "grants": [{ "kind": "feature", "ids": ["extra-attack-3"] }], "description": "Attaque supplementaire (3)." } };
const GuerrierClass = {
  id: id$1E,
  label: label$11,
  description: description$z,
  hitDie,
  subclassLevel,
  subclassIds,
  proficiencies,
  progression: progression$1
};
const id$1D = "eldritch-knight";
const classId = "fighter";
const label$10 = "Chevalier Occulte";
const description$y = "Combattant martial avec magie de magicien, abjuration et evocation.";
const spellcasting = { "ability": "INT", "preparation": "known", "storage": "memory", "focusTypes": ["arcane_focus", "component_pouch"], "casterProgression": "third", "slotsByLevel": { "1": [2, 0, 0, 0, 0, 0, 0, 0, 0], "2": [3, 0, 0, 0, 0, 0, 0, 0, 0], "3": [4, 2, 0, 0, 0, 0, 0, 0, 0], "4": [4, 3, 0, 0, 0, 0, 0, 0, 0], "5": [4, 3, 2, 0, 0, 0, 0, 0, 0], "6": [4, 3, 3, 0, 0, 0, 0, 0, 0], "7": [4, 3, 3, 1, 0, 0, 0, 0, 0], "8": [4, 3, 3, 2, 0, 0, 0, 0, 0], "9": [4, 3, 3, 3, 1, 0, 0, 0, 0], "10": [4, 3, 3, 3, 2, 0, 0, 0, 0], "11": [4, 3, 3, 3, 2, 1, 0, 0, 0], "12": [4, 3, 3, 3, 2, 1, 0, 0, 0], "13": [4, 3, 3, 3, 2, 1, 1, 0, 0], "14": [4, 3, 3, 3, 2, 1, 1, 0, 0], "15": [4, 3, 3, 3, 2, 1, 1, 1, 0], "16": [4, 3, 3, 3, 2, 1, 1, 1, 0], "17": [4, 3, 3, 3, 2, 1, 1, 1, 1], "18": [4, 3, 3, 3, 3, 1, 1, 1, 1], "19": [4, 3, 3, 3, 3, 2, 1, 1, 1], "20": [4, 3, 3, 3, 3, 2, 2, 1, 1] } };
const progression = { "3": { "grants": [{ "kind": "feature", "ids": ["eldritch-knight-spellcasting"] }], "description": "Debut de la magie de Chevalier Occulte (cantrips/sorts connus de magicien, orientation abjuration/evocation)." }, "7": { "grants": [{ "kind": "feature", "ids": ["war-magic"] }], "description": "Magie de guerre." }, "10": { "grants": [{ "kind": "feature", "ids": ["eldritch-strike"] }], "description": "Frappe eldritch." }, "15": { "grants": [{ "kind": "feature", "ids": ["arcane-charge"] }], "description": "Charge arcanique." }, "18": { "grants": [{ "kind": "feature", "ids": ["improved-war-magic"] }], "description": "Maitre de la magie de guerre." } };
const GuerrierEldritchKnight = {
  id: id$1D,
  classId,
  label: label$10,
  description: description$y,
  spellcasting,
  progression
};
const CLASS_MODULES = {
  "./Clerc/class.json": ClercClass,
  "./Guerrier/class.json": GuerrierClass
};
const SUBCLASS_MODULES = {
  "./Clerc/peace-domain.json": ClercPeaceDomain,
  "./Guerrier/eldritch-knight.json": GuerrierEldritchKnight
};
function loadClassTypesFromIndex() {
  const indexed = Array.isArray(classesIndex.types) ? classesIndex.types : [];
  const loaded = [];
  for (const path2 of indexed) {
    if (path2.toLowerCase().includes("class.json")) {
      const mod = CLASS_MODULES[path2];
      if (mod) {
        loaded.push(mod);
      } else {
        console.warn("[class-types] Type path missing in bundle:", path2);
      }
    }
  }
  if (loaded.length === 0) {
    console.warn("[class-types] No classes loaded from index.json");
  }
  return loaded;
}
function loadSubclassTypesFromIndex() {
  const indexed = Array.isArray(classesIndex.types) ? classesIndex.types : [];
  const loaded = [];
  for (const path2 of indexed) {
    if (!path2.toLowerCase().includes("class.json")) {
      const mod = SUBCLASS_MODULES[path2];
      if (mod) {
        loaded.push(mod);
      } else {
        console.warn("[class-types] Subclass path missing in bundle:", path2);
      }
    }
  }
  if (loaded.length === 0) {
    console.warn("[class-types] No subclasses loaded from index.json");
  }
  return loaded;
}
const types$5 = ["./apprenti-academique.json", "./enfant-des-rues.json", "./veteran-de-guerre.json"];
const backgroundsIndex = {
  types: types$5
};
const id$1C = "apprenti-academique";
const label$$ = "Apprenti Academique";
const description$x = "Eleve d'une academie ou d'un maitre, curieux, studieux et avide de savoir.";
const equipment$2 = ["obj_grimoire", "obj_plume_encre", "obj_tenue_academique", "obj_bourse", "object:obj_piece_or:10", "obj_besace"];
const grants$3 = [{ "kind": "skill", "ids": ["arcanes", "histoire"] }, { "kind": "tool", "ids": ["outils_artisan"] }, { "kind": "language-choice", "ids": [], "meta": { "count": 2 } }, { "kind": "feature", "ids": ["acces-au-savoir"], "meta": { "label": "Acces au Savoir", "description": "Tu sais ou trouver l'information et obtenir un acces raisonnable aux sources savantes." } }];
const traits$2 = { "personality": ["Je corrige instinctivement les erreurs des autres.", "J'ai une curiosite insatiable.", "Je parle parfois trop techniquement.", "Je prends des notes sur tout.", "Je suis fascine par l'inconnu.", "Je doute souvent de mes capacites pratiques.", "J'adore debattre.", "Je suis plus a l'aise avec les livres qu'avec les gens."], "ideals": ["Connaissance  Le savoir est la cle de tout.", "Progres  Le monde doit evoluer.", "Verite  Les faits comptent plus que les croyances.", "Responsabilite  Le savoir impose un devoir.", "Pouvoir  Comprendre, c'est dominer.", "Transmission  Le savoir doit etre partage."], "bond": "Mon maitre a disparu, laissant des recherches inachevees.", "flaw": "Je sous-estime souvent les dangers pratiques." };
const academic = {
  id: id$1C,
  label: label$$,
  description: description$x,
  equipment: equipment$2,
  grants: grants$3,
  traits: traits$2
};
const id$1B = "enfant-des-rues";
const label$_ = "Enfant des Rues";
const description$w = "Survivant des ruelles et des toits, malin, discret et opportuniste.";
const equipment$1 = ["obj_petit_couteau", "obj_bourse", "object:obj_piece_or:10", "obj_vetements_communs", "obj_souvenir_vole", "obj_sac_a_dos"];
const grants$2 = [{ "kind": "skill", "ids": ["discretion", "escamotage"] }, { "kind": "tool", "ids": ["outils_autres"] }, { "kind": "tool-choice", "ids": [], "meta": { "count": 1, "options": ["outils_instruments", "outils_jeux"] } }, { "kind": "language-choice", "ids": [], "meta": { "count": 1 } }, { "kind": "feature", "ids": ["reseau-des-ombres"], "meta": { "label": "Reseau des Ombres", "description": "Tu peux trouver un contact des bas-fonds pour une aide simple ou une info mineure." } }];
const traits$1 = { "personality": ["Je me fie toujours a mon instinct.", "J'ai du mal a faire confiance, mais quand c'est fait, c'est total.", "Je plaisante quand la situation devient tendue.", "Je garde toujours un plan de secours.", "Je suis mefiant envers l'autorite.", "J'observe tout, meme quand je semble distrait.", "Je deteste devoir quelque chose a quelqu'un.", "Je prefere agir seul, mais j'ai besoin d'un groupe."], "ideals": ["Liberte  Personne ne m'enchainera jamais.", "Survie  Les faibles n'ont pas le luxe de la morale.", "Loyaute  Mon clan passe avant tout.", "Ambition  Je merite mieux que ce que j'ai eu.", "Justice  Personne ne devrait vivre comme j'ai vecu.", "Opportunite  Chaque instant est une chance a saisir."], "bond": "Quelqu'un des rues m'a sauve la vie, et je lui dois beaucoup.", "flaw": "Je prends parfois des risques inutiles pour un gain rapide." };
const streetKid = {
  id: id$1B,
  label: label$_,
  description: description$w,
  equipment: equipment$1,
  grants: grants$2,
  traits: traits$1
};
const id$1A = "veteran-de-guerre";
const label$Z = "Veteran de Guerre";
const description$v = "Ancien soldat marque par la guerre, discipline et endurance a toute epreuve.";
const equipment = ["obj_arme_endommagee", "obj_insigne_unite", "obj_vetements_voyage", "obj_bourse", "object:obj_piece_or:10", "obj_sac_voyage"];
const grants$1 = [{ "kind": "skill", "ids": ["athletisme", "intimidation"] }, { "kind": "tool", "ids": ["outils_vehicules"] }, { "kind": "tool-choice", "ids": [], "meta": { "count": 1, "options": ["outils_jeux"] } }, { "kind": "language-choice", "ids": [], "meta": { "count": 1 } }, { "kind": "feature", "ids": ["freres-et-soeurs-d-armes"], "meta": { "label": "Freres et Soeurs d'Armes", "description": "Tu peux obtenir abri, aide basique ou informations militaires d'anciens soldats." } }];
const traits = { "personality": ["Je reste calme en toute situation.", "J'analyse toujours le terrain.", "J'ai du mal a me detendre.", "Je protege instinctivement les plus faibles.", "Je deteste le gaspillage.", "Je parle peu, mais efficacement.", "Je suis hante par mes souvenirs.", "Je respecte la chaine de commandement."], "ideals": ["Devoir  On n'abandonne jamais sa mission.", "Protection  Les innocents doivent etre defendus.", "Honneur  Mes actes me definissent.", "Redemption  Je veux reparer le passe.", "Ordre  Le chaos mene a la souffrance.", "Fraternite  Aucun combat ne se gagne seul."], "bond": "Un ancien compagnon d'armes compte toujours sur moi.", "flaw": "Je reagis parfois trop violemment face aux menaces." };
const veteran = {
  id: id$1A,
  label: label$Z,
  description: description$v,
  equipment,
  grants: grants$1,
  traits
};
const BACKGROUND_MODULES = {
  "./apprenti-academique.json": academic,
  "./enfant-des-rues.json": streetKid,
  "./veteran-de-guerre.json": veteran
};
function loadBackgroundTypesFromIndex() {
  const indexed = Array.isArray(backgroundsIndex.types) ? backgroundsIndex.types : [];
  const loaded = [];
  for (const path2 of indexed) {
    const mod = BACKGROUND_MODULES[path2];
    if (mod) {
      loaded.push(mod);
    } else {
      console.warn("[backgrounds] Type path missing in bundle:", path2);
    }
  }
  if (loaded.length === 0) {
    console.warn("[backgrounds] No backgrounds loaded from index.json");
  }
  return loaded;
}
const types$4 = ["./commun.json", "./elfique.json", "./nain.json", "./halfelin.json", "./gnome.json", "./orc.json"];
const languagesIndex = {
  types: types$4
};
const id$1z = "commun";
const label$Y = "Commun";
const common = {
  id: id$1z,
  label: label$Y
};
const id$1y = "elfique";
const label$X = "Elfique";
const elvish = {
  id: id$1y,
  label: label$X
};
const id$1x = "nain";
const label$W = "Nain";
const dwarf = {
  id: id$1x,
  label: label$W
};
const id$1w = "halfelin";
const label$V = "Halfelin";
const halfling = {
  id: id$1w,
  label: label$V
};
const id$1v = "gnome";
const label$U = "Gnome";
const gnome = {
  id: id$1v,
  label: label$U
};
const id$1u = "orc";
const label$T = "Orc";
const orc = {
  id: id$1u,
  label: label$T
};
const LANGUAGE_MODULES = {
  "./commun.json": common,
  "./elfique.json": elvish,
  "./nain.json": dwarf,
  "./halfelin.json": halfling,
  "./gnome.json": gnome,
  "./orc.json": orc
};
function loadLanguageTypesFromIndex() {
  const indexed = Array.isArray(languagesIndex.types) ? languagesIndex.types : [];
  const loaded = [];
  for (const path2 of indexed) {
    const mod = LANGUAGE_MODULES[path2];
    if (mod) {
      loaded.push(mod);
    } else {
      console.warn("[languages] Type path missing in bundle:", path2);
    }
  }
  if (loaded.length === 0) {
    console.warn("[languages] No languages loaded from index.json");
  }
  return loaded;
}
const types$3 = ["./outils-artisan.json", "./outils-autres.json", "./outils-instruments.json", "./outils-jeux.json", "./outils-vehicules.json"];
const toolsIndex = {
  types: types$3
};
const id$1t = "outils_artisan";
const label$S = "Outils d'artisan";
const type$A = "tool";
const category$1b = "artisan";
const description$u = "Categorie regroupant les outils d'artisan (alchimiste, forgeron, menuisier, etc.).";
const OutilsArtisan = {
  id: id$1t,
  label: label$S,
  type: type$A,
  category: category$1b,
  description: description$u
};
const id$1s = "outils_autres";
const label$R = "Autres outils";
const type$z = "tool";
const category$1a = "misc";
const description$t = "Categorie des autres outils (deguisement, contrefacon, herboriste, empoisonneur, voleur, navigateur).";
const OutilsAutres = {
  id: id$1s,
  label: label$R,
  type: type$z,
  category: category$1a,
  description: description$t
};
const id$1r = "outils_instruments";
const label$Q = "Instruments de musique";
const type$y = "tool";
const category$19 = "music";
const description$s = "Categorie des instruments de musique.";
const OutilsInstruments = {
  id: id$1r,
  label: label$Q,
  type: type$y,
  category: category$19,
  description: description$s
};
const id$1q = "outils_jeux";
const label$P = "Boite de jeux";
const type$x = "tool";
const category$18 = "games";
const description$r = "Categorie des jeux (des, cartes, echecs, etc.).";
const OutilsJeux = {
  id: id$1q,
  label: label$P,
  type: type$x,
  category: category$18,
  description: description$r
};
const id$1p = "outils_vehicules";
const label$O = "Vehicules";
const type$w = "tool";
const category$17 = "vehicles";
const description$q = "Categorie des vehicules (terrestres, aquatiques).";
const OutilsVehicules = {
  id: id$1p,
  label: label$O,
  type: type$w,
  category: category$17,
  description: description$q
};
const TOOL_MODULES = {
  "./outils-artisan.json": OutilsArtisan,
  "./outils-autres.json": OutilsAutres,
  "./outils-instruments.json": OutilsInstruments,
  "./outils-jeux.json": OutilsJeux,
  "./outils-vehicules.json": OutilsVehicules
};
function loadToolItemsFromIndex() {
  const indexed = Array.isArray(toolsIndex.types) ? toolsIndex.types : [];
  const loaded = [];
  for (const path2 of indexed) {
    const mod = TOOL_MODULES[path2];
    if (mod) {
      loaded.push(mod);
    } else {
      console.warn("[tools] Type path missing in bundle:", path2);
    }
  }
  if (loaded.length === 0) {
    console.warn("[tools] No tools loaded from index.json");
  }
  return loaded;
}
const types$2 = ["./contenants/obj-besace.json", "./contenants/obj-bourse.json", "./contenants/obj-carquois.json", "./contenants/obj-sac-a-dos.json", "./contenants/obj-sac-voyage.json", "./obj-grimoire.json", "./obj-insigne-unite.json", "./obj-plume-encre.json", "./obj-souvenir-vole.json", "./obj-symbole-sacre.json", "./obj-tenue-academique.json", "./obj-torche.json", "./obj-vetements-communs.json", "./obj-vetements-voyage.json", "./piece-argent.json", "./piece-cuivre.json", "./piece-or.json", "./piece-platine.json"];
const objectsIndex = {
  types: types$2
};
const id$1o = "obj_besace";
const label$N = "Besace";
const type$v = "object";
const category$16 = "pack";
const weight$v = 0.8;
const capacityWeight$4 = 10;
const tags$1o = ["sac", "paquetage", "ammo_container", "cloth"];
const description$p = "Petite besace souple pour le quotidien.";
const value$v = { "platinum": 0, "gold": 1, "silver": 0, "copper": 0 };
const harmonisable$p = false;
const ContenantsObjBesace = {
  id: id$1o,
  label: label$N,
  type: type$v,
  category: category$16,
  weight: weight$v,
  capacityWeight: capacityWeight$4,
  tags: tags$1o,
  description: description$p,
  value: value$v,
  harmonisable: harmonisable$p
};
const id$1n = "obj_bourse";
const label$M = "Bourse";
const type$u = "object";
const category$15 = "pack";
const weight$u = 0.2;
const value$u = { "platinum": 0, "gold": 1, "silver": 0, "copper": 0 };
const capacityWeight$3 = 5;
const tags$1n = ["bourse", "sac", "paquetage", "leather"];
const description$o = "Petite bourse destinee aux pieces et petits objets.";
const harmonisable$o = false;
const ContenantsObjBourse = {
  id: id$1n,
  label: label$M,
  type: type$u,
  category: category$15,
  weight: weight$u,
  value: value$u,
  capacityWeight: capacityWeight$3,
  tags: tags$1n,
  description: description$o,
  harmonisable: harmonisable$o
};
const id$1m = "obj_carquois";
const label$L = "Carquois";
const type$t = "object";
const category$14 = "pack";
const weight$t = 0.5;
const capacityWeight$2 = 3;
const tags$1m = ["conteneur", "ammo_container", "carquois", "leather"];
const description$n = "Carquois pour transporter des munitions.";
const value$t = { "platinum": 0, "gold": 1, "silver": 0, "copper": 0 };
const harmonisable$n = false;
const ContenantsObjCarquois = {
  id: id$1m,
  label: label$L,
  type: type$t,
  category: category$14,
  weight: weight$t,
  capacityWeight: capacityWeight$2,
  tags: tags$1m,
  description: description$n,
  value: value$t,
  harmonisable: harmonisable$n
};
const id$1l = "obj_sac_a_dos";
const label$K = "Sac a dos";
const type$s = "object";
const category$13 = "pack";
const weight$s = 1.5;
const capacityWeight$1 = 18;
const tags$1l = ["sac", "paquetage", "ammo_container", "cloth"];
const description$m = "Sac a dos pratique pour transporter du materiel.";
const value$s = { "platinum": 0, "gold": 2, "silver": 0, "copper": 0 };
const harmonisable$m = false;
const ContenantsObjSacADos = {
  id: id$1l,
  label: label$K,
  type: type$s,
  category: category$13,
  weight: weight$s,
  capacityWeight: capacityWeight$1,
  tags: tags$1l,
  description: description$m,
  value: value$s,
  harmonisable: harmonisable$m
};
const id$1k = "obj_sac_voyage";
const label$J = "Sac de voyage";
const type$r = "object";
const category$12 = "pack";
const weight$r = 2;
const capacityWeight = 25;
const tags$1k = ["sac", "paquetage", "ammo_container", "cloth"];
const description$l = "Sac robuste pour longs deplacements.";
const value$r = { "platinum": 0, "gold": 4, "silver": 0, "copper": 0 };
const harmonisable$l = false;
const ContenantsObjSacVoyage = {
  id: id$1k,
  label: label$J,
  type: type$r,
  category: category$12,
  weight: weight$r,
  capacityWeight,
  tags: tags$1k,
  description: description$l,
  value: value$r,
  harmonisable: harmonisable$l
};
const id$1j = "obj_grimoire";
const label$I = "Grimoire ou carnet de recherches";
const type$q = "object";
const category$11 = "misc";
const weight$q = 1;
const tags$1j = ["academique", "paper"];
const description$k = "Notes, formules et recherches personnelles.";
const value$q = { "platinum": 0, "gold": 5, "silver": 0, "copper": 0 };
const harmonisable$k = false;
const ObjGrimoire = {
  id: id$1j,
  label: label$I,
  type: type$q,
  category: category$11,
  weight: weight$q,
  tags: tags$1j,
  description: description$k,
  value: value$q,
  harmonisable: harmonisable$k
};
const id$1i = "obj_insigne_unite";
const label$H = "Insigne d'ancienne unite";
const type$p = "object";
const category$10 = "jewel";
const weight$p = 0.1;
const tags$1i = ["insigne", "militaire", "metal"];
const description$j = "Symbole d'appartenance a une ancienne unite.";
const value$p = { "platinum": 0, "gold": 0, "silver": 0, "copper": 0 };
const harmonisable$j = false;
const ObjInsigneUnite = {
  id: id$1i,
  label: label$H,
  type: type$p,
  category: category$10,
  weight: weight$p,
  tags: tags$1i,
  description: description$j,
  value: value$p,
  harmonisable: harmonisable$j
};
const id$1h = "obj_plume_encre";
const label$G = "Plume et encre";
const type$o = "object";
const category$$ = "misc";
const weight$o = 0.2;
const tags$1h = ["ecriture", "paper"];
const description$i = "Outils de base pour ecrire et prendre des notes.";
const value$o = { "platinum": 0, "gold": 1, "silver": 0, "copper": 0 };
const harmonisable$i = false;
const ObjPlumeEncre = {
  id: id$1h,
  label: label$G,
  type: type$o,
  category: category$$,
  weight: weight$o,
  tags: tags$1h,
  description: description$i,
  value: value$o,
  harmonisable: harmonisable$i
};
const id$1g = "obj_souvenir_vole";
const label$F = "Souvenir d'enfance vole";
const type$n = "object";
const category$_ = "jewel";
const weight$n = 0.1;
const tags$1g = ["souvenir", "trinket"];
const description$h = "Petit objet sentimental, sans grande valeur marchande.";
const value$n = { "platinum": 0, "gold": 0, "silver": 0, "copper": 0 };
const harmonisable$h = false;
const ObjSouvenirVole = {
  id: id$1g,
  label: label$F,
  type: type$n,
  category: category$_,
  weight: weight$n,
  tags: tags$1g,
  description: description$h,
  value: value$n,
  harmonisable: harmonisable$h
};
const id$1f = "obj_symbole_sacre";
const label$E = "Symbole sacre";
const type$m = "object";
const category$Z = "necklace";
const weight$m = 1;
const tags$1f = ["holy_symbol", "metal"];
const description$g = "Symbole sacre utilise comme focalisateur divin.";
const value$m = { "platinum": 0, "gold": 5, "silver": 0, "copper": 0 };
const harmonisable$g = false;
const ObjSymboleSacre = {
  id: id$1f,
  label: label$E,
  type: type$m,
  category: category$Z,
  weight: weight$m,
  tags: tags$1f,
  description: description$g,
  value: value$m,
  harmonisable: harmonisable$g
};
const id$1e = "obj_tenue_academique";
const label$D = "Tenue academique";
const type$l = "object";
const category$Y = "clothing_body";
const weight$l = 1.5;
const tags$1e = ["vetement", "cloth"];
const description$f = "Robe ou tenue propre aux milieux savants.";
const value$l = { "platinum": 0, "gold": 2, "silver": 0, "copper": 0 };
const harmonisable$f = false;
const ObjTenueAcademique = {
  id: id$1e,
  label: label$D,
  type: type$l,
  category: category$Y,
  weight: weight$l,
  tags: tags$1e,
  description: description$f,
  value: value$l,
  harmonisable: harmonisable$f
};
const id$1d = "obj_torche";
const label$C = "Torche";
const type$k = "object";
const category$X = "gear";
const weight$k = 0.5;
const tags$1d = ["torche", "consommable", "wood"];
const description$e = "Torche simple pour eclairer.";
const value$k = { "platinum": 0, "gold": 0, "silver": 0, "copper": 1 };
const harmonisable$e = false;
const ObjTorche = {
  id: id$1d,
  label: label$C,
  type: type$k,
  category: category$X,
  weight: weight$k,
  tags: tags$1d,
  description: description$e,
  value: value$k,
  harmonisable: harmonisable$e
};
const id$1c = "obj_vetements_communs";
const label$B = "Vetements communs";
const type$j = "object";
const category$W = "clothing_body";
const weight$j = 1.5;
const tags$1c = ["vetement", "cloth"];
const description$d = "Tenue simple et pratique.";
const value$j = { "platinum": 0, "gold": 0.5, "silver": 0, "copper": 0 };
const harmonisable$d = false;
const ObjVetementsCommuns = {
  id: id$1c,
  label: label$B,
  type: type$j,
  category: category$W,
  weight: weight$j,
  tags: tags$1c,
  description: description$d,
  value: value$j,
  harmonisable: harmonisable$d
};
const id$1b = "obj_vetements_voyage";
const label$A = "Vetements de voyage";
const type$i = "object";
const category$V = "clothing_body";
const weight$i = 2;
const tags$1b = ["vetement", "cloth"];
const description$c = "Tenue robuste pour le voyage.";
const value$i = { "platinum": 0, "gold": 1, "silver": 0, "copper": 0 };
const harmonisable$c = false;
const ObjVetementsVoyage = {
  id: id$1b,
  label: label$A,
  type: type$i,
  category: category$V,
  weight: weight$i,
  tags: tags$1b,
  description: description$c,
  value: value$i,
  harmonisable: harmonisable$c
};
const id$1a = "obj_piece_argent";
const label$z = "Piece d'argent";
const type$h = "object";
const category$U = "currency";
const weight$h = 0.01;
const value$h = { "platinum": 0, "gold": 0, "silver": 1, "copper": 0 };
const tags$1a = ["monnaie", "piece", "metal"];
const description$b = "Piece d'argent.";
const harmonisable$b = false;
const PieceArgent = {
  id: id$1a,
  label: label$z,
  type: type$h,
  category: category$U,
  weight: weight$h,
  value: value$h,
  tags: tags$1a,
  description: description$b,
  harmonisable: harmonisable$b
};
const id$19 = "obj_piece_cuivre";
const label$y = "Piece de cuivre";
const type$g = "object";
const category$T = "currency";
const weight$g = 0.01;
const value$g = { "platinum": 0, "gold": 0, "silver": 0, "copper": 1 };
const tags$19 = ["monnaie", "piece", "metal"];
const description$a = "Piece de cuivre.";
const harmonisable$a = false;
const PieceCuivre = {
  id: id$19,
  label: label$y,
  type: type$g,
  category: category$T,
  weight: weight$g,
  value: value$g,
  tags: tags$19,
  description: description$a,
  harmonisable: harmonisable$a
};
const id$18 = "obj_piece_or";
const label$x = "Piece d'or";
const type$f = "object";
const category$S = "currency";
const weight$f = 0.01;
const value$f = { "platinum": 0, "gold": 1, "silver": 0, "copper": 0 };
const tags$18 = ["monnaie", "piece", "metal"];
const description$9 = "Piece d'or.";
const harmonisable$9 = false;
const PieceOr = {
  id: id$18,
  label: label$x,
  type: type$f,
  category: category$S,
  weight: weight$f,
  value: value$f,
  tags: tags$18,
  description: description$9,
  harmonisable: harmonisable$9
};
const id$17 = "obj_piece_platine";
const label$w = "Piece de platine";
const type$e = "object";
const category$R = "currency";
const weight$e = 0.01;
const value$e = { "platinum": 1, "gold": 0, "silver": 0, "copper": 0 };
const tags$17 = ["monnaie", "piece", "metal"];
const description$8 = "Piece de platine.";
const harmonisable$8 = false;
const PiecePlatine = {
  id: id$17,
  label: label$w,
  type: type$e,
  category: category$R,
  weight: weight$e,
  value: value$e,
  tags: tags$17,
  description: description$8,
  harmonisable: harmonisable$8
};
const OBJECT_MODULES = {
  "./contenants/obj-besace.json": ContenantsObjBesace,
  "./contenants/obj-bourse.json": ContenantsObjBourse,
  "./contenants/obj-carquois.json": ContenantsObjCarquois,
  "./contenants/obj-sac-a-dos.json": ContenantsObjSacADos,
  "./contenants/obj-sac-voyage.json": ContenantsObjSacVoyage,
  "./obj-grimoire.json": ObjGrimoire,
  "./obj-insigne-unite.json": ObjInsigneUnite,
  "./obj-plume-encre.json": ObjPlumeEncre,
  "./obj-souvenir-vole.json": ObjSouvenirVole,
  "./obj-symbole-sacre.json": ObjSymboleSacre,
  "./obj-tenue-academique.json": ObjTenueAcademique,
  "./obj-torche.json": ObjTorche,
  "./obj-vetements-communs.json": ObjVetementsCommuns,
  "./obj-vetements-voyage.json": ObjVetementsVoyage,
  "./piece-argent.json": PieceArgent,
  "./piece-cuivre.json": PieceCuivre,
  "./piece-or.json": PieceOr,
  "./piece-platine.json": PiecePlatine
};
function loadObjectItemsFromIndex() {
  const indexed = Array.isArray(objectsIndex.types) ? objectsIndex.types : [];
  const loaded = [];
  for (const path2 of indexed) {
    const mod = OBJECT_MODULES[path2];
    if (mod) {
      loaded.push(mod);
    } else {
      console.warn("[objects] Type path missing in bundle:", path2);
    }
  }
  if (loaded.length === 0) {
    console.warn("[objects] No objects loaded from index.json");
  }
  return loaded;
}
const types$1 = ["./armure-gardien-runique.json", "./bouclier.json", "./chemise-mailles.json", "./cotte-mailles.json", "./cuir-cloute.json", "./cuir.json", "./demi-plaque.json", "./harnois.json"];
const armorsIndex = {
  types: types$1
};
const id$16 = "armure-gardien-runique";
const label$v = "Armure du Gardien Runique";
const type$d = "armor";
const armorCategory$7 = "medium";
const baseAC$7 = 14;
const dexCap$7 = 2;
const weight$d = 18;
const tags$16 = ["armure", "intermediaire", "metal", "magic"];
const description$7 = "Une armure gravee de runes defensives. Son pouvoir s'eveille quand elle est harmonisee.";
const category$Q = "armor_body";
const value$d = { "platinum": 0, "gold": 650, "silver": 0, "copper": 0 };
const harmonisable$7 = true;
const grants = [{ "kind": "bonus", "inline": [{ "id": "bonus-armure-gardien-runique-ac-1", "label": "+1 CA (harmonisee)", "summary": "Bonus de CA actif uniquement si l'armure est harmonisee.", "stat": "armorClass", "value": 1, "mode": "add", "tags": ["equip", "armor", "magic"], "requirements": [], "source": { "book": "HOME", "page": 0 } }] }];
const ArmureGardienRunique = {
  id: id$16,
  label: label$v,
  type: type$d,
  armorCategory: armorCategory$7,
  baseAC: baseAC$7,
  dexCap: dexCap$7,
  weight: weight$d,
  tags: tags$16,
  description: description$7,
  category: category$Q,
  value: value$d,
  harmonisable: harmonisable$7,
  grants
};
const id$15 = "bouclier";
const label$u = "Bouclier";
const type$c = "armor";
const armorCategory$6 = "shield";
const baseAC$6 = 2;
const dexCap$6 = null;
const weight$c = 3;
const tags$15 = ["armure", "bouclier", "wood"];
const description$6 = "Bouclier offrant un bonus de CA.";
const category$P = "shield";
const value$c = { "platinum": 0, "gold": 10, "silver": 0, "copper": 0 };
const harmonisable$6 = false;
const Bouclier = {
  id: id$15,
  label: label$u,
  type: type$c,
  armorCategory: armorCategory$6,
  baseAC: baseAC$6,
  dexCap: dexCap$6,
  weight: weight$c,
  tags: tags$15,
  description: description$6,
  category: category$P,
  value: value$c,
  harmonisable: harmonisable$6
};
const id$14 = "chemise_mailles";
const label$t = "Chemise de mailles";
const type$b = "armor";
const armorCategory$5 = "medium";
const baseAC$5 = 13;
const dexCap$5 = 2;
const weight$b = 10;
const tags$14 = ["armure", "intermediaire", "metal"];
const description$5 = "Cotte de mailles legere portee sous des vetements.";
const category$O = "armor_body";
const value$b = { "platinum": 0, "gold": 50, "silver": 0, "copper": 0 };
const harmonisable$5 = false;
const ChemiseMailles = {
  id: id$14,
  label: label$t,
  type: type$b,
  armorCategory: armorCategory$5,
  baseAC: baseAC$5,
  dexCap: dexCap$5,
  weight: weight$b,
  tags: tags$14,
  description: description$5,
  category: category$O,
  value: value$b,
  harmonisable: harmonisable$5
};
const id$13 = "cotte_mailles";
const label$s = "Cotte de mailles";
const type$a = "armor";
const armorCategory$4 = "heavy";
const baseAC$4 = 16;
const dexCap$4 = 0;
const weight$a = 27.5;
const tags$13 = ["armure", "lourde", "metal"];
const description$4 = "Armure lourde en anneaux de metal.";
const category$N = "armor_body";
const value$a = { "platinum": 0, "gold": 75, "silver": 0, "copper": 0 };
const harmonisable$4 = false;
const CotteMailles = {
  id: id$13,
  label: label$s,
  type: type$a,
  armorCategory: armorCategory$4,
  baseAC: baseAC$4,
  dexCap: dexCap$4,
  weight: weight$a,
  tags: tags$13,
  description: description$4,
  category: category$N,
  value: value$a,
  harmonisable: harmonisable$4
};
const id$12 = "cuir_cloute";
const label$r = "Armure de cuir cloute";
const type$9 = "armor";
const armorCategory$3 = "light";
const baseAC$3 = 12;
const dexCap$3 = null;
const weight$9 = 6.5;
const tags$12 = ["armure", "legere", "leather", "metal"];
const description$3 = "Armure de cuir renforcee par des rivets.";
const category$M = "armor_body";
const value$9 = { "platinum": 0, "gold": 45, "silver": 0, "copper": 0 };
const harmonisable$3 = false;
const CuirCloute = {
  id: id$12,
  label: label$r,
  type: type$9,
  armorCategory: armorCategory$3,
  baseAC: baseAC$3,
  dexCap: dexCap$3,
  weight: weight$9,
  tags: tags$12,
  description: description$3,
  category: category$M,
  value: value$9,
  harmonisable: harmonisable$3
};
const id$11 = "cuir";
const label$q = "Armure de cuir";
const type$8 = "armor";
const armorCategory$2 = "light";
const baseAC$2 = 11;
const dexCap$2 = null;
const weight$8 = 5;
const tags$11 = ["armure", "legere", "leather"];
const description$2 = "Armure legere en cuir.";
const category$L = "armor_body";
const value$8 = { "platinum": 0, "gold": 10, "silver": 0, "copper": 0 };
const harmonisable$2 = false;
const Cuir = {
  id: id$11,
  label: label$q,
  type: type$8,
  armorCategory: armorCategory$2,
  baseAC: baseAC$2,
  dexCap: dexCap$2,
  weight: weight$8,
  tags: tags$11,
  description: description$2,
  category: category$L,
  value: value$8,
  harmonisable: harmonisable$2
};
const id$10 = "demi_plaque";
const label$p = "Demi-plaque";
const type$7 = "armor";
const armorCategory$1 = "medium";
const baseAC$1 = 15;
const dexCap$1 = 2;
const weight$7 = 20;
const tags$10 = ["armure", "intermediaire", "metal"];
const description$1 = "Armure intermediaire avec plaques partielles.";
const category$K = "armor_body";
const value$7 = { "platinum": 0, "gold": 750, "silver": 0, "copper": 0 };
const harmonisable$1 = false;
const DemiPlaque = {
  id: id$10,
  label: label$p,
  type: type$7,
  armorCategory: armorCategory$1,
  baseAC: baseAC$1,
  dexCap: dexCap$1,
  weight: weight$7,
  tags: tags$10,
  description: description$1,
  category: category$K,
  value: value$7,
  harmonisable: harmonisable$1
};
const id$$ = "harnois";
const label$o = "Harnois";
const type$6 = "armor";
const armorCategory = "heavy";
const baseAC = 18;
const dexCap = 0;
const weight$6 = 30;
const tags$$ = ["armure", "lourde", "metal"];
const description = "Armure lourde complete en plaques.";
const category$J = "armor_body";
const value$6 = { "platinum": 0, "gold": 1500, "silver": 0, "copper": 0 };
const harmonisable = false;
const Harnois = {
  id: id$$,
  label: label$o,
  type: type$6,
  armorCategory,
  baseAC,
  dexCap,
  weight: weight$6,
  tags: tags$$,
  description,
  category: category$J,
  value: value$6,
  harmonisable
};
const ARMOR_MODULES = {
  "./armure-gardien-runique.json": ArmureGardienRunique,
  "./bouclier.json": Bouclier,
  "./chemise-mailles.json": ChemiseMailles,
  "./cotte-mailles.json": CotteMailles,
  "./cuir-cloute.json": CuirCloute,
  "./cuir.json": Cuir,
  "./demi-plaque.json": DemiPlaque,
  "./harnois.json": Harnois
};
function loadArmorItemsFromIndex() {
  const indexed = Array.isArray(armorsIndex.types) ? armorsIndex.types : [];
  const loaded = [];
  for (const path2 of indexed) {
    const mod = ARMOR_MODULES[path2];
    if (mod) {
      loaded.push(mod);
    } else {
      console.warn("[armors] Type path missing in bundle:", path2);
    }
  }
  if (loaded.length === 0) {
    console.warn("[armors] No armors loaded from index.json");
  }
  return loaded;
}
const types = ["./arrow.json", "./bolt.json", "./bullet.json", "./dart.json", "./needle.json", "./stone.json"];
const ammoIndex = {
  types
};
const id$_ = "arrow";
const name$I = "Fleche";
const label$n = "Fleche";
const type$5 = "munition";
const subtype$5 = "arrow";
const category$I = "projectile";
const descriptionCourte$5 = "Fleche standard pour arc.";
const descriptionLongue$5 = "";
const allowStack$5 = true;
const weight$5 = 0.05;
const size$5 = 0.1;
const value$5 = { "gold": 0, "silver": 1, "copper": 0, "platinum": 0 };
const rarity$5 = "commune";
const tags$_ = ["munition", "arrow"];
const ammoType$5 = "arrow";
const bundleSize$5 = 20;
const storage$5 = { "preferredSlot": "carquois", "allowedSlots": ["carquois", "paquetage"] };
const compatibility$5 = { "weaponAmmoTypes": ["arrow"], "weaponTags": ["bow", "longbow", "shortbow"] };
const Arrow = {
  id: id$_,
  name: name$I,
  label: label$n,
  type: type$5,
  subtype: subtype$5,
  category: category$I,
  descriptionCourte: descriptionCourte$5,
  descriptionLongue: descriptionLongue$5,
  allowStack: allowStack$5,
  weight: weight$5,
  size: size$5,
  value: value$5,
  rarity: rarity$5,
  tags: tags$_,
  ammoType: ammoType$5,
  bundleSize: bundleSize$5,
  storage: storage$5,
  compatibility: compatibility$5
};
const id$Z = "bolt";
const name$H = "Carreau";
const label$m = "Carreau";
const type$4 = "munition";
const subtype$4 = "bolt";
const category$H = "projectile";
const descriptionCourte$4 = "Carreau pour arbalete.";
const descriptionLongue$4 = "";
const allowStack$4 = true;
const weight$4 = 0.06;
const size$4 = 0.1;
const value$4 = { "gold": 0, "silver": 2, "copper": 0, "platinum": 0 };
const rarity$4 = "commune";
const tags$Z = ["munition", "bolt"];
const ammoType$4 = "bolt";
const bundleSize$4 = 20;
const storage$4 = { "preferredSlot": "carquois", "allowedSlots": ["carquois", "paquetage"] };
const compatibility$4 = { "weaponAmmoTypes": ["bolt"], "weaponTags": ["crossbow"] };
const Bolt = {
  id: id$Z,
  name: name$H,
  label: label$m,
  type: type$4,
  subtype: subtype$4,
  category: category$H,
  descriptionCourte: descriptionCourte$4,
  descriptionLongue: descriptionLongue$4,
  allowStack: allowStack$4,
  weight: weight$4,
  size: size$4,
  value: value$4,
  rarity: rarity$4,
  tags: tags$Z,
  ammoType: ammoType$4,
  bundleSize: bundleSize$4,
  storage: storage$4,
  compatibility: compatibility$4
};
const id$Y = "bullet";
const name$G = "Balle";
const label$l = "Balle";
const type$3 = "munition";
const subtype$3 = "bullet";
const category$G = "projectile";
const descriptionCourte$3 = "Balle standard pour arme a feu.";
const descriptionLongue$3 = "";
const allowStack$3 = true;
const weight$3 = 0.03;
const size$3 = 0.05;
const value$3 = { "gold": 0, "silver": 5, "copper": 0, "platinum": 0 };
const rarity$3 = "commune";
const tags$Y = ["munition", "bullet"];
const ammoType$3 = "bullet";
const bundleSize$3 = 10;
const storage$3 = { "preferredSlot": "paquetage", "allowedSlots": ["paquetage", "ceinture_gauche", "ceinture_droite"] };
const compatibility$3 = { "weaponAmmoTypes": ["bullet"], "weaponTags": ["firearm"] };
const Bullet = {
  id: id$Y,
  name: name$G,
  label: label$l,
  type: type$3,
  subtype: subtype$3,
  category: category$G,
  descriptionCourte: descriptionCourte$3,
  descriptionLongue: descriptionLongue$3,
  allowStack: allowStack$3,
  weight: weight$3,
  size: size$3,
  value: value$3,
  rarity: rarity$3,
  tags: tags$Y,
  ammoType: ammoType$3,
  bundleSize: bundleSize$3,
  storage: storage$3,
  compatibility: compatibility$3
};
const id$X = "dart";
const name$F = "Dard";
const label$k = "Dard";
const type$2 = "munition";
const subtype$2 = "dart";
const category$F = "projectile";
const descriptionCourte$2 = "Dard pour sarbacane ou projectile leger.";
const descriptionLongue$2 = "";
const allowStack$2 = true;
const weight$2 = 0.02;
const size$2 = 0.05;
const value$2 = { "gold": 0, "silver": 1, "copper": 0, "platinum": 0 };
const rarity$2 = "commune";
const tags$X = ["munition", "dart"];
const ammoType$2 = "dart";
const bundleSize$2 = 20;
const storage$2 = { "preferredSlot": "paquetage", "allowedSlots": ["paquetage", "ceinture_gauche", "ceinture_droite"] };
const compatibility$2 = { "weaponAmmoTypes": ["dart"], "weaponTags": ["blowgun"] };
const Dart = {
  id: id$X,
  name: name$F,
  label: label$k,
  type: type$2,
  subtype: subtype$2,
  category: category$F,
  descriptionCourte: descriptionCourte$2,
  descriptionLongue: descriptionLongue$2,
  allowStack: allowStack$2,
  weight: weight$2,
  size: size$2,
  value: value$2,
  rarity: rarity$2,
  tags: tags$X,
  ammoType: ammoType$2,
  bundleSize: bundleSize$2,
  storage: storage$2,
  compatibility: compatibility$2
};
const id$W = "stone";
const name$E = "Bille de fronde";
const label$j = "Bille de fronde";
const type$1 = "munition";
const subtype$1 = "stone";
const category$E = "projectile";
const descriptionCourte$1 = "Bille pour fronde.";
const descriptionLongue$1 = "";
const allowStack$1 = true;
const weight$1 = 0.05;
const size$1 = 0.1;
const value$1 = { "gold": 0, "silver": 0, "copper": 1, "platinum": 0 };
const rarity$1 = "commune";
const tags$W = ["munition", "stone"];
const ammoType$1 = "stone";
const bundleSize$1 = 20;
const storage$1 = { "preferredSlot": "paquetage", "allowedSlots": ["paquetage"] };
const compatibility$1 = { "weaponAmmoTypes": ["stone"], "weaponTags": ["sling"] };
const Stone = {
  id: id$W,
  name: name$E,
  label: label$j,
  type: type$1,
  subtype: subtype$1,
  category: category$E,
  descriptionCourte: descriptionCourte$1,
  descriptionLongue: descriptionLongue$1,
  allowStack: allowStack$1,
  weight: weight$1,
  size: size$1,
  value: value$1,
  rarity: rarity$1,
  tags: tags$W,
  ammoType: ammoType$1,
  bundleSize: bundleSize$1,
  storage: storage$1,
  compatibility: compatibility$1
};
const id$V = "needle";
const name$D = "Aiguille";
const label$i = "Aiguille";
const type = "munition";
const subtype = "needle";
const category$D = "projectile";
const descriptionCourte = "Aiguille fine pour lanceur discret.";
const descriptionLongue = "";
const allowStack = true;
const weight = 0.01;
const size = 0.02;
const value = { "gold": 0, "silver": 1, "copper": 0, "platinum": 0 };
const rarity = "commune";
const tags$V = ["munition", "needle"];
const ammoType = "needle";
const bundleSize = 20;
const storage = { "preferredSlot": "paquetage", "allowedSlots": ["paquetage"] };
const compatibility = { "weaponAmmoTypes": ["needle"], "weaponTags": ["needle"] };
const Needle = {
  id: id$V,
  name: name$D,
  label: label$i,
  type,
  subtype,
  category: category$D,
  descriptionCourte,
  descriptionLongue,
  allowStack,
  weight,
  size,
  value,
  rarity,
  tags: tags$V,
  ammoType,
  bundleSize,
  storage,
  compatibility
};
const AMMO_MODULES = {
  "./arrow.json": Arrow,
  "./bolt.json": Bolt,
  "./bullet.json": Bullet,
  "./dart.json": Dart,
  "./stone.json": Stone,
  "./needle.json": Needle
};
function loadAmmoTypesFromIndex() {
  const indexed = Array.isArray(ammoIndex.types) ? ammoIndex.types : [];
  const loaded = [];
  for (const path2 of indexed) {
    const mod = AMMO_MODULES[path2];
    if (mod) {
      loaded.push(mod);
    } else {
      console.warn("[ammo-types] Type path missing in bundle:", path2);
    }
  }
  if (loaded.length === 0) {
    console.warn("[ammo-types] No ammo loaded from index.json");
  }
  return loaded;
}
const bonuses = [];
const bonusesIndex = {
  bonuses
};
const BONUS_MODULES = {};
function loadBonusTypesFromIndex() {
  const indexed = Array.isArray(bonusesIndex.bonuses) ? bonusesIndex.bonuses : [];
  if (indexed.length === 0) return [];
  const loaded = [];
  for (const path2 of indexed) {
    const mod = BONUS_MODULES[path2];
    if (mod) {
      loaded.push(mod);
    } else {
      console.warn("[bonus-types] Bonus path missing in bundle:", path2);
    }
  }
  if (loaded.length === 0 && indexed.length > 0) {
    console.warn("[bonus-types] No bonuses loaded from index.json");
  }
  return loaded;
}
function key$1(x2, y2) {
  return `${x2},${y2}`;
}
function resolveOrientation(instance) {
  if (instance.orientation) return instance.orientation;
  return orientationFromRotationDeg(instance.rotation ?? 0);
}
function resolveRectSpec(footprint2) {
  if (!footprint2.length) return null;
  let minX = Number.POSITIVE_INFINITY;
  let maxX = Number.NEGATIVE_INFINITY;
  let minY = Number.POSITIVE_INFINITY;
  let maxY = Number.NEGATIVE_INFINITY;
  const set = /* @__PURE__ */ new Set();
  for (const cell of footprint2) {
    minX = Math.min(minX, cell.x);
    maxX = Math.max(maxX, cell.x);
    minY = Math.min(minY, cell.y);
    maxY = Math.max(maxY, cell.y);
    set.add(`${cell.x},${cell.y}`);
  }
  const width = maxX - minX + 1;
  const height = maxY - minY + 1;
  if (width <= 0 || height <= 0) return null;
  if (set.size !== width * height) return null;
  for (let y2 = minY; y2 <= maxY; y2++) {
    for (let x2 = minX; x2 <= maxX; x2++) {
      if (!set.has(`${x2},${y2}`)) return null;
    }
  }
  return { width, height };
}
function getObstacleVariant(typeDef, variantId) {
  var _a;
  if (!typeDef) return null;
  const v2 = (typeDef.variants || []).find((x2) => x2.id === variantId);
  return v2 ?? (((_a = typeDef.variants) == null ? void 0 : _a[0]) ?? null);
}
function getObstacleOccupiedCells(instance, typeDef) {
  const variant = getObstacleVariant(typeDef, instance.variantId);
  const footprint2 = Array.isArray(variant == null ? void 0 : variant.footprint) && variant.footprint.length ? variant.footprint : [{ x: 0, y: 0 }];
  const orientation = resolveOrientation(instance);
  const rect = resolveRectSpec(footprint2);
  if (rect) {
    return getFootprintCellsAt(
      { x: instance.x, y: instance.y },
      { kind: "rect", width: rect.width, height: rect.height },
      orientation
    );
  }
  return getFootprintCellsAt(
    { x: instance.x, y: instance.y },
    { kind: "cells", cells: footprint2 },
    orientation
  );
}
function buildObstacleBlockingSets(obstacleTypes, obstacles) {
  var _a, _b, _c;
  const typeById = /* @__PURE__ */ new Map();
  for (const t2 of obstacleTypes) typeById.set(t2.id, t2);
  const movement2 = /* @__PURE__ */ new Set();
  const vision2 = /* @__PURE__ */ new Set();
  const attacks = /* @__PURE__ */ new Set();
  const occupied = /* @__PURE__ */ new Set();
  for (const obs of obstacles) {
    if (obs.hp <= 0) continue;
    const def = typeById.get(obs.typeId);
    const cells = getObstacleOccupiedCells(obs, def);
    for (const c2 of cells) {
      const k2 = key$1(c2.x, c2.y);
      occupied.add(k2);
      if ((_a = def == null ? void 0 : def.blocking) == null ? void 0 : _a.movement) movement2.add(k2);
      if ((_b = def == null ? void 0 : def.blocking) == null ? void 0 : _b.vision) vision2.add(k2);
      if ((_c = def == null ? void 0 : def.blocking) == null ? void 0 : _c.attacks) attacks.add(k2);
    }
  }
  return { movement: movement2, vision: vision2, attacks, occupied };
}
function key(x2, y2) {
  return `${x2},${y2}`;
}
function clamp$4(value2, min, max) {
  return Math.max(min, Math.min(max, value2));
}
function resolveTokenScale(type2, override) {
  var _a;
  if (!type2) return null;
  const scaleSpec = (_a = type2.appearance) == null ? void 0 : _a.tokenScale;
  const hasOverride = typeof override === "number" && Number.isFinite(override);
  const min = scaleSpec && Number.isFinite(scaleSpec.min) ? scaleSpec.min : null;
  const max = scaleSpec && Number.isFinite(scaleSpec.max) ? scaleSpec.max : null;
  const def = scaleSpec && Number.isFinite(scaleSpec.default) ? scaleSpec.default : null;
  let chosen = null;
  if (hasOverride) {
    chosen = override;
  } else if (min !== null && max !== null) {
    const lo = Math.min(min, max);
    const hi = Math.max(min, max);
    chosen = lo + (hi - lo) * Math.random();
  } else if (def !== null) {
    chosen = def;
  }
  if (chosen === null) return null;
  if (min !== null || max !== null) {
    const lo = min ?? chosen;
    const hi = max ?? chosen;
    chosen = clamp$4(chosen, Math.min(lo, hi), Math.max(lo, hi));
  }
  return chosen;
}
function isInside(draft, x2, y2) {
  return x2 >= 0 && y2 >= 0 && x2 < draft.cols && y2 < draft.rows;
}
function indexOf(draft, x2, y2) {
  return y2 * draft.cols + x2;
}
function getTerrainAt(draft, x2, y2) {
  if (!isInside(draft, x2, y2)) return null;
  return draft.layers.terrain[indexOf(draft, x2, y2)] ?? null;
}
function getHeightAtGrid(height, cols, rows, x2, y2) {
  if (!height || height.length === 0) return 0;
  if (x2 < 0 || y2 < 0 || x2 >= cols || y2 >= rows) return 0;
  const value2 = height[y2 * cols + x2];
  return Number.isFinite(value2) ? value2 : 0;
}
function createDraft(params) {
  const cols = Math.max(1, params.cols);
  const rows = Math.max(1, params.rows);
  const size2 = cols * rows;
  const layers = {
    terrain: Array.from({ length: size2 }, () => "unknown"),
    height: Array.from({ length: size2 }, () => 0),
    light: Array.from({ length: size2 }, () => 1)
  };
  let seq = 1;
  const prefix = params.seedPrefix ?? "obs";
  const playable = /* @__PURE__ */ new Set();
  for (let y2 = 0; y2 < rows; y2++) {
    for (let x2 = 0; x2 < cols; x2++) {
      playable.add(key(x2, y2));
    }
  }
  return {
    cols,
    rows,
    layers,
    playable,
    obstacles: [],
    occupied: /* @__PURE__ */ new Set(),
    movementBlocked: /* @__PURE__ */ new Set(),
    wallSegments: [],
    wallSegmentKeys: /* @__PURE__ */ new Set(),
    decorations: [],
    decorOccupied: /* @__PURE__ */ new Set(),
    roofOpenCells: /* @__PURE__ */ new Set(),
    reserved: params.reserved ?? /* @__PURE__ */ new Set(),
    log: [],
    nextObstacleId: () => `${prefix}-${seq++}`,
    nextWallId: () => `wall-${seq++}`,
    nextDecorId: () => `decor-${seq++}`
  };
}
function setTerrain(draft, x2, y2, cell) {
  if (!isInside(draft, x2, y2)) return;
  draft.layers.terrain[indexOf(draft, x2, y2)] = cell;
}
function scatterTerrainPatches(params) {
  const { draft, rand, terrain, mask } = params;
  const count2 = Math.max(0, Math.floor(params.count));
  if (count2 === 0) return;
  const rMin = Math.max(1, Math.floor(params.radiusMin));
  const rMax = Math.max(rMin, Math.floor(params.radiusMax));
  for (let i2 = 0; i2 < count2; i2++) {
    const cx = Math.floor(rand() * draft.cols);
    const cy = Math.floor(rand() * draft.rows);
    const radius = rMin + Math.floor(rand() * (rMax - rMin + 1));
    for (let dy = -radius; dy <= radius; dy++) {
      for (let dx = -radius; dx <= radius; dx++) {
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist > radius + 0.15) continue;
        const x2 = cx + dx;
        const y2 = cy + dy;
        if (!isInside(draft, x2, y2)) continue;
        const k2 = key(x2, y2);
        if (mask && !mask.has(k2)) continue;
        setTerrain(draft, x2, y2, terrain);
      }
    }
  }
}
function setHeight(draft, x2, y2, h2) {
  if (!isInside(draft, x2, y2)) return;
  draft.layers.height[indexOf(draft, x2, y2)] = h2;
}
function setLight(draft, x2, y2, value01) {
  if (!isInside(draft, x2, y2)) return;
  draft.layers.light[indexOf(draft, x2, y2)] = clamp$4(value01, 0, 1);
}
function tryPlaceObstacle(params) {
  var _a, _b;
  const { draft, type: type2, x: x2, y: y2, variantId } = params;
  if (!type2) return false;
  const orientation = params.orientation ?? orientationFromRotationDeg(params.rotation ?? 0);
  const maxHp = Math.max(1, Number(((_a = type2.durability) == null ? void 0 : _a.maxHp) ?? 1));
  const instance = {
    id: draft.nextObstacleId(),
    typeId: type2.id,
    variantId,
    x: x2,
    y: y2,
    rotation: params.rotation ?? 0,
    orientation,
    tokenScale: (() => {
      const resolved = resolveTokenScale(type2, params.tokenScale);
      return resolved === null ? void 0 : Math.round(resolved);
    })(),
    state: typeof type2.litByDefault === "boolean" ? { lit: type2.litByDefault } : void 0,
    hp: maxHp,
    maxHp
  };
  const cells = getObstacleOccupiedCells(instance, type2);
  if (!cells.length) return false;
  const enforcePlayable = draft.playable.size > 0;
  for (const c2 of cells) {
    if (!isInside(draft, c2.x, c2.y)) return false;
    const k2 = key(c2.x, c2.y);
    if (enforcePlayable && !draft.playable.has(k2)) return false;
    if (!params.allowOnReserved && draft.reserved.has(k2)) return false;
    if (draft.occupied.has(k2)) return false;
  }
  draft.obstacles.push(instance);
  for (const c2 of cells) {
    const k2 = key(c2.x, c2.y);
    draft.occupied.add(k2);
    if ((_b = type2.blocking) == null ? void 0 : _b.movement) draft.movementBlocked.add(k2);
  }
  return true;
}
function tryPlaceWallSegment(params) {
  const { draft, x: x2, y: y2, dir, kind: kind2 } = params;
  if (!isInside(draft, x2, y2)) return false;
  const edgeKey = wallEdgeKey(x2, y2, dir);
  if (draft.wallSegmentKeys.has(edgeKey)) return false;
  if (!params.allowOnReserved) {
    const cells = getAdjacentCellsForEdge({ x: x2, y: y2, dir });
    if (draft.reserved.has(key(cells.a.x, cells.a.y)) || draft.reserved.has(key(cells.b.x, cells.b.y))) {
      return false;
    }
  }
  const seg = {
    id: draft.nextWallId(),
    typeId: params.typeId,
    x: x2,
    y: y2,
    dir,
    kind: kind2,
    state: params.state,
    hp: typeof params.maxHp === "number" ? params.maxHp : void 0,
    maxHp: typeof params.maxHp === "number" ? params.maxHp : void 0
  };
  draft.wallSegments.push(seg);
  draft.wallSegmentKeys.add(edgeKey);
  return true;
}
function tryPlaceDecor(params) {
  const { draft, spriteKey, x: x2, y: y2 } = params;
  if (!spriteKey) return false;
  if (!isInside(draft, x2, y2)) return false;
  const k2 = key(x2, y2);
  const enforcePlayable = draft.playable.size > 0;
  if (enforcePlayable && !draft.playable.has(k2)) return false;
  if (!params.allowOnReserved && draft.reserved.has(k2)) return false;
  if (draft.occupied.has(k2)) return false;
  if (draft.decorOccupied.has(k2)) return false;
  const instance = {
    id: draft.nextDecorId(),
    spriteKey,
    x: x2,
    y: y2,
    rotation: typeof params.rotation === "number" ? params.rotation : 0,
    scale: typeof params.scale === "number" ? params.scale : 1,
    layer: "ground"
  };
  draft.decorations.push(instance);
  draft.decorOccupied.add(k2);
  return true;
}
function scatterDecorations(params) {
  const { draft, rand } = params;
  const count2 = Math.max(0, Math.floor(params.count));
  if (!count2) return;
  const spriteKeys = params.spriteKeys.filter(Boolean);
  if (!spriteKeys.length) return;
  const terrainFilter = params.terrainFilter ?? null;
  const mask = params.mask ?? null;
  let placed = 0;
  let attempts = 0;
  const maxAttempts = Math.max(50, count2 * 20);
  while (placed < count2 && attempts < maxAttempts) {
    attempts++;
    const x2 = Math.floor(rand() * draft.cols);
    const y2 = Math.floor(rand() * draft.rows);
    const k2 = key(x2, y2);
    if (mask && !mask.has(k2)) continue;
    if (terrainFilter) {
      const terrain = getTerrainAt(draft, x2, y2);
      if (!terrain || !terrainFilter.includes(terrain)) continue;
    }
    const spriteKey = spriteKeys[Math.floor(rand() * spriteKeys.length)];
    const ok = tryPlaceDecor({ draft, spriteKey, x: x2, y: y2 });
    if (ok) placed++;
  }
}
function computeReachableCells(draft, start) {
  const reachable = /* @__PURE__ */ new Set();
  if (!isInside(draft, start.x, start.y)) return reachable;
  const startKey = key(start.x, start.y);
  if (draft.movementBlocked.has(startKey)) return reachable;
  const wallEdges = buildWallEdgeSets(draft.wallSegments).movement;
  const queue = [start];
  reachable.add(startKey);
  const dirs = [
    { x: 1, y: 0 },
    { x: -1, y: 0 },
    { x: 0, y: 1 },
    { x: 0, y: -1 }
  ];
  while (queue.length) {
    const cur = queue.shift();
    for (const d2 of dirs) {
      const nx = cur.x + d2.x;
      const ny = cur.y + d2.y;
      if (!isInside(draft, nx, ny)) continue;
      if (wallEdges.size > 0 && isEdgeBlockedForMovement(cur, { x: nx, y: ny }, wallEdges)) {
        continue;
      }
      const k2 = key(nx, ny);
      if (reachable.has(k2)) continue;
      if (draft.movementBlocked.has(k2)) continue;
      reachable.add(k2);
      queue.push({ x: nx, y: ny });
    }
  }
  return reachable;
}
function norm(input) {
  return String(input ?? "").toLowerCase().normalize("NFD").replace(new RegExp("\\p{Diacritic}", "gu"), "").trim();
}
function hasAny(text, patterns2) {
  return patterns2.some((p2) => p2.test(text));
}
function extractNumber(text, patterns2) {
  for (const p2 of patterns2) {
    const m2 = text.match(p2);
    if (!m2) continue;
    const n2 = Number(m2[1]);
    if (Number.isFinite(n2)) return n2;
  }
  return null;
}
const NUMBER_WORDS = {
  un: 1,
  une: 1,
  deux: 2,
  trois: 3,
  quatre: 4,
  cinq: 5,
  six: 6,
  sept: 7,
  huit: 8,
  neuf: 9,
  dix: 10
};
function extractWordNumber(text, patterns2) {
  for (const p2 of patterns2) {
    const m2 = text.match(p2);
    if (!m2) continue;
    const token = String(m2[1] ?? "").trim();
    if (!token) continue;
    const n2 = NUMBER_WORDS[token];
    if (Number.isFinite(n2)) return n2;
  }
  return null;
}
function parseOrientationToken(token) {
  const raw = String(token ?? "").trim().toLowerCase();
  if (!raw) return null;
  switch (raw) {
    case "n":
      return "up";
    case "ne":
      return "up-right";
    case "e":
      return "right";
    case "se":
      return "down-right";
    case "s":
      return "down";
    case "sw":
    case "so":
      return "down-left";
    case "w":
    case "o":
      return "left";
    case "nw":
    case "no":
      return "up-left";
    default:
      return null;
  }
}
function detectPlacementHint(clause) {
  if (/\bentre\b/.test(clause) && /\broute\b/.test(clause) && /\bmaison\b/.test(clause)) {
    return "between_road_house";
  }
  if (/\b(trottoir|bord de la route|bord de route|au bord de la route|au bord de route)\b/.test(clause)) {
    return "road_edge";
  }
  if (/\b(a cote de la route|a cote de route|pres de la route|pres de route)\b/.test(clause)) {
    return "road_edge";
  }
  if (/\b(a cote de la maison|a cote de maison|pres de la maison|pres de maison)\b/.test(clause)) {
    return "near_house";
  }
  if (/\b(sur la route|sur route|route)\b/.test(clause)) {
    return "road";
  }
  if (/\b(maison|maisons)\b/.test(clause)) {
    return "near_house";
  }
  return null;
}
function extractObstacleRequests(raw, normalized) {
  const requests = [];
  const obstacles = [
    { typeId: "charette-wood", tokens: ["charette", "charrette"] }
  ];
  const clauses = splitClauses(normalized);
  for (const clause of clauses) {
    let remaining = clause;
    const placement2 = detectPlacementHint(clause);
    for (const entry of obstacles) {
      const tokenGroup = entry.tokens.map((t2) => t2.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&")).join("|");
      const orientedPattern = new RegExp(`\\b(${tokenGroup})s?\\s*\\[\\s*(n|ne|e|se|s|sw|so|w|o|nw|no)\\s*\\]`, "g");
      let orientedCount = 0;
      let match;
      while (match = orientedPattern.exec(remaining)) {
        const dir = parseOrientationToken(match[2]);
        if (dir) {
          requests.push({
            typeId: entry.typeId,
            count: 1,
            orientation: dir,
            placement: placement2 ?? void 0
          });
          orientedCount += 1;
        }
      }
      remaining = remaining.replace(orientedPattern, " ");
      const numberPattern = new RegExp(`\\b(\\d+)\\s*(${tokenGroup})s?\\b`);
      const wordPattern = new RegExp(`\\b([a-z]+)\\s*(${tokenGroup})s?\\b`);
      const numeric = extractNumber(remaining, [numberPattern]);
      const worded = extractWordNumber(remaining, [wordPattern]);
      const count2 = numeric ?? worded;
      const hasBare = new RegExp(`\\b(${tokenGroup})s?\\b`).test(remaining);
      let remainingCount = null;
      if (count2 !== null) {
        remainingCount = Math.max(0, Math.floor(count2) - orientedCount);
      } else if (hasBare && orientedCount === 0) {
        remainingCount = 1;
      }
      if (remainingCount && remainingCount > 0) {
        requests.push({
          typeId: entry.typeId,
          count: remainingCount,
          placement: placement2 ?? void 0
        });
      }
    }
  }
  return requests.length > 0 ? requests : void 0;
}
function uniqueSides(placements) {
  const set = /* @__PURE__ */ new Set();
  for (const p2 of placements) set.add(p2.side);
  return Array.from(set);
}
function splitClauses(text) {
  return text.split(/[.;]/).map((s2) => s2.trim()).filter(Boolean);
}
function parseDoorState(text) {
  if (hasAny(text, [/\bportes? (sont )?fermees?\b/, /\bporte fermee\b/])) return "closed";
  if (hasAny(text, [/\bportes? (sont )?ouvertes?\b/, /\bporte ouverte\b/])) return "open";
  return null;
}
function parseDoorPosition(text) {
  if (/\b(centre|centree|milieu)\b/.test(text)) return "center";
  if (/\bgauche\b/.test(text)) return "start";
  if (/\bdroite\b/.test(text)) return "end";
  return void 0;
}
function parseSideHint(text) {
  if (/\bnord\b/.test(text)) return "north";
  if (/\bsud\b/.test(text)) return "south";
  if (/\best\b/.test(text)) return "east";
  if (/\bouest\b/.test(text)) return "west";
  return void 0;
}
function extractRoomCount(text) {
  const numeric = extractNumber(text, [/\b(\d+)\s*(salles?|pieces?|rooms?)\b/]);
  if (numeric !== null) return numeric;
  const worded = extractWordNumber(text, [/\b([a-z]+)\s*(salles?|pieces?|rooms?)\b/]);
  return worded ?? null;
}
function clampGrid(value2, min, max) {
  return Math.max(min, Math.min(max, Math.floor(value2)));
}
function computeExpandedGrid(params) {
  const baseCols = Math.max(1, params.cols);
  const baseRows = Math.max(1, params.rows);
  const rooms = Math.max(2, Math.floor(params.roomCount));
  const minRoomW = 6;
  const minRoomH = 6;
  const wallGap = rooms - 1;
  if (params.style === "split") {
    const axis = params.axis ?? "vertical";
    if (axis === "vertical") {
      const minCols3 = minRoomW * rooms + wallGap + 2;
      const minRows3 = minRoomH + 2;
      return {
        cols: clampGrid(Math.max(baseCols, minCols3), baseCols, 70),
        rows: clampGrid(Math.max(baseRows, minRows3), baseRows, 50)
      };
    }
    const minCols2 = minRoomW + 2;
    const minRows2 = minRoomH * rooms + wallGap + 2;
    return {
      cols: clampGrid(Math.max(baseCols, minCols2), baseCols, 70),
      rows: clampGrid(Math.max(baseRows, minRows2), baseRows, 50)
    };
  }
  const corridorWidth = 2;
  const side = params.corridorSide ?? "north";
  if (side === "north" || side === "south") {
    const minCols2 = minRoomW * rooms + wallGap + 2;
    const minRows2 = minRoomH + corridorWidth + 3;
    return {
      cols: clampGrid(Math.max(baseCols, minCols2), baseCols, 70),
      rows: clampGrid(Math.max(baseRows, minRows2), baseRows, 50)
    };
  }
  const minCols = minRoomW + corridorWidth + 3;
  const minRows = minRoomH * rooms + wallGap + 2;
  return {
    cols: clampGrid(Math.max(baseCols, minCols), baseCols, 70),
    rows: clampGrid(Math.max(baseRows, minRows), baseRows, 50)
  };
}
function mapPositionToken(token, side) {
  if (!token) return null;
  if (token === "centre" || token === "milieu") return "center";
  if (token === "gauche") return "start";
  if (token === "droite") return "end";
  if (token === "haut") return side === "east" || side === "west" ? "start" : null;
  if (token === "bas") return side === "east" || side === "west" ? "end" : null;
  return null;
}
function extractEntrancePlacements(text) {
  const placements = [];
  const doorIntent = /\bportes?\b/.test(text);
  const sideTokenToSide = {
    nord: "north",
    sud: "south",
    est: "east",
    ouest: "west"
  };
  const addPlacement = (side, count2, position) => {
    placements.push({
      side,
      count: typeof count2 === "number" && Number.isFinite(count2) ? Math.max(1, Math.floor(count2)) : void 0,
      position
    });
  };
  const pattern = /\b(\d+)?\s*portes?\s*(?:au|a|sur|du|de la|de l'|cote|cot[e])?\s*(?:mur|cote|cot[e])?\s*(nord|sud|est|ouest)\b(?:\s*(?:au|a|du|de la)?\s*(centre|milieu|gauche|droite|haut|bas))?/g;
  let match;
  while (match = pattern.exec(text)) {
    const count2 = match[1] ? Number(match[1]) : void 0;
    const sideToken = match[2];
    const posToken = match[3];
    const side = sideTokenToSide[sideToken];
    const pos = posToken ? mapPositionToken(posToken, side) : null;
    addPlacement(side, count2, pos ?? void 0);
  }
  const patternSwap = /\bportes?\s*(?:au|a|du|de la)?\s*(centre|milieu|gauche|droite|haut|bas)\s*(?:du|de la|de l'|cote|cot[e]|mur)?\s*(nord|sud|est|ouest)\b/g;
  while (match = patternSwap.exec(text)) {
    const posToken = match[1];
    const sideToken = match[2];
    const side = sideTokenToSide[sideToken];
    const pos = mapPositionToken(posToken, side);
    addPlacement(side, void 0, pos ?? void 0);
  }
  const cornerPattern = /\bportes?\s*(?:au|a|dans le)?\s*coin\s*(nord|sud)\s*[- ]?(est|ouest)\b/g;
  while (match = cornerPattern.exec(text)) {
    const sideToken = match[1];
    const posToken = match[2];
    const side = sideTokenToSide[sideToken];
    const pos = posToken === "est" ? "end" : "start";
    addPlacement(side, void 0, pos);
  }
  if (doorIntent) {
    const sideHints = [
      { side: "north", token: /\bnord\b/ },
      { side: "south", token: /\bsud\b/ },
      { side: "east", token: /\best\b/ },
      { side: "west", token: /\bouest\b/ }
    ];
    for (const hint of sideHints) {
      if (!hint.token.test(text)) continue;
      if (placements.some((p2) => p2.side === hint.side)) continue;
      addPlacement(hint.side, 1);
    }
  }
  return placements;
}
function parsePromptToSpec(params) {
  var _a, _b, _c, _d, _e;
  const raw = String(params.prompt ?? "");
  const text = norm(raw);
  const notes = [];
  const obstacleRequests = extractObstacleRequests(raw, text);
  const wantsTestObstacles = hasAny(text, [/\btest obstacles?\b/]);
  const isDungeon = hasAny(text, [
    /\bdonjon\b/,
    /\bdongon\b/,
    // tolre la faute frquente
    /\bdungeon\b/,
    /\bcatacombe\b/,
    /\bcouloir\b/,
    /\bsalle\b/
  ]);
  const isForest = hasAny(text, [
    /\bforet\b/,
    /\bbois\b/,
    /\barbres?\b/,
    /\bclairiere\b/
  ]);
  const isCity = hasAny(text, [
    /\bville\b/,
    /\brue\b/,
    /\bmaisons?\b/,
    /\bquartier\b/
  ]);
  let theme2 = "generic";
  if (isDungeon) theme2 = "dungeon";
  else if (isForest) theme2 = "forest";
  else if (isCity) theme2 = "city";
  if (wantsTestObstacles) theme2 = "generic";
  const isDay = hasAny(text, [/\bil fait jour\b/, /\bjour\b/]);
  const isNight = hasAny(text, [/\bnuit\b/, /\bobscur\b/, /\bsombre\b/]);
  const timeOfDay = isDay ? "day" : isNight ? "night" : "unknown";
  const hasTimeToken = hasAny(text, [/\bjour\b/, /\bnuit\b/]);
  const promptWithTime = raw.trim().length > 0 && timeOfDay !== "unknown" && !hasTimeToken ? `${raw.trim()} (${timeOfDay === "day" ? "jour" : "nuit"})` : raw;
  const wantsCircularRoom = hasAny(text, [/\bcircul\w+/]);
  const wantsSquareRoom = hasAny(text, [/\bcarre(?:e|es)?\b/, /\bsquare\b/]);
  const wantsRectRoom = hasAny(text, [/\brectang\w+\b/, /\brectangle\b/]);
  const wantsClearing = hasAny(text, [/\bclairiere\b/]);
  const wantsStreet = hasAny(text, [/\brue\b/]);
  const wantsHouse = hasAny(text, [/\bmaison\b/, /\bmaisons?\b/, /\bbatiment\b/]);
  const wantsBuildingLayout = hasAny(text, [
    /\btoit\b/,
    /\bterrasse\b/,
    /\bbalcon\b/,
    /\bbatiment\b/,
    /\betage\b/,
    /\blevel\b/
  ]);
  const wantsRoofClosed = hasAny(text, [/\bferme\b/, /\bclos\b/, /\bclois?\b/, /\binterieur\b/]);
  hasAny(text, [/\bouvert\b/, /\baccessible\b/, /\bterrasse\b/, /\bbalcon\b/]);
  const buildingStyle = wantsRoofClosed ? "closed" : "open";
  const noEntrances = hasAny(text, [
    /\bsans portes?\b/,
    /\bsans ouvertures?\b/,
    /\bentoure de murs?\b/,
    /\bentoure de mur\b/
  ]);
  const entrancePlacements = extractEntrancePlacements(text);
  const entrances = extractNumber(text, [/\b(\d+)\s*(acces|acces|entrees|portes)\b/]) ?? null;
  const columns = extractNumber(text, [/\b(\d+)\s*(colonnes|piliers)\b/]) ?? null;
  const houseCount = extractNumber(text, [/\b(\d+)\s*(maisons?|batiments?)\b/]) ?? null;
  const hasAltar = hasAny(text, [/\bautel\b/, /\bhotel\b/]);
  const lowLight = hasAny(text, [
    /\bfaiblement eclaire\b/,
    /\bpeu eclaire\b/,
    /\bfaible lumiere\b/
  ]);
  const centerLit = hasAny(text, [
    /\bau centre\b/,
    /\bcentre\b/,
    /\bcentral\b/
  ]);
  const doorsClosed = hasAny(text, [/\bportes? (sont )?fermees?\b/, /\bfermee\b/]);
  const sizeHint = hasAny(text, [/\bimmense\b/, /\bvaste\b/, /\bspacieu\w+\b/, /\bgrande\b/, /\bgrand\b/]) ? "large" : hasAny(text, [/\bpetit\b/, /\bpetite\b/, /\bexigu\w+\b/, /\betroit\w+\b/]) ? "small" : "medium";
  const roomCount = extractRoomCount(text);
  const wantsCorridor = hasAny(text, [/\bcouloir\b/, /\bcorridor\b/]);
  const wantsSplitWall = hasAny(text, [
    /\bsepare\w*\b/,
    /\bseparation\b/,
    /\bmur avec porte\b/
  ]);
  const corridorSide = wantsCorridor ? parseSideHint(text) : void 0;
  let splitAxis;
  if (hasAny(text, [/\best\b/, /\bouest\b/])) splitAxis = "vertical";
  else if (hasAny(text, [/\bnord\b/, /\bsud\b/])) splitAxis = "horizontal";
  const hasMultiRooms = theme2 === "dungeon" && roomCount !== null && roomCount >= 2;
  let layoutId = "generic_scatter";
  if (wantsTestObstacles) layoutId = "test_obstacles";
  else if (theme2 === "dungeon" && (wantsSquareRoom || wantsRectRoom)) layoutId = "dungeon_square_room";
  else if (theme2 === "dungeon" && wantsCircularRoom) layoutId = "dungeon_circular_room";
  else if (theme2 === "forest" && wantsClearing) layoutId = "forest_clearing";
  else if (theme2 === "city" && wantsStreet) layoutId = "city_street";
  else if (theme2 === "dungeon") layoutId = "dungeon_circular_room";
  else if (theme2 === "forest") layoutId = "forest_clearing";
  else if (theme2 === "city") layoutId = "city_street";
  if (!wantsTestObstacles && wantsBuildingLayout && !wantsStreet) layoutId = "building_tiered";
  const spec = {
    prompt: promptWithTime,
    grid: { cols: params.cols, rows: params.rows },
    layoutId,
    theme: theme2,
    timeOfDay,
    obstacleRequests,
    sizeHint,
    dungeon: theme2 === "dungeon" ? {
      borderWalls: true,
      entrances: {
        count: noEntrances ? 0 : entrances ?? (entrancePlacements.length ? 0 : 2),
        width: 1,
        placements: entrancePlacements.length ? entrancePlacements : void 0,
        sides: entrancePlacements.length ? uniqueSides(entrancePlacements) : void 0
      },
      room: {
        shape: wantsCircularRoom ? "circle" : "rectangle"
      },
      columns: columns ?? 0,
      hasAltar,
      lighting: lowLight && !isDay ? "low" : "normal"
    } : void 0,
    forest: theme2 === "forest" ? {
      radius: Math.max(2, Math.floor(Math.min(params.cols, params.rows) * 0.28)),
      treesOnRing: "sparse",
      lighting: isNight ? "night" : "day"
    } : void 0,
    city: theme2 === "city" ? {
      direction: "horizontal",
      streetWidth: 2,
      buildingDepth: 2,
      doors: doorsClosed ? "closed" : "closed",
      lighting: isNight ? "night" : "day",
      patterns: void 0
    } : void 0
  };
  if (hasAny(text, [/\bautomne\b/, /\bautomnal\b/, /\bautumn\b/, /\bfall\b/])) {
    spec.paletteId = "autumn";
  } else if (hasAny(text, [/\bhiver\b/, /\bwinter\b/])) {
    spec.paletteId = "winter";
  } else if (hasAny(text, [/\bprintemps\b/, /\bspring\b/])) {
    spec.paletteId = "spring";
  } else if (hasAny(text, [/\bete\b/, /\bsummer\b/])) {
    spec.paletteId = "summer";
  }
  let dungeonPlan = null;
  if (hasMultiRooms) {
    const normalizedRooms = Math.max(2, Math.min(6, Math.floor(roomCount ?? 2)));
    const layoutStyle = wantsCorridor || normalizedRooms > 2 ? "corridor" : wantsSplitWall ? "split" : "split";
    const rooms = Array.from({ length: normalizedRooms }, (_, idx) => ({
      id: `room-${idx + 1}`
    }));
    const playerRoomId = ((_a = rooms[0]) == null ? void 0 : _a.id) ?? "room-1";
    let enemyRoomId;
    const clauses = splitClauses(text);
    for (const clause of clauses) {
      if (!enemyRoomId && /\b(autre|l'autre|seconde|deuxieme)\b/.test(clause)) {
        enemyRoomId = (_b = rooms[1]) == null ? void 0 : _b.id;
      }
    }
    const doorState = parseDoorState(text) ?? "open";
    const doorPosition = parseDoorPosition(text);
    dungeonPlan = {
      roomCount: normalizedRooms,
      layoutStyle,
      splitAxis: layoutStyle === "split" ? splitAxis ?? "vertical" : void 0,
      corridorSide: layoutStyle === "corridor" ? corridorSide ?? "north" : void 0,
      doorState,
      doorPosition,
      playerRoomId,
      enemyRoomId,
      rooms
    };
    for (const clause of clauses) {
      const isPlayerClause = /\b(joueur|player|heros)\b/.test(clause);
      const isOtherClause = /\b(autre|l'autre|seconde|deuxieme)\b/.test(clause);
      const targetRoomId = isOtherClause ? enemyRoomId ?? ((_c = rooms[1]) == null ? void 0 : _c.id) ?? playerRoomId : isPlayerClause ? playerRoomId : void 0;
      const tableCount = extractNumber(clause, [/\b(\d+)\s*table\w*\b/]) ?? extractWordNumber(clause, [/\b([a-z]+)\s*table\w*\b/]) ?? (/\btable\w*\b/.test(clause) ? 1 : null);
      const barrelCount = extractNumber(clause, [/\b(\d+)\s*(tonneau\w*|baril\w*|barrel\w*)\b/]) ?? extractWordNumber(clause, [/\b([a-z]+)\s*(tonneau\w*|baril\w*|barrel\w*)\b/]) ?? (/\b(tonneau\w*|baril\w*|barrel\w*)\b/.test(clause) ? 2 : null);
      const enemyCount = extractNumber(clause, [/\b(\d+)\s*ennemis?\b/]) ?? extractWordNumber(clause, [/\b([a-z]+)\s*ennemis?\b/]);
      if (enemyCount !== null) {
        dungeonPlan.enemyCountOverride = Math.max(1, Math.floor(enemyCount));
        const resolvedRoomId = targetRoomId ?? dungeonPlan.enemyRoomId ?? ((_d = rooms[1]) == null ? void 0 : _d.id);
        if (resolvedRoomId) dungeonPlan.enemyRoomId = resolvedRoomId;
      }
      const addContent = (kind2, count2) => {
        if (count2 === null) return;
        const roomId = targetRoomId ?? playerRoomId;
        const room = dungeonPlan == null ? void 0 : dungeonPlan.rooms.find((r2) => r2.id === roomId);
        if (!room) return;
        room.contents = room.contents ?? [];
        room.contents.push({ kind: kind2, count: count2 });
      };
      addContent("table", tableCount);
      addContent("barrel", barrelCount);
      if (/\bacces exterieur\b/.test(clause) || /\bentree exterieure\b/.test(clause)) {
        const state = parseDoorState(clause) ?? "open";
        const side = parseSideHint(clause);
        dungeonPlan.exteriorAccess = [
          {
            roomId: playerRoomId,
            side,
            position: parseDoorPosition(clause),
            state
          }
        ];
      }
    }
    if (dungeonPlan.enemyCountOverride) {
      notes.push(`enemyCountOverride=${dungeonPlan.enemyCountOverride}`);
    }
    if ((_e = dungeonPlan.exteriorAccess) == null ? void 0 : _e.length) {
      const access = dungeonPlan.exteriorAccess[0];
      if (access) {
        notes.push(`exteriorAccess room=${access.roomId} side=${access.side ?? "auto"} state=${access.state ?? "open"}`);
      }
    }
    const expanded = computeExpandedGrid({
      cols: spec.grid.cols,
      rows: spec.grid.rows,
      roomCount: normalizedRooms,
      style: layoutStyle,
      axis: dungeonPlan.splitAxis,
      corridorSide: dungeonPlan.corridorSide
    });
    if (expanded.cols !== spec.grid.cols || expanded.rows !== spec.grid.rows) {
      notes.push(`gridExpanded=${expanded.cols}x${expanded.rows}`);
    }
    spec.grid = expanded;
    spec.layoutId = layoutStyle === "corridor" ? "dungeon_corridor_rooms" : "dungeon_split_rooms";
    spec.dungeonPlan = dungeonPlan;
    notes.push(`dungeonPlan rooms=${dungeonPlan.roomCount} style=${dungeonPlan.layoutStyle}`);
  }
  if (theme2 === "dungeon" && wantsCircularRoom) {
    if (spec.dungeon) {
      spec.dungeon.room.radius = Math.max(2, Math.floor(Math.min(params.cols, params.rows) * 0.33));
      if (entrances !== null) spec.dungeon.entrances.count = Math.max(0, entrances);
      if (entrancePlacements.length) {
        spec.dungeon.entrances.placements = entrancePlacements;
        spec.dungeon.entrances.sides = uniqueSides(entrancePlacements);
      }
      if (columns !== null) spec.dungeon.columns = Math.max(0, columns);
      if (lowLight && centerLit) spec.dungeon.lighting = "low";
    }
  }
  if (theme2 === "dungeon" && (wantsSquareRoom || wantsRectRoom)) {
    if (spec.dungeon) {
      if (entrances !== null) spec.dungeon.entrances.count = Math.max(0, entrances);
      if (entrancePlacements.length) {
        spec.dungeon.entrances.placements = entrancePlacements;
        spec.dungeon.entrances.sides = uniqueSides(entrancePlacements);
      }
      if (columns !== null) spec.dungeon.columns = Math.max(0, columns);
      if (lowLight && centerLit) spec.dungeon.lighting = "low";
    }
  }
  if (theme2 === "forest" && wantsClearing) {
    if (spec.forest) {
      spec.forest.treesOnRing = hasAny(text, [/\bparseme\b/, /\bparsem\w+/]) ? "sparse" : "dense";
      spec.forest.radius = Math.max(2, Math.floor(Math.min(params.cols, params.rows) * 0.3));
    }
  }
  if (theme2 === "city" && wantsStreet) {
    if (spec.city) {
      if (hasAny(text, [/\bverticale?\b/, /\bnord[- ]sud\b/, /\bnord\s*-\s*sud\b/])) {
        spec.city.direction = "vertical";
      } else if (hasAny(text, [/\bhorizontale?\b/, /\best[- ]ouest\b/, /\best\s*-\s*ouest\b/])) {
        spec.city.direction = "horizontal";
      } else {
        spec.city.direction = "horizontal";
      }
      spec.city.streetWidth = Math.max(1, extractNumber(text, [/\b(\d+)\s*cases?\b/]) ?? 2);
      if (houseCount !== null) spec.city.patternCount = Math.max(1, houseCount);
    }
  }
  if (theme2 === "city" && spec.city && wantsStreet && wantsHouse) {
    if (wantsBuildingLayout) {
      spec.city.patterns = [buildingStyle === "closed" ? "house-tiered-closed" : "house-tiered-open"];
    } else {
      spec.city.patterns = ["street-house-front-3x5"];
    }
    notes.push(`cityPatterns=${spec.city.patterns.join(",")}`);
    if (typeof spec.city.patternCount === "number") {
      notes.push(`cityPatternCount=${spec.city.patternCount}`);
    }
  }
  if (theme2 === "dungeon" && spec.dungeon) {
    if (noEntrances) {
      spec.dungeon.entrances.count = 0;
      spec.dungeon.entrances.placements = void 0;
      spec.dungeon.entrances.sides = void 0;
    } else if (entrancePlacements.length) {
      const placementCount = entrancePlacements.reduce(
        (sum, p2) => sum + (p2.count ?? 1),
        0
      );
      spec.dungeon.entrances.count = Math.max(
        spec.dungeon.entrances.count,
        placementCount
      );
    }
  }
  if (spec.layoutId === "building_tiered" && wantsBuildingLayout) {
    spec.building = { style: buildingStyle };
  } else {
    spec.building = void 0;
  }
  if (theme2 === "city" && spec.city) {
    const offsetMatch = text.match(/\bdecal\w*\s*(?:de\s*(\d+))?\s*(?:cases?)?\s*(?:vers|au|a|cote)?\s*(nord|sud|est|ouest)\b/);
    const hasOffsetWord = /\bdecal\w*\b/.test(text);
    const offsetAmount = offsetMatch && offsetMatch[1] ? Number(offsetMatch[1]) : 2;
    const offsetDirToken = offsetMatch == null ? void 0 : offsetMatch[2];
    const offsetDir = offsetDirToken === "nord" ? "north" : offsetDirToken === "sud" ? "south" : offsetDirToken === "est" ? "east" : offsetDirToken === "ouest" ? "west" : void 0;
    if (offsetDir) {
      spec.city.streetOffset = { dir: offsetDir, amount: Math.max(0, Math.floor(offsetAmount)) };
    } else if (hasOffsetWord) {
      const fallbackDir = spec.city.direction === "vertical" ? "west" : "north";
      spec.city.streetOffset = { dir: fallbackDir, amount: Math.max(1, Math.floor(offsetAmount)) };
    }
  }
  if (spec.obstacleRequests && spec.obstacleRequests.some((r2) => r2.placement === "between_road_house" || r2.placement === "road_edge")) {
    if (spec.city) {
      spec.city.sidewalk = Math.max(1, spec.city.sidewalk ?? 1);
    }
  }
  notes.push(`theme=${theme2} layout=${spec.layoutId} time=${timeOfDay}`);
  notes.push(`sizeHint=${sizeHint}`);
  if (obstacleRequests && obstacleRequests.length > 0) {
    notes.push(
      `obstacleRequests=${obstacleRequests.map((r2) => `${r2.typeId}x${r2.count ?? 1}${r2.orientation ? `[${r2.orientation}]` : ""}`).join(",")}`
    );
  }
  return { spec, notes };
}
function mulberry32(seed) {
  let t2 = seed >>> 0;
  return () => {
    t2 += 1831565813;
    let x2 = Math.imul(t2 ^ t2 >>> 15, 1 | t2);
    x2 ^= x2 + Math.imul(x2 ^ x2 >>> 7, 61 | x2);
    return ((x2 ^ x2 >>> 14) >>> 0) / 4294967296;
  };
}
function hashStringToSeed(input) {
  const str = String(input ?? "");
  let h2 = 2166136261;
  for (let i2 = 0; i2 < str.length; i2++) {
    h2 ^= str.charCodeAt(i2);
    h2 = Math.imul(h2, 16777619);
  }
  return h2 >>> 0;
}
function pickWeighted(items, rand) {
  var _a, _b;
  const total = items.reduce((sum, it) => sum + Math.max(0, it.weight), 0);
  if (total <= 0) return ((_a = items[0]) == null ? void 0 : _a.item) ?? null;
  let r2 = rand() * total;
  for (const it of items) {
    const w2 = Math.max(0, it.weight);
    if (r2 < w2) return it.item;
    r2 -= w2;
  }
  return ((_b = items[items.length - 1]) == null ? void 0 : _b.item) ?? null;
}
function randomIntInclusive(rand, min, max) {
  const lo = Math.min(min, max);
  const hi = Math.max(min, max);
  return lo + Math.floor(rand() * (hi - lo + 1));
}
function chooseEnemyType(enemyTypes, rand) {
  if (enemyTypes.length === 0) return null;
  return enemyTypes[Math.floor(rand() * enemyTypes.length)] ?? enemyTypes[0];
}
function spawnEnemies(params) {
  const { draft, playerStart, enemyTypes, rand, spawnMask } = params;
  const log2 = [];
  const enemySpawns = [];
  const enemyCount = clamp$4(params.enemyCount, 0, 20);
  if (enemyCount === 0) {
    log2.push("Spawns: 0/0 ennemis (desactive).");
    return { enemySpawns, log: log2 };
  }
  const reachable = computeReachableCells(draft, playerStart);
  const scoreCell = (x2, y2) => Math.abs(x2 - playerStart.x) + Math.abs(y2 - playerStart.y) + rand() * 0.25;
  const candidates = [];
  for (let y2 = 0; y2 < draft.rows; y2++) {
    for (let x2 = 0; x2 < draft.cols; x2++) {
      if (spawnMask && !spawnMask.has(key(x2, y2))) continue;
      if (draft.occupied.has(key(x2, y2))) continue;
      if (draft.playable.size > 0 && !draft.playable.has(key(x2, y2))) continue;
      if (x2 === playerStart.x && y2 === playerStart.y) continue;
      if (!spawnMask && reachable.size > 0 && !reachable.has(key(x2, y2))) continue;
      candidates.push({ x: x2, y: y2 });
    }
  }
  if (candidates.length === 0) {
    for (let y2 = 0; y2 < draft.rows; y2++) {
      for (let x2 = 0; x2 < draft.cols; x2++) {
        if (draft.occupied.has(key(x2, y2))) continue;
        if (draft.playable.size > 0 && !draft.playable.has(key(x2, y2))) continue;
        if (x2 === playerStart.x && y2 === playerStart.y) continue;
        candidates.push({ x: x2, y: y2 });
      }
    }
    log2.push("Spawns: fallback (aucune case atteignable libre).");
    if (spawnMask) log2.push("Spawns: fallback sans masque de salle.");
  }
  candidates.sort((a2, b2) => scoreCell(b2.x, b2.y) - scoreCell(a2.x, a2.y));
  for (let i2 = 0; i2 < enemyCount; i2++) {
    const enemyType = chooseEnemyType(enemyTypes, rand);
    if (!enemyType) break;
    const pos = candidates.find((c2) => !enemySpawns.some((e2) => e2.position.x === c2.x && e2.position.y === c2.y));
    if (!pos) break;
    enemySpawns.push({ enemyType, position: pos });
  }
  log2.push(`Spawns: ${enemySpawns.length}/${enemyCount} ennemis.`);
  return { enemySpawns, log: log2 };
}
const patterns = ["./street-house-front-3x5.json", "./street-market-stall-3x4.json", "./interior-table-set.json", "./interior-tavern-corner.json", "./forest-alley-2x8.json", "./forest-grove-3x3.json", "./dungeon-altar-nook.json", "./house-tiered-open.json", "./house-tiered-closed.json"];
const patternsIndex = {
  patterns
};
const id$U = "street-house-front-3x5";
const label$h = "Facade maison 3x5";
const theme$8 = "city";
const tags$U = ["house", "street", "wall"];
const footprint$8 = { "w": 11, "h": 3 };
const anchor$8 = "bottomLeft";
const constraints$8 = { "needsClearArea": true, "avoidBorder": { "top": 0, "left": 0, "right": 0, "bottom": 0 } };
const allowedTerrains$2 = ["stone", "grass", "dirt", "floor"];
const elements$8 = [];
const wallAscii$2 = ["###########", "#         #", "###########"];
const wallDoors$2 = [{ "x": 2, "y": 2, "dir": "S", "state": "closed" }];
const floorPaint$2 = { "mode": "interior", "terrain": "floor" };
const streetHouseFront = {
  id: id$U,
  label: label$h,
  theme: theme$8,
  tags: tags$U,
  footprint: footprint$8,
  anchor: anchor$8,
  constraints: constraints$8,
  allowedTerrains: allowedTerrains$2,
  elements: elements$8,
  wallAscii: wallAscii$2,
  wallDoors: wallDoors$2,
  floorPaint: floorPaint$2
};
const id$T = "street_market_stall_3x4";
const label$g = "Etal de marche 3x4";
const theme$7 = "city";
const tags$T = ["market", "stall", "street"];
const footprint$7 = { "w": 4, "h": 3 };
const anchor$7 = "bottomLeft";
const constraints$7 = { "needsClearArea": true, "avoidBorder": { "top": 0, "left": 0, "right": 0, "bottom": 0 } };
const elements$7 = [{ "type": "obstacle", "typeId": "fence-wood", "x": 0, "y": 0, "variant": "1", "rotation": 0 }, { "type": "obstacle", "typeId": "fence-wood", "x": 1, "y": 0, "variant": "1", "rotation": 0 }, { "type": "obstacle", "typeId": "fence-wood", "x": 2, "y": 0, "variant": "1", "rotation": 0 }, { "type": "obstacle", "typeId": "table-wood", "x": 1, "y": 1, "variant": "base", "rotation": 0 }, { "type": "obstacle", "typeId": "crate-wood", "x": 0, "y": 1, "variant": "base", "rotation": 0 }, { "type": "obstacle", "typeId": "barrel-wood", "x": 3, "y": 1, "variant": "base", "rotation": 0 }];
const streetMarketStall = {
  id: id$T,
  label: label$g,
  theme: theme$7,
  tags: tags$T,
  footprint: footprint$7,
  anchor: anchor$7,
  constraints: constraints$7,
  elements: elements$7
};
const id$S = "interior_table_set";
const label$f = "Table et chaises";
const theme$6 = "generic";
const tags$S = ["interior", "furniture"];
const footprint$6 = { "w": 3, "h": 3 };
const anchor$6 = "center";
const constraints$6 = { "needsClearArea": true };
const elements$6 = [{ "type": "obstacle", "typeId": "table-wood", "x": 1, "y": 1, "variant": "base", "rotation": 0 }, { "type": "obstacle", "typeId": "chair-wood", "x": 1, "y": 0, "variant": "base", "rotation": 180 }, { "type": "obstacle", "typeId": "chair-wood", "x": 1, "y": 2, "variant": "base", "rotation": 0 }, { "type": "obstacle", "typeId": "chair-wood", "x": 0, "y": 1, "variant": "base", "rotation": 90 }, { "type": "obstacle", "typeId": "chair-wood", "x": 2, "y": 1, "variant": "base", "rotation": 270 }];
const interiorTableSet = {
  id: id$S,
  label: label$f,
  theme: theme$6,
  tags: tags$S,
  footprint: footprint$6,
  anchor: anchor$6,
  constraints: constraints$6,
  elements: elements$6
};
const id$R = "interior_tavern_corner";
const label$e = "Coin taverne";
const theme$5 = "generic";
const tags$R = ["interior", "tavern", "furniture"];
const footprint$5 = { "w": 4, "h": 4 };
const anchor$5 = "bottomLeft";
const constraints$5 = { "needsClearArea": true };
const elements$5 = [{ "type": "obstacle", "typeId": "table-wood", "x": 1, "y": 1, "variant": "base", "rotation": 0 }, { "type": "obstacle", "typeId": "chair-wood", "x": 1, "y": 0, "variant": "base", "rotation": 180 }, { "type": "obstacle", "typeId": "chair-wood", "x": 2, "y": 1, "variant": "base", "rotation": 270 }, { "type": "obstacle", "typeId": "barrel-wood", "x": 3, "y": 0, "variant": "base", "rotation": 0 }, { "type": "obstacle", "typeId": "crate-wood", "x": 3, "y": 1, "variant": "base", "rotation": 0 }];
const interiorTavernCorner = {
  id: id$R,
  label: label$e,
  theme: theme$5,
  tags: tags$R,
  footprint: footprint$5,
  anchor: anchor$5,
  constraints: constraints$5,
  elements: elements$5
};
const id$Q = "forest_alley_2x8";
const label$d = "Allee d'arbres";
const theme$4 = "forest";
const tags$Q = ["alley", "trees"];
const footprint$4 = { "w": 8, "h": 4 };
const anchor$4 = "topLeft";
const constraints$4 = { "needsClearArea": true, "avoidBorder": { "left": 1, "right": 1, "top": 1, "bottom": 1 } };
const elements$4 = [{ "type": "obstacle", "typeId": "tree-oak", "x": 0, "y": 0, "variant": "base", "rotation": 0 }, { "type": "obstacle", "typeId": "tree-oak", "x": 0, "y": 3, "variant": "base", "rotation": 0 }, { "type": "obstacle", "typeId": "tree-oak", "x": 2, "y": 0, "variant": "base", "rotation": 0 }, { "type": "obstacle", "typeId": "tree-oak", "x": 2, "y": 3, "variant": "base", "rotation": 0 }, { "type": "obstacle", "typeId": "tree-oak", "x": 4, "y": 0, "variant": "base", "rotation": 0 }, { "type": "obstacle", "typeId": "tree-oak", "x": 4, "y": 3, "variant": "base", "rotation": 0 }, { "type": "obstacle", "typeId": "tree-oak", "x": 6, "y": 0, "variant": "base", "rotation": 0 }, { "type": "obstacle", "typeId": "tree-oak", "x": 6, "y": 3, "variant": "base", "rotation": 0 }];
const forestAlley = {
  id: id$Q,
  label: label$d,
  theme: theme$4,
  tags: tags$Q,
  footprint: footprint$4,
  anchor: anchor$4,
  constraints: constraints$4,
  elements: elements$4
};
const id$P = "forest_grove_3x3";
const label$c = "Petit bosquet";
const theme$3 = "forest";
const tags$P = ["grove", "trees"];
const footprint$3 = { "w": 3, "h": 3 };
const anchor$3 = "center";
const constraints$3 = { "needsClearArea": true };
const elements$3 = [{ "type": "obstacle", "typeId": "tree-oak", "x": 0, "y": 0, "variant": "base", "rotation": 0 }, { "type": "obstacle", "typeId": "tree-oak", "x": 2, "y": 0, "variant": "base", "rotation": 0 }, { "type": "obstacle", "typeId": "tree-oak", "x": 0, "y": 2, "variant": "base", "rotation": 0 }, { "type": "obstacle", "typeId": "tree-oak", "x": 2, "y": 2, "variant": "base", "rotation": 0 }, { "type": "obstacle", "typeId": "bush", "x": 1, "y": 1, "variant": "base", "rotation": 0 }];
const forestGrove = {
  id: id$P,
  label: label$c,
  theme: theme$3,
  tags: tags$P,
  footprint: footprint$3,
  anchor: anchor$3,
  constraints: constraints$3,
  elements: elements$3
};
const id$O = "dungeon_altar_nook";
const label$b = "Alcove d'autel";
const theme$2 = "dungeon";
const tags$O = ["altar", "dungeon", "ritual"];
const footprint$2 = { "w": 4, "h": 4 };
const anchor$2 = "bottomLeft";
const constraints$2 = { "needsClearArea": true };
const elements$2 = [{ "type": "obstacle", "typeId": "statue-stone", "x": 1, "y": 1, "variant": "base", "rotation": 0 }, { "type": "obstacle", "typeId": "brazier", "x": 0, "y": 1, "variant": "base", "rotation": 0 }, { "type": "obstacle", "typeId": "brazier", "x": 3, "y": 1, "variant": "base", "rotation": 0 }, { "type": "obstacle", "typeId": "torch-wall", "x": 0, "y": 3, "variant": "base", "rotation": 0 }, { "type": "obstacle", "typeId": "torch-wall", "x": 3, "y": 3, "variant": "base", "rotation": 0 }, { "type": "obstacle", "typeId": "pillar-stone", "x": 0, "y": 0, "variant": "base", "rotation": 0 }, { "type": "obstacle", "typeId": "pillar-stone", "x": 3, "y": 0, "variant": "base", "rotation": 0 }];
const dungeonAltarNook = {
  id: id$O,
  label: label$b,
  theme: theme$2,
  tags: tags$O,
  footprint: footprint$2,
  anchor: anchor$2,
  constraints: constraints$2,
  elements: elements$2
};
const id$N = "house-tiered-open";
const label$a = "Maison terrasse ouverte";
const theme$1 = "city";
const tags$N = ["maison", "terrasse", "balcon", "toit", "etage", "ouvert", "roof-open", "house"];
const footprint$1 = { "w": 6, "h": 5 };
const anchor$1 = "bottomLeft";
const constraints$1 = { "needsClearArea": true, "avoidBorder": { "top": 1, "bottom": 1, "left": 1, "right": 1 } };
const allowedTerrains$1 = ["stone", "grass", "dirt", "floor"];
const wallAscii$1 = ["######", "#    #", "#    #", "#    #", "######"];
const wallDoors$1 = [{ "x": 3, "y": 4, "dir": "S", "state": "open" }];
const floorPaint$1 = { "mode": "interior", "terrain": "floor", "height": 1 };
const elements$1 = [{ "type": "obstacle", "typeId": "stairs-stone", "x": 2, "y": 3, "variant": "base", "rotation": 0 }];
const houseTieredOpen = {
  id: id$N,
  label: label$a,
  theme: theme$1,
  tags: tags$N,
  footprint: footprint$1,
  anchor: anchor$1,
  constraints: constraints$1,
  allowedTerrains: allowedTerrains$1,
  wallAscii: wallAscii$1,
  wallDoors: wallDoors$1,
  floorPaint: floorPaint$1,
  elements: elements$1
};
const id$M = "house-tiered-closed";
const label$9 = "Maison etage clos";
const theme = "city";
const tags$M = ["maison", "etage", "ferme", "clos", "interieur", "toit", "roof-closed", "house"];
const footprint = { "w": 6, "h": 5 };
const anchor = "bottomLeft";
const constraints = { "needsClearArea": true, "avoidBorder": { "top": 1, "bottom": 1, "left": 1, "right": 1 } };
const allowedTerrains = ["stone", "grass", "dirt", "floor"];
const wallAscii = ["######", "#    #", "#    #", "#    #", "######"];
const wallDoors = [{ "x": 2, "y": 4, "dir": "S", "state": "closed" }];
const floorPaint = { "mode": "interior", "terrain": "floor", "height": 1 };
const elements = [{ "type": "obstacle", "typeId": "stairs-stone", "x": 2, "y": 3, "variant": "base", "rotation": 0 }];
const houseTieredClosed = {
  id: id$M,
  label: label$9,
  theme,
  tags: tags$M,
  footprint,
  anchor,
  constraints,
  allowedTerrains,
  wallAscii,
  wallDoors,
  floorPaint,
  elements
};
function getNormalizedWallAsciiSize(lines) {
  if (!Array.isArray(lines)) return null;
  const cleaned = lines.map((line) => String(line ?? "").replace(/\r/g, "")).filter((line) => line.trim().length > 0);
  if (cleaned.length === 0) return null;
  let w2 = 0;
  for (const line of cleaned) w2 = Math.max(w2, line.length);
  return { w: w2, h: cleaned.length };
}
function validatePattern(pattern) {
  var _a, _b, _c, _d;
  const issues = [];
  const w2 = Math.floor(((_a = pattern.footprint) == null ? void 0 : _a.w) ?? 0);
  const h2 = Math.floor(((_b = pattern.footprint) == null ? void 0 : _b.h) ?? 0);
  if (w2 <= 0 || h2 <= 0) {
    issues.push(`footprint invalide: ${(_c = pattern.footprint) == null ? void 0 : _c.w}x${(_d = pattern.footprint) == null ? void 0 : _d.h}`);
  }
  for (const el of pattern.elements ?? []) {
    const x2 = el.x;
    const y2 = el.y;
    if (typeof x2 === "number" && typeof y2 === "number" && w2 > 0 && h2 > 0) {
      if (x2 < 0 || y2 < 0 || x2 >= w2 || y2 >= h2) {
        issues.push(`element hors footprint: (${x2},${y2})`);
      }
    }
  }
  const wallSize = getNormalizedWallAsciiSize(pattern.wallAscii);
  if (wallSize && w2 > 0 && h2 > 0) {
    if (wallSize.w !== w2 || wallSize.h !== h2) {
      issues.push(`wallAscii ${wallSize.w}x${wallSize.h} != footprint ${w2}x${h2}`);
    }
    for (const door of pattern.wallDoors ?? []) {
      const dx = door.x;
      const dy = door.y;
      if (typeof dx === "number" && typeof dy === "number") {
        if (dx < 0 || dy < 0 || dx >= wallSize.w || dy >= wallSize.h) {
          issues.push(`door hors wallAscii: (${dx},${dy})`);
        }
      }
    }
  }
  return issues;
}
const PATTERN_MODULES = {
  "./street-house-front-3x5.json": streetHouseFront,
  "./street-market-stall-3x4.json": streetMarketStall,
  "./interior-table-set.json": interiorTableSet,
  "./interior-tavern-corner.json": interiorTavernCorner,
  "./forest-alley-2x8.json": forestAlley,
  "./forest-grove-3x3.json": forestGrove,
  "./dungeon-altar-nook.json": dungeonAltarNook,
  "./house-tiered-open.json": houseTieredOpen,
  "./house-tiered-closed.json": houseTieredClosed
};
function loadMapPatternsFromIndex() {
  const indexed = Array.isArray(patternsIndex.patterns) ? patternsIndex.patterns : [];
  const loaded = [];
  for (const path2 of indexed) {
    const mod = PATTERN_MODULES[path2];
    if (mod) {
      const issues = validatePattern(mod);
      for (const issue of issues) {
        console.warn(`[patterns] ${mod.id}: ${issue}`);
      }
      loaded.push(mod);
    } else {
      console.warn("[patterns] Pattern path missing in bundle:", path2);
    }
  }
  if (loaded.length === 0) {
    console.warn("[patterns] No patterns loaded from index.json");
  }
  return loaded;
}
function clamp$3(value2, min, max) {
  return Math.max(min, Math.min(max, value2));
}
function nextEven(value2) {
  const v2 = Math.max(1, Math.floor(value2));
  return v2 % 2 === 0 ? v2 : v2 + 1;
}
function resolveCityPatternFootprints(ids) {
  if (!ids.length) return null;
  const patterns2 = loadMapPatternsFromIndex();
  let maxW = 0;
  let maxH = 0;
  for (const id2 of ids) {
    const p2 = patterns2.find((item) => item.id === id2);
    if (!p2) continue;
    maxW = Math.max(maxW, Math.max(1, Math.floor(p2.footprint.w)));
    maxH = Math.max(maxH, Math.max(1, Math.floor(p2.footprint.h)));
  }
  if (maxW <= 0 || maxH <= 0) return null;
  return { maxW, maxH };
}
function recommendGridFromSpec(params) {
  var _a, _b, _c;
  const { spec } = params;
  const cols = Math.max(1, spec.grid.cols);
  const rows = Math.max(1, spec.grid.rows);
  const targetPlayableCells = spec.sizeHint === "large" ? Math.max(120, params.enemyCount * 28 + 80) : spec.sizeHint === "small" ? Math.max(48, params.enemyCount * 16 + 20) : Math.max(72, params.enemyCount * 22 + 40);
  if (spec.layoutId === "dungeon_circular_room") {
    const r2 = Math.sqrt(targetPlayableCells / Math.PI);
    const minDim = nextEven(Math.ceil(r2 * 2 + 4));
    const desiredRows = Math.max(rows, minDim);
    const desiredCols = Math.max(cols, nextEven(Math.ceil(minDim * 1.4)));
    if (desiredCols > cols || desiredRows > rows) {
      return {
        cols: clamp$3(desiredCols, cols, 60),
        rows: clamp$3(desiredRows, rows, 40),
        reason: `salle circulaire '${spec.sizeHint ?? "medium"}' -> minDim${minDim}, cible${targetPlayableCells} cases`
      };
    }
    return null;
  }
  if (spec.layoutId === "dungeon_square_room") {
    const minSide = nextEven(Math.ceil(Math.sqrt(targetPlayableCells) + 4));
    const desiredSide = Math.max(minSide, Math.max(cols, rows));
    const aspect = cols / rows;
    const wantSquare = aspect > 0.75 && aspect < 1.33;
    const desiredCols = Math.max(cols, wantSquare ? desiredSide : nextEven(Math.ceil(desiredSide * Math.max(1, aspect))));
    const desiredRows = Math.max(rows, wantSquare ? desiredSide : nextEven(Math.ceil(desiredSide / Math.max(1, aspect))));
    if (desiredCols > cols || desiredRows > rows) {
      return {
        cols: clamp$3(desiredCols, cols, 70),
        rows: clamp$3(desiredRows, rows, 50),
        reason: `salle carre '${spec.sizeHint ?? "medium"}' -> minDim${minSide}, cible${targetPlayableCells} cases`
      };
    }
    return null;
  }
  if (spec.layoutId === "city_street") {
    const scale = spec.sizeHint === "large" ? 1.6 : spec.sizeHint === "small" ? 1 : 1.25;
    const desiredCols = Math.max(cols, nextEven(Math.ceil(cols * scale)));
    const desiredRows = Math.max(
      rows,
      nextEven(Math.ceil(rows * (spec.sizeHint === "large" ? 1.4 : 1.1)))
    );
    const patternIds = ((_a = spec.city) == null ? void 0 : _a.patterns) ?? [];
    const patternCountRaw = typeof ((_b = spec.city) == null ? void 0 : _b.patternCount) === "number" ? Math.floor(spec.city.patternCount) : patternIds.length;
    const patternCount = Math.max(0, patternCountRaw);
    const footprint2 = resolveCityPatternFootprints(patternIds);
    const streetWidth = Math.max(1, Math.floor(((_c = spec.city) == null ? void 0 : _c.streetWidth) ?? 2));
    const spacing = 1;
    let minCols = desiredCols;
    let minRows = desiredRows;
    if (footprint2 && patternCount > 0) {
      const neededCols = patternCount * (footprint2.maxW + spacing) + 2;
      const neededRows = streetWidth + 2 * footprint2.maxH + 2;
      minCols = Math.max(minCols, nextEven(Math.ceil(neededCols)));
      minRows = Math.max(minRows, nextEven(Math.ceil(neededRows)));
    }
    if (minCols > cols || minRows > rows) {
      return {
        cols: clamp$3(minCols, cols, 70),
        rows: clamp$3(minRows, rows, 50),
        reason: `rue '${spec.sizeHint ?? "medium"}' -> espace pour patterns`
      };
    }
    return null;
  }
  if (spec.layoutId === "forest_clearing") {
    const scale = spec.sizeHint === "large" ? 1.5 : spec.sizeHint === "small" ? 1 : 1.2;
    const desiredCols = Math.max(cols, nextEven(Math.ceil(cols * scale)));
    const desiredRows = Math.max(rows, nextEven(Math.ceil(rows * scale)));
    if (desiredCols > cols || desiredRows > rows) {
      return {
        cols: clamp$3(desiredCols, cols, 70),
        rows: clamp$3(desiredRows, rows, 50),
        reason: `clairiere '${spec.sizeHint ?? "medium"}' -> plus d'espace autour`
      };
    }
    return null;
  }
  if (spec.sizeHint === "large") {
    const desiredCols = Math.max(cols, 18);
    const desiredRows = Math.max(rows, 12);
    if (desiredCols > cols || desiredRows > rows) {
      return {
        cols: desiredCols,
        rows: desiredRows,
        reason: "taille 'large' (fallback generique)"
      };
    }
  }
  return null;
}
function findObstacleType(obstacleTypes, typeId) {
  return obstacleTypes.find((t2) => t2.id === typeId) ?? null;
}
function weightedTypesForContext(obstacleTypes, filter) {
  return obstacleTypes.filter(filter).map((t2) => {
    var _a;
    return { item: t2, weight: Math.max(0, Number(((_a = t2.spawnRules) == null ? void 0 : _a.weight) ?? 1)) };
  }).filter((x2) => x2.weight > 0);
}
function pickVariantIdForPlacement(type2, desiredShape, rand) {
  const variants2 = Array.isArray(type2.variants) ? type2.variants : [];
  if (variants2.length === 0) return "base";
  const candidates = variants2.map((v2) => {
    const size2 = Array.isArray(v2.footprint) ? v2.footprint.length : 1;
    const weightBase = Math.max(1, size2);
    const weight2 = desiredShape === "line" ? weightBase * 2 : weightBase;
    return { item: v2.id, weight: weight2 };
  });
  return pickWeighted(candidates, rand) ?? variants2[0].id;
}
function randomRotationForPlacement(type2, variantId, rand) {
  var _a;
  const variant = (type2.variants ?? []).find((v2) => v2.id === variantId) ?? null;
  if (!(variant == null ? void 0 : variant.rotatable)) return 0;
  if (!((_a = type2.appearance) == null ? void 0 : _a.randomRotation)) return 0;
  const rotations = [0, 45, 90, 135, 180, 225, 270, 315];
  return rotations[Math.floor(rand() * rotations.length)] ?? 0;
}
function findWallType(wallTypes, typeId) {
  return wallTypes.find((t2) => t2.id === typeId) ?? null;
}
function resolveWallKindFromType(typeDef) {
  var _a, _b;
  if (!typeDef) return "wall";
  const kind2 = ((_a = typeDef.behavior) == null ? void 0 : _a.kind) ?? "solid";
  if (kind2 === "door") return "door";
  const heightClass = ((_b = typeDef.appearance) == null ? void 0 : _b.heightClass) ?? "";
  if (String(heightClass).toLowerCase() === "low") return "low";
  const tags2 = typeDef.tags ?? [];
  if (tags2.some((t2) => String(t2).toLowerCase() === "low")) return "low";
  return "wall";
}
function resolveWallMaxHp(typeDef) {
  var _a, _b;
  if (!typeDef) return null;
  if (((_a = typeDef.durability) == null ? void 0 : _a.destructible) === false) return null;
  const hp = Number(((_b = typeDef.durability) == null ? void 0 : _b.maxHp) ?? 1);
  if (!Number.isFinite(hp)) return 1;
  return Math.max(1, hp);
}
function isWallDestructible$1(typeDef) {
  var _a;
  if (!typeDef) return false;
  return ((_a = typeDef.durability) == null ? void 0 : _a.destructible) !== false;
}
function cellDistance(ax, ay, bx, by) {
  const dx = ax - bx;
  const dy = ay - by;
  return Math.sqrt(dx * dx + dy * dy);
}
function buildCircularMask(params) {
  const mask = /* @__PURE__ */ new Set();
  for (let y2 = 0; y2 < params.rows; y2++) {
    for (let x2 = 0; x2 < params.cols; x2++) {
      const d2 = cellDistance(x2, y2, params.cx, params.cy);
      if (d2 <= params.radius) mask.add(key(x2, y2));
    }
  }
  return mask;
}
function isBoundaryCell(mask, x2, y2) {
  const k2 = key(x2, y2);
  if (!mask.has(k2)) return false;
  return !mask.has(key(x2 + 1, y2)) || !mask.has(key(x2 - 1, y2)) || !mask.has(key(x2, y2 + 1)) || !mask.has(key(x2, y2 - 1));
}
function chooseOpeningsOnMaskBoundary(params) {
  const { boundary, count: count2, rand } = params;
  if (boundary.length === 0 || count2 <= 0) return [];
  const chosen = [];
  const shuffled = [...boundary].sort(() => rand() - 0.5);
  const minDist = Math.max(2, Math.floor(Math.min(params.cols, params.rows) / 3));
  for (const c2 of shuffled) {
    if (chosen.length >= count2) break;
    if (chosen.every((o2) => Math.abs(o2.x - c2.x) + Math.abs(o2.y - c2.y) >= minDist)) {
      chosen.push(c2);
    }
  }
  while (chosen.length < count2) {
    chosen.push(boundary[Math.floor(rand() * boundary.length)]);
  }
  return chosen.slice(0, count2);
}
function groupBoundaryBySide$2(params) {
  const north = [];
  const south = [];
  const west = [];
  const east = [];
  for (const cell of params.boundary) {
    const dx = cell.x - params.cx;
    const dy = cell.y - params.cy;
    if (Math.abs(dx) >= Math.abs(dy)) {
      if (dx >= 0) east.push(cell);
      else west.push(cell);
    } else {
      if (dy >= 0) south.push(cell);
      else north.push(cell);
    }
  }
  north.sort((a2, b2) => a2.x - b2.x);
  south.sort((a2, b2) => a2.x - b2.x);
  west.sort((a2, b2) => a2.y - b2.y);
  east.sort((a2, b2) => a2.y - b2.y);
  return { north, south, west, east };
}
function pickByPosition$2(cells, position) {
  if (!cells.length) return null;
  if (!position) return cells[Math.floor(cells.length / 2)] ?? null;
  if (position === "start") return cells[0] ?? null;
  if (position === "end") return cells[cells.length - 1] ?? null;
  return cells[Math.floor(cells.length / 2)] ?? null;
}
function pickOpeningsOnSide$1(params) {
  const { cells, count: count2, position, rand } = params;
  if (!cells.length || count2 <= 0) return [];
  if (count2 === 1) {
    const picked = pickByPosition$2(cells, position);
    return picked ? [picked] : [];
  }
  const picks = [];
  const step = Math.max(1, Math.floor(cells.length / (count2 + 1)));
  for (let i2 = 0; i2 < count2 && i2 * step < cells.length; i2++) {
    const idx = Math.min(cells.length - 1, step * (i2 + 1));
    picks.push(cells[idx] ?? cells[cells.length - 1]);
  }
  while (picks.length < count2) {
    picks.push(cells[Math.floor(rand() * cells.length)]);
  }
  return picks;
}
function resolveOpenings$1(params) {
  const { boundary, bySide, entrances, cols, rows, rand } = params;
  if (!entrances) return [];
  const chosen = [];
  const chosenKeys = /* @__PURE__ */ new Set();
  const placements = entrances.placements ?? [];
  for (const placement2 of placements) {
    const sideCells = bySide[placement2.side] ?? [];
    const count2 = Math.max(1, Math.floor(placement2.count ?? 1));
    const picks = pickOpeningsOnSide$1({
      cells: sideCells,
      count: count2,
      position: placement2.position,
      rand
    });
    for (const p2 of picks) {
      const k2 = key(p2.x, p2.y);
      if (chosenKeys.has(k2)) continue;
      chosenKeys.add(k2);
      chosen.push(p2);
    }
  }
  const target = Math.max(0, Math.floor(entrances.count ?? 0));
  if (chosen.length >= target) return chosen.slice(0, target);
  const sideFilter = entrances.sides && entrances.sides.length ? entrances.sides.flatMap((side) => bySide[side] ?? []) : boundary;
  const remaining = sideFilter.filter((c2) => !chosenKeys.has(key(c2.x, c2.y)));
  const extra = chooseOpeningsOnMaskBoundary({
    cols,
    rows,
    boundary: remaining,
    count: target - chosen.length,
    rand
  });
  return chosen.concat(extra);
}
function pickDungeonDefaults$2(spec, ctx) {
  const wallType = findWallType(ctx.wallTypes, "wall-stone") ?? ctx.wallTypes.find((t2) => t2.category === "wall") ?? ctx.wallTypes[0] ?? null;
  const wallDoorType = findWallType(ctx.wallTypes, "wall-stone-door") ?? ctx.wallTypes.find((t2) => (t2.tags ?? []).includes("door")) ?? null;
  const pillarType = ctx.obstacleTypes.find((t2) => t2.id === "pillar-stone") ?? ctx.obstacleTypes.find((t2) => (t2.tags ?? []).includes("pillar")) ?? null;
  const barrelType = ctx.obstacleTypes.find((t2) => t2.id === "barrel-wood") ?? ctx.obstacleTypes.find((t2) => (t2.tags ?? []).includes("barrel")) ?? null;
  return { wallType, wallDoorType, pillarType, barrelType };
}
function generateDungeonCircularRoom(params) {
  const { spec, ctx, rand } = params;
  const cols = Math.max(1, spec.grid.cols);
  const rows = Math.max(1, spec.grid.rows);
  const draft = createDraft({ cols, rows, reserved: /* @__PURE__ */ new Set(), seedPrefix: "obs" });
  draft.log.push("Layout: donjon (salle circulaire).");
  const dSpec = spec.dungeon ?? {
    borderWalls: true,
    entrances: { count: 2, width: 1 },
    room: {},
    columns: 0,
    hasAltar: false,
    lighting: "normal"
  };
  const { wallType, wallDoorType, pillarType, barrelType } = pickDungeonDefaults$2(spec, ctx);
  const roomRadius = dSpec.room.radius ?? Math.max(2, Math.floor(Math.min(cols, rows) * 0.33));
  const cx = clamp$4(Math.floor(cols * 0.62), 0, cols - 1);
  const cy = clamp$4(Math.floor(rows * 0.5), 0, rows - 1);
  const roomMask = buildCircularMask({ cols, rows, cx, cy, radius: roomRadius });
  draft.playable = roomMask;
  let playerStart = { x: cx, y: cy };
  let best = null;
  let bestScore = Number.POSITIVE_INFINITY;
  for (const k2 of roomMask) {
    const [xStr, yStr] = k2.split(",");
    const x2 = Number(xStr);
    const y2 = Number(yStr);
    if (!Number.isFinite(x2) || !Number.isFinite(y2)) continue;
    const score = x2 * 100 + Math.abs(y2 - cy);
    if (score < bestScore) {
      bestScore = score;
      best = { x: x2, y: y2 };
    }
  }
  if (best) playerStart = best;
  for (let y2 = 0; y2 < rows; y2++) {
    for (let x2 = 0; x2 < cols; x2++) {
      if (roomMask.has(key(x2, y2))) setTerrain(draft, x2, y2, "stone");
    }
  }
  const dirtPatchCount = clamp$4(Math.floor((roomMask.size || 0) / 140), 1, 5);
  scatterTerrainPatches({
    draft,
    rand,
    terrain: "dirt",
    count: dirtPatchCount,
    radiusMin: 1,
    radiusMax: 2,
    mask: roomMask
  });
  const baseLight = dSpec.lighting === "low" ? 0.25 : 0.75;
  for (let y2 = 0; y2 < rows; y2++) {
    for (let x2 = 0; x2 < cols; x2++) {
      if (!roomMask.has(key(x2, y2))) continue;
      const dist = cellDistance(x2, y2, cx, cy);
      const t2 = clamp$4(1 - dist / (roomRadius + 1e-3), 0, 1);
      const centerBoost = dSpec.lighting === "low" ? 0.55 * t2 : 0.15 * t2;
      setLight(draft, x2, y2, clamp$4(baseLight + centerBoost, 0, 1));
    }
  }
  const boundaryCells = [];
  for (let y2 = 0; y2 < rows; y2++) {
    for (let x2 = 0; x2 < cols; x2++) {
      if (!isBoundaryCell(roomMask, x2, y2)) continue;
      boundaryCells.push({ x: x2, y: y2 });
    }
  }
  const boundaryBySide = groupBoundaryBySide$2({ boundary: boundaryCells, cx, cy });
  const openings = resolveOpenings$1({
    boundary: boundaryCells,
    bySide: boundaryBySide,
    entrances: dSpec.entrances,
    cols,
    rows,
    rand
  });
  const openingKeys = new Set(openings.map((o2) => key(o2.x, o2.y)));
  for (const ok of openingKeys) draft.reserved.add(ok);
  if (wallType && dSpec.borderWalls) {
    const baseKind = resolveWallKindFromType(wallType);
    const doorKind = wallDoorType ? resolveWallKindFromType(wallDoorType) : "door";
    const baseMaxHp = resolveWallMaxHp(wallType);
    const doorMaxHp = resolveWallMaxHp(wallDoorType);
    let placedWalls = 0;
    const openingDirForCell = (cell) => {
      const dx = cell.x - cx;
      const dy = cell.y - cy;
      if (Math.abs(dx) >= Math.abs(dy)) return dx >= 0 ? "E" : "W";
      return dy >= 0 ? "S" : "N";
    };
    const dirs = [
      { dx: 0, dy: -1, dir: "N" },
      { dx: 0, dy: 1, dir: "S" },
      { dx: -1, dy: 0, dir: "W" },
      { dx: 1, dy: 0, dir: "E" }
    ];
    for (const cell of boundaryCells) {
      const isOpening = openingKeys.has(key(cell.x, cell.y));
      const openingDir = isOpening ? openingDirForCell(cell) : null;
      for (const d2 of dirs) {
        const nx = cell.x + d2.dx;
        const ny = cell.y + d2.dy;
        const neighborKey = key(nx, ny);
        if (roomMask.has(neighborKey)) continue;
        const isDoorEdge = isOpening && openingDir === d2.dir;
        const kind2 = isDoorEdge ? doorKind : baseKind;
        const state = isDoorEdge ? "open" : void 0;
        const typeId = isDoorEdge ? wallDoorType == null ? void 0 : wallDoorType.id : wallType.id;
        const maxHp = isDoorEdge ? doorMaxHp : baseMaxHp;
        if (tryPlaceWallSegment({
          draft,
          x: cell.x,
          y: cell.y,
          dir: d2.dir,
          kind: kind2,
          state,
          typeId,
          maxHp: maxHp ?? void 0,
          allowOnReserved: true
        })) {
          placedWalls++;
        }
      }
    }
    draft.log.push(`Murs: ${placedWalls} segments (avec ${openings.length} acces).`);
  } else {
    draft.log.push("Murs: aucun type de mur disponible.");
  }
  const columns = Math.max(0, dSpec.columns);
  if (columns > 0) {
    const typeForColumns = pillarType ?? null;
    if (!typeForColumns) {
      draft.log.push("Colonnes: aucun type de pilier disponible.");
    }
    let placed = 0;
    const ring = Math.max(1, Math.floor(roomRadius * 0.5));
    const candidates = [
      { x: cx + ring, y: cy },
      { x: cx - ring, y: cy },
      { x: cx, y: cy + ring },
      { x: cx, y: cy - ring }
    ].filter((p2) => roomMask.has(key(p2.x, p2.y)));
    while (typeForColumns && placed < columns && candidates.length) {
      const p2 = candidates.shift();
      const variantId = typeForColumns ? pickVariantIdForPlacement(typeForColumns, "scatter", rand) : "base";
      const rotation = typeForColumns ? randomRotationForPlacement(typeForColumns, variantId, rand) : 0;
      const ok = tryPlaceObstacle({
        draft,
        type: typeForColumns,
        x: p2.x,
        y: p2.y,
        variantId,
        rotation
      });
      if (ok) placed++;
    }
    let attempts2 = 0;
    while (typeForColumns && placed < columns && attempts2 < 200) {
      attempts2++;
      const x2 = clamp$4(cx + randomIntInclusive(rand, -roomRadius + 1, roomRadius - 1), 0, cols - 1);
      const y2 = clamp$4(cy + randomIntInclusive(rand, -roomRadius + 1, roomRadius - 1), 0, rows - 1);
      if (!roomMask.has(key(x2, y2))) continue;
      if (openingKeys.has(key(x2, y2))) continue;
      const variantId = typeForColumns ? pickVariantIdForPlacement(typeForColumns, "scatter", rand) : "base";
      const rotation = typeForColumns ? randomRotationForPlacement(typeForColumns, variantId, rand) : 0;
      const ok = tryPlaceObstacle({
        draft,
        type: typeForColumns,
        x: x2,
        y: y2,
        variantId,
        rotation
      });
      if (ok) placed++;
    }
    draft.log.push(`Colonnes: ${placed}/${columns}.`);
  }
  if (dSpec.hasAltar) {
    const altarType = barrelType ?? pillarType ?? null;
    if (altarType) {
      const variantId = pickVariantIdForPlacement(altarType, "room", rand);
      const rotation = randomRotationForPlacement(altarType, variantId, rand);
      const ok = tryPlaceObstacle({
        draft,
        type: altarType,
        x: cx,
        y: cy,
        variantId,
        rotation
      });
      draft.log.push(ok ? "Autel: plac au centre." : "Autel: placement impossible (collision).");
    } else {
      draft.log.push("Autel: aucun type d'obstacle appropri.");
    }
  }
  const propTypes = weightedTypesForContext(ctx.obstacleTypes, (t2) => t2.category !== "wall");
  const extraPropsTarget = clamp$4(Math.floor(cols * rows / 45), 1, 3);
  let extraPlaced = 0;
  let attempts = 0;
  while (extraPlaced < extraPropsTarget && attempts < 120) {
    attempts++;
    const chosen = pickWeighted(propTypes, rand) ?? null;
    if (!chosen) break;
    const x2 = clamp$4(cx + randomIntInclusive(rand, -roomRadius + 1, roomRadius - 1), 0, cols - 1);
    const y2 = clamp$4(cy + randomIntInclusive(rand, -roomRadius + 1, roomRadius - 1), 0, rows - 1);
    if (!roomMask.has(key(x2, y2))) continue;
    if (openingKeys.has(key(x2, y2))) continue;
    const variantId = pickVariantIdForPlacement(chosen, "scatter", rand);
    const rotation = randomRotationForPlacement(chosen, variantId, rand);
    const ok = tryPlaceObstacle({
      draft,
      type: chosen,
      x: x2,
      y: y2,
      variantId,
      rotation
    });
    if (ok) extraPlaced++;
  }
  if (extraPlaced > 0) draft.log.push(`Props: +${extraPlaced}.`);
  return { draft, playerStart };
}
function pickDungeonDefaults$1(ctx) {
  const wallType = findWallType(ctx.wallTypes, "wall-stone") ?? ctx.wallTypes.find((t2) => t2.category === "wall") ?? ctx.wallTypes[0] ?? null;
  const wallDoorType = findWallType(ctx.wallTypes, "wall-stone-door") ?? ctx.wallTypes.find((t2) => (t2.tags ?? []).includes("door")) ?? null;
  const pillarType = ctx.obstacleTypes.find((t2) => t2.id === "pillar-stone") ?? ctx.obstacleTypes.find((t2) => (t2.tags ?? []).includes("pillar")) ?? null;
  const barrelType = ctx.obstacleTypes.find((t2) => t2.id === "barrel-wood") ?? ctx.obstacleTypes.find((t2) => (t2.tags ?? []).includes("barrel")) ?? null;
  return { wallType, wallDoorType, pillarType, barrelType };
}
function buildRectBoundary(params) {
  const cells = [];
  for (let x2 = params.x1; x2 <= params.x2; x2++) {
    cells.push({ x: x2, y: params.y1 });
    if (params.y2 !== params.y1) cells.push({ x: x2, y: params.y2 });
  }
  for (let y2 = params.y1 + 1; y2 <= params.y2 - 1; y2++) {
    cells.push({ x: params.x1, y: y2 });
    if (params.x2 !== params.x1) cells.push({ x: params.x2, y: y2 });
  }
  return cells;
}
function groupBoundaryBySide$1(rect) {
  const north = [];
  const south = [];
  const west = [];
  const east = [];
  for (let x2 = rect.x1; x2 <= rect.x2; x2++) {
    north.push({ x: x2, y: rect.y1 });
    south.push({ x: x2, y: rect.y2 });
  }
  for (let y2 = rect.y1 + 1; y2 <= rect.y2 - 1; y2++) {
    west.push({ x: rect.x1, y: y2 });
    east.push({ x: rect.x2, y: y2 });
  }
  return { north, south, west, east };
}
function placeBoundaryEdges(params) {
  const { draft, boundaryBySide, wallType, wallDoorType, openingKeys } = params;
  if (!wallType) return 0;
  const baseKind = resolveWallKindFromType(wallType);
  const doorKind = wallDoorType ? resolveWallKindFromType(wallDoorType) : "door";
  const baseMaxHp = resolveWallMaxHp(wallType);
  const doorMaxHp = resolveWallMaxHp(wallDoorType);
  const placeSide = (cells, dir) => {
    let placed = 0;
    for (const cell of cells) {
      const isOpening = openingKeys.has(key(cell.x, cell.y));
      const kind2 = isOpening ? doorKind : baseKind;
      const state = isOpening ? "open" : void 0;
      const typeId = isOpening ? wallDoorType == null ? void 0 : wallDoorType.id : wallType.id;
      const maxHp = isOpening ? doorMaxHp : baseMaxHp;
      if (tryPlaceWallSegment({ draft, x: cell.x, y: cell.y, dir, kind: kind2, state, typeId, maxHp: maxHp ?? void 0, allowOnReserved: true })) placed++;
    }
    return placed;
  };
  return placeSide(boundaryBySide.north, "N") + placeSide(boundaryBySide.south, "S") + placeSide(boundaryBySide.west, "W") + placeSide(boundaryBySide.east, "E");
}
function chooseOpenings(params) {
  const { boundary, rand } = params;
  const count2 = Math.max(0, Math.floor(params.count));
  if (!boundary.length || count2 <= 0) return [];
  const chosen = [];
  const shuffled = [...boundary].sort(() => rand() - 0.5);
  const minDist = 4;
  for (const c2 of shuffled) {
    if (chosen.length >= count2) break;
    if (chosen.every((o2) => Math.abs(o2.x - c2.x) + Math.abs(o2.y - c2.y) >= minDist)) {
      chosen.push(c2);
    }
  }
  while (chosen.length < count2) {
    chosen.push(boundary[Math.floor(rand() * boundary.length)]);
  }
  return chosen.slice(0, count2);
}
function pickByPosition$1(cells, position) {
  if (!cells.length) return null;
  if (!position) return cells[Math.floor(cells.length / 2)] ?? null;
  if (position === "start") return cells[0] ?? null;
  if (position === "end") return cells[cells.length - 1] ?? null;
  return cells[Math.floor(cells.length / 2)] ?? null;
}
function pickOpeningsOnSide(params) {
  const { cells, count: count2, position, rand } = params;
  if (!cells.length || count2 <= 0) return [];
  if (count2 === 1) {
    const picked = pickByPosition$1(cells, position);
    return picked ? [picked] : [];
  }
  const picks = [];
  const step = Math.max(1, Math.floor(cells.length / (count2 + 1)));
  for (let i2 = 0; i2 < count2 && i2 * step < cells.length; i2++) {
    const idx = Math.min(cells.length - 1, step * (i2 + 1));
    picks.push(cells[idx] ?? cells[cells.length - 1]);
  }
  while (picks.length < count2) {
    picks.push(cells[Math.floor(rand() * cells.length)]);
  }
  return picks;
}
function resolveOpenings(params) {
  const { boundary, bySide, entrances, rand } = params;
  if (!entrances) return [];
  const chosen = [];
  const chosenKeys = /* @__PURE__ */ new Set();
  const placements = entrances.placements ?? [];
  for (const placement2 of placements) {
    const sideCells = bySide[placement2.side] ?? [];
    const count2 = Math.max(1, Math.floor(placement2.count ?? 1));
    const picks = pickOpeningsOnSide({
      cells: sideCells,
      count: count2,
      position: placement2.position,
      rand
    });
    for (const p2 of picks) {
      const k2 = key(p2.x, p2.y);
      if (chosenKeys.has(k2)) continue;
      chosenKeys.add(k2);
      chosen.push(p2);
    }
  }
  const target = Math.max(0, Math.floor(entrances.count ?? 0));
  if (chosen.length >= target) return chosen.slice(0, target);
  const sideFilter = entrances.sides && entrances.sides.length ? entrances.sides.flatMap((side) => bySide[side] ?? []) : boundary;
  const remaining = sideFilter.filter((c2) => !chosenKeys.has(key(c2.x, c2.y)));
  const extra = chooseOpenings({
    boundary: remaining,
    count: target - chosen.length,
    rand
  });
  return chosen.concat(extra);
}
function generateDungeonSquareRoom(params) {
  var _a;
  const { spec, ctx, rand } = params;
  const cols = Math.max(1, spec.grid.cols);
  const rows = Math.max(1, spec.grid.rows);
  const draft = createDraft({ cols, rows, reserved: /* @__PURE__ */ new Set(), seedPrefix: "obs" });
  draft.log.push("Layout: donjon (salle carre/rectangulaire).");
  const baseLight = ((_a = spec.dungeon) == null ? void 0 : _a.lighting) === "low" ? 0.35 : 0.8;
  for (let y2 = 0; y2 < rows; y2++) {
    for (let x2 = 0; x2 < cols; x2++) {
      setTerrain(draft, x2, y2, "stone");
      setLight(draft, x2, y2, baseLight);
    }
  }
  const dirtPatchCount = clamp$4(Math.floor(cols * rows / 140), 1, 6);
  scatterTerrainPatches({
    draft,
    rand,
    terrain: "dirt",
    count: dirtPatchCount,
    radiusMin: 1,
    radiusMax: 2
  });
  const playerStart = { x: 1, y: Math.floor(rows / 2) };
  const { wallType, wallDoorType, pillarType, barrelType } = pickDungeonDefaults$1(ctx);
  const dSpec = spec.dungeon ?? {
    borderWalls: true,
    entrances: { count: 2, width: 1 },
    columns: 0,
    hasAltar: false
  };
  const rect = { x1: 0, y1: 0, x2: cols - 1, y2: rows - 1 };
  const boundaryCells = buildRectBoundary(rect);
  const boundaryBySide = groupBoundaryBySide$1(rect);
  const openings = resolveOpenings({
    boundary: boundaryCells,
    bySide: boundaryBySide,
    entrances: dSpec.entrances,
    rand
  });
  const openingKeys = new Set(openings.map((o2) => key(o2.x, o2.y)));
  for (const ok of openingKeys) draft.reserved.add(ok);
  if (wallType && dSpec.borderWalls) {
    const placedWalls = placeBoundaryEdges({
      draft,
      boundaryBySide,
      wallType,
      wallDoorType,
      openingKeys
    });
    draft.log.push(`Murs: ${placedWalls} segments (avec ${openings.length} acces).`);
  } else {
    draft.log.push("Murs: aucun type de mur disponible.");
  }
  const columns = Math.max(0, dSpec.columns ?? 0);
  if (columns > 0) {
    const typeForColumns = pillarType ?? null;
    if (!typeForColumns) {
      draft.log.push("Colonnes: aucun type de pilier disponible.");
    }
    let placed = 0;
    let attempts2 = 0;
    while (typeForColumns && placed < columns && attempts2 < 300) {
      attempts2++;
      const x2 = clamp$4(1 + Math.floor(rand() * Math.max(1, cols - 2)), 1, Math.max(1, cols - 2));
      const y2 = clamp$4(1 + Math.floor(rand() * Math.max(1, rows - 2)), 1, Math.max(1, rows - 2));
      const variantId = typeForColumns ? pickVariantIdForPlacement(typeForColumns, "scatter", rand) : "base";
      const rotation = typeForColumns ? randomRotationForPlacement(typeForColumns, variantId, rand) : 0;
      const ok = tryPlaceObstacle({ draft, type: typeForColumns, x: x2, y: y2, variantId, rotation });
      if (ok) placed++;
    }
    draft.log.push(`Colonnes: ${placed}/${columns}.`);
  }
  if (dSpec.hasAltar) {
    const altarType = barrelType ?? pillarType ?? null;
    if (altarType) {
      const variantId = pickVariantIdForPlacement(altarType, "room", rand);
      const rotation = randomRotationForPlacement(altarType, variantId, rand);
      const cx = Math.floor(cols / 2);
      const cy = Math.floor(rows / 2);
      const ok = tryPlaceObstacle({ draft, type: altarType, x: cx, y: cy, variantId, rotation });
      draft.log.push(ok ? "Autel: plac au centre." : "Autel: placement impossible (collision).");
    } else {
      draft.log.push("Autel: aucun type d'obstacle appropri.");
    }
  }
  const propTypes = weightedTypesForContext(ctx.obstacleTypes, (t2) => t2.category !== "wall");
  const extraPropsTarget = clamp$4(Math.floor(cols * rows / 120), 0, 6);
  let extraPlaced = 0;
  let attempts = 0;
  while (extraPlaced < extraPropsTarget && attempts < 300) {
    attempts++;
    const chosen = pickWeighted(propTypes, rand) ?? null;
    if (!chosen) break;
    const x2 = clamp$4(1 + randomIntInclusive(rand, 0, Math.max(0, cols - 3)), 1, Math.max(1, cols - 2));
    const y2 = clamp$4(1 + randomIntInclusive(rand, 0, Math.max(0, rows - 3)), 1, Math.max(1, rows - 2));
    const variantId = pickVariantIdForPlacement(chosen, "scatter", rand);
    const rotation = randomRotationForPlacement(chosen, variantId, rand);
    const ok = tryPlaceObstacle({ draft, type: chosen, x: x2, y: y2, variantId, rotation });
    if (ok) extraPlaced++;
  }
  if (extraPlaced) draft.log.push(`Props: +${extraPlaced}.`);
  return { draft, playerStart };
}
function pickDungeonDefaults(ctx) {
  const wallType = findWallType(ctx.wallTypes, "wall-stone") ?? ctx.wallTypes.find((t2) => t2.category === "wall") ?? ctx.wallTypes[0] ?? null;
  const wallDoorType = findWallType(ctx.wallTypes, "wall-stone-door") ?? ctx.wallTypes.find((t2) => (t2.tags ?? []).includes("door")) ?? null;
  const pillarType = ctx.obstacleTypes.find((t2) => t2.id === "pillar-stone") ?? ctx.obstacleTypes.find((t2) => (t2.tags ?? []).includes("pillar")) ?? null;
  const barrelType = ctx.obstacleTypes.find((t2) => t2.id === "barrel-wood") ?? ctx.obstacleTypes.find((t2) => (t2.tags ?? []).includes("barrel")) ?? null;
  const tableType = ctx.obstacleTypes.find((t2) => t2.id === "table-wood") ?? ctx.obstacleTypes.find((t2) => (t2.tags ?? []).includes("table")) ?? null;
  const crateType = ctx.obstacleTypes.find((t2) => t2.id === "crate-wood") ?? ctx.obstacleTypes.find((t2) => (t2.tags ?? []).includes("crate")) ?? null;
  const altarType = ctx.obstacleTypes.find((t2) => t2.id === "altar-stone") ?? ctx.obstacleTypes.find((t2) => (t2.tags ?? []).includes("altar")) ?? null;
  return { wallType, wallDoorType, pillarType, barrelType, tableType, crateType, altarType };
}
function groupBoundaryBySide(rect) {
  const north = [];
  const south = [];
  const west = [];
  const east = [];
  for (let x2 = rect.x1; x2 <= rect.x2; x2++) {
    north.push({ x: x2, y: rect.y1 });
    south.push({ x: x2, y: rect.y2 });
  }
  for (let y2 = rect.y1 + 1; y2 <= rect.y2 - 1; y2++) {
    west.push({ x: rect.x1, y: y2 });
    east.push({ x: rect.x2, y: y2 });
  }
  return { north, south, west, east };
}
function pickByPosition(cells, position) {
  if (!cells.length) return null;
  if (!position) return cells[Math.floor(cells.length / 2)] ?? null;
  if (position === "start") return cells[0] ?? null;
  if (position === "end") return cells[cells.length - 1] ?? null;
  return cells[Math.floor(cells.length / 2)] ?? null;
}
function placeBoundaryWalls(params) {
  const { draft, boundaryBySide, wallType, wallDoorType, openings } = params;
  if (!wallType) {
    draft.log.push("Murs: aucun type de mur disponible.");
    return;
  }
  const baseKind = resolveWallKindFromType(wallType);
  const doorKind = wallDoorType ? resolveWallKindFromType(wallDoorType) : "door";
  const baseMaxHp = resolveWallMaxHp(wallType);
  const doorMaxHp = resolveWallMaxHp(wallDoorType);
  const placeSide = (cells, dir) => {
    let placed = 0;
    for (const cell of cells) {
      const k2 = key(cell.x, cell.y);
      const openingState = openings.get(k2) ?? null;
      const isOpening = openingState !== null;
      const kind2 = isOpening ? doorKind : baseKind;
      const state = isOpening ? openingState : void 0;
      const typeId = isOpening ? wallDoorType == null ? void 0 : wallDoorType.id : wallType.id;
      const maxHp = isOpening ? doorMaxHp : baseMaxHp;
      if (tryPlaceWallSegment({ draft, x: cell.x, y: cell.y, dir, kind: kind2, state, typeId, maxHp: maxHp ?? void 0, allowOnReserved: true })) {
        placed++;
      }
    }
    return placed;
  };
  const placedWalls = placeSide(boundaryBySide.north, "N") + placeSide(boundaryBySide.south, "S") + placeSide(boundaryBySide.west, "W") + placeSide(boundaryBySide.east, "E");
  draft.log.push(`Murs: ${placedWalls} segments (avec ${openings.size} acces).`);
}
function placeWallLine(params) {
  var _a;
  const { draft, wallType, wallDoorType } = params;
  if (!wallType) return;
  const baseKind = resolveWallKindFromType(wallType);
  const doorKind = wallDoorType ? resolveWallKindFromType(wallDoorType) : "door";
  const baseMaxHp = resolveWallMaxHp(wallType);
  const doorMaxHp = resolveWallMaxHp(wallDoorType);
  const isVertical = params.x1 === params.x2;
  const isHorizontal = params.y1 === params.y2;
  if (!isVertical && !isHorizontal) return;
  const dir = isVertical ? "W" : "N";
  const dx = Math.sign(params.x2 - params.x1);
  const dy = Math.sign(params.y2 - params.y1);
  let x2 = params.x1;
  let y2 = params.y1;
  while (true) {
    const isDoor = ((_a = params.doorCells) == null ? void 0 : _a.has(key(x2, y2))) ?? false;
    const kind2 = isDoor ? doorKind : baseKind;
    const state = isDoor ? params.doorState ?? "open" : void 0;
    const typeId = isDoor ? wallDoorType == null ? void 0 : wallDoorType.id : wallType.id;
    const maxHp = isDoor ? doorMaxHp : baseMaxHp;
    tryPlaceWallSegment({
      draft,
      x: x2,
      y: y2,
      dir,
      kind: kind2,
      state,
      typeId,
      maxHp: maxHp ?? void 0,
      allowOnReserved: true
    });
    if (x2 === params.x2 && y2 === params.y2) break;
    x2 += dx;
    y2 += dy;
  }
}
function pickDoorAlongLine(params) {
  const length = Math.max(1, params.max - params.min + 1);
  const center = params.min + Math.floor(length / 2);
  const start = params.min;
  const end = params.max;
  let chosen = center;
  if (params.position === "start") chosen = start;
  if (params.position === "end") chosen = end;
  if (params.axis === "vertical") return { x: params.fixed, y: chosen };
  return { x: chosen, y: params.fixed };
}
function collectRoomMask(params) {
  const mask = /* @__PURE__ */ new Set();
  const x1 = clamp$4(params.x1, 0, params.cols - 1);
  const y1 = clamp$4(params.y1, 0, params.rows - 1);
  const x2 = clamp$4(params.x2, 0, params.cols - 1);
  const y2 = clamp$4(params.y2, 0, params.rows - 1);
  for (let y3 = y1; y3 <= y2; y3++) {
    for (let x3 = x1; x3 <= x2; x3++) {
      mask.add(key(x3, y3));
    }
  }
  return mask;
}
function placeContents(params) {
  const { draft, roomMask, contents, ctx, rand } = params;
  const { tableType, barrelType, crateType, pillarType, altarType } = pickDungeonDefaults(ctx);
  const typeByKind = {
    table: tableType,
    barrel: barrelType,
    crate: crateType,
    pillar: pillarType,
    altar: altarType
  };
  let placed = 0;
  for (const item of contents) {
    const type2 = typeByKind[item.kind] ?? null;
    if (!type2) continue;
    const count2 = Math.max(1, Math.floor(item.count ?? 1));
    let placedForItem = 0;
    let attempts = 0;
    while (placedForItem < count2 && attempts < 120) {
      attempts++;
      const cells = Array.from(roomMask);
      const pick = cells[Math.floor(rand() * cells.length)] ?? null;
      if (!pick) break;
      const [xStr, yStr] = pick.split(",");
      const x2 = Number(xStr);
      const y2 = Number(yStr);
      if (!Number.isFinite(x2) || !Number.isFinite(y2)) continue;
      const variantId = pickVariantIdForPlacement(type2, "room", rand);
      const rotation = randomRotationForPlacement(type2, variantId, rand);
      const ok = tryPlaceObstacle({ draft, type: type2, x: x2, y: y2, variantId, rotation });
      if (ok) {
        placed++;
        placedForItem++;
      }
    }
  }
  return placed;
}
function fillRoomFallback(params) {
  var _a;
  const { draft, roomMask, ctx, rand } = params;
  const propTypes = weightedTypesForContext(ctx.obstacleTypes, (t2) => t2.category !== "wall");
  if (!propTypes.length) return;
  const target = Math.max(0, Math.floor(roomMask.size / 80));
  let placed = 0;
  let attempts = 0;
  while (placed < target && attempts < 100) {
    attempts++;
    const chosen = ((_a = propTypes[Math.floor(rand() * propTypes.length)]) == null ? void 0 : _a.item) ?? null;
    if (!chosen) continue;
    const cells = Array.from(roomMask);
    const pick = cells[Math.floor(rand() * cells.length)] ?? null;
    if (!pick) break;
    const [xStr, yStr] = pick.split(",");
    const x2 = Number(xStr);
    const y2 = Number(yStr);
    if (!Number.isFinite(x2) || !Number.isFinite(y2)) continue;
    const variantId = pickVariantIdForPlacement(chosen, "scatter", rand);
    const rotation = randomRotationForPlacement(chosen, variantId, rand);
    const ok = tryPlaceObstacle({ draft, type: chosen, x: x2, y: y2, variantId, rotation });
    if (ok) placed++;
  }
}
function generateDungeonRoomPlan(params) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
  const { spec, ctx, rand } = params;
  const cols = Math.max(1, spec.grid.cols);
  const rows = Math.max(1, spec.grid.rows);
  const draft = createDraft({ cols, rows, reserved: /* @__PURE__ */ new Set(), seedPrefix: "obs" });
  const plan = spec.dungeonPlan;
  draft.log.push("Layout: donjon (salles planifiees).");
  const baseLight = ((_a = spec.dungeon) == null ? void 0 : _a.lighting) === "low" ? 0.35 : 0.8;
  for (let y2 = 0; y2 < rows; y2++) {
    for (let x2 = 0; x2 < cols; x2++) {
      setTerrain(draft, x2, y2, "stone");
      setLight(draft, x2, y2, baseLight);
    }
  }
  const dirtPatchCount = clamp$4(Math.floor(cols * rows / 140), 1, 6);
  scatterTerrainPatches({
    draft,
    rand,
    terrain: "dirt",
    count: dirtPatchCount,
    radiusMin: 1,
    radiusMax: 2
  });
  const { wallType, wallDoorType } = pickDungeonDefaults(ctx);
  const rect = { x1: 0, y1: 0, x2: cols - 1, y2: rows - 1 };
  const boundaryBySide = groupBoundaryBySide(rect);
  const openings = /* @__PURE__ */ new Map();
  const playerRoomId = (plan == null ? void 0 : plan.playerRoomId) ?? ((_b = plan == null ? void 0 : plan.rooms[0]) == null ? void 0 : _b.id) ?? "room-1";
  const enemyRoomId = plan == null ? void 0 : plan.enemyRoomId;
  const roomMasks = {};
  const addExteriorOpening = (side, position, state) => {
    const cells = boundaryBySide[side] ?? [];
    const picked = pickByPosition(cells, position);
    if (!picked) return;
    openings.set(key(picked.x, picked.y), state ?? "open");
    draft.reserved.add(key(picked.x, picked.y));
  };
  if ((_c = plan == null ? void 0 : plan.exteriorAccess) == null ? void 0 : _c.length) {
    for (const access of plan.exteriorAccess) {
      const side = access.side ?? "west";
      addExteriorOpening(side, access.position, access.state === "closed" ? "closed" : "open");
    }
  }
  if ((plan == null ? void 0 : plan.layoutStyle) === "corridor") {
    const corridorSide = plan.corridorSide ?? "north";
    const corridorWidth = 2;
    const roomCount = Math.max(2, plan.roomCount);
    const roomWallGap = 0;
    if (corridorSide === "north" || corridorSide === "south") {
      const roomWidth = Math.max(3, Math.floor((cols - 2 - roomWallGap) / roomCount));
      const corridorYStart = corridorSide === "north" ? 1 : rows - corridorWidth - 1;
      const corridorYEnd = corridorYStart + corridorWidth - 1;
      const wallY = corridorSide === "north" ? corridorYEnd + 1 : corridorYStart - 1;
      let startX = 1;
      const doorCells = /* @__PURE__ */ new Set();
      for (let i2 = 0; i2 < roomCount; i2++) {
        const roomId = ((_d = plan.rooms[i2]) == null ? void 0 : _d.id) ?? `room-${i2 + 1}`;
        const x1 = startX;
        const x2 = Math.min(cols - 2, x1 + roomWidth - 1);
        const y1 = corridorSide === "north" ? wallY : 1;
        const y2 = corridorSide === "north" ? rows - 2 : wallY;
        const mask = collectRoomMask({ cols, rows, x1, y1, x2, y2 });
        roomMasks[roomId] = mask;
        const doorCell = pickDoorAlongLine({
          axis: "horizontal",
          min: x1,
          max: x2,
          fixed: wallY,
          position: plan.doorPosition
        });
        draft.reserved.add(key(doorCell.x, doorCell.y));
        doorCells.add(key(doorCell.x, doorCell.y));
        if (i2 < roomCount - 1) {
          const wallX = x2 + 1;
          placeWallLine({
            draft,
            wallType,
            wallDoorType,
            x1: wallX,
            y1,
            x2: wallX,
            y2
          });
        }
        startX = x2 + 1;
      }
      placeWallLine({
        draft,
        wallType,
        wallDoorType,
        x1: 1,
        y1: wallY,
        x2: cols - 2,
        y2: wallY,
        doorCells,
        doorState: plan.doorState === "closed" ? "closed" : "open"
      });
    } else {
      const roomHeight = Math.max(3, Math.floor((rows - 2 - roomWallGap) / roomCount));
      const corridorXStart = corridorSide === "west" ? 1 : cols - corridorWidth - 1;
      const corridorXEnd = corridorXStart + corridorWidth - 1;
      const wallX = corridorSide === "west" ? corridorXEnd + 1 : corridorXStart - 1;
      let startY = 1;
      const doorCells = /* @__PURE__ */ new Set();
      for (let i2 = 0; i2 < roomCount; i2++) {
        const roomId = ((_e = plan.rooms[i2]) == null ? void 0 : _e.id) ?? `room-${i2 + 1}`;
        const y1 = startY;
        const y2 = Math.min(rows - 2, y1 + roomHeight - 1);
        const x1 = corridorSide === "west" ? wallX : 1;
        const x2 = corridorSide === "west" ? cols - 2 : wallX;
        const mask = collectRoomMask({ cols, rows, x1, y1, x2, y2 });
        roomMasks[roomId] = mask;
        const doorCell = pickDoorAlongLine({
          axis: "vertical",
          min: y1,
          max: y2,
          fixed: wallX,
          position: plan.doorPosition
        });
        draft.reserved.add(key(doorCell.x, doorCell.y));
        doorCells.add(key(doorCell.x, doorCell.y));
        if (i2 < roomCount - 1) {
          const wallY = y2 + 1;
          placeWallLine({
            draft,
            wallType,
            wallDoorType,
            x1,
            y1: wallY,
            x2,
            y2: wallY
          });
        }
        startY = y2 + 1;
      }
      placeWallLine({
        draft,
        wallType,
        wallDoorType,
        x1: wallX,
        y1: 1,
        x2: wallX,
        y2: rows - 2,
        doorCells,
        doorState: plan.doorState === "closed" ? "closed" : "open"
      });
    }
  } else {
    const axis = (plan == null ? void 0 : plan.splitAxis) ?? "vertical";
    if (axis === "vertical") {
      const wallX = clamp$4(Math.floor(cols / 2), 2, cols - 3);
      const doorCell = pickDoorAlongLine({
        axis: "vertical",
        min: 1,
        max: rows - 2,
        fixed: wallX,
        position: plan == null ? void 0 : plan.doorPosition
      });
      draft.reserved.add(key(doorCell.x, doorCell.y));
      const doorCells = /* @__PURE__ */ new Set([key(doorCell.x, doorCell.y)]);
      placeWallLine({
        draft,
        wallType,
        wallDoorType,
        x1: wallX,
        y1: 1,
        x2: wallX,
        y2: rows - 2,
        doorCells,
        doorState: (plan == null ? void 0 : plan.doorState) === "closed" ? "closed" : "open"
      });
      const leftMask = collectRoomMask({ cols, rows, x1: 1, y1: 1, x2: wallX - 1, y2: rows - 2 });
      const rightMask = collectRoomMask({ cols, rows, x1: wallX, y1: 1, x2: cols - 2, y2: rows - 2 });
      roomMasks[((_f = plan == null ? void 0 : plan.rooms[0]) == null ? void 0 : _f.id) ?? "room-1"] = leftMask;
      roomMasks[((_g = plan == null ? void 0 : plan.rooms[1]) == null ? void 0 : _g.id) ?? "room-2"] = rightMask;
    } else {
      const wallY = clamp$4(Math.floor(rows / 2), 2, rows - 3);
      const doorCell = pickDoorAlongLine({
        axis: "horizontal",
        min: 1,
        max: cols - 2,
        fixed: wallY,
        position: plan == null ? void 0 : plan.doorPosition
      });
      draft.reserved.add(key(doorCell.x, doorCell.y));
      const doorCells = /* @__PURE__ */ new Set([key(doorCell.x, doorCell.y)]);
      placeWallLine({
        draft,
        wallType,
        wallDoorType,
        x1: 1,
        y1: wallY,
        x2: cols - 2,
        y2: wallY,
        doorCells,
        doorState: (plan == null ? void 0 : plan.doorState) === "closed" ? "closed" : "open"
      });
      const topMask = collectRoomMask({ cols, rows, x1: 1, y1: 1, x2: cols - 2, y2: wallY - 1 });
      const bottomMask = collectRoomMask({ cols, rows, x1: 1, y1: wallY, x2: cols - 2, y2: rows - 2 });
      roomMasks[((_h = plan == null ? void 0 : plan.rooms[0]) == null ? void 0 : _h.id) ?? "room-1"] = topMask;
      roomMasks[((_i = plan == null ? void 0 : plan.rooms[1]) == null ? void 0 : _i.id) ?? "room-2"] = bottomMask;
    }
  }
  if (openings.size === 0 && plan) {
    if (plan.layoutStyle === "corridor") {
      const side = plan.corridorSide ?? "north";
      addExteriorOpening(side, plan.doorPosition, plan.doorState === "closed" ? "closed" : "open");
    } else {
      const axis = plan.splitAxis ?? "vertical";
      const isFirstRoomPlayer = playerRoomId === (((_j = plan.rooms[0]) == null ? void 0 : _j.id) ?? "room-1");
      const side = axis === "vertical" ? isFirstRoomPlayer ? "west" : "east" : isFirstRoomPlayer ? "north" : "south";
      addExteriorOpening(side, plan.doorPosition, plan.doorState === "closed" ? "closed" : "open");
    }
  }
  placeBoundaryWalls({
    draft,
    boundaryBySide,
    wallType,
    wallDoorType,
    openings
  });
  if ((_k = plan == null ? void 0 : plan.rooms) == null ? void 0 : _k.length) {
    for (const room of plan.rooms) {
      const mask = roomMasks[room.id];
      if (!mask) continue;
      if ((_l = room.contents) == null ? void 0 : _l.length) {
        placeContents({ draft, roomMask: mask, contents: room.contents, ctx, rand });
      } else {
        fillRoomFallback({ draft, roomMask: mask, ctx, rand });
      }
    }
  }
  const playerMask = roomMasks[playerRoomId] ?? null;
  let playerStart = { x: 1, y: Math.floor(rows / 2) };
  if (playerMask && playerMask.size > 0) {
    const cells = Array.from(playerMask);
    const pick = cells[Math.floor(cells.length / 3)] ?? cells[0];
    if (pick) {
      const [xStr, yStr] = pick.split(",");
      const x2 = Number(xStr);
      const y2 = Number(yStr);
      if (Number.isFinite(x2) && Number.isFinite(y2)) playerStart = { x: x2, y: y2 };
    }
  }
  return { draft, playerStart, roomMasks, playerRoomId, enemyRoomId };
}
const DEFAULT_DOOR_STATE = "closed";
function rotateDir(dir, rotation) {
  const order = ["N", "E", "S", "W"];
  const idx = order.indexOf(dir);
  const steps = rotation === 90 ? 1 : rotation === 180 ? 2 : rotation === 270 ? 3 : 0;
  return order[(idx + steps) % order.length] ?? dir;
}
function rotatePoint(x2, y2, w2, h2, rotation) {
  switch (rotation) {
    case 90:
      return { x: h2 - 1 - y2, y: x2 };
    case 180:
      return { x: w2 - 1 - x2, y: h2 - 1 - y2 };
    case 270:
      return { x: y2, y: w2 - 1 - x2 };
    default:
      return { x: x2, y: y2 };
  }
}
function normalizeAscii(lines) {
  const cleaned = lines.map((line) => (line ?? "").replace(/\r/g, "")).filter((line) => line.trim().length > 0);
  const width = cleaned.reduce((max, line) => Math.max(max, line.length), 0);
  return cleaned.map((line) => line.padEnd(width, " "));
}
function getCellChar(lines, x2, y2) {
  if (y2 < 0 || y2 >= lines.length) return " ";
  const row = lines[y2] ?? "";
  if (x2 < 0 || x2 >= row.length) return " ";
  return row[x2] ?? " ";
}
function buildInteriorCellsFromAscii(params) {
  const rotation = params.rotation ?? 0;
  const base = normalizeAscii(params.ascii ?? []);
  const baseW = base.length > 0 ? base[0].length : 0;
  const baseH = base.length;
  if (baseW === 0 || baseH === 0) return [];
  const isWallCell = (x2, y2) => {
    const ch = getCellChar(base, x2, y2);
    return ch === "#" || ch === "L";
  };
  const isEmptyCell = (x2, y2) => {
    if (x2 < 0 || y2 < 0 || x2 >= baseW || y2 >= baseH) return false;
    return !isWallCell(x2, y2);
  };
  const visited = /* @__PURE__ */ new Set();
  const floodDirs = [
    { dx: 1, dy: 0 },
    { dx: -1, dy: 0 },
    { dx: 0, dy: 1 },
    { dx: 0, dy: -1 }
  ];
  const interiorKeys = /* @__PURE__ */ new Set();
  for (let y2 = 0; y2 < baseH; y2++) {
    for (let x2 = 0; x2 < baseW; x2++) {
      if (!isWallCell(x2, y2)) continue;
      const k2 = `${x2},${y2}`;
      if (visited.has(k2)) continue;
      const queue = [{ x: x2, y: y2 }];
      visited.add(k2);
      const cells2 = [];
      while (queue.length) {
        const cur = queue.shift();
        cells2.push(cur);
        for (const d2 of floodDirs) {
          const nx = cur.x + d2.dx;
          const ny = cur.y + d2.dy;
          if (!isWallCell(nx, ny)) continue;
          const nk = `${nx},${ny}`;
          if (visited.has(nk)) continue;
          visited.add(nk);
          queue.push({ x: nx, y: ny });
        }
      }
      let minX = baseW;
      let maxX = 0;
      let minY = baseH;
      let maxY = 0;
      for (const cell of cells2) {
        minX = Math.min(minX, cell.x);
        maxX = Math.max(maxX, cell.x);
        minY = Math.min(minY, cell.y);
        maxY = Math.max(maxY, cell.y);
      }
      minX = Math.max(0, minX - 1);
      minY = Math.max(0, minY - 1);
      maxX = Math.min(baseW - 1, maxX + 1);
      maxY = Math.min(baseH - 1, maxY + 1);
      const outside = /* @__PURE__ */ new Set();
      const queueEmpty = [];
      for (let x22 = minX; x22 <= maxX; x22++) {
        for (const y22 of [minY, maxY]) {
          if (!isEmptyCell(x22, y22)) continue;
          const kk = `${x22},${y22}`;
          if (outside.has(kk)) continue;
          outside.add(kk);
          queueEmpty.push({ x: x22, y: y22 });
        }
      }
      for (let y22 = minY; y22 <= maxY; y22++) {
        for (const x22 of [minX, maxX]) {
          if (!isEmptyCell(x22, y22)) continue;
          const kk = `${x22},${y22}`;
          if (outside.has(kk)) continue;
          outside.add(kk);
          queueEmpty.push({ x: x22, y: y22 });
        }
      }
      while (queueEmpty.length) {
        const cur = queueEmpty.shift();
        for (const d2 of floodDirs) {
          const nx = cur.x + d2.dx;
          const ny = cur.y + d2.dy;
          if (nx < minX || nx > maxX || ny < minY || ny > maxY) continue;
          if (!isEmptyCell(nx, ny)) continue;
          const kk = `${nx},${ny}`;
          if (outside.has(kk)) continue;
          outside.add(kk);
          queueEmpty.push({ x: nx, y: ny });
        }
      }
      for (let iy = minY; iy <= maxY; iy++) {
        for (let ix = minX; ix <= maxX; ix++) {
          if (!isEmptyCell(ix, iy)) continue;
          const kk = `${ix},${iy}`;
          if (outside.has(kk)) continue;
          interiorKeys.add(kk);
        }
      }
    }
  }
  const cells = [];
  for (const kk of interiorKeys) {
    const parts = kk.split(",");
    const x2 = Number(parts[0]);
    const y2 = Number(parts[1]);
    if (!Number.isFinite(x2) || !Number.isFinite(y2)) continue;
    const rotated = rotatePoint(x2, y2, baseW, baseH, rotation);
    cells.push({ x: params.originX + rotated.x, y: params.originY + rotated.y });
  }
  return cells;
}
function buildSegmentsFromAscii(params) {
  var _a;
  const rotation = params.rotation ?? 0;
  const base = normalizeAscii(params.ascii ?? []);
  const baseW = base.length > 0 ? base[0].length : 0;
  const baseH = base.length;
  const segments = /* @__PURE__ */ new Map();
  const addSegment = (x2, y2, dir, kind2, state) => {
    const key2 = wallEdgeKey(x2, y2, dir);
    const existing = segments.get(key2);
    const id2 = (existing == null ? void 0 : existing.id) ?? params.nextId();
    if (existing) {
      if (existing.kind === "door") return;
      if (existing.kind === "wall") {
        if (kind2 === "wall") return;
      }
    }
    segments.set(key2, { id: id2, x: x2, y: y2, dir, kind: kind2, state });
  };
  const isWallCell = (x2, y2) => {
    const ch = getCellChar(base, x2, y2);
    return ch === "#" || ch === "L";
  };
  const isEmptyCell = (x2, y2) => {
    if (x2 < 0 || y2 < 0 || x2 >= baseW || y2 >= baseH) return false;
    return !isWallCell(x2, y2);
  };
  const dirs = [
    { dx: 0, dy: -1, dir: "N" },
    { dx: 1, dy: 0, dir: "E" },
    { dx: 0, dy: 1, dir: "S" },
    { dx: -1, dy: 0, dir: "W" }
  ];
  const visited = /* @__PURE__ */ new Set();
  const floodDirs = [
    { dx: 1, dy: 0 },
    { dx: -1, dy: 0 },
    { dx: 0, dy: 1 },
    { dx: 0, dy: -1 }
  ];
  const components2 = [];
  for (let y2 = 0; y2 < baseH; y2++) {
    for (let x2 = 0; x2 < baseW; x2++) {
      if (!isWallCell(x2, y2)) continue;
      const k2 = `${x2},${y2}`;
      if (visited.has(k2)) continue;
      const queue = [{ x: x2, y: y2 }];
      visited.add(k2);
      const cells = [];
      while (queue.length) {
        const cur = queue.shift();
        cells.push(cur);
        for (const d2 of floodDirs) {
          const nx = cur.x + d2.dx;
          const ny = cur.y + d2.dy;
          if (!isWallCell(nx, ny)) continue;
          const nk = `${nx},${ny}`;
          if (visited.has(nk)) continue;
          visited.add(nk);
          queue.push({ x: nx, y: ny });
        }
      }
      components2.push({ cells });
    }
  }
  for (const comp of components2) {
    let minX = baseW;
    let maxX = 0;
    let minY = baseH;
    let maxY = 0;
    for (const cell of comp.cells) {
      minX = Math.min(minX, cell.x);
      maxX = Math.max(maxX, cell.x);
      minY = Math.min(minY, cell.y);
      maxY = Math.max(maxY, cell.y);
    }
    minX = Math.max(0, minX - 1);
    minY = Math.max(0, minY - 1);
    maxX = Math.min(baseW - 1, maxX + 1);
    maxY = Math.min(baseH - 1, maxY + 1);
    const outside = /* @__PURE__ */ new Set();
    const queue = [];
    for (let x2 = minX; x2 <= maxX; x2++) {
      for (const y2 of [minY, maxY]) {
        if (!isEmptyCell(x2, y2)) continue;
        const k2 = `${x2},${y2}`;
        if (outside.has(k2)) continue;
        outside.add(k2);
        queue.push({ x: x2, y: y2 });
      }
    }
    for (let y2 = minY; y2 <= maxY; y2++) {
      for (const x2 of [minX, maxX]) {
        if (!isEmptyCell(x2, y2)) continue;
        const k2 = `${x2},${y2}`;
        if (outside.has(k2)) continue;
        outside.add(k2);
        queue.push({ x: x2, y: y2 });
      }
    }
    while (queue.length) {
      const cur = queue.shift();
      for (const d2 of floodDirs) {
        const nx = cur.x + d2.dx;
        const ny = cur.y + d2.dy;
        if (nx < minX || nx > maxX || ny < minY || ny > maxY) continue;
        if (!isEmptyCell(nx, ny)) continue;
        const k2 = `${nx},${ny}`;
        if (outside.has(k2)) continue;
        outside.add(k2);
        queue.push({ x: nx, y: ny });
      }
    }
    for (const cell of comp.cells) {
      const ch = getCellChar(base, cell.x, cell.y);
      const kind2 = ch === "L" ? "low" : "wall";
      const rotated = rotatePoint(cell.x, cell.y, baseW, baseH, rotation);
      const gx = params.originX + rotated.x;
      const gy = params.originY + rotated.y;
      for (const d2 of dirs) {
        const nx = cell.x + d2.dx;
        const ny = cell.y + d2.dy;
        if (isWallCell(nx, ny)) continue;
        const outsideOk = nx < minX || nx > maxX || ny < minY || ny > maxY || outside.has(`${nx},${ny}`);
        if (!outsideOk) continue;
        const dir = rotateDir(d2.dir, rotation);
        addSegment(gx, gy, dir, kind2);
      }
    }
  }
  const doors = Array.isArray(params.doors) ? params.doors : [];
  for (const door of doors) {
    const rotated = rotatePoint(door.x, door.y, baseW, baseH, rotation);
    const dir = rotateDir(door.dir, rotation);
    const gx = params.originX + rotated.x;
    const gy = params.originY + rotated.y;
    const key2 = wallEdgeKey(gx, gy, dir);
    const id2 = ((_a = segments.get(key2)) == null ? void 0 : _a.id) ?? params.nextId();
    segments.set(key2, {
      id: id2,
      x: gx,
      y: gy,
      dir,
      kind: "door",
      state: door.state ?? DEFAULT_DOOR_STATE
    });
  }
  return Array.from(segments.values());
}
function buildWallCellsFromAscii(params) {
  const rotation = params.rotation ?? 0;
  const base = normalizeAscii(params.ascii ?? []);
  const baseW = base.length > 0 ? base[0].length : 0;
  const baseH = base.length;
  const cells = [];
  for (let y2 = 0; y2 < baseH; y2++) {
    for (let x2 = 0; x2 < baseW; x2++) {
      const ch = getCellChar(base, x2, y2);
      if (ch !== "#" && ch !== "L") continue;
      const rotated = rotatePoint(x2, y2, baseW, baseH, rotation);
      const gx = params.originX + rotated.x;
      const gy = params.originY + rotated.y;
      cells.push({ x: gx, y: gy });
    }
  }
  return cells;
}
function getAsciiFootprint(ascii) {
  const base = normalizeAscii(ascii ?? []);
  const w2 = base.length > 0 ? base[0].length : 0;
  const h2 = base.length;
  return { w: w2, h: h2 };
}
function isTreeType(typeDef) {
  if (!typeDef) return false;
  return (typeDef.tags ?? []).some((tag) => String(tag).toLowerCase() === "tree");
}
function getSpriteGridCells(params) {
  const tilesX = Math.max(1, Math.floor(params.tilesX));
  const tilesY = Math.max(1, Math.floor(params.tilesY));
  const left = Math.floor(tilesX / 2);
  const right = tilesX - left - 1;
  const top = Math.floor(tilesY / 2);
  const bottom = tilesY - top - 1;
  const cells = [];
  for (let dy = -top; dy <= bottom; dy++) {
    for (let dx = -left; dx <= right; dx++) {
      const gx = params.x + dx;
      const gy = params.y + dy;
      if (gx < 0 || gy < 0 || gx >= params.cols || gy >= params.rows) continue;
      cells.push({ x: gx, y: gy });
    }
  }
  return cells;
}
function getTreePlacementCells(params) {
  var _a;
  const { obstacle, typeDef, cols, rows } = params;
  if (!typeDef) return [];
  const grid = (_a = typeDef.appearance) == null ? void 0 : _a.spriteGrid;
  if (grid && Number.isFinite(grid.tilesX) && Number.isFinite(grid.tilesY)) {
    return getSpriteGridCells({
      x: obstacle.x,
      y: obstacle.y,
      tilesX: grid.tilesX,
      tilesY: grid.tilesY,
      cols,
      rows
    });
  }
  return getObstacleOccupiedCells(obstacle, typeDef);
}
function hasTreeOverlap(params) {
  if (!params.candidate.length) return false;
  const candidateKeys = new Set(params.candidate.map((c2) => key(c2.x, c2.y)));
  for (const obs of params.draftObstacles) {
    const typeDef = params.typeById.get(obs.typeId) ?? null;
    if (!isTreeType(typeDef)) continue;
    const cells = getTreePlacementCells({
      obstacle: obs,
      typeDef,
      cols: params.cols,
      rows: params.rows
    });
    for (const cell of cells) {
      if (candidateKeys.has(key(cell.x, cell.y))) return true;
    }
  }
  return false;
}
function pickWallTypeForKind(kind2, wallTypes) {
  if (!wallTypes || wallTypes.length === 0) return null;
  if (kind2 === "door") {
    return wallTypes.find((t2) => (t2.tags ?? []).some((tag) => String(tag).toLowerCase() === "door")) ?? wallTypes.find((t2) => {
      var _a;
      return ((_a = t2.behavior) == null ? void 0 : _a.kind) === "door";
    }) ?? wallTypes[0] ?? null;
  }
  if (kind2 === "low") {
    return wallTypes.find((t2) => (t2.tags ?? []).some((tag) => String(tag).toLowerCase() === "low")) ?? wallTypes.find((t2) => {
      var _a;
      return String(((_a = t2.appearance) == null ? void 0 : _a.heightClass) ?? "").toLowerCase() === "low";
    }) ?? wallTypes[0] ?? null;
  }
  return wallTypes.find((t2) => t2.category === "wall") ?? wallTypes[0] ?? null;
}
function normalizePrompt(input) {
  return String(input ?? "").toLowerCase().normalize("NFD").replace(new RegExp("\\p{Diacritic}", "gu"), "").trim();
}
function anchorOffsetForSize(anchor2, w2, h2) {
  switch (anchor2) {
    case "topRight":
      return { x: w2 - 1, y: 0 };
    case "bottomLeft":
      return { x: 0, y: h2 - 1 };
    case "bottomRight":
      return { x: w2 - 1, y: h2 - 1 };
    case "center":
      return { x: Math.floor((w2 - 1) / 2), y: Math.floor((h2 - 1) / 2) };
    default:
      return { x: 0, y: 0 };
  }
}
function anchorOffset(pattern, override, sizeOverride) {
  const anchor2 = override ?? pattern.anchor;
  const w2 = Math.max(1, Math.floor((sizeOverride == null ? void 0 : sizeOverride.w) ?? pattern.footprint.w));
  const h2 = Math.max(1, Math.floor((sizeOverride == null ? void 0 : sizeOverride.h) ?? pattern.footprint.h));
  return anchorOffsetForSize(anchor2, w2, h2);
}
function pickElements(pattern, rand) {
  const variants2 = pattern.variants ?? [];
  if (variants2.length > 0) {
    if (rand) {
      const idx = Math.floor(rand() * variants2.length);
      return (variants2[idx] ?? variants2[0]).elements;
    }
    return variants2[0].elements;
  }
  return pattern.elements;
}
function hasPatternTag(pattern, tag) {
  const tags2 = pattern.tags ?? [];
  const target = String(tag).toLowerCase();
  return tags2.some((t2) => String(t2).toLowerCase() === target);
}
function transformPoint(params) {
  const { w: w2, h: h2 } = params;
  let x2 = params.x;
  let y2 = params.y;
  if (params.transform.mirrorX) x2 = w2 - 1 - x2;
  if (params.transform.mirrorY) y2 = h2 - 1 - y2;
  const rot = params.transform.rotation ?? 0;
  switch (rot) {
    case 90:
      return { x: h2 - 1 - y2, y: x2 };
    case 180:
      return { x: w2 - 1 - x2, y: h2 - 1 - y2 };
    case 270:
      return { x: y2, y: w2 - 1 - x2 };
    default:
      return { x: x2, y: y2 };
  }
}
function transformedSize(w2, h2, rotation) {
  const rot = rotation ?? 0;
  if (rot === 90 || rot === 270) return { w: h2, h: w2 };
  return { w: w2, h: h2 };
}
function getPatternSize(pattern, transform) {
  return transformedSize(
    Math.max(1, Math.floor(pattern.footprint.w)),
    Math.max(1, Math.floor(pattern.footprint.h)),
    transform == null ? void 0 : transform.rotation
  );
}
function applyTransformToElements(params) {
  const w2 = Math.max(1, Math.floor(params.pattern.footprint.w));
  const h2 = Math.max(1, Math.floor(params.pattern.footprint.h));
  const size2 = transformedSize(w2, h2, params.transform.rotation);
  const elements2 = params.elements.map((element) => {
    const p2 = transformPoint({
      x: element.x,
      y: element.y,
      w: w2,
      h: h2,
      transform: params.transform
    });
    return { ...element, x: p2.x, y: p2.y };
  });
  return { elements: elements2, size: size2 };
}
function fitsBounds(params) {
  var _a, _b, _c;
  const { draft, pattern, originX, originY } = params;
  const w2 = Math.max(1, Math.floor(((_a = params.size) == null ? void 0 : _a.w) ?? pattern.footprint.w));
  const h2 = Math.max(1, Math.floor(((_b = params.size) == null ? void 0 : _b.h) ?? pattern.footprint.h));
  if (originX < 0 || originY < 0) return false;
  if (originX + w2 - 1 >= draft.cols) return false;
  if (originY + h2 - 1 >= draft.rows) return false;
  const avoid = (_c = pattern.constraints) == null ? void 0 : _c.avoidBorder;
  if (avoid) {
    const left = Math.max(0, Math.floor(avoid.left ?? 0));
    const right = Math.max(0, Math.floor(avoid.right ?? 0));
    const top = Math.max(0, Math.floor(avoid.top ?? 0));
    const bottom = Math.max(0, Math.floor(avoid.bottom ?? 0));
    if (originX < left) return false;
    if (originY < top) return false;
    if (originX + w2 - 1 > draft.cols - 1 - right) return false;
    if (originY + h2 - 1 > draft.rows - 1 - bottom) return false;
  }
  return true;
}
function isPlayable(draft, x2, y2) {
  if (draft.playable.size === 0) return true;
  return draft.playable.has(key(x2, y2));
}
function isClearArea(params) {
  var _a, _b, _c;
  const { draft, pattern, originX, originY } = params;
  if (!((_a = pattern.constraints) == null ? void 0 : _a.needsClearArea)) return true;
  const w2 = Math.max(1, Math.floor(((_b = params.size) == null ? void 0 : _b.w) ?? pattern.footprint.w));
  const h2 = Math.max(1, Math.floor(((_c = params.size) == null ? void 0 : _c.h) ?? pattern.footprint.h));
  for (let y2 = 0; y2 < h2; y2++) {
    for (let x2 = 0; x2 < w2; x2++) {
      const gx = originX + x2;
      const gy = originY + y2;
      if (!isInside(draft, gx, gy)) return false;
      if (!isPlayable(draft, gx, gy)) return false;
      const k2 = key(gx, gy);
      if (draft.occupied.has(k2)) return false;
      if (draft.decorOccupied.has(k2)) return false;
      if (draft.reserved.has(k2)) return false;
    }
  }
  return true;
}
function canPlaceElements(params) {
  var _a, _b, _c, _d, _e;
  const { draft, originX, originY, elements: elements2, obstacleTypes } = params;
  const w2 = Math.max(1, Math.floor(((_a = params.size) == null ? void 0 : _a.w) ?? params.pattern.footprint.w));
  const h2 = Math.max(1, Math.floor(((_b = params.size) == null ? void 0 : _b.h) ?? params.pattern.footprint.h));
  const maxX = originX + w2 - 1;
  const maxY = originY + h2 - 1;
  const typeById = new Map(obstacleTypes.map((t2) => [t2.id, t2]));
  for (const element of elements2) {
    if (element.x < 0 || element.y < 0 || element.x >= w2 || element.y >= h2) return false;
    const gx = originX + element.x;
    const gy = originY + element.y;
    if (element.type === "decor") {
      if (!isInside(draft, gx, gy)) return false;
      if (!isPlayable(draft, gx, gy)) return false;
      const k2 = key(gx, gy);
      if (draft.occupied.has(k2)) return false;
      if (draft.decorOccupied.has(k2)) return false;
      if (draft.reserved.has(k2)) return false;
      continue;
    }
    if (element.type === "tile") {
      if (!isInside(draft, gx, gy)) return false;
      if (!isPlayable(draft, gx, gy)) return false;
      continue;
    }
    const typeId = element.typeId ?? "";
    const typeDef = typeById.get(typeId) ?? null;
    if (!typeDef) return false;
    const variantId = element.variant ?? ((_d = (_c = typeDef.variants) == null ? void 0 : _c[0]) == null ? void 0 : _d.id) ?? "base";
    const rotation = element.rotation ?? 0;
    const temp = {
      variantId,
      x: gx,
      y: gy,
      rotation
    };
    const cells = getObstacleOccupiedCells(temp, typeDef);
    if (!cells.length) return false;
    if (isTreeType(typeDef)) {
      const grid = (_e = typeDef.appearance) == null ? void 0 : _e.spriteGrid;
      const candidateCells = grid && Number.isFinite(grid.tilesX) && Number.isFinite(grid.tilesY) ? getSpriteGridCells({
        x: gx,
        y: gy,
        tilesX: grid.tilesX,
        tilesY: grid.tilesY,
        cols: draft.cols,
        rows: draft.rows
      }) : cells;
      if (hasTreeOverlap({
        candidate: candidateCells,
        draftObstacles: draft.obstacles,
        typeById,
        cols: draft.cols,
        rows: draft.rows
      })) {
        return false;
      }
    }
    for (const c2 of cells) {
      if (!isInside(draft, c2.x, c2.y)) return false;
      if (c2.x < originX || c2.x > maxX || c2.y < originY || c2.y > maxY) return false;
      if (!isPlayable(draft, c2.x, c2.y)) return false;
      const k2 = key(c2.x, c2.y);
      if (draft.occupied.has(k2)) return false;
      if (draft.decorOccupied.has(k2)) return false;
      if (draft.reserved.has(k2)) return false;
    }
  }
  return true;
}
function respectsAllowedTerrains(params) {
  var _a, _b;
  const { draft, pattern, originX, originY } = params;
  const allowed = pattern.allowedTerrains;
  if (!Array.isArray(allowed) || allowed.length === 0) return true;
  const allowedSet = new Set(allowed.map((t2) => String(t2)));
  const w2 = Math.max(1, Math.floor(((_a = params.size) == null ? void 0 : _a.w) ?? pattern.footprint.w));
  const h2 = Math.max(1, Math.floor(((_b = params.size) == null ? void 0 : _b.h) ?? pattern.footprint.h));
  for (let y2 = 0; y2 < h2; y2++) {
    for (let x2 = 0; x2 < w2; x2++) {
      const gx = originX + x2;
      const gy = originY + y2;
      if (!isInside(draft, gx, gy)) return false;
      const terrain = getTerrainAt(draft, gx, gy);
      if (!terrain || !allowedSet.has(String(terrain))) return false;
    }
  }
  return true;
}
function placePattern(params) {
  var _a, _b, _c;
  const { draft, pattern, anchorX, anchorY, obstacleTypes, rand, anchorOverride, transform, wallTypes } = params;
  const baseElements = pickElements(pattern, rand);
  const { elements: elements2, size: size2 } = applyTransformToElements({
    pattern,
    elements: baseElements,
    transform: transform ?? {}
  });
  const offset = anchorOffset(pattern, anchorOverride, size2);
  const originX = anchorX - offset.x;
  const originY = anchorY - offset.y;
  if (!fitsBounds({ draft, pattern, originX, originY, size: size2 })) return false;
  if (!isClearArea({ draft, pattern, originX, originY, size: size2 })) return false;
  if (!respectsAllowedTerrains({ draft, pattern, originX, originY, size: size2 })) return false;
  const asciiFootprint = Array.isArray(pattern.wallAscii) && pattern.wallAscii.length > 0 ? getAsciiFootprint(pattern.wallAscii) : null;
  if (asciiFootprint) {
    const fpW = Math.max(1, Math.floor(pattern.footprint.w));
    const fpH = Math.max(1, Math.floor(pattern.footprint.h));
    if (asciiFootprint.w > fpW || asciiFootprint.h > fpH) return false;
  }
  if (!canPlaceElements({ draft, pattern, originX, originY, elements: elements2, obstacleTypes, size: size2 })) return false;
  if (((_a = pattern.floorPaint) == null ? void 0 : _a.mode) === "interior" && Array.isArray(pattern.wallAscii)) {
    const interiorCells = buildInteriorCellsFromAscii({
      ascii: pattern.wallAscii,
      originX,
      originY,
      rotation: (transform == null ? void 0 : transform.rotation) ?? 0
    });
    const wallCells = buildWallCellsFromAscii({
      ascii: pattern.wallAscii,
      originX,
      originY,
      rotation: (transform == null ? void 0 : transform.rotation) ?? 0
    });
    const paintKeys = /* @__PURE__ */ new Set();
    const paintTargets = [];
    for (const cell of interiorCells) {
      const k2 = key(cell.x, cell.y);
      if (paintKeys.has(k2)) continue;
      paintKeys.add(k2);
      paintTargets.push(cell);
    }
    for (const cell of wallCells) {
      const k2 = key(cell.x, cell.y);
      if (paintKeys.has(k2)) continue;
      paintKeys.add(k2);
      paintTargets.push(cell);
    }
    for (const cell of paintTargets) {
      setTerrain(draft, cell.x, cell.y, pattern.floorPaint.terrain);
      if (typeof pattern.floorPaint.height === "number") {
        setHeight(draft, cell.x, cell.y, pattern.floorPaint.height);
      }
    }
    if (hasPatternTag(pattern, "roof-open")) {
      for (const cell of interiorCells) {
        draft.roofOpenCells.add(key(cell.x, cell.y));
      }
    }
  }
  for (const element of elements2) {
    const gx = originX + element.x;
    const gy = originY + element.y;
    if (element.type === "tile") {
      if (typeof element.height === "number") {
        setHeight(draft, gx, gy, element.height);
      }
      if (typeof element.terrain === "string") {
        setTerrain(draft, gx, gy, element.terrain);
      }
      continue;
    }
    if (element.type === "decor") {
      const ok2 = tryPlaceDecor({
        draft,
        spriteKey: element.spriteKey ?? "",
        x: gx,
        y: gy,
        rotation: element.rotation,
        scale: element.scale
      });
      if (!ok2) return false;
      continue;
    }
    const typeId = element.typeId ?? "";
    const typeDef = obstacleTypes.find((t2) => t2.id === typeId) ?? null;
    if (!typeDef) return false;
    const variantId = element.variant ?? ((_c = (_b = typeDef.variants) == null ? void 0 : _b[0]) == null ? void 0 : _c.id) ?? "base";
    const ok = tryPlaceObstacle({
      draft,
      type: typeDef,
      x: gx,
      y: gy,
      variantId,
      rotation: element.rotation ?? 0
    });
    if (!ok) return false;
  }
  if (Array.isArray(pattern.wallAscii) && pattern.wallAscii.length > 0) {
    const segments = buildSegmentsFromAscii({
      ascii: pattern.wallAscii,
      originX,
      originY,
      rotation: (transform == null ? void 0 : transform.rotation) ?? 0,
      doors: pattern.wallDoors ?? [],
      nextId: draft.nextWallId
    });
    for (const seg of segments) {
      const type2 = pickWallTypeForKind(seg.kind, wallTypes);
      const maxHp = resolveWallMaxHp(type2);
      if (type2) seg.typeId = type2.id;
      if (maxHp !== null) {
        seg.maxHp = maxHp;
        seg.hp = maxHp;
      }
      draft.wallSegments.push(seg);
      draft.wallSegmentKeys.add(wallEdgeKeyForSegment(seg));
    }
    const wallCells = buildWallCellsFromAscii({
      ascii: pattern.wallAscii,
      originX,
      originY,
      rotation: (transform == null ? void 0 : transform.rotation) ?? 0
    });
    for (const cell of wallCells) {
      const k2 = key(cell.x, cell.y);
      draft.occupied.add(k2);
      draft.movementBlocked.add(k2);
    }
  }
  return true;
}
function placePatternAtOrigin(params) {
  const { draft, pattern, originX, originY, obstacleTypes, rand, anchorOverride, transform } = params;
  const size2 = transformedSize(
    Math.max(1, Math.floor(pattern.footprint.w)),
    Math.max(1, Math.floor(pattern.footprint.h)),
    transform == null ? void 0 : transform.rotation
  );
  const offset = anchorOffset(pattern, anchorOverride, size2);
  return placePattern({
    draft,
    pattern,
    obstacleTypes,
    wallTypes: params.wallTypes,
    rand,
    anchorOverride,
    transform,
    anchorX: originX + offset.x,
    anchorY: originY + offset.y
  });
}
function pickPatternTransform(params) {
  var _a;
  const rotations = ((_a = params.allowedRotations) == null ? void 0 : _a.length) ? params.allowedRotations : [0];
  const rotation = rotations[Math.floor(params.rand() * rotations.length)];
  const mirrorX = params.allowMirrorX ? params.rand() < 0.5 : false;
  const mirrorY = params.allowMirrorY ? params.rand() < 0.5 : false;
  return { rotation, mirrorX, mirrorY };
}
function choosePatternsByPrompt(params) {
  const normalized = normalizePrompt(params.prompt);
  if (!normalized) {
    const picks2 = [];
    for (let i2 = 0; i2 < params.count; i2++) {
      const p2 = params.patterns[Math.floor(params.rand() * params.patterns.length)];
      if (p2) picks2.push(p2);
    }
    return picks2;
  }
  const scored = params.patterns.map((p2) => {
    const tags2 = p2.tags ?? [];
    let score = 1;
    for (const t2 of tags2) {
      if (!t2) continue;
      if (normalized.includes(normalizePrompt(t2))) score += 4;
    }
    if (normalized.includes(normalizePrompt(p2.label))) score += 2;
    return { item: p2, weight: score };
  });
  const picks = [];
  const pool = [...scored];
  for (let i2 = 0; i2 < params.count && pool.length; i2++) {
    const total = pool.reduce((sum, p2) => sum + p2.weight, 0);
    let roll = params.rand() * total;
    let chosenIdx = 0;
    for (let idx = 0; idx < pool.length; idx++) {
      roll -= pool[idx].weight;
      if (roll <= 0) {
        chosenIdx = idx;
        break;
      }
    }
    const picked = pool.splice(chosenIdx, 1)[0];
    if (picked) picks.push(picked.item);
  }
  return picks;
}
const FOREST_PATTERNS = loadMapPatternsFromIndex().filter((p2) => p2.theme === "forest");
function placeForestPatterns(params) {
  const { draft, rand, obstacleTypes, cols, rows, cx, cy, radius, prompt } = params;
  if (FOREST_PATTERNS.length === 0) return 0;
  let placed = 0;
  const picks = choosePatternsByPrompt({
    patterns: FOREST_PATTERNS,
    prompt,
    rand,
    count: 2
  });
  for (const pattern of picks) {
    const transform = pickPatternTransform({
      rand,
      allowedRotations: [0, 90, 180, 270],
      allowMirrorX: true,
      allowMirrorY: true
    });
    const size2 = getPatternSize(pattern, transform);
    const originX = clamp$4(cx - Math.floor(size2.w / 2), 0, cols - 1);
    const originY = clamp$4(cy - Math.floor(size2.h / 2), 0, rows - 1);
    let ok = placePatternAtOrigin({
      draft,
      pattern,
      originX,
      originY,
      obstacleTypes,
      rand,
      transform
    });
    if (!ok) {
      const attempts = 4;
      for (let i2 = 0; i2 < attempts && !ok; i2++) {
        const ox = clamp$4(cx + randomIntInclusive(rand, -radius, radius), 0, cols - 1);
        const oy = clamp$4(cy + randomIntInclusive(rand, -radius, radius), 0, rows - 1);
        ok = placePatternAtOrigin({
          draft,
          pattern,
          originX: ox,
          originY: oy,
          obstacleTypes,
          rand,
          transform
        });
      }
    }
    if (ok) placed++;
  }
  return placed;
}
function distance(ax, ay, bx, by) {
  const dx = ax - bx;
  const dy = ay - by;
  return Math.sqrt(dx * dx + dy * dy);
}
function generateForestClearing(params) {
  var _a;
  const { spec, ctx, rand } = params;
  const cols = Math.max(1, spec.grid.cols);
  const rows = Math.max(1, spec.grid.rows);
  const playerStart = { x: 1, y: Math.floor(rows / 2) };
  const draft = createDraft({ cols, rows, reserved: /* @__PURE__ */ new Set(), seedPrefix: "obs" });
  const forest = spec.forest ?? {
    radius: Math.max(2, Math.floor(Math.min(cols, rows) * 0.3)),
    treesOnRing: "sparse",
    lighting: "day"
  };
  const cx = clamp$4(Math.floor(cols * 0.6), 0, cols - 1);
  const cy = clamp$4(Math.floor(rows * 0.5), 0, rows - 1);
  const r2 = Math.max(2, forest.radius);
  draft.log.push("Layout: fort (clairire).");
  const placedPatterns = placeForestPatterns({
    draft,
    rand,
    obstacleTypes: ctx.obstacleTypes,
    cols,
    rows,
    cx,
    cy,
    radius: r2,
    prompt: spec.prompt
  });
  if (placedPatterns > 0) {
    draft.log.push(`Patterns: +${placedPatterns} (forest).`);
  }
  for (let y2 = 0; y2 < rows; y2++) {
    for (let x2 = 0; x2 < cols; x2++) {
      setTerrain(draft, x2, y2, "grass");
    }
  }
  const dirtPatchCount = clamp$4(Math.floor(cols * rows / 55), 2, 10);
  scatterTerrainPatches({
    draft,
    rand,
    terrain: "dirt",
    count: dirtPatchCount,
    radiusMin: 1,
    radiusMax: 3
  });
  const baseLight = forest.lighting === "night" ? 0.25 : 0.9;
  for (let y2 = 0; y2 < rows; y2++) {
    for (let x2 = 0; x2 < cols; x2++) setLight(draft, x2, y2, baseLight);
  }
  const typeById = new Map(ctx.obstacleTypes.map((t2) => [t2.id, t2]));
  const treeType = findObstacleType(ctx.obstacleTypes, "tree-oak") ?? ctx.obstacleTypes.find((t2) => (t2.tags ?? []).includes("tree")) ?? ctx.obstacleTypes.find((t2) => t2.category === "vegetation") ?? null;
  const vegetationTypes = weightedTypesForContext(
    ctx.obstacleTypes,
    (t2) => (t2.tags ?? []).includes("tree") || t2.category === "vegetation"
  );
  const ringThickness = forest.treesOnRing === "dense" ? 1.8 : 1.2;
  const density = forest.treesOnRing === "dense" ? 0.55 : 0.3;
  let placed = 0;
  let attempts = 0;
  const target = clamp$4(Math.floor(cols * rows * density * 0.12), 3, 14);
  while (placed < target && attempts < 400) {
    attempts++;
    const x2 = Math.floor(rand() * cols);
    const y2 = Math.floor(rand() * rows);
    const d2 = distance(x2, y2, cx, cy);
    const onRing = d2 >= r2 - ringThickness && d2 <= r2 + ringThickness;
    if (!onRing) continue;
    const chosen = pickWeighted(vegetationTypes, rand) ?? treeType;
    if (!chosen) break;
    if (isTreeType(chosen)) {
      const grid = (_a = chosen.appearance) == null ? void 0 : _a.spriteGrid;
      const candidateCells = grid && Number.isFinite(grid.tilesX) && Number.isFinite(grid.tilesY) ? getSpriteGridCells({
        x: x2,
        y: y2,
        tilesX: grid.tilesX,
        tilesY: grid.tilesY,
        cols,
        rows
      }) : [{ x: x2, y: y2 }];
      const hasOverlap = hasTreeOverlap({
        candidate: candidateCells,
        draftObstacles: draft.obstacles,
        typeById,
        cols,
        rows
      });
      if (hasOverlap) continue;
    }
    const variantId = pickVariantIdForPlacement(chosen, "scatter", rand);
    const rotation = randomRotationForPlacement(chosen, variantId, rand);
    const ok = tryPlaceObstacle({
      draft,
      type: chosen,
      x: x2,
      y: y2,
      variantId,
      rotation
    });
    if (ok) placed++;
  }
  draft.log.push(`Arbres: ${placed} (anneau de clairire).`);
  const propTypes = weightedTypesForContext(ctx.obstacleTypes, (t2) => t2.category !== "wall" && t2.category !== "vegetation");
  const smallTarget = clamp$4(Math.floor(cols * rows / 80), 0, 3);
  let propsPlaced = 0;
  attempts = 0;
  while (propsPlaced < smallTarget && attempts < 150) {
    attempts++;
    const x2 = clamp$4(cx + randomIntInclusive(rand, -r2 + 1, r2 - 1), 0, cols - 1);
    const y2 = clamp$4(cy + randomIntInclusive(rand, -r2 + 1, r2 - 1), 0, rows - 1);
    const d2 = distance(x2, y2, cx, cy);
    if (d2 > r2 - 1) continue;
    const chosen = pickWeighted(propTypes, rand) ?? null;
    if (!chosen) break;
    const variantId = pickVariantIdForPlacement(chosen, "scatter", rand);
    const rotation = randomRotationForPlacement(chosen, variantId, rand);
    const ok = tryPlaceObstacle({ draft, type: chosen, x: x2, y: y2, variantId, rotation });
    if (ok) propsPlaced++;
  }
  if (propsPlaced) draft.log.push(`Props: +${propsPlaced}.`);
  const decorCount = clamp$4(Math.floor(cols * rows / 18), 6, 24);
  const decorBefore = draft.decorations.length;
  scatterDecorations({
    draft,
    rand,
    spriteKeys: ["decor:grass", "decor:grass_2"],
    count: decorCount,
    terrainFilter: ["grass"]
  });
  const decorPlaced = draft.decorations.length - decorBefore;
  if (decorPlaced > 0) draft.log.push(`Decor: +${decorPlaced}.`);
  return { draft, playerStart };
}
const CITY_PATTERNS = loadMapPatternsFromIndex().filter((p2) => p2.theme === "city");
function resolveCityPatterns(spec) {
  var _a, _b, _c;
  const requested = Array.isArray((_a = spec.city) == null ? void 0 : _a.patterns) && ((_b = spec.city) == null ? void 0 : _b.patterns.length) ? spec.city.patterns : null;
  const requestedCount = typeof ((_c = spec.city) == null ? void 0 : _c.patternCount) === "number" ? Math.max(1, Math.floor(spec.city.patternCount)) : null;
  if (!requested) return { patterns: CITY_PATTERNS, requested: null, requestedCount };
  const requestedSet = new Set(requested);
  const filtered = CITY_PATTERNS.filter((p2) => requestedSet.has(p2.id));
  return { patterns: filtered, requested, requestedCount };
}
function placeCityPatterns(params) {
  const { draft, rand, obstacleTypes, wallTypes, cols, rows, anchorYs, anchorXs, prompt, patterns: patterns2, requestedPatterns, patternCount } = params;
  if (patterns2.length === 0) return { count: 0, ids: [] };
  const anchorOffset2 = (anchor2, size2) => {
    switch (anchor2) {
      case "topRight":
        return { x: size2.w - 1, y: 0 };
      case "bottomLeft":
        return { x: 0, y: size2.h - 1 };
      case "bottomRight":
        return { x: size2.w - 1, y: size2.h - 1 };
      case "center":
        return { x: Math.floor((size2.w - 1) / 2), y: Math.floor((size2.h - 1) / 2) };
      default:
        return { x: 0, y: 0 };
    }
  };
  let placed = 0;
  const placedIds = [];
  const attempts = Math.min(8, cols);
  const desiredCount = Math.max(
    1,
    Math.floor(
      patternCount ?? (requestedPatterns && requestedPatterns.length ? patterns2.length : attempts)
    )
  );
  const picks = requestedPatterns && requestedPatterns.length ? Array.from({ length: desiredCount }, (_, idx) => patterns2[idx % patterns2.length]) : choosePatternsByPrompt({
    patterns: patterns2,
    prompt,
    rand,
    count: desiredCount
  });
  for (const pattern of picks) {
    const attemptCount = Math.max(3, Math.min(10, cols));
    let placedThis = false;
    for (let attempt = 0; attempt < attemptCount && !placedThis; attempt++) {
      const transform = pickPatternTransform({
        rand,
        allowedRotations: [0, 180],
        allowMirrorX: true,
        allowMirrorY: false
      });
      const size2 = getPatternSize(pattern, transform);
      const maxAnchorX = cols - size2.w;
      const maxAnchorY = rows - size2.h;
      if (maxAnchorX < 0) continue;
      if (maxAnchorY < 0) continue;
      const anchorX = anchorXs && anchorXs.length ? anchorXs[Math.floor(rand() * anchorXs.length)] : Math.floor(rand() * (maxAnchorX + 1));
      const anchorY = anchorYs && anchorYs.length ? anchorYs[Math.floor(rand() * anchorYs.length)] : Math.floor(rand() * (maxAnchorY + 1));
      if (anchorX < 0 || anchorX >= cols || anchorY < 0 || anchorY >= rows) continue;
      const ok = placePattern({ draft, pattern, anchorX, anchorY, obstacleTypes, wallTypes, rand, transform });
      if (ok) {
        const offset = anchorOffset2(pattern.anchor, size2);
        const originX = anchorX - offset.x;
        const originY = anchorY - offset.y;
        placed++;
        placedIds.push(pattern.id);
        placedThis = true;
        draft.log.push(
          `Pattern placee: ${pattern.id} anchor=(${anchorX},${anchorY}) origin=(${originX},${originY}) size=${size2.w}x${size2.h} rot=${transform.rotation ?? 0} mx=${transform.mirrorX ? 1 : 0} my=${transform.mirrorY ? 1 : 0}`
        );
      }
    }
  }
  if (placedIds.length > 0) {
    draft.log.push(`Patterns (city): ${placedIds.join(", ")}.`);
  } else if (requestedPatterns && requestedPatterns.length > 0) {
    draft.log.push(`Patterns (city): echec de placement pour ${requestedPatterns.join(", ")}.`);
  }
  return { count: placed, ids: placedIds };
}
function generateCityStreet(params) {
  var _a, _b;
  const { spec, ctx, rand } = params;
  const cols = Math.max(1, spec.grid.cols);
  const rows = Math.max(1, spec.grid.rows);
  const playerStart = { x: 1, y: Math.floor(rows / 2) };
  const draft = createDraft({ cols, rows, reserved: /* @__PURE__ */ new Set(), seedPrefix: "obs" });
  const city = spec.city ?? {
    direction: "horizontal",
    streetWidth: 2,
    buildingDepth: 2,
    lighting: "day"
  };
  const { patterns: patterns2, requested, requestedCount } = resolveCityPatterns(spec);
  draft.log.push("Module: city_street.");
  draft.log.push("Layout: ville (rue).");
  const baseLight = city.lighting === "night" ? 0.25 : 0.9;
  for (let y2 = 0; y2 < rows; y2++) {
    for (let x2 = 0; x2 < cols; x2++) {
      setLight(draft, x2, y2, baseLight);
      setTerrain(draft, x2, y2, "stone");
    }
  }
  const direction = city.direction ?? "horizontal";
  const sidewalk = Math.max(0, Math.floor(city.sidewalk ?? 0));
  const streetW = direction === "horizontal" ? clamp$4(Math.floor(city.streetWidth), 1, Math.max(1, rows - 2)) : clamp$4(Math.floor(city.streetWidth), 1, Math.max(1, cols - 2));
  const maxDepth = direction === "horizontal" ? Math.max(1, Math.floor(rows / 2) - 1) : Math.max(1, Math.floor(cols / 2) - 1);
  let depth2 = clamp$4(Math.floor(city.buildingDepth), 1, maxDepth);
  if (requested && patterns2.length > 0) {
    const requiredDepth = patterns2.reduce((max, p2) => {
      const size2 = direction === "horizontal" ? p2.footprint.h : p2.footprint.w;
      return Math.max(max, Math.floor(size2));
    }, 1);
    if (requiredDepth > maxDepth) {
      draft.log.push(`Patterns: besoin depth=${requiredDepth}, max=${maxDepth} (trop petit).`);
    } else if (requiredDepth > depth2) {
      depth2 = clamp$4(requiredDepth, 1, maxDepth);
      draft.log.push(`Patterns: buildingDepth ajuste a ${depth2}.`);
    }
  }
  const centerY = clamp$4(Math.floor(rows / 2), 0, rows - 1);
  const centerX = clamp$4(Math.floor(cols / 2), 0, cols - 1);
  const offset = ((_a = city.streetOffset) == null ? void 0 : _a.amount) ?? 0;
  const offsetDir = ((_b = city.streetOffset) == null ? void 0 : _b.dir) ?? null;
  let streetCenterY = centerY;
  let streetCenterX = centerX;
  if (offset > 0 && offsetDir) {
    if (direction === "horizontal") {
      if (offsetDir === "north") streetCenterY -= offset;
      if (offsetDir === "south") streetCenterY += offset;
    } else {
      if (offsetDir === "west") streetCenterX -= offset;
      if (offsetDir === "east") streetCenterX += offset;
    }
  }
  streetCenterY = clamp$4(streetCenterY, 0, rows - 1);
  streetCenterX = clamp$4(streetCenterX, 0, cols - 1);
  const streetY1 = clamp$4(streetCenterY - Math.floor(streetW / 2), 0, rows - 1);
  const streetY2 = clamp$4(streetY1 + streetW - 1, 0, rows - 1);
  const streetX1 = clamp$4(streetCenterX - Math.floor(streetW / 2), 0, cols - 1);
  const streetX2 = clamp$4(streetX1 + streetW - 1, 0, cols - 1);
  if (direction === "horizontal") {
    for (let y2 = streetY1; y2 <= streetY2; y2++) {
      for (let x2 = 0; x2 < cols; x2++) setTerrain(draft, x2, y2, "road");
    }
  } else {
    for (let x2 = streetX1; x2 <= streetX2; x2++) {
      for (let y2 = 0; y2 < rows; y2++) setTerrain(draft, x2, y2, "road");
    }
  }
  const topY2 = clamp$4(streetY1 - 1 - sidewalk, 0, rows - 1);
  const topY1 = clamp$4(topY2 - depth2 + 1, 0, rows - 1);
  const botY1 = clamp$4(streetY2 + 1 + sidewalk, 0, rows - 1);
  const botY2 = clamp$4(botY1 + depth2 - 1, 0, rows - 1);
  const leftX2 = clamp$4(streetX1 - 1 - sidewalk, 0, cols - 1);
  const leftX1 = clamp$4(leftX2 - depth2 + 1, 0, cols - 1);
  const rightX1 = clamp$4(streetX2 + 1 + sidewalk, 0, cols - 1);
  const rightX2 = clamp$4(rightX1 + depth2 - 1, 0, cols - 1);
  if (requested && requested.length > 0 && patterns2.length === 0) {
    draft.log.push(`Patterns (city): aucun pattern charge pour ${requested.join(", ")}.`);
  }
  const placedPatterns = placeCityPatterns({
    draft,
    rand,
    obstacleTypes: ctx.obstacleTypes,
    wallTypes: ctx.wallTypes,
    cols,
    rows,
    anchorYs: direction === "horizontal" ? [topY2, botY2] : void 0,
    anchorXs: direction === "vertical" ? [leftX2, rightX1] : void 0,
    prompt: spec.prompt,
    patterns: patterns2,
    requestedPatterns: requested,
    patternCount: requestedCount
  });
  if (placedPatterns.count > 0) {
    draft.log.push(`Patterns: +${placedPatterns.count} (city).`);
  }
  if (spec.obstacleRequests && spec.obstacleRequests.length > 0) {
    const maxAttemptsPerItem = Math.max(20, cols * 2);
    for (const req of spec.obstacleRequests) {
      const type2 = findObstacleType(ctx.obstacleTypes, req.typeId);
      if (!type2) {
        draft.log.push(`Obstacle manquant: ${req.typeId}.`);
        continue;
      }
      const count2 = Math.max(1, Math.floor(req.count ?? 1));
      const orientation = req.orientation;
      const placement2 = req.placement ?? "road";
      let placed = 0;
      let attempts = 0;
      while (placed < count2 && attempts < maxAttemptsPerItem) {
        attempts += 1;
        let x2 = Math.floor(rand() * cols);
        let y2 = Math.floor(rand() * rows);
        if (direction === "horizontal") {
          if (placement2 === "road") {
            y2 = clamp$4(streetY1 + Math.floor(rand() * (streetY2 - streetY1 + 1)), 0, rows - 1);
          } else if (placement2 === "road_edge" || placement2 === "between_road_house") {
            const sideRows = [
              ...Array.from({ length: Math.max(0, streetY1 - topY2 - 1) }, (_, i2) => topY2 + 1 + i2),
              ...Array.from({ length: Math.max(0, botY1 - streetY2 - 1) }, (_, i2) => streetY2 + 1 + i2)
            ].filter((v2) => v2 >= 0 && v2 < rows);
            if (sideRows.length > 0) {
              y2 = sideRows[Math.floor(rand() * sideRows.length)];
            } else {
              y2 = clamp$4(streetY1 + Math.floor(rand() * (streetY2 - streetY1 + 1)), 0, rows - 1);
            }
          } else if (placement2 === "near_house") {
            const houseRows = [
              ...Array.from({ length: Math.max(0, topY2 - topY1 + 1) }, (_, i2) => topY1 + i2),
              ...Array.from({ length: Math.max(0, botY2 - botY1 + 1) }, (_, i2) => botY1 + i2)
            ].filter((v2) => v2 >= 0 && v2 < rows);
            if (houseRows.length > 0) {
              y2 = houseRows[Math.floor(rand() * houseRows.length)];
            }
          }
        } else {
          if (placement2 === "road") {
            x2 = clamp$4(streetX1 + Math.floor(rand() * (streetX2 - streetX1 + 1)), 0, cols - 1);
          } else if (placement2 === "road_edge" || placement2 === "between_road_house") {
            const sideCols = [
              ...Array.from({ length: Math.max(0, streetX1 - leftX2 - 1) }, (_, i2) => leftX2 + 1 + i2),
              ...Array.from({ length: Math.max(0, rightX1 - streetX2 - 1) }, (_, i2) => streetX2 + 1 + i2)
            ].filter((v2) => v2 >= 0 && v2 < cols);
            if (sideCols.length > 0) {
              x2 = sideCols[Math.floor(rand() * sideCols.length)];
            } else {
              x2 = clamp$4(streetX1 + Math.floor(rand() * (streetX2 - streetX1 + 1)), 0, cols - 1);
            }
          } else if (placement2 === "near_house") {
            const houseCols = [
              ...Array.from({ length: Math.max(0, leftX2 - leftX1 + 1) }, (_, i2) => leftX1 + i2),
              ...Array.from({ length: Math.max(0, rightX2 - rightX1 + 1) }, (_, i2) => rightX1 + i2)
            ].filter((v2) => v2 >= 0 && v2 < cols);
            if (houseCols.length > 0) {
              x2 = houseCols[Math.floor(rand() * houseCols.length)];
            }
          }
        }
        const variantId = pickVariantIdForPlacement(type2, "scatter", rand);
        const rotation = orientation === void 0 ? randomRotationForPlacement(type2, variantId, rand) : 0;
        const ok = tryPlaceObstacle({
          draft,
          type: type2,
          x: x2,
          y: y2,
          variantId,
          rotation,
          orientation
        });
        if (ok) placed += 1;
      }
      draft.log.push(`Obstacle demande: ${req.typeId} (${placed}/${count2}).`);
    }
  }
  draft.log.push("Maisons: murs places uniquement via patterns.");
  return { draft, playerStart };
}
const ROOF_HEIGHT = 1;
const HOLE_RADIUS = 1;
function clampRange(value2, min, max) {
  return Math.max(min, Math.min(max, value2));
}
function buildInnerBounds(cols, rows) {
  const safeCols = Math.max(6, cols);
  const safeRows = Math.max(6, rows);
  const padding = Math.max(1, Math.floor(Math.min(safeCols, safeRows) * 0.15));
  const roofWidth = Math.max(4, safeCols - padding * 2);
  const roofHeight = Math.max(4, safeRows - padding * 2);
  const x1 = clampRange(Math.floor((safeCols - roofWidth) / 2), 1, safeCols - 3);
  const y1 = clampRange(Math.floor((safeRows - roofHeight) / 2), 1, safeRows - 3);
  const x2 = clampRange(x1 + roofWidth - 1, x1 + 2, safeCols - 2);
  const y2 = clampRange(y1 + roofHeight - 1, y1 + 2, safeRows - 2);
  return { x1, x2, y1, y2 };
}
function ensureInBounds(value2, max) {
  return clampRange(value2, 0, max - 1);
}
function generateTieredBuilding(params) {
  var _a, _b, _c;
  const { spec, ctx } = params;
  const cols = Math.max(6, spec.grid.cols);
  const rows = Math.max(6, spec.grid.rows);
  const draft = createDraft({ cols, rows, reserved: /* @__PURE__ */ new Set(), seedPrefix: "bld" });
  const style = ((_a = spec.building) == null ? void 0 : _a.style) === "closed" ? "closed" : "open";
  draft.log.push("Module: building_tiered.");
  for (let y2 = 0; y2 < rows; y2++) {
    for (let x2 = 0; x2 < cols; x2++) {
      setTerrain(draft, x2, y2, "stone");
    }
  }
  const bounds = buildInnerBounds(cols, rows);
  for (let y2 = bounds.y1; y2 <= bounds.y2; y2++) {
    for (let x2 = bounds.x1; x2 <= bounds.x2; x2++) {
      setHeight(draft, x2, y2, ROOF_HEIGHT);
    }
  }
  const centerX = Math.floor((bounds.x1 + bounds.x2) / 2);
  const centerY = Math.floor((bounds.y1 + bounds.y2) / 2);
  setHeight(draft, centerX, centerY, 0);
  const stairType = findObstacleType(ctx.obstacleTypes, "stairs-stone");
  if (stairType) {
    const stairVariantId = ((_c = (_b = stairType.variants) == null ? void 0 : _b[0]) == null ? void 0 : _c.id) ?? "base";
    tryPlaceObstacle({
      draft,
      type: stairType,
      x: centerX,
      y: centerY,
      variantId: stairVariantId,
      rotation: 0
    });
  }
  let startY = centerY - HOLE_RADIUS - 1;
  if (startY < 0) startY = centerY + HOLE_RADIUS + 1;
  startY = ensureInBounds(startY, rows);
  setHeight(draft, centerX, startY, 0);
  const minY = Math.min(centerY, startY);
  const maxY = Math.max(centerY, startY);
  for (let y2 = minY; y2 <= maxY; y2++) {
    setHeight(draft, centerX, y2, 0);
  }
  const playerStart = { x: ensureInBounds(centerX, cols), y: startY };
  if (style === "closed") {
    const wallType = findWallType(ctx.wallTypes, "wall-stone") ?? ctx.wallTypes[0] ?? null;
    if (wallType) {
      const baseKind = resolveWallKindFromType(wallType);
      const baseMaxHp = resolveWallMaxHp(wallType);
      const placed = /* @__PURE__ */ new Set();
      const placeEdge = (x2, y2, dir) => {
        if (x2 < 0 || x2 >= cols || y2 < 0 || y2 >= rows) return;
        const key2 = `${x2},${y2},${dir}`;
        if (placed.has(key2)) return;
        placed.add(key2);
        tryPlaceWallSegment({ draft, x: x2, y: y2, dir, kind: baseKind, typeId: wallType.id, maxHp: baseMaxHp ?? void 0, allowOnReserved: true });
      };
      for (let x2 = bounds.x1; x2 <= bounds.x2; x2++) {
        placeEdge(x2, bounds.y1 - 1, "S");
        placeEdge(x2, bounds.y2 + 1, "N");
      }
      for (let y2 = bounds.y1; y2 <= bounds.y2; y2++) {
        placeEdge(bounds.x1 - 1, y2, "E");
        placeEdge(bounds.x2 + 1, y2, "W");
      }
    }
  }
  draft.log.push(`Btiment  toit ${style} gnr (niveau 1 accessible).`);
  return { draft, playerStart };
}
function generateGenericScatter(params) {
  const { spec, ctx, rand } = params;
  const cols = Math.max(1, spec.grid.cols);
  const rows = Math.max(1, spec.grid.rows);
  const playerStart = { x: 1, y: Math.floor(rows / 2) };
  const draft = createDraft({ cols, rows, reserved: /* @__PURE__ */ new Set(), seedPrefix: "obs" });
  draft.log.push("Layout: basique (scatter).");
  for (let y2 = 0; y2 < rows; y2++) {
    for (let x2 = 0; x2 < cols; x2++) {
      setTerrain(draft, x2, y2, "floor");
      setLight(draft, x2, y2, 0.75);
    }
  }
  const barrelType = findObstacleType(ctx.obstacleTypes, "barrel-wood") ?? ctx.obstacleTypes.find((t2) => (t2.tags ?? []).includes("barrel")) ?? null;
  const props = weightedTypesForContext(ctx.obstacleTypes, (t2) => t2.category !== "wall");
  const count2 = clamp$4(Math.floor(cols * rows / 18), 1, 8);
  let placed = 0;
  for (let i2 = 0; i2 < count2; i2++) {
    const chosen = pickWeighted(props, rand) ?? barrelType;
    if (!chosen) break;
    const x2 = Math.floor(rand() * cols);
    const y2 = Math.floor(rand() * rows);
    const variantId = pickVariantIdForPlacement(chosen, "scatter", rand);
    const rotation = randomRotationForPlacement(chosen, variantId, rand);
    const ok = tryPlaceObstacle({ draft, type: chosen, x: x2, y: y2, variantId, rotation });
    if (ok) placed++;
  }
  draft.log.push(`Props: ${placed}.`);
  return { draft, playerStart };
}
function getFootprintBounds(cells) {
  if (!cells || cells.length === 0) {
    return { minX: 0, minY: 0, maxX: 0, maxY: 0, w: 1, h: 1 };
  }
  let minX = Number.POSITIVE_INFINITY;
  let minY = Number.POSITIVE_INFINITY;
  let maxX = Number.NEGATIVE_INFINITY;
  let maxY = Number.NEGATIVE_INFINITY;
  for (const cell of cells) {
    if (cell.x < minX) minX = cell.x;
    if (cell.y < minY) minY = cell.y;
    if (cell.x > maxX) maxX = cell.x;
    if (cell.y > maxY) maxY = cell.y;
  }
  if (!Number.isFinite(minX) || !Number.isFinite(minY) || !Number.isFinite(maxX) || !Number.isFinite(maxY)) {
    return { minX: 0, minY: 0, maxX: 0, maxY: 0, w: 1, h: 1 };
  }
  const w2 = Math.max(1, Math.round(maxX - minX + 1));
  const h2 = Math.max(1, Math.round(maxY - minY + 1));
  return { minX, minY, maxX, maxY, w: w2, h: h2 };
}
function getOccupiedBounds(type2, variantId) {
  const instance = {
    typeId: type2.id,
    variantId,
    x: 0,
    y: 0,
    rotation: 0
  };
  const cells = getObstacleOccupiedCells(instance, type2);
  return getFootprintBounds(cells);
}
function getSpriteGridSize(type2) {
  var _a, _b, _c, _d, _e, _f, _g;
  const grids = [];
  if (((_b = (_a = type2.appearance) == null ? void 0 : _a.spriteGrid) == null ? void 0 : _b.tilesX) && ((_d = (_c = type2.appearance) == null ? void 0 : _c.spriteGrid) == null ? void 0 : _d.tilesY)) {
    grids.push(type2.appearance.spriteGrid);
  }
  if ((_e = type2.appearance) == null ? void 0 : _e.layers) {
    for (const layer of type2.appearance.layers) {
      if (((_f = layer.spriteGrid) == null ? void 0 : _f.tilesX) && ((_g = layer.spriteGrid) == null ? void 0 : _g.tilesY)) {
        grids.push(layer.spriteGrid);
      }
    }
  }
  if (!grids.length) return null;
  const w2 = Math.max(...grids.map((g2) => Math.max(1, Math.floor(g2.tilesX))));
  const h2 = Math.max(...grids.map((g2) => Math.max(1, Math.floor(g2.tilesY))));
  return { w: w2, h: h2 };
}
function generateTestObstacles(params) {
  const { spec, ctx } = params;
  const padding = 1;
  const startX = 2;
  const startY = 1;
  const effectZoneW = 5;
  const effectZoneH = 5;
  const fireOnly2 = ctx.obstacleTypes.find((type2) => type2.id === "fire-only") ?? null;
  const items = ctx.obstacleTypes.filter((type2) => type2.id !== "fire-only").sort((a2, b2) => a2.id.localeCompare(b2.id)).map((type2) => {
    const variant = type2.variants.find((v2) => v2.id === "base") ?? type2.variants[0];
    const bounds = getOccupiedBounds(type2, (variant == null ? void 0 : variant.id) ?? "base");
    const spriteGrid = getSpriteGridSize(type2);
    if (spriteGrid) {
      bounds.w = Math.max(bounds.w, spriteGrid.w);
      bounds.h = Math.max(bounds.h, spriteGrid.h);
    }
    return { type: type2, variantId: (variant == null ? void 0 : variant.id) ?? "base", bounds };
  });
  const maxItemW = items.reduce((max, item) => Math.max(max, item.bounds.w), 1);
  let cols = Math.max(1, Math.floor(spec.grid.cols));
  cols = Math.max(cols, startX + maxItemW + padding);
  const usableCols = Math.max(1, cols - startX);
  let cursorX = 0;
  let cursorY = 0;
  let rowH = 0;
  const placements = [];
  let maxPlacedX = startX;
  for (const item of items) {
    if (cursorX > 0 && cursorX + item.bounds.w > usableCols) {
      cursorX = 0;
      cursorY += rowH + padding;
      rowH = 0;
    }
    placements.push({ item, x: startX + cursorX, y: startY + cursorY });
    maxPlacedX = Math.max(maxPlacedX, startX + cursorX + item.bounds.w - 1);
    cursorX += item.bounds.w + padding;
    rowH = Math.max(rowH, item.bounds.h);
  }
  const rowsNeeded = startY + cursorY + rowH + 1;
  const effectZoneX = maxPlacedX + padding + 2;
  const effectZoneY = startY;
  cols = Math.max(cols, effectZoneX + effectZoneW + 1);
  const rows = Math.max(1, Math.floor(spec.grid.rows), rowsNeeded, effectZoneY + effectZoneH + 1);
  const draft = createDraft({ cols, rows, reserved: /* @__PURE__ */ new Set(), seedPrefix: "testobs" });
  for (let y2 = 0; y2 < rows; y2++) {
    for (let x2 = 0; x2 < cols; x2++) {
      setTerrain(draft, x2, y2, "stone");
      setLight(draft, x2, y2, 0.85);
    }
  }
  draft.reserved.add(key(0, 0));
  draft.reserved.add(key(1, 0));
  draft.reserved.add(key(0, 1));
  draft.reserved.add(key(1, 1));
  for (const placement2 of placements) {
    const { item } = placement2;
    const originX = placement2.x - item.bounds.minX;
    const originY = placement2.y - item.bounds.minY;
    const ok = tryPlaceObstacle({
      draft,
      type: item.type,
      x: originX,
      y: originY,
      variantId: item.variantId,
      rotation: 0
    });
    if (!ok) {
      draft.log.push(`Test obstacle ignore: ${item.type.id}`);
    }
  }
  for (let y2 = effectZoneY; y2 < effectZoneY + effectZoneH; y2++) {
    for (let x2 = effectZoneX; x2 < effectZoneX + effectZoneW; x2++) {
      setTerrain(draft, x2, y2, "floor");
    }
  }
  if (fireOnly2) {
    const centerX = effectZoneX + Math.floor(effectZoneW / 2);
    const centerY = effectZoneY + Math.floor(effectZoneH / 2);
    tryPlaceObstacle({
      draft,
      type: fireOnly2,
      x: centerX,
      y: centerY,
      variantId: "base",
      rotation: 0
    });
  }
  const playerStart = { x: 0, y: 0 };
  draft.log.push(`Test obstacles: ${draft.obstacles.length}/${items.length}`);
  return { draft, playerStart };
}
function buildMapFromPrompt(params) {
  const { spec, notes } = parsePromptToSpec({
    prompt: params.prompt,
    cols: params.grid.cols,
    rows: params.grid.rows
  });
  const seed = hashStringToSeed(params.prompt || "default");
  const rand = mulberry32(seed);
  return { spec, notes, rand };
}
function generateFromSpec(params) {
  const { spec, ctx, rand } = params;
  switch (spec.layoutId) {
    case "dungeon_circular_room":
      return generateDungeonCircularRoom({ spec, ctx, rand });
    case "dungeon_square_room":
      return generateDungeonSquareRoom({ spec, ctx, rand });
    case "dungeon_split_rooms":
    case "dungeon_corridor_rooms":
      return generateDungeonRoomPlan({ spec, ctx, rand });
    case "forest_clearing":
      return generateForestClearing({ spec, ctx, rand });
    case "city_street":
      return generateCityStreet({ spec, ctx, rand });
    case "building_tiered":
      return generateTieredBuilding({ spec, ctx });
    case "test_obstacles":
      return generateTestObstacles({ spec, ctx });
    default:
      return generateGenericScatter({ spec, ctx, rand });
  }
}
function isPlayableCell(draft, x2, y2) {
  if (draft.playable.size === 0) return true;
  return draft.playable.has(key(x2, y2));
}
function hasClearance(draft, center, radius) {
  if (radius <= 0) return !draft.occupied.has(key(center.x, center.y));
  for (let dy = -radius; dy <= radius; dy++) {
    for (let dx = -radius; dx <= radius; dx++) {
      const dist = Math.abs(dx) + Math.abs(dy);
      if (dist > radius) continue;
      const x2 = center.x + dx;
      const y2 = center.y + dy;
      if (x2 < 0 || y2 < 0 || x2 >= draft.cols || y2 >= draft.rows) continue;
      if (draft.occupied.has(key(x2, y2))) return false;
    }
  }
  return true;
}
function resolvePlayerStart(draft, hint) {
  const fallback = { x: 0, y: 0 };
  const safeHint = Number.isFinite(hint == null ? void 0 : hint.x) && Number.isFinite(hint == null ? void 0 : hint.y) ? hint : fallback;
  const hintHeight = getHeightAtGrid(
    draft.layers.height,
    draft.cols,
    draft.rows,
    safeHint.x,
    safeHint.y
  );
  const clearanceOptions = [2, 1, 0];
  for (const radius of clearanceOptions) {
    let best = null;
    let bestScore = Number.POSITIVE_INFINITY;
    for (let y2 = 0; y2 < draft.rows; y2++) {
      for (let x2 = 0; x2 < draft.cols; x2++) {
        if (!isPlayableCell(draft, x2, y2)) continue;
        const candidate = { x: x2, y: y2 };
        if (!hasClearance(draft, candidate, radius)) continue;
        const dist = Math.abs(x2 - safeHint.x) + Math.abs(y2 - safeHint.y);
        const height = getHeightAtGrid(draft.layers.height, draft.cols, draft.rows, x2, y2);
        const heightPenalty = height === hintHeight ? 0 : 1e4;
        const score = heightPenalty + dist * 1e3 + x2 * 2 + Math.abs(y2 - safeHint.y);
        if (score < bestScore) {
          bestScore = score;
          best = candidate;
        }
      }
    }
    if (best) return best;
  }
  for (let y2 = 0; y2 < draft.rows; y2++) {
    for (let x2 = 0; x2 < draft.cols; x2++) {
      if (!isPlayableCell(draft, x2, y2)) continue;
      if (!draft.occupied.has(key(x2, y2))) return { x: x2, y: y2 };
    }
  }
  return fallback;
}
function runGenerationPipeline(params) {
  var _a;
  const { spec, notes, rand } = buildMapFromPrompt(params);
  const rawPrompt = String(params.prompt ?? "");
  const disableEnemies = rawPrompt.trimStart().toLowerCase().startsWith("test");
  const recommendedGrid = recommendGridFromSpec({
    spec,
    enemyCount: disableEnemies ? 0 : params.ctx.enemyCount
  });
  const { draft, playerStart, roomMasks, enemyRoomId } = generateFromSpec({ spec, ctx: params.ctx, rand });
  const resolvedPlayerStart = resolvePlayerStart(draft, playerStart);
  const enemyCountOverride = (_a = spec.dungeonPlan) == null ? void 0 : _a.enemyCountOverride;
  const resolvedEnemyCount = enemyCountOverride ?? params.ctx.enemyCount;
  const effectiveEnemyCount = disableEnemies ? 0 : resolvedEnemyCount;
  const enemyRoomMask = enemyRoomId && roomMasks ? roomMasks[enemyRoomId] ?? null : null;
  const { enemySpawns, log: spawnLog } = spawnEnemies({
    draft,
    playerStart: resolvedPlayerStart,
    enemyCount: effectiveEnemyCount,
    enemyTypes: params.ctx.enemyTypes,
    rand,
    spawnMask: enemyRoomMask ?? void 0
  });
  const summaryParts = [];
  const generationLog = [];
  if (spec.prompt.trim()) summaryParts.push(`Prompt: ${spec.prompt.trim()}`);
  summaryParts.push(
    spec.layoutId === "dungeon_circular_room" ? "Layout: donjon (salle circulaire)." : spec.layoutId === "dungeon_square_room" ? "Layout: donjon (salle carree)." : spec.layoutId === "dungeon_split_rooms" ? "Layout: donjon (salles separees)." : spec.layoutId === "dungeon_corridor_rooms" ? "Layout: donjon (salles avec couloir)." : spec.layoutId === "forest_clearing" ? "Layout: foret (clairiere)." : spec.layoutId === "city_street" ? "Layout: ville (rue)." : spec.layoutId === "test_obstacles" ? "Layout: test obstacles." : "Layout: basique."
  );
  summaryParts.push(`Obstacles: ${draft.obstacles.length}. Murs: ${draft.wallSegments.length}. Ennemis: ${enemySpawns.length}.`);
  generationLog.push(...notes.map((n2) => `[spec] ${n2}`));
  generationLog.push(`[spec] timeOfDay=${spec.timeOfDay}`);
  if (spec.paletteId) {
    generationLog.push(`[spec] palette=${spec.paletteId}`);
  }
  generationLog.push(`[gen] module=${spec.layoutId}`);
  if (disableEnemies) {
    generationLog.push("[spec] testPrompt=true (ennemis desactive)");
  }
  if (recommendedGrid) {
    generationLog.push(
      `[spec] recommendedGrid=${recommendedGrid.cols}x${recommendedGrid.rows} (${recommendedGrid.reason})`
    );
  }
  generationLog.push(...draft.log.map((l2) => `[gen] ${l2}`));
  generationLog.push(...spawnLog.map((l2) => `[spawn] ${l2}`));
  const wallSegmentMap = /* @__PURE__ */ new Map();
  for (const seg of draft.wallSegments) {
    wallSegmentMap.set(wallEdgeKeyForSegment(seg), seg);
  }
  return {
    summaryParts,
    generationLog,
    grid: { cols: draft.cols, rows: draft.rows },
    theme: spec.theme,
    paletteId: spec.paletteId,
    playerStart: resolvedPlayerStart,
    enemySpawns,
    playableCells: Array.from(draft.playable),
    obstacles: draft.obstacles,
    wallSegments: Array.from(wallSegmentMap.values()),
    terrain: draft.layers.terrain,
    height: draft.layers.height,
    light: draft.layers.light,
    decorations: draft.decorations,
    roofOpenCells: Array.from(draft.roofOpenCells),
    recommendedGrid: recommendedGrid ?? void 0
  };
}
function generateBattleMap(request) {
  const cols = Math.max(1, request.grid.cols);
  const rows = Math.max(1, request.grid.rows);
  const result = runGenerationPipeline({
    prompt: String(request.prompt ?? ""),
    grid: { cols, rows },
    ctx: {
      enemyCount: request.enemyCount,
      enemyTypes: request.enemyTypes,
      obstacleTypes: request.obstacleTypes,
      wallTypes: request.wallTypes
    }
  });
  return {
    summary: result.summaryParts.join(" "),
    grid: result.grid,
    theme: result.theme,
    paletteId: result.paletteId,
    playerStart: result.playerStart,
    enemySpawns: result.enemySpawns,
    playableCells: result.playableCells,
    obstacles: result.obstacles,
    wallSegments: result.wallSegments,
    terrain: result.terrain,
    height: result.height,
    light: result.light,
    decorations: result.decorations,
    roofOpenCells: result.roofOpenCells,
    recommendedGrid: result.recommendedGrid,
    generationLog: result.generationLog
  };
}
const TERRAIN_PRIORITY = ["rock", "dirt", "grass", "water"];
const DEFAULT_PRIORITY = 0;
const priorityByTerrain = new Map(
  TERRAIN_PRIORITY.map((id2, index) => [id2, TERRAIN_PRIORITY.length - index])
);
function getPriority(cell) {
  return priorityByTerrain.get(cell) ?? DEFAULT_PRIORITY;
}
function buildTerrainMixLayer(params) {
  const cols = Math.max(1, Math.floor(params.cols));
  const rows = Math.max(1, Math.floor(params.rows));
  const size2 = cols * rows;
  const terrain = Array.isArray(params.terrain) ? params.terrain : [];
  const playable = params.playableCells ?? null;
  const result = Array.from({ length: size2 }, () => null);
  const isPlayable2 = (x2, y2) => {
    if (!playable || playable.size === 0) return true;
    return playable.has(`${x2},${y2}`);
  };
  const getTerrainAt2 = (x2, y2) => {
    if (x2 < 0 || y2 < 0 || x2 >= cols || y2 >= rows) return "unknown";
    const index = y2 * cols + x2;
    return terrain[index] ?? "unknown";
  };
  const tryCorner = (x2, y2, corner, diagX, diagY, orthoA, orthoB) => {
    if (!isPlayable2(diagX, diagY)) return null;
    if (!isPlayable2(orthoA.x, orthoA.y) || !isPlayable2(orthoB.x, orthoB.y)) return null;
    const base = getTerrainAt2(x2, y2);
    const blend = getTerrainAt2(diagX, diagY);
    if (!blend || blend === "unknown" || blend === base) return null;
    if (getPriority(blend) <= getPriority(base)) return null;
    if (getTerrainAt2(orthoA.x, orthoA.y) !== blend) return null;
    if (getTerrainAt2(orthoB.x, orthoB.y) !== blend) return null;
    return { base, blend, corner };
  };
  for (let y2 = 0; y2 < rows; y2++) {
    for (let x2 = 0; x2 < cols; x2++) {
      if (!isPlayable2(x2, y2)) continue;
      const matches = [];
      const ne = tryCorner(
        x2,
        y2,
        "NE",
        x2 + 1,
        y2 - 1,
        { x: x2, y: y2 - 1 },
        { x: x2 + 1, y: y2 }
      );
      if (ne) matches.push(ne);
      const nw = tryCorner(
        x2,
        y2,
        "NW",
        x2 - 1,
        y2 - 1,
        { x: x2, y: y2 - 1 },
        { x: x2 - 1, y: y2 }
      );
      if (nw) matches.push(nw);
      const se = tryCorner(
        x2,
        y2,
        "SE",
        x2 + 1,
        y2 + 1,
        { x: x2, y: y2 + 1 },
        { x: x2 + 1, y: y2 }
      );
      if (se) matches.push(se);
      const sw = tryCorner(
        x2,
        y2,
        "SW",
        x2 - 1,
        y2 + 1,
        { x: x2, y: y2 + 1 },
        { x: x2 - 1, y: y2 }
      );
      if (sw) matches.push(sw);
      const index = y2 * cols + x2;
      result[index] = matches.length === 1 ? matches[0] : null;
    }
  }
  return result;
}
const id$L = "unknown";
const label$8 = "Unknown";
const fallbackColor$8 = "#4a4a4a";
const tags$L = ["default"];
const passable$8 = true;
const moveCost$8 = 1;
const unknown = {
  id: id$L,
  label: label$8,
  fallbackColor: fallbackColor$8,
  tags: tags$L,
  passable: passable$8,
  moveCost: moveCost$8
};
const id$K = "stone";
const label$7 = "Stone";
const textureId$3 = "stone-basic";
const fallbackColor$7 = "#6b6f74";
const tags$K = ["rock", "interior"];
const passable$7 = true;
const moveCost$7 = 1;
const stone = {
  id: id$K,
  label: label$7,
  textureId: textureId$3,
  fallbackColor: fallbackColor$7,
  tags: tags$K,
  passable: passable$7,
  moveCost: moveCost$7
};
const id$J = "road";
const label$6 = "Road";
const textureId$2 = "road-basic";
const fallbackColor$6 = "#5a4a3a";
const tags$J = ["exterior", "path"];
const passable$6 = true;
const moveCost$6 = 1;
const road = {
  id: id$J,
  label: label$6,
  textureId: textureId$2,
  fallbackColor: fallbackColor$6,
  tags: tags$J,
  passable: passable$6,
  moveCost: moveCost$6
};
const id$I = "grass";
const label$5 = "Grass";
const textureId$1 = "grass-basic";
const fallbackColor$5 = "#35962a";
const solidColor = "#35962a";
const tags$I = ["exterior", "nature"];
const passable$5 = true;
const moveCost$5 = 1;
const grass = {
  id: id$I,
  label: label$5,
  textureId: textureId$1,
  fallbackColor: fallbackColor$5,
  solidColor,
  tags: tags$I,
  passable: passable$5,
  moveCost: moveCost$5
};
const id$H = "floor";
const label$4 = "Wood floor";
const textureId = "wood-plank";
const fallbackColor$4 = "#8b6a47";
const tags$H = ["interior", "wood"];
const passable$4 = true;
const moveCost$4 = 1;
const floor = {
  id: id$H,
  label: label$4,
  textureId,
  fallbackColor: fallbackColor$4,
  tags: tags$H,
  passable: passable$4,
  moveCost: moveCost$4
};
const id$G = "dirt";
const label$3 = "Dirt";
const fallbackColor$3 = "#6a5536";
const tags$G = ["exterior", "nature"];
const passable$3 = true;
const moveCost$3 = 1;
const dirt = {
  id: id$G,
  label: label$3,
  fallbackColor: fallbackColor$3,
  tags: tags$G,
  passable: passable$3,
  moveCost: moveCost$3
};
const id$F = "mud";
const label$2 = "Mud";
const fallbackColor$2 = "#5a4433";
const tags$F = ["exterior", "wet"];
const passable$2 = true;
const moveCost$2 = 2;
const mud = {
  id: id$F,
  label: label$2,
  fallbackColor: fallbackColor$2,
  tags: tags$F,
  passable: passable$2,
  moveCost: moveCost$2
};
const id$E = "water";
const label$1 = "Water";
const fallbackColor$1 = "#2f5d8a";
const tags$E = ["liquid"];
const passable$1 = true;
const moveCost$1 = 2;
const liquid$1 = true;
const depth$1 = 1;
const water = {
  id: id$E,
  label: label$1,
  fallbackColor: fallbackColor$1,
  tags: tags$E,
  passable: passable$1,
  moveCost: moveCost$1,
  liquid: liquid$1,
  depth: depth$1
};
const id$D = "deep-water";
const label = "Deep water";
const fallbackColor = "#1f3b63";
const tags$D = ["liquid"];
const passable = true;
const moveCost = 3;
const liquid = true;
const depth = 3;
const deepWater = {
  id: id$D,
  label,
  fallbackColor,
  tags: tags$D,
  passable,
  moveCost,
  liquid,
  depth
};
const FLOOR_MATERIALS = [
  unknown,
  stone,
  road,
  grass,
  floor,
  dirt,
  mud,
  water,
  deepWater
];
const floorMaterialMap = new Map(FLOOR_MATERIALS.map((mat) => [mat.id, mat]));
function getFloorMaterial(id2) {
  if (!id2) return null;
  return floorMaterialMap.get(id2) ?? null;
}
const actions = ["../attacks/bow-shot.json", "../attacks/melee-strike.json", "../attacks/throw-dagger.json", "../items/torch-toggle.json", "../moves/dash.json", "../moves/move.json", "../spells/aid.json", "../spells/arcane-bolt.json", "../spells/aura-of-purity.json", "../spells/beacon-of-hope.json", "../spells/greater-restoration.json", "../spells/heroism.json", "../spells/minor-ward.json", "../spells/rarys-telepathic-bond.json", "../spells/rayon-de-feu.json", "../spells/resilient-sphere.json", "../spells/sanctuary.json", "../spells/sending.json", "../spells/vague-ardente.json", "../spells/warding-bond.json", "../supports/action-surge.json", "../supports/cast-magic.json", "../supports/disengage.json", "../supports/divine-spark-heal.json", "../supports/divine-spark-necrotic.json", "../supports/divine-spark-radiant.json", "../supports/dodge.json", "../supports/help.json", "../supports/hide.json", "../supports/indomitable.json", "../supports/influence.json", "../supports/observe.json", "../supports/ready-action.json", "../supports/second-wind.json", "../supports/study.json", "../supports/turn-undead.json", "../supports/use-item.json"];
const actionsIndex = {
  actions
};
const id$C = "aid";
const name$C = "Aide";
const level$d = 2;
const school$d = "abjuration";
const components$d = { "verbal": true, "somatic": true, "material": true };
const summary$C = "Renforce la vigueur d'un groupe d'allies.";
const category$C = "support";
const actionCost$C = { "actionType": "action", "movementCost": 0 };
const targeting$C = { "target": "ally", "range": { "min": 0, "max": 9, "shape": "SPHERE" }, "maxTargets": 3, "requiresLos": true };
const usage$C = { "perTurn": 1, "perEncounter": null, "resource": null };
const tags$C = ["spell", "support", "cleric"];
const ops$C = { "onResolve": [{ "op": "ApplyCondition", "target": "primary", "statusId": "aid", "durationTurns": 60 }, { "op": "LogEvent", "message": "Aide appliquee." }] };
const aid = {
  id: id$C,
  name: name$C,
  level: level$d,
  school: school$d,
  components: components$d,
  summary: summary$C,
  category: category$C,
  actionCost: actionCost$C,
  targeting: targeting$C,
  usage: usage$C,
  tags: tags$C,
  ops: ops$C
};
const id$B = "arcane-bolt";
const name$B = "Trait Arcanique";
const level$c = 1;
const school$c = "evocation";
const components$c = { "verbal": true, "somatic": true, "material": false };
const summary$B = "Placeholder: petit projectile magique.";
const category$B = "attack";
const actionCost$B = { "actionType": "action", "movementCost": 0 };
const targeting$B = { "target": "hostile", "range": { "min": 1.5, "max": 9, "shape": "SPHERE" }, "maxTargets": 1, "requiresLos": true };
const usage$B = { "perTurn": 1, "perEncounter": null, "resource": null };
const attack$4 = { "bonus": 0, "critRange": 20 };
const damage$4 = { "formula": "1d8", "critRule": "double-dice", "damageType": "FORCE" };
const resolution$d = { "kind": "ATTACK_ROLL", "bonus": 0, "critRange": 20, "critRule": "double-dice" };
const ops$B = { "onHit": [{ "op": "DealDamage", "target": "primary", "formula": "1d8", "damageType": "FORCE" }, { "op": "DealDamage", "target": "primary", "formula": "1d8", "damageType": "FORCE" }], "onResolve": [{ "op": "LogEvent", "message": "Trait arcanique." }] };
const tags$B = ["spell", "ranged"];
const arcaneBolt = {
  id: id$B,
  name: name$B,
  level: level$c,
  school: school$c,
  components: components$c,
  summary: summary$B,
  category: category$B,
  actionCost: actionCost$B,
  targeting: targeting$B,
  usage: usage$B,
  attack: attack$4,
  damage: damage$4,
  resolution: resolution$d,
  ops: ops$B,
  tags: tags$B
};
const id$A = "aura-of-purity";
const name$A = "Aura de purete";
const level$b = 4;
const school$b = "abjuration";
const components$b = { "verbal": true, "somatic": true, "material": true };
const summary$A = "Aura protectrice contre maladies et effets nefastes.";
const category$A = "support";
const actionCost$A = { "actionType": "action", "movementCost": 0 };
const targeting$A = { "target": "self", "range": { "min": 0, "max": 0, "shape": "SPHERE" }, "maxTargets": 1, "requiresLos": false };
const usage$A = { "perTurn": 1, "perEncounter": null, "resource": null };
const tags$A = ["spell", "defense", "cleric"];
const ops$A = { "onResolve": [{ "op": "ApplyCondition", "target": "self", "statusId": "aura-of-purity", "durationTurns": 10 }, { "op": "LogEvent", "message": "Aura de purete activee." }] };
const auraOfPurity = {
  id: id$A,
  name: name$A,
  level: level$b,
  school: school$b,
  components: components$b,
  summary: summary$A,
  category: category$A,
  actionCost: actionCost$A,
  targeting: targeting$A,
  usage: usage$A,
  tags: tags$A,
  ops: ops$A
};
const id$z = "beacon-of-hope";
const name$z = "Flamme d'espoir";
const level$a = 3;
const school$a = "abjuration";
const components$a = { "verbal": true, "somatic": true, "material": false };
const summary$z = "Renforce les soins et la determination.";
const category$z = "support";
const actionCost$z = { "actionType": "action", "movementCost": 0 };
const targeting$z = { "target": "ally", "range": { "min": 0, "max": 9, "shape": "SPHERE" }, "maxTargets": 3, "requiresLos": true };
const usage$z = { "perTurn": 1, "perEncounter": null, "resource": null };
const tags$z = ["spell", "support", "cleric"];
const ops$z = { "onResolve": [{ "op": "ApplyCondition", "target": "primary", "statusId": "beacon-of-hope", "durationTurns": 10 }, { "op": "LogEvent", "message": "Flamme d'espoir appliquee." }] };
const beaconOfHope = {
  id: id$z,
  name: name$z,
  level: level$a,
  school: school$a,
  components: components$a,
  summary: summary$z,
  category: category$z,
  actionCost: actionCost$z,
  targeting: targeting$z,
  usage: usage$z,
  tags: tags$z,
  ops: ops$z
};
const id$y = "greater-restoration";
const name$y = "Restauration superieure";
const level$9 = 5;
const school$9 = "abjuration";
const components$9 = { "verbal": true, "somatic": true, "material": true };
const summary$y = "Supprime des afflictions majeures sur une cible.";
const category$y = "support";
const actionCost$y = { "actionType": "action", "movementCost": 0 };
const targeting$y = { "target": "ally", "range": { "min": 0, "max": 9, "shape": "SPHERE" }, "maxTargets": 1, "requiresLos": true };
const usage$y = { "perTurn": 1, "perEncounter": null, "resource": null };
const tags$y = ["spell", "support", "cleric"];
const ops$y = { "onResolve": [{ "op": "ApplyCondition", "target": "primary", "statusId": "greater-restoration", "durationTurns": 1 }, { "op": "LogEvent", "message": "Restauration superieure appliquee." }] };
const greaterRestoration = {
  id: id$y,
  name: name$y,
  level: level$9,
  school: school$9,
  components: components$9,
  summary: summary$y,
  category: category$y,
  actionCost: actionCost$y,
  targeting: targeting$y,
  usage: usage$y,
  tags: tags$y,
  ops: ops$y
};
const id$x = "heroism";
const name$x = "Heroisme";
const level$8 = 1;
const school$8 = "enchantment";
const components$8 = { "verbal": true, "somatic": true, "material": false };
const summary$x = "Insuffle du courage et protege contre la peur.";
const category$x = "support";
const actionCost$x = { "actionType": "action", "movementCost": 0 };
const targeting$x = { "target": "ally", "range": { "min": 0, "max": 9, "shape": "SPHERE" }, "maxTargets": 1, "requiresLos": true };
const usage$x = { "perTurn": 1, "perEncounter": null, "resource": null };
const tags$x = ["spell", "support", "cleric"];
const ops$x = { "onResolve": [{ "op": "ApplyCondition", "target": "primary", "statusId": "heroism", "durationTurns": 10 }, { "op": "LogEvent", "message": "Heroisme applique." }] };
const heroism = {
  id: id$x,
  name: name$x,
  level: level$8,
  school: school$8,
  components: components$8,
  summary: summary$x,
  category: category$x,
  actionCost: actionCost$x,
  targeting: targeting$x,
  usage: usage$x,
  tags: tags$x,
  ops: ops$x
};
const id$w = "minor-ward";
const name$w = "Garde Mineure";
const level$7 = 1;
const school$7 = "abjuration";
const components$7 = { "verbal": true, "somatic": true, "material": false };
const summary$w = "Placeholder: protection temporaire.";
const category$w = "support";
const actionCost$w = { "actionType": "action", "movementCost": 0 };
const targeting$w = { "target": "self", "range": { "min": 0, "max": 0, "shape": "SPHERE" }, "maxTargets": 1, "requiresLos": false };
const usage$w = { "perTurn": 1, "perEncounter": null, "resource": null };
const tags$w = ["spell", "defense", "cleric"];
const ops$w = { "onResolve": [{ "op": "ApplyCondition", "target": "self", "statusId": "guarded", "durationTurns": 1 }, { "op": "LogEvent", "message": "Garde mineure activee." }] };
const minorWard = {
  id: id$w,
  name: name$w,
  level: level$7,
  school: school$7,
  components: components$7,
  summary: summary$w,
  category: category$w,
  actionCost: actionCost$w,
  targeting: targeting$w,
  usage: usage$w,
  tags: tags$w,
  ops: ops$w
};
const id$v = "rarys-telepathic-bond";
const name$v = "Lien telepathique de Rary";
const level$6 = 5;
const school$6 = "divination";
const components$6 = { "verbal": true, "somatic": true, "material": true };
const summary$v = "Lie telepathiquement plusieurs allies.";
const category$v = "support";
const actionCost$v = { "actionType": "action", "movementCost": 0 };
const targeting$v = { "target": "ally", "range": { "min": 0, "max": 9, "shape": "SPHERE" }, "maxTargets": 6, "requiresLos": true };
const usage$v = { "perTurn": 1, "perEncounter": null, "resource": null };
const tags$v = ["spell", "support", "cleric"];
const ops$v = { "onResolve": [{ "op": "ApplyCondition", "target": "primary", "statusId": "telepathic-bond", "durationTurns": 60 }, { "op": "LogEvent", "message": "Lien telepathique etabli." }] };
const rarysTelepathicBond = {
  id: id$v,
  name: name$v,
  level: level$6,
  school: school$6,
  components: components$6,
  summary: summary$v,
  category: category$v,
  actionCost: actionCost$v,
  targeting: targeting$v,
  usage: usage$v,
  tags: tags$v,
  ops: ops$v
};
const id$u = "rayon-de-feu";
const name$u = "Rayon de feu";
const level$5 = 0;
const school$5 = "evocation";
const components$5 = { "verbal": true, "somatic": true, "material": false };
const summary$u = "Un trait de feu qui brule une cible a distance.";
const category$u = "attack";
const actionCost$u = { "actionType": "action", "movementCost": 0 };
const targeting$u = { "target": "hostile", "range": { "min": 0, "max": 36, "shape": "LINE" }, "maxTargets": 1, "requiresLos": true };
const usage$u = { "perTurn": null, "perEncounter": null, "resource": null };
const conditions$q = [];
const attack$3 = { "bonus": 0, "critRange": 20 };
const damage$3 = { "formula": "1d10", "critRule": "double-dice", "damageType": "FIRE" };
const resolution$c = { "kind": "ATTACK_ROLL", "bonus": 0, "critRange": 20, "critRule": "double-dice" };
const ops$u = { "onHit": [{ "op": "DealDamage", "target": "primary", "formula": "1d10", "damageType": "FIRE" }], "onMiss": [{ "op": "LogEvent", "message": "Le rayon rate sa cible." }] };
const tags$u = ["spell", "ranged", "fire"];
const rayonDeFeu = {
  id: id$u,
  name: name$u,
  level: level$5,
  school: school$5,
  components: components$5,
  summary: summary$u,
  category: category$u,
  actionCost: actionCost$u,
  targeting: targeting$u,
  usage: usage$u,
  conditions: conditions$q,
  attack: attack$3,
  damage: damage$3,
  resolution: resolution$c,
  ops: ops$u,
  tags: tags$u
};
const id$t = "resilient-sphere";
const name$t = "Sphere resiliente";
const level$4 = 4;
const school$4 = "evocation";
const components$4 = { "verbal": true, "somatic": true, "material": true };
const summary$t = "Emprisonne une cible dans une sphere protectrice.";
const category$t = "control";
const actionCost$t = { "actionType": "action", "movementCost": 0 };
const targeting$t = { "target": "hostile", "range": { "min": 0, "max": 9, "shape": "SPHERE" }, "maxTargets": 1, "requiresLos": true };
const usage$t = { "perTurn": 1, "perEncounter": null, "resource": null };
const tags$t = ["spell", "control", "cleric"];
const ops$t = { "onResolve": [{ "op": "ApplyCondition", "target": "primary", "statusId": "resilient-sphere", "durationTurns": 10 }, { "op": "LogEvent", "message": "Sphere resiliente appliquee." }] };
const resilientSphere = {
  id: id$t,
  name: name$t,
  level: level$4,
  school: school$4,
  components: components$4,
  summary: summary$t,
  category: category$t,
  actionCost: actionCost$t,
  targeting: targeting$t,
  usage: usage$t,
  tags: tags$t,
  ops: ops$t
};
const id$s = "sanctuary";
const name$s = "Sanctuaire";
const level$3 = 1;
const school$3 = "abjuration";
const components$3 = { "verbal": true, "somatic": true, "material": true };
const summary$s = "Protege une cible contre les attaques directes.";
const category$s = "support";
const actionCost$s = { "actionType": "action", "movementCost": 0 };
const targeting$s = { "target": "ally", "range": { "min": 0, "max": 9, "shape": "SPHERE" }, "maxTargets": 1, "requiresLos": true };
const usage$s = { "perTurn": 1, "perEncounter": null, "resource": null };
const tags$s = ["spell", "defense", "cleric"];
const ops$s = { "onResolve": [{ "op": "ApplyCondition", "target": "primary", "statusId": "sanctuary", "durationTurns": 10 }, { "op": "LogEvent", "message": "Sanctuaire applique." }] };
const sanctuary = {
  id: id$s,
  name: name$s,
  level: level$3,
  school: school$3,
  components: components$3,
  summary: summary$s,
  category: category$s,
  actionCost: actionCost$s,
  targeting: targeting$s,
  usage: usage$s,
  tags: tags$s,
  ops: ops$s
};
const id$r = "sending";
const name$r = "Message";
const level$2 = 3;
const school$2 = "evocation";
const components$2 = { "verbal": true, "somatic": true, "material": true };
const summary$r = "Envoie un message magique a distance.";
const category$r = "support";
const actionCost$r = { "actionType": "action", "movementCost": 0 };
const targeting$r = { "target": "ally", "range": { "min": 0, "max": 30, "shape": "SPHERE" }, "maxTargets": 1, "requiresLos": false };
const usage$r = { "perTurn": 1, "perEncounter": null, "resource": null };
const tags$r = ["spell", "utility", "cleric"];
const ops$r = { "onResolve": [{ "op": "LogEvent", "message": "Message envoye." }] };
const sending = {
  id: id$r,
  name: name$r,
  level: level$2,
  school: school$2,
  components: components$2,
  summary: summary$r,
  category: category$r,
  actionCost: actionCost$r,
  targeting: targeting$r,
  usage: usage$r,
  tags: tags$r,
  ops: ops$r
};
const id$q = "vague-ardente";
const name$q = "Vague ardente";
const level$1 = 2;
const school$1 = "evocation";
const components$1 = { "verbal": true, "somatic": true, "material": false };
const summary$q = "Une vague de flammes qui brule les ennemis dans un cone.";
const category$q = "control";
const actionCost$q = { "actionType": "action", "movementCost": 0 };
const targeting$q = { "target": "hostile", "range": { "min": 0, "max": 6, "shape": "CONE" }, "maxTargets": 3, "requiresLos": true };
const usage$q = { "perTurn": null, "perEncounter": null, "resource": null };
const conditions$p = [];
const resolution$b = { "kind": "SAVING_THROW", "save": { "ability": "DEX", "dc": 13 } };
const ops$q = { "onSaveFail": [{ "op": "DealDamage", "target": "primary", "formula": "3d6", "damageType": "FIRE" }, { "op": "ApplyCondition", "target": "primary", "statusId": "burning", "durationTurns": 2 }], "onSaveSuccess": [{ "op": "DealDamageScaled", "target": "primary", "formula": "3d6", "damageType": "FIRE", "scale": "half" }], "onResolve": [{ "op": "LogEvent", "message": "Une vague ardente se dechaine." }] };
const tags$q = ["spell", "fire", "area", "control"];
const vagueArdente = {
  id: id$q,
  name: name$q,
  level: level$1,
  school: school$1,
  components: components$1,
  summary: summary$q,
  category: category$q,
  actionCost: actionCost$q,
  targeting: targeting$q,
  usage: usage$q,
  conditions: conditions$p,
  resolution: resolution$b,
  ops: ops$q,
  tags: tags$q
};
const id$p = "warding-bond";
const name$p = "Lien protecteur";
const level = 2;
const school = "abjuration";
const components = { "verbal": true, "somatic": true, "material": true };
const summary$p = "Lie le lanceur a un allie pour partager les degats.";
const category$p = "support";
const actionCost$p = { "actionType": "action", "movementCost": 0 };
const targeting$p = { "target": "ally", "range": { "min": 0, "max": 9, "shape": "SPHERE" }, "maxTargets": 1, "requiresLos": true };
const usage$p = { "perTurn": 1, "perEncounter": null, "resource": null };
const tags$p = ["spell", "support", "cleric"];
const ops$p = { "onResolve": [{ "op": "ApplyCondition", "target": "primary", "statusId": "warding-bond", "durationTurns": 60 }, { "op": "LogEvent", "message": "Lien protecteur applique." }] };
const wardingBond = {
  id: id$p,
  name: name$p,
  level,
  school,
  components,
  summary: summary$p,
  category: category$p,
  actionCost: actionCost$p,
  targeting: targeting$p,
  usage: usage$p,
  tags: tags$p,
  ops: ops$p
};
const id$o = "bow-shot";
const name$o = "Tir a l'arc";
const summary$o = "Tir a distance contre une cible hostile, prefere eviter la melee.";
const uiMessageHit$2 = "Vous avez ete touche par une fleche.";
const uiMessageMiss$2 = "Vous evitez une fleche.";
const category$o = "attack";
const actionCost$o = { "actionType": "action", "movementCost": 0 };
const targeting$o = { "target": "hostile", "range": { "min": 3, "max": 9, "shape": "SPHERE" }, "maxTargets": 1, "requiresLos": true };
const usage$o = { "perTurn": 1, "perEncounter": null, "resource": null };
const conditions$o = [{ "type": "TARGET_ALIVE", "target": "primary", "reason": "La cible doit etre en vie." }];
const attack$2 = { "bonus": 5, "critRange": 20 };
const damage$2 = { "formula": "1d4 + modDEX", "critRule": "double-dice", "damageType": "PIERCING" };
const aiHints$5 = { "priority": "poke_from_range", "successLog": "Tir a l'arc.", "failureLog": "Cible hors portee/ligne de vue ou trop proche." };
const tags$o = ["distance", "bow"];
const ops$o = { "onHit": [{ "op": "DealDamage", "target": "primary", "formula": "1d4 + modDEX", "damageType": "PIERCING" }], "onResolve": [{ "op": "LogEvent", "message": "Une fleche siffle dans l'air." }] };
const AttacksBowShot = {
  id: id$o,
  name: name$o,
  summary: summary$o,
  uiMessageHit: uiMessageHit$2,
  uiMessageMiss: uiMessageMiss$2,
  category: category$o,
  actionCost: actionCost$o,
  targeting: targeting$o,
  usage: usage$o,
  conditions: conditions$o,
  attack: attack$2,
  damage: damage$2,
  aiHints: aiHints$5,
  tags: tags$o,
  ops: ops$o
};
const id$n = "melee-strike";
const name$n = "Frappe basique";
const summary$n = "Attaque de melee simple contre une cible adjacente (mains nues si aucune arme).";
const uiMessageHit$1 = "Vous avez ete touche par une attaque au corps a corps.";
const uiMessageMiss$1 = "Vous evitez une attaque au corps a corps.";
const category$n = "attack";
const actionCost$n = { "actionType": "action", "movementCost": 0 };
const targeting$n = { "target": "hostile", "range": { "min": 0, "max": 1.5, "shape": "SPHERE" }, "maxTargets": 1, "requiresLos": true };
const usage$n = { "perTurn": null, "perEncounter": null, "resource": null };
const conditions$n = [{ "type": "DISTANCE_MAX", "target": "primary", "max": 1.5, "reason": "Portee de melee uniquement." }, { "type": "TARGET_ALIVE", "target": "primary", "reason": "La cible doit avoir des PV restants." }];
const attack$1 = { "bonus": 5, "critRange": 20 };
const damage$1 = { "formula": "1d4 + modFOR", "critRule": "double-dice", "damageType": "BLUDGEONING" };
const resolution$a = { "kind": "ATTACK_ROLL", "bonus": 5, "critRange": 20, "critRule": "double-dice" };
const ops$n = { "onHit": [{ "op": "DealDamage", "target": "primary", "formula": "1d4 + modFOR", "damageType": "BLUDGEONING" }], "onResolve": [{ "op": "PlayVisualEffect", "effectId": "melee-slash", "anchor": "target", "orientation": "to_target", "rotationOffsetDeg": -135 }, { "op": "LogEvent", "message": "Frappe au contact." }] };
const aiHints$4 = { "priority": "finish_low_hp_target", "successLog": "Frappe au contact.", "failureLog": "Cible hors portee ou non visible." };
const tags$n = ["melee"];
const AttacksMeleeStrike = {
  id: id$n,
  name: name$n,
  summary: summary$n,
  uiMessageHit: uiMessageHit$1,
  uiMessageMiss: uiMessageMiss$1,
  category: category$n,
  actionCost: actionCost$n,
  targeting: targeting$n,
  usage: usage$n,
  conditions: conditions$n,
  attack: attack$1,
  damage: damage$1,
  resolution: resolution$a,
  ops: ops$n,
  aiHints: aiHints$4,
  tags: tags$n
};
const id$m = "throw-dagger";
const name$m = "Lancer de dague";
const summary$m = "Attaque a distance courte avec une dague a lancer.";
const uiMessageHit = "Vous avez ete touche par une dague lancee.";
const uiMessageMiss = "Vous evitez une dague lancee.";
const category$m = "attack";
const actionCost$m = { "actionType": "action", "movementCost": 0 };
const targeting$m = { "target": "hostile", "range": { "min": 1.5, "max": 6, "shape": "SPHERE" }, "maxTargets": 1, "requiresLos": true };
const usage$m = { "perTurn": 1, "perEncounter": null, "resource": { "name": "dagger", "pool": "bandolier", "min": 1 } };
const conditions$m = [{ "type": "DISTANCE_BETWEEN", "target": "primary", "min": 1.5, "max": 6, "reason": "Hors de melee mais a portee de lancer." }, { "type": "RESOURCE_AT_LEAST", "resource": "dagger", "pool": "bandolier", "value": 1, "reason": "Besoin d'une dague a lancer." }];
const attack = { "bonus": 4, "critRange": 20 };
const damage = { "formula": "1d4 + modDEX", "critRule": "double-dice", "damageType": "PIERCING" };
const aiHints$3 = { "priority": "poke_from_range", "successLog": "Dague lancee.", "failureLog": "Pas de dague ou cible hors portee." };
const tags$m = ["distance", "arme", "jet"];
const ops$m = { "onHit": [{ "op": "DealDamage", "target": "primary", "formula": "1d4 + modDEX", "damageType": "PIERCING" }], "onResolve": [{ "op": "SpendResource", "name": "dagger", "pool": "bandolier", "amount": 1 }, { "op": "LogEvent", "message": "Dague lancee: 1d4+DEX degats perforants." }] };
const AttacksThrowDagger = {
  id: id$m,
  name: name$m,
  summary: summary$m,
  uiMessageHit,
  uiMessageMiss,
  category: category$m,
  actionCost: actionCost$m,
  targeting: targeting$m,
  usage: usage$m,
  conditions: conditions$m,
  attack,
  damage,
  aiHints: aiHints$3,
  tags: tags$m,
  ops: ops$m
};
const id$l = "dash";
const name$l = "Course";
const summary$l = "Transforme l'action en 3 cases de mouvement en plus.";
const category$l = "movement";
const actionCost$l = { "actionType": "action", "movementCost": 0 };
const targeting$l = { "target": "self", "range": { "min": 0, "max": 0, "shape": "SPHERE" }, "maxTargets": 1, "requiresLos": false };
const usage$l = { "perTurn": 1, "perEncounter": null, "resource": null };
const conditions$l = [];
const aiHints$2 = { "priority": "close_gap", "successLog": "Course utilisee pour approcher.", "failureLog": "Deja a portee, course ignoree." };
const tags$l = ["mobilite", "deplacement"];
const ops$l = { "onResolve": [{ "op": "ModifyPathLimit", "delta": 3 }, { "op": "LogEvent", "message": "Course: +3 cases de mouvement pour ce tour." }] };
const MovesDash = {
  id: id$l,
  name: name$l,
  summary: summary$l,
  category: category$l,
  actionCost: actionCost$l,
  targeting: targeting$l,
  usage: usage$l,
  conditions: conditions$l,
  aiHints: aiHints$2,
  tags: tags$l,
  ops: ops$l
};
const id$k = "move";
const name$k = "Deplacement";
const summary$k = "Deplacement tactique vers une case cible (portee base: moveRange).";
const category$k = "movement";
const actionCost$k = { "actionType": "action", "movementCost": 0 };
const targeting$k = { "target": "emptyCell", "range": { "min": 1.5, "max": 4.5, "shape": "SPHERE" }, "maxTargets": 1, "requiresLos": false };
const usage$k = { "perTurn": 1, "perEncounter": null, "resource": null };
const conditions$k = [];
const aiHints$1 = { "priority": "positioning", "successLog": "Deplacement.", "failureLog": "Aucun chemin valide." };
const tags$k = ["movement"];
const ops$k = { "onResolve": [{ "op": "MoveTo", "target": "self", "maxSteps": "moveRange" }, { "op": "LogEvent", "message": "Deplacement effectue." }] };
const MovesMove = {
  id: id$k,
  name: name$k,
  summary: summary$k,
  category: category$k,
  actionCost: actionCost$k,
  targeting: targeting$k,
  usage: usage$k,
  conditions: conditions$k,
  aiHints: aiHints$1,
  tags: tags$k,
  ops: ops$k
};
const id$j = "action-surge";
const name$j = "Fougue";
const summary$j = "Depense une charge de Fougue pour declencher une acceleration tactique.";
const category$j = "support";
const actionCost$j = { "actionType": "free", "movementCost": 0 };
const targeting$j = { "target": "self", "range": { "min": 0, "max": 0, "shape": "SPHERE" }, "maxTargets": 1, "requiresLos": false };
const usage$j = { "perTurn": 1, "perEncounter": null, "resource": { "name": "action-surge", "pool": null, "min": 1 } };
const resolution$9 = { "kind": "NO_ROLL" };
const conditions$j = [{ "type": "ACTOR_ALIVE", "reason": "Le lanceur doit etre vivant." }];
const ops$j = { "onResolve": [{ "op": "SpendResource", "name": "action-surge", "amount": 1 }, { "op": "LogEvent", "message": "Fougue utilisee." }] };
const tags$j = ["fighter", "support", "resource"];
const SupportsActionSurge = {
  id: id$j,
  name: name$j,
  summary: summary$j,
  category: category$j,
  actionCost: actionCost$j,
  targeting: targeting$j,
  usage: usage$j,
  resolution: resolution$9,
  conditions: conditions$j,
  ops: ops$j,
  tags: tags$j
};
const id$i = "cast-magic";
const name$i = "Magie";
const summary$i = "Cadre d'action pour lancer un sort ou activer un effet magique.";
const category$i = "support";
const actionCost$i = { "actionType": "action", "movementCost": 0 };
const targeting$i = { "target": "self", "range": { "min": 0, "max": 0, "shape": "SPHERE" }, "maxTargets": 1, "requiresLos": false };
const usage$i = { "perTurn": null, "perEncounter": null, "resource": null };
const conditions$i = [];
const tags$i = ["core-action", "magic"];
const ops$i = { "onResolve": [{ "op": "LogEvent", "message": "Magie: choisissez un sort ou un effet magique disponible." }] };
const SupportsCastMagic = {
  id: id$i,
  name: name$i,
  summary: summary$i,
  category: category$i,
  actionCost: actionCost$i,
  targeting: targeting$i,
  usage: usage$i,
  conditions: conditions$i,
  tags: tags$i,
  ops: ops$i
};
const id$h = "disengage";
const name$h = "Desengagement";
const summary$h = "Votre deplacement ne provoque pas d'attaques d'opportunite jusqu'au debut de votre prochain tour.";
const category$h = "defense";
const actionCost$h = { "actionType": "action", "movementCost": 0 };
const targeting$h = { "target": "self", "range": { "min": 0, "max": 0, "shape": "SPHERE" }, "maxTargets": 1, "requiresLos": false };
const usage$h = { "perTurn": 1, "perEncounter": null, "resource": null };
const conditions$h = [];
const tags$h = ["core-action", "defense", "mobility"];
const ops$h = { "onResolve": [{ "op": "ApplyCondition", "target": "self", "statusId": "disengaging", "durationTurns": 1 }, { "op": "LogEvent", "message": "Desengagement actif: pas d'attaque d'opportunite jusqu'au debut du prochain tour." }] };
const SupportsDisengage = {
  id: id$h,
  name: name$h,
  summary: summary$h,
  category: category$h,
  actionCost: actionCost$h,
  targeting: targeting$h,
  usage: usage$h,
  conditions: conditions$h,
  tags: tags$h,
  ops: ops$h
};
const id$g = "divine-spark-heal";
const name$g = "Etincelle divine (Soin)";
const summary$g = "Conduit divin: restaure des points de vie a une cible alliee.";
const category$g = "support";
const actionCost$g = { "actionType": "action", "movementCost": 0 };
const targeting$g = { "target": "ally", "range": { "min": 0, "max": 9, "shape": "SPHERE" }, "maxTargets": 1, "requiresLos": true };
const usage$g = { "perTurn": null, "perEncounter": null, "resource": { "name": "channel-divinity", "pool": null, "min": 1 } };
const resolution$8 = { "kind": "NO_ROLL" };
const conditions$g = [{ "type": "TARGET_ALIVE", "target": "primary", "reason": "La cible doit avoir des PV restants." }];
const ops$g = { "onResolve": [{ "op": "SpendResource", "name": "channel-divinity", "amount": 1 }] };
const hooks$2 = [{ "when": "beforeApply", "if": [{ "type": "ACTOR_VALUE", "key": "level", "cmp": "LT", "value": 7 }], "apply": [{ "op": "Heal", "target": "primary", "formula": "1d8 + modSAG" }, { "op": "LogEvent", "message": "Etincelle divine (soin, 1d8)." }] }, { "when": "beforeApply", "if": [{ "type": "AND", "all": [{ "type": "ACTOR_VALUE", "key": "level", "cmp": "GTE", "value": 7 }, { "type": "ACTOR_VALUE", "key": "level", "cmp": "LT", "value": 13 }] }], "apply": [{ "op": "Heal", "target": "primary", "formula": "2d8 + modSAG" }, { "op": "LogEvent", "message": "Etincelle divine (soin, 2d8)." }] }, { "when": "beforeApply", "if": [{ "type": "AND", "all": [{ "type": "ACTOR_VALUE", "key": "level", "cmp": "GTE", "value": 13 }, { "type": "ACTOR_VALUE", "key": "level", "cmp": "LT", "value": 18 }] }], "apply": [{ "op": "Heal", "target": "primary", "formula": "3d8 + modSAG" }, { "op": "LogEvent", "message": "Etincelle divine (soin, 3d8)." }] }, { "when": "beforeApply", "if": [{ "type": "ACTOR_VALUE", "key": "level", "cmp": "GTE", "value": 18 }], "apply": [{ "op": "Heal", "target": "primary", "formula": "4d8 + modSAG" }, { "op": "LogEvent", "message": "Etincelle divine (soin, 4d8)." }] }];
const tags$g = ["cleric", "channel-divinity", "support"];
const SupportsDivineSparkHeal = {
  id: id$g,
  name: name$g,
  summary: summary$g,
  category: category$g,
  actionCost: actionCost$g,
  targeting: targeting$g,
  usage: usage$g,
  resolution: resolution$8,
  conditions: conditions$g,
  ops: ops$g,
  hooks: hooks$2,
  tags: tags$g
};
const id$f = "divine-spark-necrotic";
const name$f = "Etincelle divine (Necrotique)";
const summary$f = "Conduit divin: degats necrotiques sur jet de Constitution.";
const category$f = "support";
const actionCost$f = { "actionType": "action", "movementCost": 0 };
const targeting$f = { "target": "hostile", "range": { "min": 0, "max": 9, "shape": "SPHERE" }, "maxTargets": 1, "requiresLos": true };
const usage$f = { "perTurn": null, "perEncounter": null, "resource": { "name": "channel-divinity", "pool": null, "min": 1 } };
const resolution$7 = { "kind": "SAVING_THROW", "save": { "ability": "CON", "dc": 10, "dcFormula": "8 + proficiencyBonus + modSAG" } };
const conditions$f = [{ "type": "TARGET_ALIVE", "target": "primary", "reason": "La cible doit etre vivante." }];
const ops$f = { "onResolve": [{ "op": "SpendResource", "name": "channel-divinity", "amount": 1 }], "onSaveFail": [], "onSaveSuccess": [] };
const hooks$1 = [{ "when": "onOutcome", "if": [{ "type": "AND", "all": [{ "type": "OUTCOME_IS", "value": "SAVE_FAIL" }, { "type": "ACTOR_VALUE", "key": "level", "cmp": "LT", "value": 7 }] }], "apply": [{ "op": "DealDamage", "target": "primary", "formula": "1d8 + modSAG", "damageType": "NECROTIC" }] }, { "when": "onOutcome", "if": [{ "type": "AND", "all": [{ "type": "OUTCOME_IS", "value": "SAVE_SUCCESS" }, { "type": "ACTOR_VALUE", "key": "level", "cmp": "LT", "value": 7 }] }], "apply": [{ "op": "DealDamageScaled", "target": "primary", "formula": "1d8 + modSAG", "damageType": "NECROTIC", "scale": "half" }] }, { "when": "onOutcome", "if": [{ "type": "AND", "all": [{ "type": "OUTCOME_IS", "value": "SAVE_FAIL" }, { "type": "ACTOR_VALUE", "key": "level", "cmp": "GTE", "value": 7 }, { "type": "ACTOR_VALUE", "key": "level", "cmp": "LT", "value": 13 }] }], "apply": [{ "op": "DealDamage", "target": "primary", "formula": "2d8 + modSAG", "damageType": "NECROTIC" }] }, { "when": "onOutcome", "if": [{ "type": "AND", "all": [{ "type": "OUTCOME_IS", "value": "SAVE_SUCCESS" }, { "type": "ACTOR_VALUE", "key": "level", "cmp": "GTE", "value": 7 }, { "type": "ACTOR_VALUE", "key": "level", "cmp": "LT", "value": 13 }] }], "apply": [{ "op": "DealDamageScaled", "target": "primary", "formula": "2d8 + modSAG", "damageType": "NECROTIC", "scale": "half" }] }, { "when": "onOutcome", "if": [{ "type": "AND", "all": [{ "type": "OUTCOME_IS", "value": "SAVE_FAIL" }, { "type": "ACTOR_VALUE", "key": "level", "cmp": "GTE", "value": 13 }, { "type": "ACTOR_VALUE", "key": "level", "cmp": "LT", "value": 18 }] }], "apply": [{ "op": "DealDamage", "target": "primary", "formula": "3d8 + modSAG", "damageType": "NECROTIC" }] }, { "when": "onOutcome", "if": [{ "type": "AND", "all": [{ "type": "OUTCOME_IS", "value": "SAVE_SUCCESS" }, { "type": "ACTOR_VALUE", "key": "level", "cmp": "GTE", "value": 13 }, { "type": "ACTOR_VALUE", "key": "level", "cmp": "LT", "value": 18 }] }], "apply": [{ "op": "DealDamageScaled", "target": "primary", "formula": "3d8 + modSAG", "damageType": "NECROTIC", "scale": "half" }] }, { "when": "onOutcome", "if": [{ "type": "AND", "all": [{ "type": "OUTCOME_IS", "value": "SAVE_FAIL" }, { "type": "ACTOR_VALUE", "key": "level", "cmp": "GTE", "value": 18 }] }], "apply": [{ "op": "DealDamage", "target": "primary", "formula": "4d8 + modSAG", "damageType": "NECROTIC" }] }, { "when": "onOutcome", "if": [{ "type": "AND", "all": [{ "type": "OUTCOME_IS", "value": "SAVE_SUCCESS" }, { "type": "ACTOR_VALUE", "key": "level", "cmp": "GTE", "value": 18 }] }], "apply": [{ "op": "DealDamageScaled", "target": "primary", "formula": "4d8 + modSAG", "damageType": "NECROTIC", "scale": "half" }] }];
const tags$f = ["cleric", "channel-divinity", "support"];
const SupportsDivineSparkNecrotic = {
  id: id$f,
  name: name$f,
  summary: summary$f,
  category: category$f,
  actionCost: actionCost$f,
  targeting: targeting$f,
  usage: usage$f,
  resolution: resolution$7,
  conditions: conditions$f,
  ops: ops$f,
  hooks: hooks$1,
  tags: tags$f
};
const id$e = "divine-spark-radiant";
const name$e = "Etincelle divine (Radiant)";
const summary$e = "Conduit divin: degats radiants sur jet de Constitution.";
const category$e = "support";
const actionCost$e = { "actionType": "action", "movementCost": 0 };
const targeting$e = { "target": "hostile", "range": { "min": 0, "max": 9, "shape": "SPHERE" }, "maxTargets": 1, "requiresLos": true };
const usage$e = { "perTurn": null, "perEncounter": null, "resource": { "name": "channel-divinity", "pool": null, "min": 1 } };
const resolution$6 = { "kind": "SAVING_THROW", "save": { "ability": "CON", "dc": 10, "dcFormula": "8 + proficiencyBonus + modSAG" } };
const conditions$e = [{ "type": "TARGET_ALIVE", "target": "primary", "reason": "La cible doit etre vivante." }];
const ops$e = { "onResolve": [{ "op": "SpendResource", "name": "channel-divinity", "amount": 1 }], "onSaveFail": [], "onSaveSuccess": [] };
const hooks = [{ "when": "onOutcome", "if": [{ "type": "AND", "all": [{ "type": "OUTCOME_IS", "value": "SAVE_FAIL" }, { "type": "ACTOR_VALUE", "key": "level", "cmp": "LT", "value": 7 }] }], "apply": [{ "op": "DealDamage", "target": "primary", "formula": "1d8 + modSAG", "damageType": "RADIANT" }] }, { "when": "onOutcome", "if": [{ "type": "AND", "all": [{ "type": "OUTCOME_IS", "value": "SAVE_SUCCESS" }, { "type": "ACTOR_VALUE", "key": "level", "cmp": "LT", "value": 7 }] }], "apply": [{ "op": "DealDamageScaled", "target": "primary", "formula": "1d8 + modSAG", "damageType": "RADIANT", "scale": "half" }] }, { "when": "onOutcome", "if": [{ "type": "AND", "all": [{ "type": "OUTCOME_IS", "value": "SAVE_FAIL" }, { "type": "ACTOR_VALUE", "key": "level", "cmp": "GTE", "value": 7 }, { "type": "ACTOR_VALUE", "key": "level", "cmp": "LT", "value": 13 }] }], "apply": [{ "op": "DealDamage", "target": "primary", "formula": "2d8 + modSAG", "damageType": "RADIANT" }] }, { "when": "onOutcome", "if": [{ "type": "AND", "all": [{ "type": "OUTCOME_IS", "value": "SAVE_SUCCESS" }, { "type": "ACTOR_VALUE", "key": "level", "cmp": "GTE", "value": 7 }, { "type": "ACTOR_VALUE", "key": "level", "cmp": "LT", "value": 13 }] }], "apply": [{ "op": "DealDamageScaled", "target": "primary", "formula": "2d8 + modSAG", "damageType": "RADIANT", "scale": "half" }] }, { "when": "onOutcome", "if": [{ "type": "AND", "all": [{ "type": "OUTCOME_IS", "value": "SAVE_FAIL" }, { "type": "ACTOR_VALUE", "key": "level", "cmp": "GTE", "value": 13 }, { "type": "ACTOR_VALUE", "key": "level", "cmp": "LT", "value": 18 }] }], "apply": [{ "op": "DealDamage", "target": "primary", "formula": "3d8 + modSAG", "damageType": "RADIANT" }] }, { "when": "onOutcome", "if": [{ "type": "AND", "all": [{ "type": "OUTCOME_IS", "value": "SAVE_SUCCESS" }, { "type": "ACTOR_VALUE", "key": "level", "cmp": "GTE", "value": 13 }, { "type": "ACTOR_VALUE", "key": "level", "cmp": "LT", "value": 18 }] }], "apply": [{ "op": "DealDamageScaled", "target": "primary", "formula": "3d8 + modSAG", "damageType": "RADIANT", "scale": "half" }] }, { "when": "onOutcome", "if": [{ "type": "AND", "all": [{ "type": "OUTCOME_IS", "value": "SAVE_FAIL" }, { "type": "ACTOR_VALUE", "key": "level", "cmp": "GTE", "value": 18 }] }], "apply": [{ "op": "DealDamage", "target": "primary", "formula": "4d8 + modSAG", "damageType": "RADIANT" }] }, { "when": "onOutcome", "if": [{ "type": "AND", "all": [{ "type": "OUTCOME_IS", "value": "SAVE_SUCCESS" }, { "type": "ACTOR_VALUE", "key": "level", "cmp": "GTE", "value": 18 }] }], "apply": [{ "op": "DealDamageScaled", "target": "primary", "formula": "4d8 + modSAG", "damageType": "RADIANT", "scale": "half" }] }];
const tags$e = ["cleric", "channel-divinity", "support"];
const SupportsDivineSparkRadiant = {
  id: id$e,
  name: name$e,
  summary: summary$e,
  category: category$e,
  actionCost: actionCost$e,
  targeting: targeting$e,
  usage: usage$e,
  resolution: resolution$6,
  conditions: conditions$e,
  ops: ops$e,
  hooks,
  tags: tags$e
};
const id$d = "dodge";
const name$d = "Esquive";
const summary$d = "Jusqu'au debut de votre prochain tour, les attaques contre vous ont le desavantage.";
const category$d = "defense";
const actionCost$d = { "actionType": "action", "movementCost": 0 };
const targeting$d = { "target": "self", "range": { "min": 0, "max": 0, "shape": "SPHERE" }, "maxTargets": 1, "requiresLos": false };
const usage$d = { "perTurn": 1, "perEncounter": null, "resource": null };
const conditions$d = [];
const tags$d = ["core-action", "defense"];
const ops$d = { "onResolve": [{ "op": "ApplyCondition", "target": "self", "statusId": "dodge", "durationTurns": 1 }, { "op": "LogEvent", "message": "Esquive active: desavantage contre vos assaillants jusqu'au debut de votre prochain tour." }] };
const SupportsDodge = {
  id: id$d,
  name: name$d,
  summary: summary$d,
  category: category$d,
  actionCost: actionCost$d,
  targeting: targeting$d,
  usage: usage$d,
  conditions: conditions$d,
  tags: tags$d,
  ops: ops$d
};
const id$c = "help";
const name$c = "Soutien";
const summary$c = "Aidez une creature proche ou prodiguez une aide immediate.";
const category$c = "support";
const actionCost$c = { "actionType": "action", "movementCost": 0 };
const targeting$c = { "target": "ally", "range": { "min": 0, "max": 1.5, "shape": "SPHERE" }, "maxTargets": 1, "requiresLos": true };
const usage$c = { "perTurn": null, "perEncounter": null, "resource": null };
const conditions$c = [{ "type": "TARGET_ALIVE", "target": "primary", "reason": "L'allie doit etre actif." }];
const tags$c = ["core-action", "support", "first-aid"];
const ops$c = { "onResolve": [{ "op": "Heal", "target": "primary", "formula": "1" }, { "op": "ApplyCondition", "target": "primary", "statusId": "helped", "durationTurns": 1 }, { "op": "LogEvent", "message": "Soutien: assistance apportee a la cible." }] };
const SupportsHelp = {
  id: id$c,
  name: name$c,
  summary: summary$c,
  category: category$c,
  actionCost: actionCost$c,
  targeting: targeting$c,
  usage: usage$c,
  conditions: conditions$c,
  tags: tags$c,
  ops: ops$c
};
const id$b = "hide";
const name$b = "Furtivite";
const summary$b = "Effectue un jet de DEX (Discretion) pour tenter de vous dissimuler.";
const category$b = "support";
const actionCost$b = { "actionType": "action", "movementCost": 0 };
const targeting$b = { "target": "self", "range": { "min": 0, "max": 0, "shape": "SPHERE" }, "maxTargets": 1, "requiresLos": false };
const usage$b = { "perTurn": null, "perEncounter": null, "resource": null };
const resolution$5 = { "kind": "ABILITY_CHECK", "check": { "ability": "DEX", "dc": 12 } };
const conditions$b = [];
const tags$b = ["core-action", "check", "stealth"];
const ops$b = { "onResolve": [{ "op": "LogEvent", "message": "Furtivite: tentative de dissimulation." }], "onHit": [{ "op": "ApplyCondition", "target": "self", "statusId": "hidden", "durationTurns": 1 }, { "op": "LogEvent", "message": "Furtivite reussie: vous etes cache pour un court instant." }], "onMiss": [{ "op": "LogEvent", "message": "Furtivite echouee." }] };
const SupportsHide = {
  id: id$b,
  name: name$b,
  summary: summary$b,
  category: category$b,
  actionCost: actionCost$b,
  targeting: targeting$b,
  usage: usage$b,
  resolution: resolution$5,
  conditions: conditions$b,
  tags: tags$b,
  ops: ops$b
};
const id$a = "indomitable";
const name$a = "Inflexible";
const summary$a = "Depense une charge d Inflexible pour representer la relance defensive.";
const category$a = "support";
const actionCost$a = { "actionType": "free", "movementCost": 0 };
const targeting$a = { "target": "self", "range": { "min": 0, "max": 0, "shape": "SPHERE" }, "maxTargets": 1, "requiresLos": false };
const usage$a = { "perTurn": null, "perEncounter": null, "resource": { "name": "indomitable", "pool": null, "min": 1 } };
const resolution$4 = { "kind": "NO_ROLL" };
const conditions$a = [{ "type": "ACTOR_ALIVE", "reason": "Le lanceur doit etre vivant." }];
const ops$a = { "onResolve": [{ "op": "SpendResource", "name": "indomitable", "amount": 1 }, { "op": "LogEvent", "message": "Inflexible utilisee." }] };
const tags$a = ["fighter", "support", "resource"];
const SupportsIndomitable = {
  id: id$a,
  name: name$a,
  summary: summary$a,
  category: category$a,
  actionCost: actionCost$a,
  targeting: targeting$a,
  usage: usage$a,
  resolution: resolution$4,
  conditions: conditions$a,
  ops: ops$a,
  tags: tags$a
};
const id$9 = "influence";
const name$9 = "Influence";
const summary$9 = "Effectue un jet de Charisme pour influer sur une creature.";
const category$9 = "support";
const actionCost$9 = { "actionType": "action", "movementCost": 0 };
const targeting$9 = { "target": "hostile", "range": { "min": 0, "max": 9, "shape": "SPHERE" }, "maxTargets": 1, "requiresLos": true };
const usage$9 = { "perTurn": null, "perEncounter": null, "resource": null };
const resolution$3 = { "kind": "ABILITY_CHECK", "check": { "ability": "CHA", "dc": 12 } };
const conditions$9 = [{ "type": "TARGET_ALIVE", "target": "primary", "reason": "La cible doit etre consciente et active." }];
const tags$9 = ["core-action", "check", "social"];
const ops$9 = { "onResolve": [{ "op": "LogEvent", "message": "Influence: tentative de pression sociale." }], "onHit": [{ "op": "LogEvent", "message": "Influence reussie." }], "onMiss": [{ "op": "LogEvent", "message": "Influence echouee." }] };
const SupportsInfluence = {
  id: id$9,
  name: name$9,
  summary: summary$9,
  category: category$9,
  actionCost: actionCost$9,
  targeting: targeting$9,
  usage: usage$9,
  resolution: resolution$3,
  conditions: conditions$9,
  tags: tags$9,
  ops: ops$9
};
const id$8 = "observe";
const name$8 = "Observation";
const summary$8 = "Effectue un jet de Sagesse pour observer votre environnement.";
const category$8 = "support";
const actionCost$8 = { "actionType": "action", "movementCost": 0 };
const targeting$8 = { "target": "self", "range": { "min": 0, "max": 0, "shape": "SPHERE" }, "maxTargets": 1, "requiresLos": false };
const usage$8 = { "perTurn": null, "perEncounter": null, "resource": null };
const resolution$2 = { "kind": "ABILITY_CHECK", "check": { "ability": "SAG", "dc": 12 } };
const conditions$8 = [];
const tags$8 = ["core-action", "check", "wisdom"];
const ops$8 = { "onResolve": [{ "op": "LogEvent", "message": "Observation: vous scrutez la zone." }], "onHit": [{ "op": "LogEvent", "message": "Observation reussie." }], "onMiss": [{ "op": "LogEvent", "message": "Observation echouee." }] };
const SupportsObserve = {
  id: id$8,
  name: name$8,
  summary: summary$8,
  category: category$8,
  actionCost: actionCost$8,
  targeting: targeting$8,
  usage: usage$8,
  resolution: resolution$2,
  conditions: conditions$8,
  tags: tags$8,
  ops: ops$8
};
const id$7 = "ready-action";
const name$7 = "Intention";
const summary$7 = "Vous vous preparez a reagir a un declencheur defini.";
const category$7 = "defense";
const actionCost$7 = { "actionType": "action", "movementCost": 0 };
const targeting$7 = { "target": "self", "range": { "min": 0, "max": 0, "shape": "SPHERE" }, "maxTargets": 1, "requiresLos": false };
const usage$7 = { "perTurn": 1, "perEncounter": null, "resource": null };
const conditions$7 = [];
const tags$7 = ["core-action", "ready"];
const ops$7 = { "onResolve": [{ "op": "ApplyCondition", "target": "self", "statusId": "readying", "durationTurns": 1 }, { "op": "LogEvent", "message": "Intention: vous etes pret a reagir au declencheur choisi." }] };
const SupportsReadyAction = {
  id: id$7,
  name: name$7,
  summary: summary$7,
  category: category$7,
  actionCost: actionCost$7,
  targeting: targeting$7,
  usage: usage$7,
  conditions: conditions$7,
  tags: tags$7,
  ops: ops$7
};
const id$6 = "second-wind";
const name$6 = "Second souffle";
const summary$6 = "Restaure une partie des PV en bonus action.";
const category$6 = "support";
const actionCost$6 = { "actionType": "bonus", "movementCost": 0 };
const targeting$6 = { "target": "self", "range": { "min": 0, "max": 0, "shape": "SPHERE" }, "maxTargets": 1, "requiresLos": false };
const usage$6 = { "perTurn": null, "perEncounter": 1, "resource": null };
const conditions$6 = [{ "type": "STAT_BELOW_PERCENT", "who": "self", "stat": "hp", "percentMax": 0.75, "reason": "Economiser tant que les PV sont hauts." }];
const aiHints = { "priority": "survive", "successLog": "Second souffle declenche.", "failureLog": "PV trop hauts." };
const tags$6 = ["soin", "defense", "survie"];
const ops$6 = { "onResolve": [{ "op": "Heal", "target": "self", "formula": "1d10 + level" }, { "op": "GrantTempHp", "target": "self", "amount": 2 }, { "op": "LogEvent", "message": "Second souffle: soigne 1d10 + niveau." }] };
const SupportsSecondWind = {
  id: id$6,
  name: name$6,
  summary: summary$6,
  category: category$6,
  actionCost: actionCost$6,
  targeting: targeting$6,
  usage: usage$6,
  conditions: conditions$6,
  aiHints,
  tags: tags$6,
  ops: ops$6
};
const id$5 = "study";
const name$5 = "Etude";
const summary$5 = "Effectue un jet d'Intelligence pour analyser une situation.";
const category$5 = "support";
const actionCost$5 = { "actionType": "action", "movementCost": 0 };
const targeting$5 = { "target": "self", "range": { "min": 0, "max": 0, "shape": "SPHERE" }, "maxTargets": 1, "requiresLos": false };
const usage$5 = { "perTurn": null, "perEncounter": null, "resource": null };
const resolution$1 = { "kind": "ABILITY_CHECK", "check": { "ability": "INT", "dc": 12 } };
const conditions$5 = [];
const tags$5 = ["core-action", "check", "intelligence"];
const ops$5 = { "onResolve": [{ "op": "LogEvent", "message": "Etude: tentative d'analyse en cours." }], "onHit": [{ "op": "LogEvent", "message": "Etude reussie." }], "onMiss": [{ "op": "LogEvent", "message": "Etude echouee." }] };
const SupportsStudy = {
  id: id$5,
  name: name$5,
  summary: summary$5,
  category: category$5,
  actionCost: actionCost$5,
  targeting: targeting$5,
  usage: usage$5,
  resolution: resolution$1,
  conditions: conditions$5,
  tags: tags$5,
  ops: ops$5
};
const id$4 = "turn-undead";
const name$4 = "Renvoi des morts-vivants";
const summary$4 = "Conduit divin: repousse les morts-vivants autour de vous.";
const category$4 = "control";
const actionCost$4 = { "actionType": "action", "movementCost": 0 };
const targeting$4 = { "target": "hostile", "range": { "min": 0, "max": 9, "shape": "SPHERE" }, "maxTargets": 8, "requiresLos": true };
const usage$4 = { "perTurn": null, "perEncounter": null, "resource": { "name": "channel-divinity", "pool": null, "min": 1 } };
const resolution = { "kind": "SAVING_THROW", "save": { "ability": "SAG", "dc": 10, "dcFormula": "8 + proficiencyBonus + modSAG" } };
const conditions$4 = [{ "type": "TARGET_ALIVE", "target": "primary", "reason": "La cible doit etre vivante." }, { "type": "TARGET_CREATURE_TYPE_IS", "value": "UNDEAD", "reason": "Renvoi ne cible que les morts-vivants." }];
const ops$4 = { "onResolve": [{ "op": "SpendResource", "name": "channel-divinity", "amount": 1 }, { "op": "LogEvent", "message": "Renvoi des morts-vivants." }], "onSaveFail": [{ "op": "ApplyCondition", "target": "primary", "statusId": "FRIGHTENED", "durationTurns": 10 }, { "op": "ApplyCondition", "target": "primary", "statusId": "INCAPACITATED", "durationTurns": 10 }] };
const tags$4 = ["cleric", "channel-divinity", "control"];
const SupportsTurnUndead = {
  id: id$4,
  name: name$4,
  summary: summary$4,
  category: category$4,
  actionCost: actionCost$4,
  targeting: targeting$4,
  usage: usage$4,
  resolution,
  conditions: conditions$4,
  ops: ops$4,
  tags: tags$4
};
const id$3 = "use-item";
const name$3 = "Utilisation";
const summary$3 = "Utilise un objet non magique ou une interaction utilitaire.";
const category$3 = "item";
const actionCost$3 = { "actionType": "action", "movementCost": 0 };
const targeting$3 = { "target": "self", "range": { "min": 0, "max": 0, "shape": "SPHERE" }, "maxTargets": 1, "requiresLos": false };
const usage$3 = { "perTurn": null, "perEncounter": null, "resource": null };
const conditions$3 = [];
const tags$3 = ["core-action", "item", "utility"];
const ops$3 = { "onResolve": [{ "op": "LogEvent", "message": "Utilisation: action d'objet executee." }] };
const SupportsUseItem = {
  id: id$3,
  name: name$3,
  summary: summary$3,
  category: category$3,
  actionCost: actionCost$3,
  targeting: targeting$3,
  usage: usage$3,
  conditions: conditions$3,
  tags: tags$3,
  ops: ops$3
};
const id$2 = "torch-toggle";
const name$2 = "Allumer la torche";
const summary$2 = "Allume ou eteint la torche du joueur pour eclairer autour de lui.";
const category$2 = "item";
const actionCost$2 = { "actionType": "bonus", "movementCost": 0 };
const targeting$2 = { "target": "self", "range": { "min": 0, "max": 0, "shape": "SPHERE" }, "maxTargets": 1, "requiresLos": false };
const usage$2 = { "perTurn": null, "perEncounter": null, "resource": { "name": "torch", "pool": "gear", "min": 1 } };
const conditions$2 = [{ "type": "PHASE_IS", "value": "player", "reason": "Tour joueur requis." }, { "type": "RESOURCE_AT_LEAST", "resource": "torch", "pool": "gear", "value": 1, "reason": "Besoin d'une torche." }];
const tags$2 = ["lumiere", "objet", "utilitaire"];
const ops$2 = { "onResolve": [{ "op": "ToggleTorch" }, { "op": "LogEvent", "message": "Torche: etat bascule." }] };
const ItemsTorchToggle = {
  id: id$2,
  name: name$2,
  summary: summary$2,
  category: category$2,
  actionCost: actionCost$2,
  targeting: targeting$2,
  usage: usage$2,
  conditions: conditions$2,
  tags: tags$2,
  ops: ops$2
};
const ACTION_MODULES = {
  "../spells/aid.json": aid,
  "../spells/arcane-bolt.json": arcaneBolt,
  "../spells/aura-of-purity.json": auraOfPurity,
  "../spells/beacon-of-hope.json": beaconOfHope,
  "../spells/greater-restoration.json": greaterRestoration,
  "../spells/heroism.json": heroism,
  "../spells/minor-ward.json": minorWard,
  "../spells/rarys-telepathic-bond.json": rarysTelepathicBond,
  "../spells/rayon-de-feu.json": rayonDeFeu,
  "../spells/resilient-sphere.json": resilientSphere,
  "../spells/sanctuary.json": sanctuary,
  "../spells/sending.json": sending,
  "../spells/vague-ardente.json": vagueArdente,
  "../spells/warding-bond.json": wardingBond,
  "../attacks/bow-shot.json": AttacksBowShot,
  "../attacks/melee-strike.json": AttacksMeleeStrike,
  "../attacks/throw-dagger.json": AttacksThrowDagger,
  "../moves/dash.json": MovesDash,
  "../moves/move.json": MovesMove,
  "../supports/action-surge.json": SupportsActionSurge,
  "../supports/cast-magic.json": SupportsCastMagic,
  "../supports/disengage.json": SupportsDisengage,
  "../supports/divine-spark-heal.json": SupportsDivineSparkHeal,
  "../supports/divine-spark-necrotic.json": SupportsDivineSparkNecrotic,
  "../supports/divine-spark-radiant.json": SupportsDivineSparkRadiant,
  "../supports/dodge.json": SupportsDodge,
  "../supports/help.json": SupportsHelp,
  "../supports/hide.json": SupportsHide,
  "../supports/indomitable.json": SupportsIndomitable,
  "../supports/influence.json": SupportsInfluence,
  "../supports/observe.json": SupportsObserve,
  "../supports/ready-action.json": SupportsReadyAction,
  "../supports/second-wind.json": SupportsSecondWind,
  "../supports/study.json": SupportsStudy,
  "../supports/turn-undead.json": SupportsTurnUndead,
  "../supports/use-item.json": SupportsUseItem,
  "../items/torch-toggle.json": ItemsTorchToggle
};
function loadActionTypesFromIndex() {
  const indexed = Array.isArray(actionsIndex.actions) ? actionsIndex.actions : [];
  const loaded = [];
  for (const path2 of indexed) {
    const mod = ACTION_MODULES[path2];
    if (mod) {
      loaded.push(mod);
    } else {
      console.warn("[actions] Action path missing in bundle:", path2);
    }
  }
  if (loaded.length === 0) {
    console.warn("[actions] No actions loaded from index.json");
  }
  return loaded;
}
const moveTypes = ["./types/walk.json", "./types/sprint.json"];
const moveTypesIndex = {
  moveTypes
};
const id$1 = "move-walk";
const name$1 = "Marcher";
const summary$1 = "Deplacement standard sans depenser d'action.";
const category$1 = "movement";
const actionCost$1 = { "actionType": "free", "movementCost": 0 };
const targeting$1 = { "target": "self", "range": { "min": 0, "max": 0, "shape": "SPHERE" }, "maxTargets": 1, "requiresLos": false };
const usage$1 = { "perTurn": null, "perEncounter": null, "resource": null };
const conditions$1 = [];
const movement$1 = { "pathLimitMultiplier": 1 };
const tags$1 = ["movement", "move-type"];
const ops$1 = { "onResolve": [{ "op": "LogEvent", "message": "Mode marche: selectionnez un trajet." }] };
const walkMoveType = {
  id: id$1,
  name: name$1,
  summary: summary$1,
  category: category$1,
  actionCost: actionCost$1,
  targeting: targeting$1,
  usage: usage$1,
  conditions: conditions$1,
  movement: movement$1,
  tags: tags$1,
  ops: ops$1
};
const id = "move-sprint";
const name = "Sprint";
const summary = "Depense 1 action pour doubler le deplacement.";
const category = "movement";
const actionCost = { "actionType": "action", "movementCost": 0 };
const targeting = { "target": "self", "range": { "min": 0, "max": 0, "shape": "SPHERE" }, "maxTargets": 1, "requiresLos": false };
const usage = { "perTurn": null, "perEncounter": null, "resource": null };
const conditions = [];
const movement = { "pathLimitMultiplier": 2 };
const tags = ["movement", "move-type"];
const ops = { "onResolve": [{ "op": "LogEvent", "message": "Sprint: deplacement double pour ce tour." }] };
const sprintMoveType = {
  id,
  name,
  summary,
  category,
  actionCost,
  targeting,
  usage,
  conditions,
  movement,
  tags,
  ops
};
function rollDie(sides, count2 = 1) {
  const rolls = [];
  for (let i2 = 0; i2 < count2; i2++) {
    rolls.push(1 + Math.floor(Math.random() * sides));
  }
  const total = rolls.reduce((acc, n2) => acc + n2, 0);
  return { rolls, total };
}
function rollAttack(bonus, mode = "normal", critRange = 20) {
  if (mode === "advantage") {
    const a2 = rollDie(20);
    const b2 = rollDie(20);
    const chosen = Math.max(a2.total, b2.total);
    return {
      d20: { rolls: [a2.total, b2.total], total: chosen },
      bonus,
      total: chosen + bonus,
      mode,
      isCrit: chosen >= critRange
    };
  }
  if (mode === "disadvantage") {
    const a2 = rollDie(20);
    const b2 = rollDie(20);
    const chosen = Math.min(a2.total, b2.total);
    return {
      d20: { rolls: [a2.total, b2.total], total: chosen },
      bonus,
      total: chosen + bonus,
      mode,
      isCrit: chosen >= critRange
    };
  }
  const single = rollDie(20);
  return {
    d20: single,
    bonus,
    total: single.total + bonus,
    mode,
    isCrit: single.total >= critRange
  };
}
function parseFormula(formula) {
  const terms = [];
  const cleaned = formula.replace(/\s+/g, "");
  const tokens = cleaned.split(/(?=[+-])/);
  for (const raw of tokens) {
    if (!raw) continue;
    const sign2 = raw.startsWith("-") ? -1 : 1;
    const token = raw.replace(/^[+-]/, "");
    const diceMatch = token.match(/^(\d*)d(\d+)$/i);
    if (diceMatch) {
      const count2 = diceMatch[1] ? parseInt(diceMatch[1], 10) : 1;
      const sides = parseInt(diceMatch[2], 10);
      terms.push({ diceCount: sign2 * count2, diceSides: sides, modifier: 0 });
      continue;
    }
    const flat = parseInt(token, 10);
    if (!Number.isNaN(flat)) {
      terms.push({ diceCount: 0, diceSides: 0, modifier: sign2 * flat });
    }
  }
  return terms;
}
function rollDamage(formula, opts) {
  const isCrit = Boolean(opts == null ? void 0 : opts.isCrit);
  const critRule = (opts == null ? void 0 : opts.critRule) ?? "double-dice";
  const rerollLow = opts == null ? void 0 : opts.rerollLow;
  const terms = parseFormula(formula);
  const dice = [];
  let flatModifier = 0;
  for (const term of terms) {
    if (term.diceCount !== 0 && term.diceSides > 0) {
      const count2 = Math.abs(term.diceCount);
      const totalDice = isCrit && critRule === "double-dice" ? count2 * 2 : count2;
      const roll = rerollLow && Number.isFinite(rerollLow.lte) ? (() => {
        const rolls = [];
        for (let i2 = 0; i2 < totalDice; i2++) {
          let current = rollDie(term.diceSides).total;
          if (current <= rerollLow.lte) {
            current = rollDie(term.diceSides).total;
          }
          rolls.push(current);
        }
        return { rolls, total: rolls.reduce((acc, n2) => acc + n2, 0) };
      })() : rollDie(term.diceSides, totalDice);
      dice.push(term.diceCount < 0 ? { rolls: roll.rolls, total: -roll.total } : roll);
    } else {
      flatModifier += term.modifier;
    }
  }
  let diceSum = dice.reduce((acc, r2) => acc + r2.total, 0);
  let total = diceSum + flatModifier;
  if (isCrit && critRule === "double-total") {
    total *= 2;
  }
  return {
    dice,
    flatModifier,
    total,
    formula,
    isCrit
  };
}
function coordKey(x2, y2) {
  return `${x2},${y2}`;
}
function gridDistance(a2, b2) {
  return Math.max(Math.abs(a2.x - b2.x), Math.abs(a2.y - b2.y));
}
class MinHeap {
  constructor() {
    __publicField(this, "items", []);
  }
  get size() {
    return this.items.length;
  }
  push(value2, score) {
    this.items.push({ value: value2, score });
    this.bubbleUp(this.items.length - 1);
  }
  pop() {
    if (this.items.length === 0) return null;
    const root = this.items[0];
    const last = this.items.pop();
    if (this.items.length > 0) {
      this.items[0] = last;
      this.bubbleDown(0);
    }
    return root.value;
  }
  bubbleUp(index) {
    let idx = index;
    while (idx > 0) {
      const parent = Math.floor((idx - 1) / 2);
      if (this.items[idx].score >= this.items[parent].score) break;
      [this.items[idx], this.items[parent]] = [this.items[parent], this.items[idx]];
      idx = parent;
    }
  }
  bubbleDown(index) {
    let idx = index;
    const length = this.items.length;
    while (true) {
      const left = idx * 2 + 1;
      const right = idx * 2 + 2;
      let smallest = idx;
      if (left < length && this.items[left].score < this.items[smallest].score) {
        smallest = left;
      }
      if (right < length && this.items[right].score < this.items[smallest].score) {
        smallest = right;
      }
      if (smallest === idx) break;
      [this.items[idx], this.items[smallest]] = [this.items[smallest], this.items[idx]];
      idx = smallest;
    }
  }
}
function getMovementProfile(entity) {
  if (entity.movementProfile) {
    return {
      ...entity.movementProfile,
      speed: metersToCells(entity.movementProfile.speed)
    };
  }
  if (typeof entity.moveRange === "number") {
    return {
      type: "ground",
      speed: metersToCells(entity.moveRange),
      directions: 8,
      canPassThroughWalls: false,
      canPassThroughEntities: false,
      canStopOnOccupiedTile: false
    };
  }
  return null;
}
function canEnterCell(entity, profile, x2, y2, occupiedByTokens, allowTargetOccupied, target, targetCells, blockedCells, playableCells, grid, heightMap, floorIds, activeLevel) {
  const cols = (grid == null ? void 0 : grid.cols) ?? GRID_COLS;
  const rows = (grid == null ? void 0 : grid.rows) ?? GRID_ROWS;
  const entityCells = getTokenOccupiedCellsAt(entity, { x: x2, y: y2 });
  if (!entityCells.length) return false;
  for (const cell of entityCells) {
    if (!isCellInsideGrid(cell.x, cell.y, cols, rows)) return false;
    if (heightMap && heightMap.length > 0 && typeof activeLevel === "number") {
      const baseHeight = getHeightAtGrid(heightMap, cols, rows, cell.x, cell.y);
      if (baseHeight !== activeLevel) {
        return false;
      }
    }
    if (floorIds && floorIds.length > 0) {
      const idx = cell.y * cols + cell.x;
      if (idx >= 0 && idx < floorIds.length) {
        const floorId = floorIds[idx];
        const mat = getFloorMaterial(floorId);
        if ((mat == null ? void 0 : mat.passable) === false) return false;
      }
    }
    const cellKey = coordKey(cell.x, cell.y);
    if (playableCells && playableCells.size > 0 && !playableCells.has(cellKey)) {
      return false;
    }
    if (blockedCells == null ? void 0 : blockedCells.has(cellKey)) {
      if (!(profile == null ? void 0 : profile.canPassThroughWalls)) {
        return false;
      }
    }
  }
  const isTarget = x2 === target.x && y2 === target.y;
  const overlaps = entityCells.some((c2) => occupiedByTokens.has(coordKey(c2.x, c2.y)));
  if (!overlaps) {
    return true;
  }
  if (isTarget && allowTargetOccupied) {
    if (!targetCells || targetCells.size === 0) return true;
    const allOverlapsAreTarget = entityCells.every((c2) => {
      const key2 = coordKey(c2.x, c2.y);
      return !occupiedByTokens.has(key2) || targetCells.has(key2);
    });
    if (allOverlapsAreTarget) return true;
  }
  if (!profile) {
    return false;
  }
  if (profile.canPassThroughEntities) {
    if (isTarget && profile.canStopOnOccupiedTile === false) {
      return false;
    }
    return true;
  }
  return false;
}
function getMoveCostForCell(x2, y2, cols, rows, floorIds) {
  if (!floorIds || floorIds.length === 0) return 1;
  const idx = y2 * cols + x2;
  if (idx < 0 || idx >= floorIds.length) return 1;
  const mat = getFloorMaterial(floorIds[idx]);
  const cost = Number((mat == null ? void 0 : mat.moveCost) ?? 1);
  if (!Number.isFinite(cost) || cost <= 0) return 1;
  return cost;
}
function computePathTowards(entity, target, tokens, options) {
  var _a, _b;
  const profile = getMovementProfile(entity);
  const maxCost = profile && profile.speed > 0 ? Math.min(options.maxDistance, profile.speed) : options.maxDistance;
  const start = { x: entity.x, y: entity.y };
  if (start.x === target.x && start.y === target.y) {
    return [];
  }
  const occupiedByTokens = /* @__PURE__ */ new Set();
  for (const t2 of tokens) {
    if (t2.id === entity.id || t2.hp <= 0) continue;
    for (const c2 of getTokenOccupiedCells(t2)) {
      occupiedByTokens.add(coordKey(c2.x, c2.y));
    }
  }
  const targetCellsSet = options.targetCells && options.targetCells.length > 0 ? new Set(options.targetCells.map((c2) => coordKey(c2.x, c2.y))) : null;
  const visited = /* @__PURE__ */ new Set();
  const parents = /* @__PURE__ */ new Map();
  const costs = /* @__PURE__ */ new Map();
  const steps = /* @__PURE__ */ new Map();
  const open = new MinHeap();
  const startKey = coordKey(start.x, start.y);
  parents.set(startKey, null);
  costs.set(startKey, 0);
  steps.set(startKey, 0);
  open.push(start, 0);
  let foundTargetKey = null;
  const allowDiagonals = (profile == null ? void 0 : profile.directions) !== 4;
  const dirs = allowDiagonals ? [
    { x: 1, y: 0 },
    { x: -1, y: 0 },
    { x: 0, y: 1 },
    { x: 0, y: -1 },
    { x: 1, y: 1 },
    { x: 1, y: -1 },
    { x: -1, y: 1 },
    { x: -1, y: -1 }
  ] : [
    { x: 1, y: 0 },
    { x: -1, y: 0 },
    { x: 0, y: 1 },
    { x: 0, y: -1 }
  ];
  const cols = ((_a = options.grid) == null ? void 0 : _a.cols) ?? GRID_COLS;
  const rows = ((_b = options.grid) == null ? void 0 : _b.rows) ?? GRID_ROWS;
  while (open.size > 0) {
    const current = open.pop();
    const currentKey = coordKey(current.x, current.y);
    const currentCost = costs.get(currentKey) ?? 0;
    if (visited.has(currentKey)) continue;
    visited.add(currentKey);
    if (currentCost > maxCost) {
      continue;
    }
    for (const dir of dirs) {
      const nx = current.x + dir.x;
      const ny = current.y + dir.y;
      const key2 = coordKey(nx, ny);
      if (!canEnterCell(
        entity,
        profile,
        nx,
        ny,
        occupiedByTokens,
        options.allowTargetOccupied ?? false,
        target,
        targetCellsSet,
        options.blockedCells ?? null,
        options.playableCells ?? null,
        options.grid ?? null,
        options.heightMap ?? null,
        options.floorIds ?? null,
        options.activeLevel ?? null
      )) {
        continue;
      }
      if (options.wallEdges && isEdgeBlockedForMovement(current, { x: nx, y: ny }, options.wallEdges)) {
        continue;
      }
      const isDiagonal = dir.x !== 0 && dir.y !== 0;
      if (isDiagonal) {
        const sideAOk = canEnterCell(
          entity,
          profile,
          current.x + dir.x,
          current.y,
          occupiedByTokens,
          false,
          target,
          targetCellsSet,
          options.blockedCells ?? null,
          options.playableCells ?? null,
          options.grid ?? null,
          options.heightMap ?? null,
          options.floorIds ?? null,
          options.activeLevel ?? null
        );
        const sideBOk = canEnterCell(
          entity,
          profile,
          current.x,
          current.y + dir.y,
          occupiedByTokens,
          false,
          target,
          targetCellsSet,
          options.blockedCells ?? null,
          options.playableCells ?? null,
          options.grid ?? null,
          options.heightMap ?? null,
          options.floorIds ?? null,
          options.activeLevel ?? null
        );
        if (!sideAOk || !sideBOk) continue;
        if (options.wallEdges) {
          const stepX = { x: current.x + dir.x, y: current.y };
          const stepY = { x: current.x, y: current.y + dir.y };
          const diagonal = { x: nx, y: ny };
          if (isEdgeBlockedForMovement(current, stepX, options.wallEdges)) {
            continue;
          }
          if (isEdgeBlockedForMovement(current, stepY, options.wallEdges)) {
            continue;
          }
          if (isEdgeBlockedForMovement(stepX, diagonal, options.wallEdges)) {
            continue;
          }
          if (isEdgeBlockedForMovement(stepY, diagonal, options.wallEdges)) {
            continue;
          }
        }
      }
      const stepCost = getMoveCostForCell(nx, ny, cols, rows, options.floorIds ?? null);
      const newCost = currentCost + stepCost;
      if (newCost > maxCost) continue;
      const prevCost = costs.get(key2);
      if (prevCost === void 0 || newCost < prevCost) {
        parents.set(key2, currentKey);
        costs.set(key2, newCost);
        steps.set(key2, (steps.get(currentKey) ?? 0) + 1);
        const node = { x: nx, y: ny };
        open.push(node, newCost);
      }
      if (nx === target.x && ny === target.y) {
        foundTargetKey = key2;
        break;
      }
    }
    if (foundTargetKey) break;
  }
  let endKey = foundTargetKey;
  if (!endKey) {
    let bestKey = null;
    let bestDist = Number.POSITIVE_INFINITY;
    let bestCost = Number.POSITIVE_INFINITY;
    for (const key2 of costs.keys()) {
      const [sx, sy] = key2.split(",").map(Number);
      const d2 = gridDistance({ x: sx, y: sy }, target);
      const costFromStart = costs.get(key2) ?? 0;
      if (costFromStart === 0) continue;
      if (costFromStart > maxCost) continue;
      if (d2 < bestDist || d2 === bestDist && costFromStart < bestCost) {
        bestDist = d2;
        bestCost = costFromStart;
        bestKey = key2;
      }
    }
    if (!bestKey) {
      return [];
    }
    endKey = bestKey;
  }
  const pathReversed = [];
  let cursor = endKey;
  while (cursor) {
    const [x2, y2] = cursor.split(",").map(Number);
    pathReversed.push({ x: x2, y: y2 });
    if (cursor === startKey) break;
    cursor = parents.get(cursor) ?? null;
  }
  const path2 = pathReversed.reverse();
  return path2;
}
function compileActionPlan(params) {
  const hooks2 = params.action.hooks ?? [];
  const reactionWindows = params.action.reactionWindows ?? [];
  return {
    action: params.action,
    actor: params.actor,
    target: params.target ?? null,
    hooks: hooks2,
    reactionWindows
  };
}
function beginTransaction(state) {
  var _a;
  return {
    state: {
      ...state,
      actor: { ...state.actor },
      player: { ...state.player },
      enemies: state.enemies.map((enemy) => ({ ...enemy })),
      effects: state.effects.map((effect) => ({ ...effect })),
      targeting: state.targeting ? {
        targets: ((_a = state.targeting.targets) == null ? void 0 : _a.map((target) => ({ ...target }))) ?? [],
        locked: state.targeting.locked ?? false
      } : void 0,
      targetingConfig: state.targetingConfig ? { ...state.targetingConfig } : void 0
    },
    logs: []
  };
}
function logTransaction(tx, message, onLog) {
  tx.logs.push(message);
  onLog == null ? void 0 : onLog(message);
}
function pickTarget(state, selector, explicitTarget) {
  if (selector === "self") return state.actor;
  if (explicitTarget && explicitTarget.kind === "token") {
    const targetId = explicitTarget.token.id;
    if (state.player.id === targetId) return state.player;
    return state.enemies.find((enemy) => enemy.id === targetId) ?? null;
  }
  return null;
}
function ensureDefenseArray(token, mode) {
  token.defenses = token.defenses ?? {};
  token.defenses.damage = token.defenses.damage ?? {};
  const key2 = mode === "resistance" ? "resist" : mode === "vulnerability" ? "vulnerable" : "immune";
  token.defenses.damage[key2] = token.defenses.damage[key2] ?? [];
  return token.defenses.damage[key2];
}
function moveTokenByDelta(token, dx, dy) {
  token.x = (token.x ?? 0) + dx;
  token.y = (token.y ?? 0) + dy;
}
function resolveTokenById(state, token) {
  if (!(token == null ? void 0 : token.id)) return null;
  if (state.actor.id === token.id) return state.actor;
  if (state.player.id === token.id) return state.player;
  return state.enemies.find((enemy) => enemy.id === token.id) ?? null;
}
function getConcentrationSourceId(token) {
  if (!(token == null ? void 0 : token.concentration)) return null;
  if (typeof token.concentration === "object") {
    return token.concentration.sourceId ?? token.id ?? null;
  }
  return token.id ?? null;
}
function linkStatusToConcentration(state, status) {
  var _a;
  const sourceId = (_a = state.concentrationLink) == null ? void 0 : _a.sourceId;
  if (!sourceId) return status;
  return { ...status, concentrationSourceId: sourceId };
}
function shouldLinkEffectToConcentration(state, effectTypeId) {
  const link = state.concentrationLink;
  if (!link) return false;
  if (!link.effectId) return true;
  return link.effectId === effectTypeId;
}
function linkEffectToConcentration(state, effect) {
  var _a;
  const sourceId = (_a = state.concentrationLink) == null ? void 0 : _a.sourceId;
  if (!sourceId) return effect;
  if (!shouldLinkEffectToConcentration(state, effect.typeId)) return effect;
  return { ...effect, concentrationSourceId: sourceId };
}
function removeConcentrationLinkedStatuses(state, sourceId) {
  let removed = 0;
  const tokens = [state.player, ...state.enemies];
  for (const token of tokens) {
    if (!Array.isArray(token.statuses) || token.statuses.length === 0) continue;
    const before = token.statuses.length;
    token.statuses = token.statuses.filter((status) => status.concentrationSourceId !== sourceId);
    removed += Math.max(0, before - token.statuses.length);
  }
  return removed;
}
function removeConcentrationLinkedEffects(state, sourceId) {
  if (!Array.isArray(state.effects) || state.effects.length === 0) return 0;
  const before = state.effects.length;
  state.effects = state.effects.filter((effect) => effect.concentrationSourceId !== sourceId);
  return Math.max(0, before - state.effects.length);
}
function breakConcentration(params) {
  const { state, tx, token, opts, reason } = params;
  const sourceId = getConcentrationSourceId(token);
  token.concentration = null;
  if (sourceId) {
    const removed = removeConcentrationLinkedStatuses(state, sourceId);
    const removedEffects = removeConcentrationLinkedEffects(state, sourceId);
    logTransaction(
      tx,
      `${reason}${removed > 0 || removedEffects > 0 ? ` (${removed + removedEffects} effets lies retires)` : ""}`,
      opts.onLog
    );
  } else {
    logTransaction(tx, reason, opts.onLog);
  }
}
function maybeCheckConcentrationOnDamage(params) {
  var _a, _b;
  const { state, tx, targetToken, damage: damage2, opts } = params;
  if (!(targetToken == null ? void 0 : targetToken.concentration)) return;
  if (damage2 <= 0) return;
  const dc = Math.max(10, Math.floor(damage2 / 2));
  const mod = ((_b = (_a = targetToken == null ? void 0 : targetToken.combatStats) == null ? void 0 : _a.mods) == null ? void 0 : _b.modCON) ?? 0;
  const roll = rollDamage("1d20", { isCrit: false, critRule: "double-dice" });
  const total = roll.total + mod;
  logTransaction(
    tx,
    `Concentration: d20 ${roll.total} + ${mod} = ${total} (DD ${dc})`,
    opts.onLog
  );
  if (total < dc) {
    breakConcentration({
      state,
      tx,
      token: targetToken,
      opts,
      reason: "Concentration brisee par degats."
    });
  }
}
function ensureTargetingState(state, explicitTarget) {
  var _a;
  if (state.targeting) {
    state.targeting.targets = state.targeting.targets ?? [];
    state.targeting.locked = state.targeting.locked ?? false;
    return {
      targets: state.targeting.targets,
      locked: state.targeting.locked
    };
  }
  const targets = [];
  if ((explicitTarget == null ? void 0 : explicitTarget.kind) === "token") {
    const resolved = resolveTokenById(state, explicitTarget.token);
    if (resolved) targets.push(resolved);
  } else if (((_a = state.targetingConfig) == null ? void 0 : _a.target) === "self") {
    targets.push(state.actor);
  }
  state.targeting = { targets, locked: false };
  return { targets, locked: false };
}
function getTokenTags$1(token) {
  var _a;
  const tags2 = [];
  if (Array.isArray(token == null ? void 0 : token.tags)) tags2.push(...token.tags);
  if (Array.isArray((_a = token == null ? void 0 : token.combatStats) == null ? void 0 : _a.tags)) tags2.push(...token.combatStats.tags);
  return tags2;
}
function getPotentialTargets(state) {
  var _a;
  const target = ((_a = state.targetingConfig) == null ? void 0 : _a.target) ?? null;
  if (target === "self") return [state.actor];
  if (target === "player") return [state.player];
  if (target === "enemy") return state.enemies;
  if (target === "hostile") {
    return state.actor.type === "player" ? state.enemies : [state.player];
  }
  if (target === "ally") {
    return state.actor.type === "player" ? [state.player] : state.enemies;
  }
  return [];
}
function directionFromTo(from, to) {
  const dx = to.x - from.x;
  const dy = to.y - from.y;
  if (dx === 0 && dy === 0) return { x: 0, y: 0 };
  const mag = Math.sqrt(dx * dx + dy * dy) || 1;
  return { x: dx / mag, y: dy / mag };
}
function applyOperation(params) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u;
  const { op, tx, state, explicitTarget, opts } = params;
  if (op.op === "LogEvent") {
    logTransaction(tx, op.message, opts.onLog);
    return;
  }
  if (op.op === "EmitEvent") {
    (_a = opts.onEmitEvent) == null ? void 0 : _a.call(opts, { kind: op.kind, data: op.data });
    return;
  }
  if (op.op === "SpendResource") {
    (_b = opts.spendResource) == null ? void 0 : _b.call(opts, op.name, op.pool ?? null, op.amount);
    logTransaction(tx, `Ressource depensee: ${op.name} -${op.amount}`, opts.onLog);
    return;
  }
  if (op.op === "RestoreResource") {
    if (opts.restoreResource) {
      opts.restoreResource(op.name, op.pool ?? null, op.amount);
    } else if (opts.spendResource) {
      opts.spendResource(op.name, op.pool ?? null, -op.amount);
    }
    logTransaction(tx, `Ressource restauree: ${op.name} +${op.amount}`, opts.onLog);
    return;
  }
  if (op.op === "SetResource") {
    (_c = opts.setResource) == null ? void 0 : _c.call(opts, op.name, op.pool ?? null, op.amount);
    logTransaction(tx, `Ressource fixee: ${op.name} = ${op.amount}`, opts.onLog);
    return;
  }
  if (op.op === "ConsumeSlot") {
    (_d = opts.consumeSlot) == null ? void 0 : _d.call(opts, op.slot, op.level, op.amount);
    logTransaction(tx, `Slot consomme: ${op.slot}${op.level ? ` (lvl ${op.level})` : ""}`, opts.onLog);
    return;
  }
  if (op.op === "RestoreSlot") {
    (_e = opts.restoreSlot) == null ? void 0 : _e.call(opts, op.slot, op.level, op.amount);
    logTransaction(tx, `Slot restaure: ${op.slot}${op.level ? ` (lvl ${op.level})` : ""}`, opts.onLog);
    return;
  }
  if (op.op === "CreateZone") {
    const targetCell = op.target === "self" ? { x: state.actor.x, y: state.actor.y } : (explicitTarget == null ? void 0 : explicitTarget.kind) === "token" ? (() => {
      const targetId = explicitTarget.token.id;
      if (state.player.id === targetId) return { x: state.player.x, y: state.player.y };
      const enemy = state.enemies.find((e2) => e2.id === targetId);
      return enemy ? { x: enemy.x, y: enemy.y } : null;
    })() : null;
    if (!targetCell) return;
    const id2 = `zone-${op.effectTypeId}-${Date.now()}-${Math.random().toString(36).slice(2, 6)}`;
    tx.state.effects = tx.state.effects.filter(
      (effect2) => !(effect2.kind === "zone" && effect2.typeId === op.effectTypeId && effect2.sourceId === state.actor.id)
    );
    const effect = linkEffectToConcentration(state, {
      id: id2,
      typeId: op.effectTypeId,
      x: targetCell.x,
      y: targetCell.y,
      active: true,
      kind: "zone",
      sourceId: state.actor.id
    });
    tx.state.effects.push(effect);
    logTransaction(tx, `Zone creee: ${op.effectTypeId}`, opts.onLog);
    return;
  }
  if (op.op === "RemoveZone") {
    tx.state.effects = tx.state.effects.filter((effect) => {
      if (op.zoneId && effect.id === op.zoneId) return false;
      if (op.effectTypeId && effect.typeId === op.effectTypeId) return false;
      return true;
    });
    logTransaction(tx, `Zone retiree`, opts.onLog);
    return;
  }
  if (op.op === "ModifyZone") {
    const effect = tx.state.effects.find((e2) => e2.id === op.zoneId);
    if (effect) {
      if (typeof op.active === "boolean") effect.active = op.active;
      if (typeof op.x === "number") effect.x = op.x;
      if (typeof op.y === "number") effect.y = op.y;
      logTransaction(tx, `Zone modifiee: ${op.zoneId}`, opts.onLog);
    }
    return;
  }
  if (op.op === "CreateSurface") {
    const targetCell = op.target === "self" ? { x: state.actor.x, y: state.actor.y } : (explicitTarget == null ? void 0 : explicitTarget.kind) === "token" ? (() => {
      const targetId = explicitTarget.token.id;
      if (state.player.id === targetId) return { x: state.player.x, y: state.player.y };
      const enemy = state.enemies.find((e2) => e2.id === targetId);
      return enemy ? { x: enemy.x, y: enemy.y } : null;
    })() : null;
    if (!targetCell) return;
    const id2 = `surface-${op.effectTypeId}-${Date.now()}-${Math.random().toString(36).slice(2, 6)}`;
    tx.state.effects = tx.state.effects.filter(
      (effect2) => !(effect2.kind === "surface" && effect2.typeId === op.effectTypeId && effect2.sourceId === state.actor.id)
    );
    const effect = linkEffectToConcentration(state, {
      id: id2,
      typeId: op.effectTypeId,
      x: targetCell.x,
      y: targetCell.y,
      active: true,
      kind: "surface",
      sourceId: state.actor.id
    });
    tx.state.effects.push(effect);
    logTransaction(tx, `Surface creee: ${op.effectTypeId}`, opts.onLog);
    return;
  }
  if (op.op === "RemoveSurface") {
    tx.state.effects = tx.state.effects.filter((effect) => {
      if (op.surfaceId && effect.id === op.surfaceId) return false;
      if (op.effectTypeId && effect.typeId === op.effectTypeId) return false;
      return true;
    });
    logTransaction(tx, `Surface retiree`, opts.onLog);
    return;
  }
  if (op.op === "ApplyAura") {
    const targetToken2 = pickTarget(state, op.target, explicitTarget);
    if (!targetToken2) return;
    const id2 = `aura-${op.effectTypeId}-${Date.now()}-${Math.random().toString(36).slice(2, 6)}`;
    tx.state.effects = tx.state.effects.filter(
      (effect2) => !(effect2.kind === "aura" && effect2.typeId === op.effectTypeId && effect2.sourceId === state.actor.id && effect2.anchorTokenId === targetToken2.id)
    );
    const effect = linkEffectToConcentration(state, {
      id: id2,
      typeId: op.effectTypeId,
      x: targetToken2.x,
      y: targetToken2.y,
      active: true,
      kind: "aura",
      sourceId: state.actor.id,
      anchorTokenId: targetToken2.id
    });
    tx.state.effects.push(effect);
    logTransaction(tx, `Aura appliquee: ${op.effectTypeId}`, opts.onLog);
    return;
  }
  const targetToken = pickTarget(state, op.target, explicitTarget);
  if (!targetToken) return;
  if (op.op === "DealDamage") {
    const formula = resolveFormula(op.formula, { actor: state.actor, sampleCharacter: void 0 });
    const override = ((_g = (_f = opts.rollOverrides) == null ? void 0 : _f.consumeDamageRoll) == null ? void 0 : _g.call(_f)) ?? null;
    const roll = override ?? rollDamage(formula, {
      isCrit: Boolean((_h = opts.damageContext) == null ? void 0 : _h.isCrit),
      critRule: ((_i = opts.damageContext) == null ? void 0 : _i.critRule) ?? "double-dice"
    });
    const total = op.scale === "half" ? Math.floor(roll.total / 2) : roll.total;
    const diceText = roll.dice.map((d2) => d2.rolls.join("+")).join(" | ");
    const detail = diceText || roll.flatModifier ? ` [${diceText}${roll.flatModifier ? ` + ${roll.flatModifier}` : ""}]` : "";
    const beforeHp = Number(targetToken.hp ?? 0);
    const tempHp = typeof targetToken.tempHp === "number" ? targetToken.tempHp : 0;
    const beforeTempHp = tempHp;
    if (tempHp > 0) {
      const remaining = Math.max(0, total - tempHp);
      targetToken.tempHp = Math.max(0, tempHp - total);
      targetToken.hp = Math.max(0, targetToken.hp - remaining);
    } else {
      targetToken.hp = Math.max(0, targetToken.hp - total);
    }
    const afterHp = Number(targetToken.hp ?? 0);
    const afterTempHp = typeof targetToken.tempHp === "number" ? targetToken.tempHp : 0;
    const dmgType = op.damageType ? ` ${op.damageType}` : "";
    logTransaction(
      tx,
      `Degats${dmgType}: ${targetToken.id} prend ${total} (${formula})${detail} | PV ${beforeHp}->${afterHp} | Temp ${beforeTempHp}->${afterTempHp}`,
      opts.onLog
    );
    maybeCheckConcentrationOnDamage({ state, tx, targetToken, damage: total, opts });
    return;
  }
  if (op.op === "DealDamageScaled") {
    const formula = resolveFormula(op.formula, { actor: state.actor, sampleCharacter: void 0 });
    const roll = rollDamage(formula, {
      isCrit: Boolean((_j = opts.damageContext) == null ? void 0 : _j.isCrit),
      critRule: ((_k = opts.damageContext) == null ? void 0 : _k.critRule) ?? "double-dice"
    });
    const total = op.scale === "quarter" ? Math.floor(roll.total / 4) : Math.floor(roll.total / 2);
    const diceText = roll.dice.map((d2) => d2.rolls.join("+")).join(" | ");
    const detail = diceText || roll.flatModifier ? ` [${diceText}${roll.flatModifier ? ` + ${roll.flatModifier}` : ""}]` : "";
    const beforeHp = Number(targetToken.hp ?? 0);
    const tempHp = typeof targetToken.tempHp === "number" ? targetToken.tempHp : 0;
    const beforeTempHp = tempHp;
    if (tempHp > 0) {
      const remaining = Math.max(0, total - tempHp);
      targetToken.tempHp = Math.max(0, tempHp - total);
      targetToken.hp = Math.max(0, targetToken.hp - remaining);
    } else {
      targetToken.hp = Math.max(0, targetToken.hp - total);
    }
    const afterHp = Number(targetToken.hp ?? 0);
    const afterTempHp = typeof targetToken.tempHp === "number" ? targetToken.tempHp : 0;
    const dmgType = op.damageType ? ` ${op.damageType}` : "";
    logTransaction(
      tx,
      `Degats reduits${dmgType}: ${targetToken.id} prend ${total} (${formula})${detail} | PV ${beforeHp}->${afterHp} | Temp ${beforeTempHp}->${afterTempHp}`,
      opts.onLog
    );
    maybeCheckConcentrationOnDamage({ state, tx, targetToken, damage: total, opts });
    return;
  }
  if (op.op === "ApplyDamageTypeMod") {
    const list = ensureDefenseArray(targetToken, op.mode);
    if (!list.includes(op.damageType)) list.push(op.damageType);
    logTransaction(tx, `Defense ${op.mode}: ${op.damageType}`, opts.onLog);
    return;
  }
  if (op.op === "Heal") {
    const formula = resolveFormula(op.formula, { actor: state.actor, sampleCharacter: void 0 });
    const roll = rollDamage(formula, { isCrit: false, critRule: "double-dice" });
    const total = roll.total;
    const diceText = roll.dice.map((d2) => d2.rolls.join("+")).join(" | ");
    const detail = diceText || roll.flatModifier ? ` [${diceText}${roll.flatModifier ? ` + ${roll.flatModifier}` : ""}]` : "";
    const beforeHp = Number(targetToken.hp ?? 0);
    targetToken.hp = Math.min(targetToken.maxHp, targetToken.hp + total);
    const afterHp = Number(targetToken.hp ?? 0);
    logTransaction(tx, `Soin: ${targetToken.id} +${total} (${formula})${detail} | PV ${beforeHp}->${afterHp}`, opts.onLog);
    return;
  }
  if (op.op === "ApplyCondition") {
    const statuses = targetToken.statuses ? [...targetToken.statuses] : [];
    const status = linkStatusToConcentration(state, {
      id: op.statusId,
      remainingTurns: op.durationTurns,
      sourceId: state.actor.id,
      durationTick: "start"
    });
    statuses.push(status);
    targetToken.statuses = statuses;
    logTransaction(tx, `Etat applique: ${op.statusId} (${op.durationTurns} tours)`, opts.onLog);
    return;
  }
  if (op.op === "RemoveCondition") {
    const statuses = targetToken.statuses ? [...targetToken.statuses] : [];
    targetToken.statuses = statuses.filter((status) => status.id !== op.statusId);
    logTransaction(tx, `Etat retire: ${op.statusId}`, opts.onLog);
    return;
  }
  if (op.op === "ExtendCondition") {
    const statuses = targetToken.statuses ? [...targetToken.statuses] : [];
    for (const status of statuses) {
      if (status.id === op.statusId) {
        status.remainingTurns = Math.max(0, status.remainingTurns + op.durationTurns);
      }
    }
    targetToken.statuses = statuses;
    logTransaction(tx, `Etat prolonge: ${op.statusId} (+${op.durationTurns})`, opts.onLog);
    return;
  }
  if (op.op === "SetConditionStack") {
    const statuses = targetToken.statuses ? [...targetToken.statuses] : [];
    const kept = statuses.filter((status) => status.id !== op.statusId);
    for (let i2 = 0; i2 < op.stacks; i2++) {
      kept.push({ id: op.statusId, remainingTurns: 1, sourceId: state.actor.id });
    }
    targetToken.statuses = kept;
    logTransaction(tx, `Stacks etat: ${op.statusId} = ${op.stacks}`, opts.onLog);
    return;
  }
  if (op.op === "StartConcentration") {
    if (targetToken.concentration) {
      breakConcentration({
        state,
        tx,
        token: targetToken,
        opts,
        reason: "Concentration remplacee."
      });
    }
    const sourceId = op.sourceId ?? state.actor.id;
    const effectId = op.effectId ?? null;
    targetToken.concentration = {
      sourceId,
      effectId
    };
    state.concentrationLink = { sourceId, effectId };
    if (effectId) {
      for (const effect of state.effects) {
        if (!effect.concentrationSourceId && effect.typeId === effectId) {
          effect.concentrationSourceId = sourceId;
        }
      }
    }
    logTransaction(tx, `Concentration demarree`, opts.onLog);
    return;
  }
  if (op.op === "BreakConcentration") {
    breakConcentration({
      state,
      tx,
      token: targetToken,
      opts,
      reason: "Concentration interrompue."
    });
    return;
  }
  if (op.op === "GrantTempHp") {
    const amount = typeof op.amount === "number" ? op.amount : 0;
    if (amount <= 0) return;
    targetToken.tempHp = Math.max(targetToken.tempHp ?? 0, amount);
    (_l = opts.onGrantTempHp) == null ? void 0 : _l.call(opts, { targetId: targetToken.id, amount, durationTurns: op.durationTurns });
    logTransaction(tx, `PV temporaires: +${amount}`, opts.onLog);
    return;
  }
  if (op.op === "MoveForced") {
    if (!op.to) return;
    if (opts.onMoveForced) {
      opts.onMoveForced({ state, targetId: targetToken.id, to: op.to });
    } else {
      targetToken.x = op.to.x;
      targetToken.y = op.to.y;
    }
    logTransaction(tx, `Deplacement force vers (${op.to.x}, ${op.to.y})`, opts.onLog);
    return;
  }
  if (op.op === "Teleport") {
    if (opts.onTeleport) {
      opts.onTeleport({ state, targetId: targetToken.id, to: op.to });
    } else {
      targetToken.x = op.to.x;
      targetToken.y = op.to.y;
    }
    logTransaction(tx, `Teleportation vers (${op.to.x}, ${op.to.y})`, opts.onLog);
    return;
  }
  if (op.op === "SwapPositions") {
    if (opts.onSwapPositions) {
      opts.onSwapPositions({ state, aId: state.actor.id, bId: targetToken.id });
    } else {
      const ax = state.actor.x;
      const ay = state.actor.y;
      state.actor.x = targetToken.x;
      state.actor.y = targetToken.y;
      targetToken.x = ax;
      targetToken.y = ay;
    }
    logTransaction(tx, `Positions echangees`, opts.onLog);
    return;
  }
  if (op.op === "Knockback" || op.op === "Push" || op.op === "Pull") {
    const distance2 = op.distance ?? 0;
    let dir = op.direction ?? null;
    if (!dir) {
      const from = op.op === "Pull" ? { x: targetToken.x, y: targetToken.y } : { x: state.actor.x, y: state.actor.y };
      const to = op.op === "Pull" ? { x: state.actor.x, y: state.actor.y } : { x: targetToken.x, y: targetToken.y };
      dir = directionFromTo(from, to);
    }
    if (opts.onDisplace) {
      opts.onDisplace({ state, targetId: targetToken.id, direction: dir, distance: distance2 });
      logTransaction(tx, `${op.op} ${distance2} (deplacement force)`, opts.onLog);
    } else {
      const dx = Math.round(dir.x * distance2);
      const dy = Math.round(dir.y * distance2);
      moveTokenByDelta(targetToken, dx, dy);
      logTransaction(tx, `${op.op} ${distance2} vers (${dx}, ${dy})`, opts.onLog);
    }
    return;
  }
  if (op.op === "MoveTo") {
    if ((explicitTarget == null ? void 0 : explicitTarget.kind) !== "cell") return;
    let maxSteps = null;
    if (typeof op.maxSteps === "number") {
      maxSteps = op.maxSteps;
    } else if (typeof op.maxSteps === "string") {
      const resolved = resolveFormula(op.maxSteps, { actor: state.actor, sampleCharacter: void 0 });
      const parsed = Number.parseFloat(resolved);
      if (Number.isFinite(parsed)) maxSteps = parsed;
    }
    (_m = opts.onMoveTo) == null ? void 0 : _m.call(opts, {
      state: tx.state,
      targetCell: { x: explicitTarget.x, y: explicitTarget.y },
      maxSteps
    });
    return;
  }
  if (op.op === "AddDice") {
    const roll = rollDamage(op.formula, { isCrit: false, critRule: "double-dice" });
    tx.state.rollContext = tx.state.rollContext ?? {};
    tx.state.rollContext.bonusDelta = (tx.state.rollContext.bonusDelta ?? 0) + roll.total;
    logTransaction(tx, `Bonus de jet: +${roll.total} (${op.formula})`, opts.onLog);
    return;
  }
  if (op.op === "ReplaceRoll") {
    tx.state.rollContext = tx.state.rollContext ?? {};
    tx.state.rollContext.replaceRoll = op.value;
    logTransaction(tx, `Jet remplace: ${op.value}`, opts.onLog);
    return;
  }
  if (op.op === "Reroll") {
    tx.state.rollContext = tx.state.rollContext ?? {};
    tx.state.rollContext.reroll = op.mode ?? "max";
    logTransaction(tx, `Relance jet (${op.mode ?? "max"})`, opts.onLog);
    return;
  }
  if (op.op === "SetMinimumRoll") {
    tx.state.rollContext = tx.state.rollContext ?? {};
    tx.state.rollContext.minRoll = op.value;
    logTransaction(tx, `Jet min: ${op.value}`, opts.onLog);
    return;
  }
  if (op.op === "SetMaximumRoll") {
    tx.state.rollContext = tx.state.rollContext ?? {};
    tx.state.rollContext.maxRoll = op.value;
    logTransaction(tx, `Jet max: ${op.value}`, opts.onLog);
    return;
  }
  if (op.op === "ModifyBonus") {
    tx.state.rollContext = tx.state.rollContext ?? {};
    tx.state.rollContext.bonusDelta = (tx.state.rollContext.bonusDelta ?? 0) + op.delta;
    logTransaction(tx, `Bonus modifie: ${op.delta >= 0 ? "+" : ""}${op.delta}`, opts.onLog);
    return;
  }
  if (op.op === "ModifyDC") {
    tx.state.rollContext = tx.state.rollContext ?? {};
    tx.state.rollContext.dcDelta = (tx.state.rollContext.dcDelta ?? 0) + op.delta;
    logTransaction(tx, `DC modifie: ${op.delta >= 0 ? "+" : ""}${op.delta}`, opts.onLog);
    return;
  }
  if (op.op === "LockTarget") {
    const targeting2 = ensureTargetingState(state, explicitTarget);
    state.targeting = { targets: targeting2.targets, locked: true };
    logTransaction(tx, "Ciblage verrouille", opts.onLog);
    return;
  }
  if (op.op === "ExpandTargets") {
    const targeting2 = ensureTargetingState(state, explicitTarget);
    if (targeting2.locked) {
      logTransaction(tx, "Ciblage verrouille (ExpandTargets ignore)", opts.onLog);
      return;
    }
    const currentIds = new Set(targeting2.targets.map((t2) => t2.id));
    const candidates = getPotentialTargets(state).filter((t2) => t2 && t2.hp > 0 && !currentIds.has(t2.id)).filter((t2) => opts.isTargetAllowed ? opts.isTargetAllowed(t2) : true).sort((a2, b2) => distanceBetweenTokens(state.actor, a2) - distanceBetweenTokens(state.actor, b2));
    const maxTargets = typeof ((_n = state.targetingConfig) == null ? void 0 : _n.maxTargets) === "number" ? state.targetingConfig.maxTargets : null;
    const desired = Math.max(0, op.count ?? 0);
    const remaining = maxTargets === null ? desired : Math.max(0, maxTargets - targeting2.targets.length);
    const toAdd = candidates.slice(0, Math.min(desired, remaining));
    if (toAdd.length > 0) {
      targeting2.targets.push(...toAdd);
    }
    state.targeting = { targets: targeting2.targets, locked: false };
    logTransaction(tx, `Ciblage etendu (+${toAdd.length})`, opts.onLog);
    return;
  }
  if (op.op === "FilterTargets") {
    const targeting2 = ensureTargetingState(state, explicitTarget);
    if (targeting2.locked) {
      logTransaction(tx, "Ciblage verrouille (FilterTargets ignore)", opts.onLog);
      return;
    }
    if (op.tag) {
      targeting2.targets = targeting2.targets.filter((t2) => getTokenTags$1(t2).includes(op.tag));
      state.targeting = { targets: targeting2.targets, locked: false };
      logTransaction(tx, `Ciblage filtre (${op.tag})`, opts.onLog);
      return;
    }
    logTransaction(tx, "Ciblage filtre (tag manquant)", opts.onLog);
    return;
  }
  if (op.op === "Retarget") {
    const targeting2 = ensureTargetingState(state, explicitTarget);
    if (targeting2.locked) {
      logTransaction(tx, "Ciblage verrouille (Retarget ignore)", opts.onLog);
      return;
    }
    if (op.target === "self") {
      targeting2.targets = [state.actor];
      state.targeting = { targets: targeting2.targets, locked: false };
      logTransaction(tx, "Ciblage retarget: self", opts.onLog);
      return;
    }
    if (op.target === "primary") {
      const primary = (explicitTarget == null ? void 0 : explicitTarget.kind) === "token" ? resolveTokenById(state, explicitTarget.token) : null;
      targeting2.targets = primary ? [primary] : targeting2.targets.slice(0, 1);
      state.targeting = { targets: targeting2.targets, locked: false };
      logTransaction(tx, "Ciblage retarget: primary", opts.onLog);
      return;
    }
    logTransaction(tx, "Ciblage retarget: noop", opts.onLog);
    return;
  }
  if (op.op === "SpawnEntity") {
    const explicitToken = (explicitTarget == null ? void 0 : explicitTarget.kind) === "token" ? resolveTokenById(state, explicitTarget.token) : null;
    const targetCell = (explicitTarget == null ? void 0 : explicitTarget.kind) === "cell" ? { x: explicitTarget.x, y: explicitTarget.y } : explicitToken ? { x: explicitToken.x ?? state.actor.x, y: explicitToken.y ?? state.actor.y } : { x: state.actor.x, y: state.actor.y };
    const ownerId = state.actor.id;
    const ownerType = state.actor.type;
    const spawned = opts.spawnEntity ? opts.spawnEntity({
      entityTypeId: op.entityTypeId,
      x: targetCell.x,
      y: targetCell.y,
      ownerId,
      ownerType
    }) : null;
    if (spawned) {
      state.enemies.push(spawned);
      logTransaction(tx, `Entite invoquee: ${op.entityTypeId}`, opts.onLog);
    } else {
      logTransaction(tx, `Invocation echouee: ${op.entityTypeId}`, opts.onLog);
    }
    return;
  }
  if (op.op === "DespawnEntity") {
    state.enemies = state.enemies.filter((enemy) => enemy.id !== op.entityId);
    (_o = opts.despawnEntity) == null ? void 0 : _o.call(opts, op.entityId);
    logTransaction(tx, `Entite retiree: ${op.entityId}`, opts.onLog);
    return;
  }
  if (op.op === "ControlSummon") {
    const ownerId = op.ownerId ?? state.actor.id;
    const ownerType = ((_p = resolveTokenById(state, { id: ownerId })) == null ? void 0 : _p.type) ?? state.actor.type;
    const token = resolveTokenById(state, { id: op.entityId });
    if (token) {
      token.summonOwnerId = ownerId;
      token.summonOwnerType = ownerType;
    }
    (_q = opts.controlSummon) == null ? void 0 : _q.call(opts, { entityId: op.entityId, ownerId });
    logTransaction(tx, `Controle invocation: ${op.entityId}`, opts.onLog);
    return;
  }
  if (op.op === "AddTag") {
    const anyToken = targetToken;
    anyToken.tags = Array.isArray(anyToken.tags) ? anyToken.tags : [];
    if (!anyToken.tags.includes(op.tag)) anyToken.tags.push(op.tag);
    logTransaction(tx, `Tag ajoute: ${op.tag}`, opts.onLog);
    return;
  }
  if (op.op === "RemoveTag") {
    const anyToken = targetToken;
    anyToken.tags = Array.isArray(anyToken.tags) ? anyToken.tags : [];
    anyToken.tags = anyToken.tags.filter((tag) => tag !== op.tag);
    logTransaction(tx, `Tag retire: ${op.tag}`, opts.onLog);
    return;
  }
  if (op.op === "SetFlag") {
    const anyToken = targetToken;
    anyToken.flags = anyToken.flags ?? {};
    anyToken.flags[op.flag] = op.value;
    logTransaction(tx, `Flag ${op.flag} = ${op.value}`, opts.onLog);
    return;
  }
  if (op.op === "ModifyPathLimit") {
    if (typeof op.delta === "number") {
      (_r = opts.onModifyPathLimit) == null ? void 0 : _r.call(opts, op.delta);
      logTransaction(tx, `Limite de trajet modifiee (${op.delta >= 0 ? "+" : ""}${op.delta})`, opts.onLog);
    }
    return;
  }
  if (op.op === "ToggleTorch") {
    (_s = opts.onToggleTorch) == null ? void 0 : _s.call(opts);
    return;
  }
  if (op.op === "SetKillerInstinctTarget") {
    (_t = opts.onSetKillerInstinctTarget) == null ? void 0 : _t.call(opts, targetToken.id);
    logTransaction(tx, `Instinct de tueur: cible ${targetToken.id}`, opts.onLog);
    return;
  }
  if (op.op === "PlayVisualEffect") {
    if (op.effectId) {
      (_u = opts.onPlayVisualEffect) == null ? void 0 : _u.call(opts, {
        effectId: op.effectId,
        anchor: op.anchor,
        offset: op.offset,
        orientation: op.orientation,
        rotationOffsetDeg: op.rotationOffsetDeg,
        durationMs: op.durationMs
      });
    }
    return;
  }
}
function compare(cmp, left, right) {
  switch (cmp) {
    case "EQ":
      return left === right;
    case "NE":
      return left !== right;
    case "LT":
      return left < right;
    case "LTE":
      return left <= right;
    case "GT":
      return left > right;
    case "GTE":
      return left >= right;
    case "IN":
      return left === right;
    case "NIN":
      return left !== right;
    default:
      return false;
  }
}
function getTags(token) {
  var _a;
  const tags2 = ((_a = token.combatStats) == null ? void 0 : _a.tags) ?? [];
  const extra = token.tags ?? [];
  return [...tags2, ...extra];
}
function getStatuses(token) {
  return token.statuses ?? [];
}
function getResourceAmountFallback(token, name2) {
  var _a, _b;
  const pool = (_b = (_a = token.combatStats) == null ? void 0 : _a.resources) == null ? void 0 : _b[name2];
  if (!pool) return 0;
  return Number(pool.current ?? 0);
}
function outcomeHasFlag(outcome, flag) {
  if (!outcome) return false;
  if (flag === "HIT") {
    return outcome.kind === "hit" || outcome.kind === "crit" || outcome.kind === "checkSuccess" || outcome.kind === "contestedWin";
  }
  if (flag === "MISS") {
    return outcome.kind === "miss" || outcome.kind === "checkFail" || outcome.kind === "contestedLose";
  }
  if (flag === "CRIT") return outcome.kind === "crit";
  if (flag === "SAVE_SUCCESS") return outcome.kind === "saveSuccess";
  if (flag === "SAVE_FAIL") return outcome.kind === "saveFail";
  if (flag === "CHECK_SUCCESS") return outcome.kind === "checkSuccess";
  if (flag === "CHECK_FAIL") return outcome.kind === "checkFail";
  if (flag === "CONTESTED_WIN") return outcome.kind === "contestedWin";
  if (flag === "CONTESTED_LOSE") return outcome.kind === "contestedLose";
  if (flag === "AUTO_SUCCESS") {
    return outcome.kind === "hit" && outcome.roll === 0 && outcome.total === 0;
  }
  if (flag === "AUTO_FAIL") {
    return outcome.kind === "miss" && outcome.roll === 0 && outcome.total === 0;
  }
  if (flag === "PARTIAL") return false;
  return false;
}
function getCreatureType(token) {
  var _a;
  const anyToken = token;
  return ((_a = anyToken.creature) == null ? void 0 : _a.type) ?? null;
}
function getCreatureTags(token) {
  var _a;
  const anyToken = token;
  return ((_a = anyToken.creature) == null ? void 0 : _a.tags) ?? [];
}
function getSize(token) {
  var _a;
  const anyToken = token;
  return ((_a = anyToken.creature) == null ? void 0 : _a.size) ?? null;
}
function canMove(token, move) {
  var _a;
  const targetMove = move.toLowerCase();
  if (token.movementModes && typeof token.movementModes === "object") {
    return Object.keys(token.movementModes).some((key2) => key2.toLowerCase() === targetMove);
  }
  const movementType = (_a = token.movementProfile) == null ? void 0 : _a.type;
  if (!movementType) return false;
  if (movementType === "flying") return targetMove === "fly";
  if (movementType === "ground") return targetMove === "walk";
  return movementType.toLowerCase() === targetMove;
}
function getDamageDefenses(token) {
  var _a;
  const anyToken = token;
  return ((_a = anyToken.defenses) == null ? void 0 : _a.damage) ?? null;
}
function getValue(token, key2, values) {
  if (values && typeof values[key2] === "number") return values[key2];
  const anyToken = token;
  const raw = anyToken[key2];
  if (typeof raw === "number") return raw;
  return null;
}
function getUsageCount(usage2, scope, key2) {
  if (!usage2) return 0;
  const map = usage2[scope];
  if (!map) return 0;
  const raw = map[key2];
  return typeof raw === "number" ? raw : 0;
}
function isHpBelow(params) {
  const { token, value: value2, mode } = params;
  if (mode === "absolute") {
    return (token.hp ?? 0) <= value2;
  }
  const maxHp = token.maxHp ?? 0;
  const curHp = token.hp ?? 0;
  if (maxHp <= 0) return false;
  return curHp / maxHp < value2;
}
function evaluateConditionExpr(condition, ctx) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
  switch (condition.type) {
    case "AND":
      return condition.all.every((cond) => evaluateConditionExpr(cond, ctx));
    case "OR":
      return condition.any.some((cond) => evaluateConditionExpr(cond, ctx));
    case "NOT":
      return !evaluateConditionExpr(condition.expr, ctx);
    case "PHASE_IS": {
      const expected = condition.value ?? condition.mustBe;
      if (!expected) return true;
      return ctx.phase === expected;
    }
    case "OUTCOME_IS":
      return !!ctx.outcome && outcomeHasFlag(ctx.outcome, condition.value);
    case "OUTCOME_IN":
      return !!ctx.outcome && condition.values.some((flag) => outcomeHasFlag(ctx.outcome, flag));
    case "ROLL_AT_LEAST":
      return typeof ((_a = ctx.outcome) == null ? void 0 : _a.roll) === "number" ? ctx.outcome.roll >= condition.value : false;
    case "ROLL_AT_MOST":
      return typeof ((_b = ctx.outcome) == null ? void 0 : _b.roll) === "number" ? ctx.outcome.roll <= condition.value : false;
    case "OUTCOME_HAS":
      return outcomeHasFlag(ctx.outcome, condition.flag);
    case "TARGET_ALIVE":
      return !!ctx.target && ctx.target.hp > 0;
    case "TARGET_HP_BELOW":
      return !!ctx.target && isHpBelow({ token: ctx.target, value: condition.value, mode: condition.mode });
    case "ACTOR_HP_BELOW":
      return isHpBelow({ token: ctx.actor, value: condition.value, mode: condition.mode });
    case "DISTANCE_MAX":
      return typeof ctx.distance === "number" ? ctx.distance <= condition.max : false;
    case "DISTANCE_WITHIN":
      if (typeof ctx.distance !== "number") return false;
      if (typeof condition.min === "number" && ctx.distance < condition.min) return false;
      if (typeof condition.max === "number" && ctx.distance > condition.max) return false;
      return true;
    case "DISTANCE_BETWEEN": {
      if (typeof ctx.distance !== "number") return false;
      if (typeof condition.min === "number" && ctx.distance < condition.min) return false;
      if (typeof condition.max === "number" && ctx.distance > condition.max) return false;
      return true;
    }
    case "HAS_LINE_OF_SIGHT":
      if (typeof condition.value === "boolean") return (ctx.lineOfSight ?? false) === condition.value;
      return !!ctx.lineOfSight;
    case "SAME_LEVEL":
      if (typeof condition.value === "boolean") return (ctx.sameLevel ?? false) === condition.value;
      return !!ctx.sameLevel;
    case "TARGET_IN_AREA":
      if (typeof condition.value === "boolean") return (ctx.targetInArea ?? false) === condition.value;
      return !!ctx.targetInArea;
    case "ONCE_PER_TURN":
      return getUsageCount(ctx.usage, "turn", condition.key) <= 0;
    case "ONCE_PER_ROUND":
      return getUsageCount(ctx.usage, "round", condition.key) <= 0;
    case "ONCE_PER_COMBAT":
      return getUsageCount(ctx.usage, "combat", condition.key) <= 0;
    case "NOT_USED_THIS_TURN":
      return getUsageCount(ctx.usage, "turn", condition.key) <= 0;
    case "IS_REACTION_AVAILABLE":
      if (typeof condition.value === "boolean") return (ctx.reactionAvailable ?? false) === condition.value;
      return !!ctx.reactionAvailable;
    case "IS_CONCENTRATING":
      if (typeof condition.value === "boolean") return (ctx.concentrating ?? false) === condition.value;
      return !!ctx.concentrating;
    case "IS_SURPRISED":
      if (typeof condition.value === "boolean") return (ctx.surprised ?? false) === condition.value;
      return !!ctx.surprised;
    case "IS_IN_LIGHT":
      if (typeof condition.value === "boolean") return (ctx.inLight ?? false) === condition.value;
      return !!ctx.inLight;
    case "STAT_BELOW_PERCENT": {
      const who = condition.who === "target" ? ctx.target : ctx.actor;
      if (!who) return false;
      if (condition.stat !== "hp") return false;
      const maxHp = who.maxHp ?? 0;
      const curHp = who.hp ?? 0;
      if (maxHp <= 0) return false;
      return curHp / maxHp < condition.percentMax;
    }
    case "RESOURCE_AT_LEAST": {
      const amount = ctx.getResourceAmount ? ctx.getResourceAmount(condition.resource, condition.pool ?? null) : getResourceAmountFallback(ctx.actor, condition.resource);
      return amount >= condition.value;
    }
    case "RESOURCE_AT_MOST": {
      const amount = ctx.getResourceAmount ? ctx.getResourceAmount(condition.resource, condition.pool ?? null) : getResourceAmountFallback(ctx.actor, condition.resource);
      return amount <= condition.value;
    }
    case "HAS_RESOURCE": {
      const token = condition.who === "target" ? ctx.target : ctx.actor;
      if (!token) return false;
      const amount = getResourceAmountFallback(token, condition.key);
      return compare(condition.cmp, amount, condition.value);
    }
    case "SLOT_AVAILABLE": {
      if (!ctx.getSlotAmount) return false;
      const amount = ctx.getSlotAmount(condition.slot, condition.level);
      const min = typeof condition.min === "number" ? condition.min : 1;
      return amount >= min;
    }
    case "ACTOR_HAS_RESOURCE": {
      const amount = getResourceAmountFallback(ctx.actor, condition.key);
      return compare(condition.cmp, amount, condition.value);
    }
    case "TARGET_HAS_RESOURCE": {
      if (!ctx.target) return false;
      const amount = getResourceAmountFallback(ctx.target, condition.key);
      return compare(condition.cmp, amount, condition.value);
    }
    case "ACTOR_HAS_TAG":
      return getTags(ctx.actor).includes(condition.tag);
    case "TARGET_HAS_TAG":
      return !!ctx.target && getTags(ctx.target).includes(condition.tag);
    case "ACTOR_HAS_CONDITION":
      return getStatuses(ctx.actor).some((status) => status.id === condition.condition);
    case "TARGET_HAS_CONDITION":
      return !!ctx.target && getStatuses(ctx.target).some((status) => status.id === condition.condition);
    case "ACTOR_CONDITION_STACKS": {
      const stacks = getStatuses(ctx.actor).filter((status) => status.id === condition.condition).length;
      return compare(condition.cmp, stacks, condition.value);
    }
    case "TARGET_CONDITION_STACKS": {
      if (!ctx.target) return false;
      const stacks = getStatuses(ctx.target).filter((status) => status.id === condition.condition).length;
      return compare(condition.cmp, stacks, condition.value);
    }
    case "ACTOR_CREATURE_TYPE_IS":
      return getCreatureType(ctx.actor) === condition.value;
    case "TARGET_CREATURE_TYPE_IS":
      return !!ctx.target && getCreatureType(ctx.target) === condition.value;
    case "ACTOR_CREATURE_HAS_TAG":
      return getCreatureTags(ctx.actor).includes(condition.tag);
    case "TARGET_CREATURE_HAS_TAG":
      return !!ctx.target && getCreatureTags(ctx.target).includes(condition.tag);
    case "ACTOR_SIZE_IS":
      return getSize(ctx.actor) === condition.value;
    case "TARGET_SIZE_IS":
      return !!ctx.target && getSize(ctx.target) === condition.value;
    case "ACTOR_CAN_MOVE":
      return canMove(ctx.actor, condition.move);
    case "TARGET_CAN_MOVE":
      return !!ctx.target && canMove(ctx.target, condition.move);
    case "ACTOR_DAMAGE_IMMUNE": {
      const defenses = getDamageDefenses(ctx.actor);
      return !!((_c = defenses == null ? void 0 : defenses.immune) == null ? void 0 : _c.includes(condition.damageType));
    }
    case "TARGET_DAMAGE_IMMUNE": {
      const defenses = ctx.target ? getDamageDefenses(ctx.target) : null;
      return !!((_d = defenses == null ? void 0 : defenses.immune) == null ? void 0 : _d.includes(condition.damageType));
    }
    case "ACTOR_DAMAGE_RESIST": {
      const defenses = getDamageDefenses(ctx.actor);
      return !!((_e = defenses == null ? void 0 : defenses.resist) == null ? void 0 : _e.includes(condition.damageType));
    }
    case "TARGET_DAMAGE_RESIST": {
      const defenses = ctx.target ? getDamageDefenses(ctx.target) : null;
      return !!((_f = defenses == null ? void 0 : defenses.resist) == null ? void 0 : _f.includes(condition.damageType));
    }
    case "ACTOR_DAMAGE_VULNERABLE": {
      const defenses = getDamageDefenses(ctx.actor);
      return !!((_g = defenses == null ? void 0 : defenses.vulnerable) == null ? void 0 : _g.includes(condition.damageType));
    }
    case "TARGET_DAMAGE_VULNERABLE": {
      const defenses = ctx.target ? getDamageDefenses(ctx.target) : null;
      return !!((_h = defenses == null ? void 0 : defenses.vulnerable) == null ? void 0 : _h.includes(condition.damageType));
    }
    case "ACTOR_VALUE": {
      const value2 = getValue(ctx.actor, condition.key, (_i = ctx.valueLookup) == null ? void 0 : _i.actor);
      if (value2 === null) return false;
      return compare(condition.cmp, value2, condition.value);
    }
    case "TARGET_VALUE": {
      if (!ctx.target) return false;
      const value2 = getValue(ctx.target, condition.key, (_j = ctx.valueLookup) == null ? void 0 : _j.target);
      if (value2 === null) return false;
      return compare(condition.cmp, value2, condition.value);
    }
    default:
      return false;
  }
}
function evaluateAllConditions(conditions2, ctx) {
  if (!conditions2 || conditions2.length === 0) return true;
  return conditions2.every((cond) => evaluateConditionExpr(cond, ctx));
}
function shouldApplyHook(hook, ctx, opts) {
  return evaluateAllConditions(hook.if, {
    actor: ctx.actor,
    target: ctx.target,
    outcome: ctx.outcome,
    getResourceAmount: opts.getResourceAmount
  });
}
function resolvePromptDecision(hook, opts) {
  if (!hook.prompt) return "accept";
  if (opts.promptHandler) return opts.promptHandler(hook.prompt);
  return hook.prompt.defaultDecision ?? "reject";
}
function logPipeline(tx, message, opts) {
  logTransaction(tx, `[pipeline] ${message}`, opts.onLog);
}
function describeOperation(op) {
  switch (op.op) {
    case "DealDamage":
      return `DealDamage(${op.formula}${op.damageType ? `, ${op.damageType}` : ""}${op.scale ? `, scale=${op.scale}` : ""})`;
    case "DealDamageScaled":
      return `DealDamageScaled(${op.formula}, scale=${op.scale}${op.damageType ? `, ${op.damageType}` : ""})`;
    case "Heal":
      return `Heal(${op.formula})`;
    case "ApplyCondition":
      return `ApplyCondition(${op.statusId}, ${op.durationTurns} tours)`;
    case "RemoveCondition":
      return `RemoveCondition(${op.statusId})`;
    case "SpendResource":
      return `SpendResource(${op.name}, ${op.amount})`;
    case "ConsumeSlot":
      return `ConsumeSlot(${op.slot}${op.level ? ` lvl ${op.level}` : ""})`;
    case "CreateZone":
      return `CreateZone(${op.effectTypeId})`;
    case "CreateSurface":
      return `CreateSurface(${op.effectTypeId})`;
    case "ApplyAura":
      return `ApplyAura(${op.effectTypeId})`;
    case "Push":
    case "Pull":
    case "Knockback":
      return `${op.op}(${op.distance})`;
    case "LogEvent":
      return `LogEvent(${op.message})`;
    default:
      return op.op;
  }
}
function normalizeHookWhen(when) {
  switch (when) {
    case "pre_resolution":
    case "PRE_RESOLUTION_WINDOW":
    case "preResolution":
      return "preResolution";
    case "on_outcome":
    case "ON_OUTCOME":
    case "onOutcome":
      return "onOutcome";
    case "on_apply":
    case "APPLY_TARGET_EFFECTS":
    case "APPLY_WORLD_EFFECTS":
    case "afterApply":
      return "afterApply";
    case "post_resolution":
    case "POST_RESOLUTION_WINDOW":
    case "postResolution":
      return "postResolution";
    case "COMMIT":
    case "beforeCommit":
      return "beforeCommit";
    case "afterCommit":
      return "afterCommit";
    case "onIntentBuild":
    case "onOptionsResolve":
    case "onValidate":
    case "onTargeting":
    case "onResolve":
    case "beforeApply":
      return when;
    default:
      return null;
  }
}
function applyHooks(params) {
  const { hooks: hooks2, phase, state, target, outcome, explicitTarget, tx, opts } = params;
  for (const hook of hooks2 ?? []) {
    const normalized = normalizeHookWhen(hook.when);
    if (normalized !== phase) continue;
    const hookContext = { actor: state.actor, target, outcome };
    if (!shouldApplyHook(hook, hookContext, opts)) {
      logPipeline(tx, `Hook ${phase}: ignore (conditions non remplies).`, opts);
      continue;
    }
    const decision = resolvePromptDecision(hook, opts);
    if (decision === "accept") {
      logPipeline(tx, `Hook ${phase}: applique (${hook.apply.length} operation(s)).`, opts);
      for (const op of hook.apply) {
        applyOperation({
          op,
          tx,
          state,
          explicitTarget,
          opts
        });
      }
    } else {
      logPipeline(tx, `Hook ${phase}: refuse (prompt).`, opts);
    }
  }
}
function resolveOutcome(params) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
  const { plan, state } = params;
  const resolution2 = plan.action.resolution ?? { kind: "NO_ROLL" };
  const target = params.target;
  const rollContext = state.rollContext ?? {};
  const abilityToModKey = (ability) => {
    switch (ability) {
      case "FOR":
        return "modFOR";
      case "DEX":
        return "modDEX";
      case "CON":
        return "modCON";
      case "INT":
        return "modINT";
      case "SAG":
        return "modSAG";
      case "CHA":
        return "modCHA";
      default:
        return "modFOR";
    }
  };
  if (resolution2.kind === "ATTACK_ROLL") {
    const effectiveAdvantage = resolveWeaponMasteryAdvantage({
      base: params.advantageMode ?? "normal",
      actor: state.actor,
      target
    });
    const bonus = (resolution2.bonus ?? 0) + (rollContext.bonusDelta ?? 0);
    const critRange = resolution2.critRange ?? 20;
    let roll = ((_a = params.rollOverrides) == null ? void 0 : _a.attack) ?? rollAttack(bonus, effectiveAdvantage, critRange);
    if (rollContext.replaceRoll !== void 0) {
      const d20 = rollContext.replaceRoll;
      roll = {
        ...roll,
        d20: { total: d20 },
        total: d20 + bonus,
        isCrit: d20 >= critRange
      };
    }
    if (rollContext.reroll) {
      const reroll = rollAttack(bonus, params.advantageMode ?? "normal", critRange);
      roll = rollContext.reroll === "min" ? reroll.total < roll.total ? reroll : roll : reroll.total > roll.total ? reroll : roll;
    }
    if (typeof rollContext.minRoll === "number") {
      const d20 = Math.max(rollContext.minRoll, roll.d20.total);
      roll = { ...roll, d20: { total: d20 }, total: d20 + bonus, isCrit: d20 >= critRange };
    }
    if (typeof rollContext.maxRoll === "number") {
      const d20 = Math.min(rollContext.maxRoll, roll.d20.total);
      roll = { ...roll, d20: { total: d20 }, total: d20 + bonus, isCrit: d20 >= critRange };
    }
    const targetAC = target && typeof target.armorClass === "number" ? target.armorClass : null;
    const isHit = targetAC === null ? true : roll.total >= targetAC || roll.isCrit;
    const kind2 = roll.isCrit ? "crit" : isHit ? "hit" : "miss";
    consumeWeaponMasteryAdvantage({
      actor: state.actor,
      target,
      advantageUsed: effectiveAdvantage !== "normal"
    });
    return {
      outcome: { kind: kind2, roll: roll.d20.total, total: roll.total, isCrit: roll.isCrit },
      target
    };
  }
  if (resolution2.kind === "SAVING_THROW" && resolution2.save) {
    const ability = resolution2.save.ability;
    const dc = resolution2.save.dc + (rollContext.dcDelta ?? 0);
    const modKey = abilityToModKey(ability);
    const mod = (((_c = (_b = target == null ? void 0 : target.combatStats) == null ? void 0 : _b.mods) == null ? void 0 : _c[modKey]) ?? 0) + (rollContext.bonusDelta ?? 0);
    let roll = rollDamage("1d20", { isCrit: false, critRule: "double-dice" });
    if (rollContext.replaceRoll !== void 0) {
      roll = { ...roll, total: rollContext.replaceRoll };
    }
    if (rollContext.reroll) {
      const reroll = rollDamage("1d20", { isCrit: false, critRule: "double-dice" });
      roll = rollContext.reroll === "min" ? reroll.total < roll.total ? reroll : roll : reroll.total > roll.total ? reroll : roll;
    }
    if (typeof rollContext.minRoll === "number") {
      roll = { ...roll, total: Math.max(rollContext.minRoll, roll.total) };
    }
    if (typeof rollContext.maxRoll === "number") {
      roll = { ...roll, total: Math.min(rollContext.maxRoll, roll.total) };
    }
    const total = roll.total + mod;
    const success = total >= dc;
    const kind2 = success ? "saveSuccess" : "saveFail";
    return {
      outcome: { kind: kind2, roll: roll.total, total },
      target
    };
  }
  if (resolution2.kind === "ABILITY_CHECK" && resolution2.check) {
    const ability = resolution2.check.ability;
    const dc = resolution2.check.dc + (rollContext.dcDelta ?? 0);
    const modKey = abilityToModKey(ability);
    const mod = (((_e = (_d = state.actor.combatStats) == null ? void 0 : _d.mods) == null ? void 0 : _e[modKey]) ?? 0) + (rollContext.bonusDelta ?? 0);
    let roll = rollDamage("1d20", { isCrit: false, critRule: "double-dice" });
    if (rollContext.replaceRoll !== void 0) {
      roll = { ...roll, total: rollContext.replaceRoll };
    }
    if (rollContext.reroll) {
      const reroll = rollDamage("1d20", { isCrit: false, critRule: "double-dice" });
      roll = rollContext.reroll === "min" ? reroll.total < roll.total ? reroll : roll : reroll.total > roll.total ? reroll : roll;
    }
    if (typeof rollContext.minRoll === "number") {
      roll = { ...roll, total: Math.max(rollContext.minRoll, roll.total) };
    }
    if (typeof rollContext.maxRoll === "number") {
      roll = { ...roll, total: Math.min(rollContext.maxRoll, roll.total) };
    }
    const total = roll.total + mod;
    const success = total >= dc;
    const kind2 = success ? "checkSuccess" : "checkFail";
    return {
      outcome: { kind: kind2, roll: roll.total, total },
      target
    };
  }
  if (resolution2.kind === "CONTESTED_CHECK") {
    const contested = resolution2.contested;
    const actorAbility = (contested == null ? void 0 : contested.actorAbility) ?? ((_f = resolution2.check) == null ? void 0 : _f.ability) ?? "FOR";
    const targetAbility = (contested == null ? void 0 : contested.targetAbility) ?? ((_g = resolution2.save) == null ? void 0 : _g.ability) ?? "FOR";
    const actorModKey = abilityToModKey(actorAbility);
    const targetModKey = abilityToModKey(targetAbility);
    const actorMod = (((_i = (_h = state.actor.combatStats) == null ? void 0 : _h.mods) == null ? void 0 : _i[actorModKey]) ?? 0) + ((contested == null ? void 0 : contested.actorBonus) ?? 0) + (rollContext.bonusDelta ?? 0);
    const targetMod = (((_k = (_j = target == null ? void 0 : target.combatStats) == null ? void 0 : _j.mods) == null ? void 0 : _k[targetModKey]) ?? 0) + ((contested == null ? void 0 : contested.targetBonus) ?? 0);
    const actorRoll = rollDamage("1d20", { isCrit: false, critRule: "double-dice" });
    const targetRoll = rollDamage("1d20", { isCrit: false, critRule: "double-dice" });
    const actorTotal = actorRoll.total + actorMod;
    const targetTotal = targetRoll.total + targetMod;
    const tieWinner = (contested == null ? void 0 : contested.tieWinner) ?? "actor";
    const actorWins = actorTotal > targetTotal || actorTotal === targetTotal && tieWinner === "actor";
    const kind2 = actorWins ? "contestedWin" : "contestedLose";
    return {
      outcome: {
        kind: kind2,
        roll: actorRoll.total,
        total: actorTotal,
        contested: {
          actorRoll: actorRoll.total,
          actorTotal,
          targetRoll: targetRoll.total,
          targetTotal
        }
      },
      target
    };
  }
  return {
    outcome: { kind: "hit", roll: 0, total: 0 },
    target
  };
}
function getTokenTags(token) {
  var _a, _b;
  if (!token) return [];
  const tags2 = Array.isArray(token.tags) ? token.tags : [];
  const combatTags = Array.isArray((_a = token.combatStats) == null ? void 0 : _a.tags) ? ((_b = token.combatStats) == null ? void 0 : _b.tags) ?? [] : [];
  return [...tags2, ...combatTags];
}
function addTokenTag(token, tag) {
  if (!token) return;
  const anyToken = token;
  anyToken.tags = Array.isArray(anyToken.tags) ? anyToken.tags : [];
  if (!anyToken.tags.includes(tag)) anyToken.tags.push(tag);
}
function removeTokenTagsByPrefix(token, prefix) {
  if (!token) return;
  const anyToken = token;
  if (!Array.isArray(anyToken.tags)) return;
  const nextTags = anyToken.tags.filter((tag) => !tag.startsWith(prefix));
  if (nextTags.length === anyToken.tags.length) return;
  anyToken.tags = nextTags;
}
function resolveWeaponMasteryAdvantage(params) {
  const { base, actor, target } = params;
  let score = base === "advantage" ? 1 : base === "disadvantage" ? -1 : 0;
  const actorTags = getTokenTags(actor);
  if (actorTags.some((tag) => tag.startsWith("wm-sape:next:"))) score -= 1;
  if (target) {
    const targetTags = getTokenTags(target);
    const advPrefix = `wm-ouverture:adv:${actor.id}`;
    if (targetTags.some((tag) => tag === advPrefix || tag.startsWith(`${advPrefix}:`))) {
      score += 1;
    }
  }
  if (score > 0) return "advantage";
  if (score < 0) return "disadvantage";
  return "normal";
}
function consumeWeaponMasteryAdvantage(params) {
  const { actor, target, advantageUsed } = params;
  if (!advantageUsed) return;
  removeTokenTagsByPrefix(actor, "wm-sape:next:");
  if (target) {
    removeTokenTagsByPrefix(target, `wm-ouverture:adv:${actor.id}`);
  }
}
function extractAbilityModToken(formula) {
  if (!formula) return null;
  const match = formula.match(/modFOR|modDEX|modCON|modINT|modSAG|modCHA/);
  return match ? match[0] : null;
}
function abilityModFromToken(actor, modToken) {
  var _a;
  if (!modToken) return 0;
  const mods = (_a = actor.combatStats) == null ? void 0 : _a.mods;
  if (!mods) return 0;
  if (modToken === "modFOR") return Number(mods.modFOR ?? 0);
  if (modToken === "modDEX") return Number(mods.modDEX ?? 0);
  if (modToken === "modCON") return Number(mods.modCON ?? 0);
  if (modToken === "modINT") return Number(mods.modINT ?? 0);
  if (modToken === "modSAG") return Number(mods.modSAG ?? 0);
  if (modToken === "modCHA") return Number(mods.modCHA ?? 0);
  return 0;
}
function stripAbilityMod(formula, modToken) {
  if (!modToken) return formula;
  const cleaned = formula.replace(/\s+/g, "");
  const pattern = new RegExp(`([+-])${modToken}`, "i");
  const removed = cleaned.replace(pattern, "");
  return removed.length > 0 ? removed : formula;
}
function getMasteryTriggerFromTags(tags2, masteryId) {
  const token = `wm-trigger:${masteryId}:`;
  const found = tags2.find((tag) => tag.startsWith(token));
  if (found === `${token}on_miss`) return "on_miss";
  if (found === `${token}on_intent`) return "on_intent";
  return "on_hit";
}
function getProficiencyBonus(actor) {
  var _a;
  const level2 = Number(((_a = actor.combatStats) == null ? void 0 : _a.level) ?? 1);
  if (level2 <= 4) return 2;
  if (level2 <= 8) return 3;
  if (level2 <= 12) return 4;
  if (level2 <= 16) return 5;
  return 6;
}
function getHostileTargets(state, actor) {
  if (actor.type === "player") return state.enemies ?? [];
  return [state.player];
}
function applyWeaponMasteryEffects(params) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
  const { plan, state, tx, target, outcome, opts } = params;
  const tags2 = plan.action.tags ?? [];
  const activeMasteries = tags2.filter((tag) => tag.startsWith("wm-active:")).map((tag) => tag.replace("wm-active:", "")).filter(Boolean);
  if (activeMasteries.length === 0) return;
  const actorTags = getTokenTags(state.actor);
  const damageFormula = ((_a = plan.action.damage) == null ? void 0 : _a.formula) ?? "";
  const damageType = ((_b = plan.action.damage) == null ? void 0 : _b.damageType) ?? void 0;
  const modToken = extractAbilityModToken(damageFormula);
  const abilityMod = abilityModFromToken(state.actor, modToken);
  const baseRange = ((_d = (_c = plan.action.targeting) == null ? void 0 : _c.range) == null ? void 0 : _d.max) ?? 1.5;
  for (const masteryId of activeMasteries) {
    if (!actorTags.includes(`wm:${masteryId}`)) continue;
    const trigger2 = getMasteryTriggerFromTags(tags2, masteryId);
    if (trigger2 === "on_hit" && !(outcome.kind === "hit" || outcome.kind === "crit")) continue;
    if (trigger2 === "on_miss" && outcome.kind !== "miss") continue;
    if (masteryId === "ouverture") {
      if (target) {
        addTokenTag(target, `wm-ouverture:adv:${state.actor.id}`);
        logTransaction(tx, "Botte d'arme: Ouverture (avantage prochain jet)", opts.onLog);
      }
      continue;
    }
    if (masteryId === "sape") {
      if (target) {
        addTokenTag(target, `wm-sape:next:${state.actor.id}`);
        logTransaction(tx, "Botte d'arme: Sape (desavantage prochain jet)", opts.onLog);
      }
      continue;
    }
    if (masteryId === "poussee") {
      if (target) {
        applyOperation({
          op: { op: "Push", target: "primary", distance: 3 },
          tx,
          state,
          explicitTarget: { kind: "token", token: target },
          opts
        });
      }
      continue;
    }
    if (masteryId === "ralentissement") {
      if (target) {
        addTokenTag(target, `wm-ralentissement:${state.actor.id}`);
        logTransaction(tx, "Botte d'arme: Ralentissement (-3m vitesse)", opts.onLog);
      }
      continue;
    }
    if (masteryId === "ecorchure") {
      if (target && abilityMod > 0) {
        applyOperation({
          op: {
            op: "DealDamage",
            target: "primary",
            formula: String(Math.max(0, abilityMod)),
            damageType
          },
          tx,
          state,
          explicitTarget: { kind: "token", token: target },
          opts
        });
        logTransaction(tx, "Botte d'arme: Ecorchure", opts.onLog);
      }
      continue;
    }
    if (masteryId === "renversement") {
      if (target) {
        const prof = getProficiencyBonus(state.actor);
        const dc = 8 + abilityMod + prof;
        const mod = ((_f = (_e = target.combatStats) == null ? void 0 : _e.mods) == null ? void 0 : _f.modCON) ?? 0;
        const roll = rollDamage("1d20", { isCrit: false, critRule: "double-dice" });
        const total = roll.total + mod;
        logTransaction(tx, `Renversement: d20 ${roll.total} + ${mod} = ${total} vs DD ${dc}`, opts.onLog);
        if (total < dc) {
          applyOperation({
            op: { op: "ApplyCondition", target: "primary", statusId: "prone", durationTurns: 1 },
            tx,
            state,
            explicitTarget: { kind: "token", token: target },
            opts
          });
        }
      }
      continue;
    }
    if (masteryId === "enchainement") {
      const primary = target;
      if (!primary) continue;
      const hostiles = getHostileTargets(state, state.actor).filter((t2) => t2.id !== primary.id && t2.hp > 0).filter((t2) => distanceBetweenTokens(primary, t2) <= 1.5).filter((t2) => distanceBetweenTokens(state.actor, t2) <= baseRange);
      if (hostiles.length === 0) continue;
      const secondary = hostiles.sort(
        (a2, b2) => distanceBetweenTokens(primary, a2) - distanceBetweenTokens(primary, b2)
      )[0];
      const bonus = ((_g = plan.action.attack) == null ? void 0 : _g.bonus) ?? ((_h = plan.action.resolution) == null ? void 0 : _h.bonus) ?? 0;
      const critRange = ((_i = plan.action.attack) == null ? void 0 : _i.critRange) ?? ((_j = plan.action.resolution) == null ? void 0 : _j.critRange) ?? 20;
      const roll = rollAttack(bonus, "normal", critRange);
      const targetAC = typeof secondary.armorClass === "number" ? secondary.armorClass : null;
      const hit = targetAC === null ? true : roll.total >= targetAC || roll.isCrit;
      logTransaction(tx, `Enchainement: jet ${roll.total}${hit ? " (hit)" : " (miss)"}`, opts.onLog);
      if (hit) {
        const baseFormula = damageFormula ? abilityMod < 0 ? damageFormula : stripAbilityMod(damageFormula, modToken) : "";
        if (baseFormula) {
          const formula = resolveFormula(baseFormula, { actor: state.actor, sampleCharacter: void 0 });
          const dmg = rollDamage(formula, { isCrit: false, critRule: "double-dice" });
          const total = dmg.total;
          secondary.hp = Math.max(0, secondary.hp - total);
          logTransaction(tx, `Enchainement: degats ${total} (${formula})`, opts.onLog);
        }
      }
      continue;
    }
    if (masteryId === "coup_double") {
      const hasLight = tags2.includes("weapon:light");
      if (!hasLight || !target) continue;
      const bonus = ((_k = plan.action.attack) == null ? void 0 : _k.bonus) ?? ((_l = plan.action.resolution) == null ? void 0 : _l.bonus) ?? 0;
      const critRange = ((_m = plan.action.attack) == null ? void 0 : _m.critRange) ?? ((_n = plan.action.resolution) == null ? void 0 : _n.critRange) ?? 20;
      const roll = rollAttack(bonus, "normal", critRange);
      const targetAC = typeof target.armorClass === "number" ? target.armorClass : null;
      const hit = targetAC === null ? true : roll.total >= targetAC || roll.isCrit;
      logTransaction(tx, `Coup double: jet ${roll.total}${hit ? " (hit)" : " (miss)"}`, opts.onLog);
      if (hit) {
        const baseFormula = damageFormula ? abilityMod < 0 ? damageFormula : stripAbilityMod(damageFormula, modToken) : "";
        if (baseFormula) {
          const formula = resolveFormula(baseFormula, { actor: state.actor, sampleCharacter: void 0 });
          const dmg = rollDamage(formula, { isCrit: false, critRule: "double-dice" });
          const total = dmg.total;
          target.hp = Math.max(0, target.hp - total);
          logTransaction(tx, `Coup double: degats ${total} (${formula})`, opts.onLog);
        }
      }
      continue;
    }
  }
}
function collectOperations(effects, outcome) {
  const ops2 = [];
  if (effects == null ? void 0 : effects.onResolve) ops2.push(...effects.onResolve);
  if ((outcome.kind === "hit" || outcome.kind === "checkSuccess" || outcome.kind === "contestedWin") && (effects == null ? void 0 : effects.onHit)) {
    ops2.push(...effects.onHit);
  }
  if ((outcome.kind === "miss" || outcome.kind === "checkFail" || outcome.kind === "contestedLose") && (effects == null ? void 0 : effects.onMiss)) {
    ops2.push(...effects.onMiss);
  }
  if (outcome.kind === "crit") {
    if (effects == null ? void 0 : effects.onHit) ops2.push(...effects.onHit);
    if (effects == null ? void 0 : effects.onCrit) ops2.push(...effects.onCrit);
  }
  if (outcome.kind === "saveSuccess" && (effects == null ? void 0 : effects.onSaveSuccess)) ops2.push(...effects.onSaveSuccess);
  if (outcome.kind === "saveFail" && (effects == null ? void 0 : effects.onSaveFail)) ops2.push(...effects.onSaveFail);
  return ops2;
}
function executePlan(params) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z;
  const { plan, state, opts } = params;
  const tx = beginTransaction(state);
  tx.state.targetingConfig = {
    target: ((_a = plan.action.targeting) == null ? void 0 : _a.target) ?? null,
    maxTargets: typeof ((_b = plan.action.targeting) == null ? void 0 : _b.maxTargets) === "number" ? plan.action.targeting.maxTargets : null
  };
  const initialTarget = plan.target && "id" in plan.target ? plan.target : null;
  const initialTargets = (() => {
    var _a2;
    if (plan.target && "kind" in plan.target && plan.target.kind === "tokens") {
      return plan.target.tokens ?? [];
    }
    if (plan.target && "id" in plan.target) {
      return [plan.target];
    }
    if (((_a2 = plan.action.targeting) == null ? void 0 : _a2.target) === "self") {
      return [tx.state.actor];
    }
    return [];
  })();
  tx.state.targeting = {
    targets: initialTargets.filter(Boolean),
    locked: false
  };
  logPipeline(
    tx,
    `Start action=${plan.action.id} (${plan.action.name}) actor=${tx.state.actor.id} resolution=${((_c = plan.action.resolution) == null ? void 0 : _c.kind) ?? "NO_ROLL"}`,
    opts
  );
  logPipeline(
    tx,
    `Targeting init: mode=${((_d = plan.action.targeting) == null ? void 0 : _d.target) ?? "none"} targets=${((_e = tx.state.targeting.targets) == null ? void 0 : _e.map((t2) => t2.id).join(", ")) || "none"} max=${((_f = plan.action.targeting) == null ? void 0 : _f.maxTargets) ?? "n/a"}`,
    opts
  );
  logPipeline(tx, "Phase 1 BuildIntent", opts);
  applyHooks({
    hooks: plan.hooks ?? [],
    phase: "onIntentBuild",
    state: tx.state,
    target: initialTarget,
    outcome: null,
    explicitTarget: initialTarget ? { kind: "token", token: initialTarget } : null,
    tx,
    opts
  });
  logPipeline(tx, "Phase 2 GatherResolveOptions", opts);
  applyHooks({
    hooks: plan.hooks ?? [],
    phase: "onOptionsResolve",
    state: tx.state,
    target: initialTarget,
    outcome: null,
    explicitTarget: initialTarget ? { kind: "token", token: initialTarget } : null,
    tx,
    opts
  });
  logPipeline(tx, "Phase 3 Validate", opts);
  applyHooks({
    hooks: plan.hooks ?? [],
    phase: "onValidate",
    state: tx.state,
    target: initialTarget,
    outcome: null,
    explicitTarget: initialTarget ? { kind: "token", token: initialTarget } : null,
    tx,
    opts
  });
  logPipeline(tx, "Phase 4 Targeting", opts);
  applyHooks({
    hooks: plan.hooks ?? [],
    phase: "onTargeting",
    state: tx.state,
    target: initialTarget,
    outcome: null,
    explicitTarget: initialTarget ? { kind: "token", token: initialTarget } : null,
    tx,
    opts
  });
  const primaryTarget = ((_h = (_g = tx.state.targeting) == null ? void 0 : _g.targets) == null ? void 0 : _h[0]) ?? initialTarget;
  logPipeline(tx, "Phase 5 PreResolution", opts);
  applyHooks({
    hooks: plan.hooks ?? [],
    phase: "preResolution",
    state: tx.state,
    target: primaryTarget,
    outcome: null,
    explicitTarget: primaryTarget ? { kind: "token", token: primaryTarget } : null,
    tx,
    opts
  });
  if (plan.reactionWindows.includes("pre")) {
    logPipeline(tx, "Pre reaction window open", opts);
    const result = ((_i = opts.onReactionWindow) == null ? void 0 : _i.call(opts, "pre")) ?? "continue";
    if (result === "interrupt") {
      logPipeline(tx, "Interrupted during pre reaction window", opts);
      return {
        ok: false,
        logs: tx.logs,
        state: tx.state,
        interrupted: true,
        outcome: { kind: "miss", roll: 0, total: 0 }
      };
    }
  }
  const targets = (((_j = tx.state.targeting) == null ? void 0 : _j.targets) ?? []).filter(Boolean);
  const resolvedOutcomes = targets.length ? targets.map(
    (target) => resolveOutcome({
      plan,
      state: tx.state,
      advantageMode: params.advantageMode,
      rollOverrides: opts.rollOverrides,
      target
    })
  ) : [
    resolveOutcome({
      plan,
      state: tx.state,
      advantageMode: params.advantageMode,
      rollOverrides: opts.rollOverrides,
      target: null
    })
  ];
  logPipeline(
    tx,
    `Phase 6 ResolveCheck: ${resolvedOutcomes.length} cible(s)`,
    opts
  );
  for (const [index, resolved] of resolvedOutcomes.entries()) {
    const { outcome, target } = resolved;
    const outcomeScopedOpts = {
      ...opts,
      damageContext: {
        isCrit: Boolean(outcome.isCrit || outcome.kind === "crit"),
        critRule: ((_k = plan.action.resolution) == null ? void 0 : _k.critRule) ?? "double-dice"
      }
    };
    const targetLabel = target ? `${target.id}` : "none";
    logPipeline(
      tx,
      `Cible ${index + 1}/${resolvedOutcomes.length}: ${targetLabel} -> outcome=${outcome.kind}`,
      opts
    );
    if (((_l = plan.action.resolution) == null ? void 0 : _l.kind) === "ATTACK_ROLL") {
      const targetAC = target && typeof target.armorClass === "number" ? target.armorClass : null;
      logTransaction(
        tx,
        `Jet de touche (${plan.action.name}) : ${outcome.roll} + ${((_m = plan.action.resolution) == null ? void 0 : _m.bonus) ?? 0} = ${outcome.total}` + (targetAC !== null ? ` vs CA ${targetAC}` : "") + (outcome.isCrit ? " (critique!)" : ""),
        opts.onLog
      );
      if (outcome.kind === "miss") {
        logTransaction(
          tx,
          `L'attaque (${plan.action.name}) rate sa cible. Pas de degats.`,
          opts.onLog
        );
      }
    }
    if (((_n = plan.action.resolution) == null ? void 0 : _n.kind) === "SAVING_THROW" && plan.action.resolution.save) {
      const ability = plan.action.resolution.save.ability;
      const dc = plan.action.resolution.save.dc + (((_o = tx.state.rollContext) == null ? void 0 : _o.dcDelta) ?? 0);
      const modKey = `mod${ability}`;
      const mod = (((_q = (_p = target == null ? void 0 : target.combatStats) == null ? void 0 : _p.mods) == null ? void 0 : _q[modKey]) ?? 0) + (((_r = tx.state.rollContext) == null ? void 0 : _r.bonusDelta) ?? 0);
      logTransaction(
        tx,
        `Jet de sauvegarde (${ability}) : ${outcome.roll} + ${mod} = ${outcome.total} vs DD ${dc}`,
        opts.onLog
      );
    }
    if (((_s = plan.action.resolution) == null ? void 0 : _s.kind) === "ABILITY_CHECK" && plan.action.resolution.check) {
      const ability = plan.action.resolution.check.ability;
      const dc = plan.action.resolution.check.dc + (((_t = tx.state.rollContext) == null ? void 0 : _t.dcDelta) ?? 0);
      const modKey = `mod${ability}`;
      const mod = (((_v = (_u = target == null ? void 0 : target.combatStats) == null ? void 0 : _u.mods) == null ? void 0 : _v[modKey]) ?? 0) + (((_w = tx.state.rollContext) == null ? void 0 : _w.bonusDelta) ?? 0);
      logTransaction(
        tx,
        `Jet de competence (${ability}) : ${outcome.roll} + ${mod} = ${outcome.total} vs DD ${dc}`,
        opts.onLog
      );
    }
    if (((_x = plan.action.resolution) == null ? void 0 : _x.kind) === "CONTESTED_CHECK" && outcome.contested) {
      const actorRoll = outcome.contested.actorRoll;
      const targetRoll = outcome.contested.targetRoll;
      const actorTotal = outcome.contested.actorTotal;
      const targetTotal = outcome.contested.targetTotal;
      logTransaction(
        tx,
        `Jet oppose : acteur ${actorRoll} => ${actorTotal} vs cible ${targetRoll} => ${targetTotal}`,
        opts.onLog
      );
    }
    applyHooks({
      hooks: plan.hooks ?? [],
      phase: "onResolve",
      state: tx.state,
      target,
      outcome,
      explicitTarget: target ? { kind: "token", token: target } : null,
      tx,
      opts
    });
    applyHooks({
      hooks: plan.hooks ?? [],
      phase: "onOutcome",
      state: tx.state,
      target,
      outcome,
      explicitTarget: target ? { kind: "token", token: target } : null,
      tx,
      opts
    });
    applyWeaponMasteryEffects({
      plan,
      state: tx.state,
      tx,
      target,
      outcome,
      opts
    });
    applyHooks({
      hooks: plan.hooks ?? [],
      phase: "beforeApply",
      state: tx.state,
      target,
      outcome,
      explicitTarget: target ? { kind: "token", token: target } : null,
      tx,
      opts
    });
    const ops2 = collectOperations(plan.action.effects, outcome);
    logPipeline(
      tx,
      `Phase 7/8/9 Outcome+Apply: ${ops2.length} operation(s) pour ${targetLabel}`,
      opts
    );
    const explicitTarget = plan.target && "id" in plan.target ? { kind: "token", token: plan.target } : plan.target && "x" in plan.target ? { kind: "cell", x: plan.target.x, y: plan.target.y } : null;
    for (const op of ops2) {
      logPipeline(tx, `Apply op: ${describeOperation(op)}`, opts);
      applyOperation({
        op,
        tx,
        state: tx.state,
        explicitTarget: explicitTarget ?? (target ? { kind: "token", token: target } : null),
        opts: outcomeScopedOpts
      });
    }
    applyHooks({
      hooks: plan.hooks ?? [],
      phase: "afterApply",
      state: tx.state,
      target,
      outcome,
      explicitTarget: target ? { kind: "token", token: target } : null,
      tx,
      opts
    });
    applyHooks({
      hooks: plan.hooks ?? [],
      phase: "postResolution",
      state: tx.state,
      target,
      outcome,
      explicitTarget: target ? { kind: "token", token: target } : null,
      tx,
      opts
    });
  }
  if (plan.reactionWindows.includes("post")) {
    logPipeline(tx, "Post reaction window open", opts);
    const result = ((_y = opts.onReactionWindow) == null ? void 0 : _y.call(opts, "post")) ?? "continue";
    if (result === "interrupt") {
      logPipeline(tx, "Interrupted during post reaction window", opts);
      const lastOutcome = ((_z = resolvedOutcomes[resolvedOutcomes.length - 1]) == null ? void 0 : _z.outcome) ?? { kind: "miss", roll: 0, total: 0 };
      return { ok: false, logs: tx.logs, state: tx.state, interrupted: true, outcome: lastOutcome };
    }
  }
  const lastResolved = resolvedOutcomes[resolvedOutcomes.length - 1] ?? {
    outcome: { kind: "hit", roll: 0, total: 0 },
    target: null
  };
  const finalTarget = lastResolved.target ?? null;
  const finalOutcome = lastResolved.outcome;
  applyHooks({
    hooks: plan.hooks ?? [],
    phase: "beforeCommit",
    state: tx.state,
    target: finalTarget,
    outcome: finalOutcome,
    explicitTarget: finalTarget ? { kind: "token", token: finalTarget } : null,
    tx,
    opts
  });
  applyHooks({
    hooks: plan.hooks ?? [],
    phase: "afterCommit",
    state: tx.state,
    target: finalTarget,
    outcome: finalOutcome,
    explicitTarget: finalTarget ? { kind: "token", token: finalTarget } : null,
    tx,
    opts
  });
  logPipeline(tx, `Phase 11 Commit done: finalOutcome=${finalOutcome.kind}`, opts);
  return { ok: true, logs: tx.logs, state: tx.state, outcome: finalOutcome };
}
const kindMap = {
  ATTACK_ROLL: "ATTACK_ROLL",
  SAVING_THROW: "SAVING_THROW",
  ABILITY_CHECK: "ABILITY_CHECK",
  CONTESTED_CHECK: "CONTESTED_CHECK",
  NO_ROLL: "NO_ROLL"
};
const abilityMap = {
  FOR: "FOR",
  DEX: "DEX",
  CON: "CON",
  INT: "INT",
  SAG: "SAG",
  CHA: "CHA"
};
function mapResolution(action2) {
  var _a, _b, _c;
  if (action2.resolution) {
    const res = action2.resolution;
    const normalized = { ...res };
    if (typeof res.kind === "string" && kindMap[res.kind]) {
      normalized.kind = kindMap[res.kind];
    }
    if (((_a = res.save) == null ? void 0 : _a.ability) && abilityMap[String(res.save.ability)]) {
      normalized.save = { ...res.save, ability: abilityMap[String(res.save.ability)] };
    }
    if (((_b = res.check) == null ? void 0 : _b.ability) && abilityMap[String(res.check.ability)]) {
      normalized.check = { ...res.check, ability: abilityMap[String(res.check.ability)] };
    }
    return normalized;
  }
  if (action2.attack) {
    return {
      kind: "ATTACK_ROLL",
      bonus: action2.attack.bonus,
      critRange: action2.attack.critRange ?? 20,
      critRule: ((_c = action2.damage) == null ? void 0 : _c.critRule) ?? "double-dice"
    };
  }
  return { kind: "NO_ROLL" };
}
function normalizeTargeting(action2) {
  return action2.targeting;
}
function mapEffects(action2) {
  if (!action2.ops) return void 0;
  return action2.ops;
}
function actionDefinitionToActionSpec(action2) {
  return {
    id: action2.id,
    name: action2.name,
    summary: action2.summary,
    targeting: normalizeTargeting(action2),
    resolution: mapResolution(action2),
    effects: mapEffects(action2),
    reactionWindows: action2.reactionWindows ?? [],
    hooks: action2.hooks ?? [],
    tags: action2.tags ?? []
  };
}
function normalizeWeaponModToken(mod) {
  if (!mod) return null;
  const cleaned = String(mod).replace(/\s+/g, "");
  if (cleaned === "mod.FOR" || cleaned === "modFOR") return "modFOR";
  if (cleaned === "mod.DEX" || cleaned === "modDEX") return "modDEX";
  if (cleaned === "mod.CON" || cleaned === "modCON") return "modCON";
  if (cleaned === "mod.INT" || cleaned === "modINT") return "modINT";
  if (cleaned === "mod.SAG" || cleaned === "modSAG" || cleaned === "mod.WIS" || cleaned === "modWIS") {
    return "modSAG";
  }
  if (cleaned === "mod.CHA" || cleaned === "modCHA") return "modCHA";
  return null;
}
function computeWeaponAttackBonus(params) {
  var _a, _b;
  const {
    actor,
    weapon,
    getAbilityModForActor,
    getProficiencyBonusForActor,
    getWeaponProficienciesForActor,
    forceModToken
  } = params;
  const modToken = forceModToken ?? normalizeWeaponModToken(((_a = weapon.attack) == null ? void 0 : _a.mod) ?? null);
  const abilityMod = getAbilityModForActor(actor, modToken);
  const profs = getWeaponProficienciesForActor(actor);
  const proficient = profs.includes(weapon.subtype);
  const profBonus = proficient ? getProficiencyBonusForActor(actor) : 0;
  const bonusSpec = (_b = weapon.attack) == null ? void 0 : _b.bonus;
  const extraBonus = typeof bonusSpec === "number" ? bonusSpec : typeof bonusSpec === "string" && bonusSpec === "bonus_maitrise" ? profBonus : 0;
  return abilityMod + extraBonus;
}
function resolveWeaponModToken(params) {
  var _a, _b, _c;
  const { actor, weapon, getAbilityModForActor } = params;
  const base = normalizeWeaponModToken(((_a = weapon.effectOnHit) == null ? void 0 : _a.mod) ?? ((_b = weapon.attack) == null ? void 0 : _b.mod) ?? null);
  if (!((_c = weapon.properties) == null ? void 0 : _c.finesse)) return base;
  const str = getAbilityModForActor(actor, "modFOR");
  const dex = getAbilityModForActor(actor, "modDEX");
  return dex >= str ? "modDEX" : "modFOR";
}
function buildWeaponOverrideAction(params) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t;
  const { action: action2, weapon, attackBonus, modToken, prefersRanged, useTwoHandedDamage } = params;
  const weaponMasteries = Array.isArray(weapon.weaponMastery) ? weapon.weaponMastery : [];
  const masteryTags = weaponMasteries.map((id2) => `wm-active:${id2}`);
  const weaponTags = [];
  weaponTags.push(`weapon:id:${weapon.id}`);
  if ((_a = weapon.properties) == null ? void 0 : _a.light) weaponTags.push("weapon:light");
  if ((_b = weapon.properties) == null ? void 0 : _b.heavy) weaponTags.push("weapon:heavy");
  if ((_c = weapon.properties) == null ? void 0 : _c.thrown) weaponTags.push("weapon:thrown");
  if ((_d = weapon.properties) == null ? void 0 : _d.twoHanded) weaponTags.push("weapon:two-handed");
  if ((_e = weapon.properties) == null ? void 0 : _e.loading) weaponTags.push("weapon:loading");
  if ((_f = weapon.properties) == null ? void 0 : _f.ammunition) weaponTags.push("weapon:ammunition");
  const useRangedMode = Boolean(prefersRanged);
  weaponTags.push(useRangedMode ? "weapon:mode:ranged" : "weapon:mode:melee");
  const normalRange = useRangedMode && ((_g = weapon.properties) == null ? void 0 : _g.thrown) ? weapon.properties.thrown.normal : ((_i = (_h = weapon.properties) == null ? void 0 : _h.range) == null ? void 0 : _i.normal) ?? ((_j = weapon.properties) == null ? void 0 : _j.reach) ?? null;
  const longRange = useRangedMode && ((_k = weapon.properties) == null ? void 0 : _k.thrown) ? weapon.properties.thrown.long : ((_m = (_l = weapon.properties) == null ? void 0 : _l.range) == null ? void 0 : _m.long) ?? null;
  if (typeof normalRange === "number" && normalRange > 0) {
    weaponTags.push(`weapon:range-normal:${normalRange}`);
  }
  if (typeof longRange === "number" && longRange > 0) {
    weaponTags.push(`weapon:range-long:${longRange}`);
  }
  const nextTags = Array.from(/* @__PURE__ */ new Set([...action2.tags ?? [], ...masteryTags, ...weaponTags]));
  const versatileDice = (_n = weapon.properties) == null ? void 0 : _n.versatile;
  const canUseVersatile = !useRangedMode && Boolean(useTwoHandedDamage) && typeof versatileDice === "string" && versatileDice.trim().length > 0;
  const damageDice = canUseVersatile && typeof versatileDice === "string" ? versatileDice : ((_o = weapon.effectOnHit) == null ? void 0 : _o.damage) ?? ((_p = weapon.damage) == null ? void 0 : _p.dice) ?? null;
  const damageType = ((_q = weapon.effectOnHit) == null ? void 0 : _q.damageType) ?? ((_r = weapon.damage) == null ? void 0 : _r.damageType) ?? null;
  const finalModToken = modToken ?? normalizeWeaponModToken(((_s = weapon.effectOnHit) == null ? void 0 : _s.mod) ?? ((_t = weapon.attack) == null ? void 0 : _t.mod));
  if (!damageDice) {
    return {
      ...action2,
      tags: nextTags,
      ops: mergeWeaponExtraDamageOps(action2.ops, weapon)
    };
  }
  const formula = finalModToken ? `${damageDice} + ${finalModToken}` : damageDice;
  const nextRangeMax = typeof longRange === "number" && longRange > 0 ? longRange : typeof normalRange === "number" && normalRange > 0 ? normalRange : action2.targeting.range.max;
  const nextBase = {
    ...action2,
    tags: nextTags,
    attack: action2.attack ? { ...action2.attack, bonus: attackBonus } : { bonus: attackBonus, critRange: 20 },
    damage: action2.damage ? { ...action2.damage, formula, damageType: damageType ?? action2.damage.damageType } : action2.damage,
    targeting: action2.targeting ? {
      ...action2.targeting,
      range: {
        ...action2.targeting.range,
        max: nextRangeMax
      }
    } : action2.targeting,
    ops: action2.ops ? Object.fromEntries(
      Object.entries(action2.ops).map(([key2, list]) => [
        key2,
        Array.isArray(list) ? list.map((op) => {
          var _a2;
          if ((op == null ? void 0 : op.op) !== "DealDamage") return op;
          const currentFormula = String(op.formula ?? "");
          const shouldOverride = currentFormula === ((_a2 = action2.damage) == null ? void 0 : _a2.formula);
          if (!shouldOverride) return op;
          return {
            ...op,
            formula,
            damageType: damageType ?? op.damageType
          };
        }) : list
      ])
    ) : action2.ops
  };
  return {
    ...nextBase,
    ops: mergeWeaponExtraDamageOps(nextBase.ops, weapon)
  };
}
function normalizeExtraDamageBranch(when) {
  if (when === "onResolve") return "onResolve";
  if (when === "onCrit") return "onCrit";
  if (when === "onMiss") return "onMiss";
  return "onHit";
}
function mergeWeaponExtraDamageOps(ops2, weapon) {
  const extra = Array.isArray(weapon.extraDamage) ? weapon.extraDamage : [];
  if (extra.length === 0) return ops2;
  const nextOps = {
    onResolve: Array.isArray(ops2 == null ? void 0 : ops2.onResolve) ? [...ops2.onResolve] : [],
    onHit: Array.isArray(ops2 == null ? void 0 : ops2.onHit) ? [...ops2.onHit] : [],
    onMiss: Array.isArray(ops2 == null ? void 0 : ops2.onMiss) ? [...ops2.onMiss] : [],
    onCrit: Array.isArray(ops2 == null ? void 0 : ops2.onCrit) ? [...ops2.onCrit] : [],
    onSaveSuccess: Array.isArray(ops2 == null ? void 0 : ops2.onSaveSuccess) ? [...ops2.onSaveSuccess] : [],
    onSaveFail: Array.isArray(ops2 == null ? void 0 : ops2.onSaveFail) ? [...ops2.onSaveFail] : []
  };
  const existingKeySet = /* @__PURE__ */ new Set();
  ["onResolve", "onHit", "onMiss", "onCrit"].forEach((branch) => {
    const list = nextOps[branch] ?? [];
    list.forEach((op) => {
      if ((op == null ? void 0 : op.op) !== "DealDamage") return;
      const source2 = String((op == null ? void 0 : op.source) ?? "");
      const sourceWeaponId = String((op == null ? void 0 : op.sourceWeaponId) ?? "");
      const formula = String((op == null ? void 0 : op.formula) ?? "");
      const damageType = String((op == null ? void 0 : op.damageType) ?? "");
      if (source2 !== "weapon-extraDamage") return;
      existingKeySet.add(`${sourceWeaponId}|${branch}|${formula}|${damageType}`);
    });
  });
  extra.forEach((entry) => {
    if (!entry) return;
    const formula = String(entry.dice ?? "").trim();
    const damageType = String(entry.damageType ?? "").trim();
    if (!formula || !damageType) return;
    const branch = normalizeExtraDamageBranch(entry.when);
    const dedupeKey = `${weapon.id}|${branch}|${formula}|${damageType}`;
    if (existingKeySet.has(dedupeKey)) return;
    existingKeySet.add(dedupeKey);
    (nextOps[branch] ?? (nextOps[branch] = [])).push({
      op: "DealDamage",
      target: "primary",
      formula,
      damageType,
      source: "weapon-extraDamage",
      sourceWeaponId: weapon.id
    });
  });
  return nextOps;
}
function getWeaponIdFromActionTags(tags2) {
  if (!Array.isArray(tags2)) return null;
  const token = tags2.find((tag) => typeof tag === "string" && tag.startsWith("weapon:id:"));
  if (!token) return null;
  const value2 = token.slice("weapon:id:".length).trim();
  return value2.length > 0 ? value2 : null;
}
function getWeaponLoadingUsageKey(action2) {
  var _a;
  const tags2 = Array.isArray(action2.tags) ? action2.tags : [];
  if (!tags2.includes("weapon:loading")) return null;
  const actionType = (_a = action2.actionCost) == null ? void 0 : _a.actionType;
  if (actionType !== "action" && actionType !== "bonus" && actionType !== "reaction") return null;
  const weaponId = getWeaponIdFromActionTags(tags2) ?? action2.id;
  return `weapon:loading:${weaponId}:${actionType}`;
}
function areOnSameBaseLevel(ctx, a2, b2) {
  var _a, _b;
  if (!ctx.heightMap || ctx.heightMap.length === 0) return true;
  const cols = ((_a = ctx.grid) == null ? void 0 : _a.cols) ?? GRID_COLS;
  const rows = ((_b = ctx.grid) == null ? void 0 : _b.rows) ?? GRID_ROWS;
  const ha = getHeightAtGrid(ctx.heightMap, cols, rows, a2.x, a2.y);
  const hb = getHeightAtGrid(ctx.heightMap, cols, rows, b2.x, b2.y);
  return ha === hb;
}
function getLightAtToken(ctx, token) {
  var _a;
  if (!ctx.lightLevels || ctx.lightLevels.length === 0) return null;
  const cols = ((_a = ctx.grid) == null ? void 0 : _a.cols) ?? GRID_COLS;
  const idx = token.y * cols + token.x;
  const value2 = ctx.lightLevels[idx];
  return Number.isFinite(value2) ? value2 : null;
}
function isInLight(ctx, token) {
  const value2 = getLightAtToken(ctx, token);
  if (value2 === null) return null;
  return value2 > 0;
}
function isCellAllowed(params) {
  var _a, _b;
  const { ctx, state, x: x2, y: y2, excludeIds } = params;
  const cols = ((_a = ctx.grid) == null ? void 0 : _a.cols) ?? GRID_COLS;
  const rows = ((_b = ctx.grid) == null ? void 0 : _b.rows) ?? GRID_ROWS;
  if (!isCellInsideGrid(x2, y2, cols, rows)) return false;
  if (ctx.playableCells && ctx.playableCells.size > 0) {
    const key2 = `${x2},${y2}`;
    if (!ctx.playableCells.has(key2)) return false;
  }
  if (ctx.blockedMovementCells && ctx.blockedMovementCells.size > 0) {
    const key2 = `${x2},${y2}`;
    if (ctx.blockedMovementCells.has(key2)) return false;
  }
  if (ctx.heightMap && typeof ctx.activeLevel === "number") {
    const h2 = getHeightAtGrid(ctx.heightMap, cols, rows, x2, y2);
    if (h2 !== ctx.activeLevel) return false;
  }
  const occupied = [state.player, ...state.enemies].some(
    (token) => !(excludeIds == null ? void 0 : excludeIds.includes(token.id)) && token.x === x2 && token.y === y2
  );
  if (occupied) return false;
  return true;
}
function updateTokenPosition(params) {
  const { state, token, x: x2, y: y2 } = params;
  token.x = x2;
  token.y = y2;
  if (token.id === state.player.id) {
    state.player = token;
    return;
  }
  const idx = state.enemies.findIndex((e2) => e2.id === token.id);
  if (idx >= 0) state.enemies[idx] = token;
}
function getTokensForPath(ctx, state) {
  var _a, _b;
  if (!ctx.heightMap || typeof ctx.activeLevel !== "number") {
    return [state.player, ...state.enemies];
  }
  const cols = ((_a = ctx.grid) == null ? void 0 : _a.cols) ?? GRID_COLS;
  const rows = ((_b = ctx.grid) == null ? void 0 : _b.rows) ?? GRID_ROWS;
  return [state.player, ...state.enemies].filter((token) => {
    const baseHeight = getHeightAtGrid(ctx.heightMap, cols, rows, token.x, token.y);
    return baseHeight === ctx.activeLevel;
  });
}
function applyForcedMove(params) {
  const { ctx, state, token, to } = params;
  const dx = to.x - token.x;
  const dy = to.y - token.y;
  const steps = Math.max(Math.abs(dx), Math.abs(dy));
  if (steps === 0) return;
  const tokensForPath = getTokensForPath(ctx, state);
  const path2 = computePathTowards(token, { x: to.x, y: to.y }, tokensForPath, {
    maxDistance: Math.max(0, steps),
    allowTargetOccupied: false,
    blockedCells: ctx.blockedMovementCells ?? null,
    wallEdges: ctx.blockedMovementEdges ?? null,
    playableCells: ctx.playableCells ?? null,
    grid: ctx.grid ?? null,
    heightMap: ctx.heightMap ?? null,
    floorIds: ctx.floorIds ?? null,
    activeLevel: ctx.activeLevel ?? null
  });
  if (path2.length === 0) return;
  const destination = path2[path2.length - 1];
  updateTokenPosition({ state, token, x: destination.x, y: destination.y });
}
function applyTeleport(params) {
  const { ctx, state, token, to } = params;
  if (!isCellAllowed({ ctx, state, x: to.x, y: to.y, excludeIds: [token.id] })) {
    return;
  }
  updateTokenPosition({ state, token, x: to.x, y: to.y });
}
function applyDisplace(params) {
  const { ctx, state, token, direction, distance: distance2 } = params;
  const steps = Math.max(0, Math.round(distance2));
  if (steps <= 0) return;
  const stepX = direction.x === 0 ? 0 : direction.x > 0 ? 1 : -1;
  const stepY = direction.y === 0 ? 0 : direction.y > 0 ? 1 : -1;
  const targetX = token.x + stepX * steps;
  const targetY = token.y + stepY * steps;
  const tokensForPath = getTokensForPath(ctx, state);
  const path2 = computePathTowards(token, { x: targetX, y: targetY }, tokensForPath, {
    maxDistance: steps,
    allowTargetOccupied: false,
    blockedCells: ctx.blockedMovementCells ?? null,
    wallEdges: ctx.blockedMovementEdges ?? null,
    playableCells: ctx.playableCells ?? null,
    grid: ctx.grid ?? null,
    heightMap: ctx.heightMap ?? null,
    floorIds: ctx.floorIds ?? null,
    activeLevel: ctx.activeLevel ?? null
  });
  if (path2.length === 0) return;
  const destination = path2[path2.length - 1];
  updateTokenPosition({ state, token, x: destination.x, y: destination.y });
}
function applySwapPositions(params) {
  const { ctx, state, a: a2, b: b2 } = params;
  if (!isCellAllowed({ ctx, state, x: b2.x, y: b2.y, excludeIds: [a2.id, b2.id] }) || !isCellAllowed({ ctx, state, x: a2.x, y: a2.y, excludeIds: [a2.id, b2.id] })) {
    return;
  }
  const ax = a2.x;
  const ay = a2.y;
  updateTokenPosition({ state, token: a2, x: b2.x, y: b2.y });
  updateTokenPosition({ state, token: b2, x: ax, y: ay });
}
function resolveTokenInState(state, id2) {
  if (state.player.id === id2) return state.player;
  return state.enemies.find((e2) => e2.id === id2) ?? null;
}
function getTokenSide(token) {
  return token.summonOwnerType ?? token.type;
}
function isHostileTarget(actor, targetToken) {
  return getTokenSide(actor) !== getTokenSide(targetToken);
}
function isAllyTarget(actor, targetToken) {
  return getTokenSide(actor) === getTokenSide(targetToken);
}
function validateTokenTarget(action2, ctx, targetToken) {
  var _a, _b, _c, _d, _e, _f;
  const actor = ctx.actor;
  const allTokens = [ctx.player, ...ctx.enemies];
  if (targetToken.hp <= 0) {
    return { ok: false, reason: "La cible est deja a terre." };
  }
  if (!areOnSameBaseLevel(ctx, actor, targetToken)) {
    return { ok: false, reason: "Cible sur un autre niveau." };
  }
  const dist = distanceBetweenTokens(actor, targetToken);
  const range = (_a = action2.targeting) == null ? void 0 : _a.range;
  if (range) {
    if (typeof range.min === "number" && dist < range.min) {
      return {
        ok: false,
        reason: `Cible trop proche pour ${action2.name} (distance ${dist}, min ${range.min}).`
      };
    }
    if (typeof range.max === "number" && dist > range.max) {
      return {
        ok: false,
        reason: `Cible hors portee pour ${action2.name} (distance ${dist}, max ${range.max}).`
      };
    }
  }
  if (Array.isArray(action2.conditions) && action2.conditions.length > 0) {
    const ok = evaluateAllConditions(action2.conditions, {
      actor,
      target: targetToken,
      distance: dist,
      phase: ctx.enginePhase ?? ctx.phase,
      sameLevel: areOnSameBaseLevel(ctx, actor, targetToken),
      targetInArea: ((_c = (_b = action2.targeting) == null ? void 0 : _b.range) == null ? void 0 : _c.shape) && typeof action2.targeting.range.max === "number" ? dist <= action2.targeting.range.max : null,
      inLight: isInLight(ctx, targetToken),
      lineOfSight: ((_d = action2.targeting) == null ? void 0 : _d.requiresLos) ? isTargetVisible(
        actor,
        targetToken,
        allTokens,
        ctx.blockedVisionCells ?? null,
        ctx.playableCells ?? null,
        ctx.wallVisionEdges ?? null,
        ctx.lightLevels ?? null,
        ctx.grid ?? null
      ) : null,
      getResourceAmount: ctx.getResourceAmount,
      getSlotAmount: ctx.getSlotAmount,
      usage: ctx.usage ?? null,
      reactionAvailable: ctx.reactionAvailable ?? null,
      concentrating: ctx.concentrating ?? null,
      surprised: ctx.surprised ?? null
    });
    if (!ok) {
      const firstReason = (_e = action2.conditions.find((cond) => cond.reason)) == null ? void 0 : _e.reason;
      return { ok: false, reason: firstReason || "Conditions non remplies." };
    }
  }
  if ((_f = action2.targeting) == null ? void 0 : _f.requiresLos) {
    const visible = isTargetVisible(
      actor,
      targetToken,
      allTokens,
      ctx.blockedVisionCells ?? null,
      ctx.playableCells ?? null,
      ctx.wallVisionEdges ?? null,
      ctx.lightLevels ?? null,
      ctx.grid ?? null
    );
    if (!visible) {
      return { ok: false, reason: "Cible hors vision (ligne de vue requise)." };
    }
    const targetCell = getClosestFootprintCellToPoint({ x: actor.x, y: actor.y }, targetToken) ?? { x: targetToken.x, y: targetToken.y };
    const canHit = hasLineOfEffect(
      { x: actor.x, y: actor.y },
      targetCell,
      ctx.blockedAttackCells ?? null,
      ctx.wallVisionEdges ?? null
    );
    if (!canHit) {
      return { ok: false, reason: "Trajectoire bloquee (obstacle entre l'attaquant et la cible)." };
    }
  }
  return { ok: true };
}
function validateActionTarget(action2, ctx, target) {
  var _a, _b;
  const actor = ctx.actor;
  const targeting2 = action2.targeting;
  if (!targeting2) return { ok: false, reason: "Action sans ciblage." };
  if (targeting2.target === "self") {
    return { ok: true };
  }
  if (targeting2.target === "enemy") {
    if (target.kind === "tokens") {
      const tokens = target.tokens.filter((t2) => t2.type === "enemy");
      if (tokens.length === 0) return { ok: false, reason: "Cible ennemi manquante." };
      if (typeof targeting2.maxTargets === "number" && tokens.length > targeting2.maxTargets) {
        return { ok: false, reason: "Trop de cibles." };
      }
      for (const token of tokens) {
        const res = validateTokenTarget(action2, ctx, token);
        if (!res.ok) return res;
      }
      return { ok: true };
    }
    if (target.kind !== "token" || target.token.type !== "enemy") {
      return { ok: false, reason: "Cible ennemi manquante." };
    }
    return validateTokenTarget(action2, ctx, target.token);
  }
  if (targeting2.target === "player") {
    const playerToken = target.kind === "token" ? target.token : ctx.player;
    if (!playerToken || playerToken.id !== ctx.player.id) {
      return { ok: false, reason: "Cible joueur manquante." };
    }
    return validateTokenTarget(action2, ctx, playerToken);
  }
  if (targeting2.target === "hostile") {
    let targetToken = null;
    if (target.kind === "tokens") {
      const tokens = target.tokens.filter((t2) => isHostileTarget(actor, t2));
      if (tokens.length === 0) return { ok: false, reason: "Cible hostile manquante." };
      if (typeof targeting2.maxTargets === "number" && tokens.length > targeting2.maxTargets) {
        return { ok: false, reason: "Trop de cibles." };
      }
      for (const token of tokens) {
        const res = validateTokenTarget(action2, ctx, token);
        if (!res.ok) return res;
      }
      return { ok: true };
    }
    if (target.kind === "token") {
      targetToken = target.token;
    } else if (actor.type === "enemy") {
      targetToken = ctx.player;
    }
    if (!targetToken || !isHostileTarget(actor, targetToken)) {
      return { ok: false, reason: "Cible hostile manquante." };
    }
    return validateTokenTarget(action2, ctx, targetToken);
  }
  if (targeting2.target === "ally") {
    if (target.kind === "tokens") {
      const tokens = target.tokens.filter((t2) => isAllyTarget(actor, t2));
      if (tokens.length === 0) return { ok: false, reason: "Cible allie manquante." };
      if (typeof targeting2.maxTargets === "number" && tokens.length > targeting2.maxTargets) {
        return { ok: false, reason: "Trop de cibles." };
      }
      for (const token of tokens) {
        const res = validateTokenTarget(action2, ctx, token);
        if (!res.ok) return res;
      }
      return { ok: true };
    }
    if (target.kind !== "token") {
      return { ok: false, reason: "Cible allie manquante." };
    }
    if (!isAllyTarget(actor, target.token)) {
      return { ok: false, reason: "Cible allie invalide." };
    }
    return validateTokenTarget(action2, ctx, target.token);
  }
  if (targeting2.target === "emptyCell" || targeting2.target === "cell") {
    if (target.kind !== "cell") {
      return { ok: false, reason: "Cible de case manquante." };
    }
    const cols = ((_a = ctx.grid) == null ? void 0 : _a.cols) ?? GRID_COLS;
    const rows = ((_b = ctx.grid) == null ? void 0 : _b.rows) ?? GRID_ROWS;
    if (!isCellInsideGrid(target.x, target.y, cols, rows)) {
      return { ok: false, reason: "Case hors plateau." };
    }
    if (ctx.playableCells && ctx.playableCells.size > 0) {
      const k2 = `${target.x},${target.y}`;
      if (!ctx.playableCells.has(k2)) {
        return { ok: false, reason: "Case hors zone jouable." };
      }
    }
    return { ok: true };
  }
  return { ok: false, reason: "Type de ciblage non supporte." };
}
function computeAvailabilityForActor(action2, ctx) {
  var _a, _b, _c, _d;
  const reasons = [];
  const details = [];
  const availabilityConditions = (action2.conditions || []).filter((cond) => {
    return !["TARGET_ALIVE", "DISTANCE_MAX", "DISTANCE_BETWEEN"].includes(cond.type);
  });
  if (availabilityConditions.length > 0) {
    const ok = evaluateAllConditions(availabilityConditions, {
      actor: ctx.actor,
      target: ctx.player,
      phase: ctx.enginePhase ?? ctx.phase,
      getResourceAmount: ctx.getResourceAmount,
      getSlotAmount: ctx.getSlotAmount,
      usage: ctx.usage ?? null,
      reactionAvailable: ctx.reactionAvailable ?? null,
      concentrating: ctx.concentrating ?? null,
      surprised: ctx.surprised ?? null,
      inLight: isInLight(ctx, ctx.actor),
      sameLevel: true,
      valueLookup: {
        actor: {
          hp: ctx.actor.hp,
          maxHp: ctx.actor.maxHp
        }
      }
    });
    if (!ok) {
      const firstReason = (_a = availabilityConditions.find((cond) => cond.reason)) == null ? void 0 : _a.reason;
      reasons.push(firstReason || "Conditions non remplies.");
    }
  }
  const usageResource = (_b = action2.usage) == null ? void 0 : _b.resource;
  if (ctx.getResourceAmount && (usageResource == null ? void 0 : usageResource.name) && typeof usageResource.min === "number") {
    const amount = ctx.getResourceAmount(usageResource.name, usageResource.pool ?? null);
    if (amount < usageResource.min) {
      const poolSuffix = usageResource.pool ? ` (${usageResource.pool})` : "";
      reasons.push(
        `Ressource insuffisante: ${usageResource.name}${poolSuffix} (${amount}/${usageResource.min}).`
      );
    }
  }
  const loadingUsageKey = getWeaponLoadingUsageKey(action2);
  if (loadingUsageKey) {
    const count2 = Number(((_d = (_c = ctx.usage) == null ? void 0 : _c.turn) == null ? void 0 : _d[loadingUsageKey]) ?? 0);
    if (count2 >= 1) {
      reasons.push("Arme a chargement: deja utilisee pour ce type d'action ce tour.");
    }
  }
  if (ctx.getActionConstraintIssues) {
    const issues = ctx.getActionConstraintIssues({
      action: action2,
      actor: ctx.actor
    });
    if (Array.isArray(issues) && issues.length > 0) {
      reasons.push(...issues.filter((issue) => typeof issue === "string" && issue.trim().length > 0));
    }
  }
  return { enabled: reasons.length === 0, reasons, details };
}
function parseWeaponTagNumber(tags2, prefix) {
  if (!Array.isArray(tags2)) return null;
  const token = tags2.find((tag) => typeof tag === "string" && tag.startsWith(prefix));
  if (!token) return null;
  const raw = token.slice(prefix.length);
  const value2 = Number(raw);
  return Number.isFinite(value2) ? value2 : null;
}
function getAbilityScoreForActor(params) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const { actor, ability, sampleCharacter: sampleCharacter2 } = params;
  if (actor.type === "player") {
    const score = ability === "FOR" ? (_b = (_a = sampleCharacter2 == null ? void 0 : sampleCharacter2.caracs) == null ? void 0 : _a.force) == null ? void 0 : _b.FOR : (_d = (_c = sampleCharacter2 == null ? void 0 : sampleCharacter2.caracs) == null ? void 0 : _c.dexterite) == null ? void 0 : _d.DEX;
    if (typeof score === "number" && Number.isFinite(score)) return score;
  }
  const mod = ability === "FOR" ? (_f = (_e = actor.combatStats) == null ? void 0 : _e.mods) == null ? void 0 : _f.modFOR : (_h = (_g = actor.combatStats) == null ? void 0 : _g.mods) == null ? void 0 : _h.modDEX;
  if (typeof mod === "number" && Number.isFinite(mod)) return Math.floor(mod * 2 + 10);
  return 10;
}
function mergeAdvantageMode(base, scoreDelta) {
  const baseScore = base === "advantage" ? 1 : base === "disadvantage" ? -1 : 0;
  const score = baseScore + scoreDelta;
  if (score > 0) return "advantage";
  if (score < 0) return "disadvantage";
  return "normal";
}
function resolveActionUnified(action2, ctx, target, opts) {
  var _a, _b;
  const logs = [];
  const log2 = (m2) => {
    var _a2;
    logs.push(m2);
    (_a2 = ctx.onLog) == null ? void 0 : _a2.call(ctx, m2);
  };
  const availability = computeAvailabilityForActor(action2, ctx);
  if (!availability.enabled) {
    return { ok: false, reason: availability.reasons.join(" | "), logs };
  }
  const validation = validateActionTarget(action2, ctx, target);
  if (!validation.ok) {
    return { ok: false, reason: validation.reason, logs };
  }
  const actor = {
    ...ctx.actor,
    tags: Array.isArray(ctx.actor.tags) ? [...ctx.actor.tags] : [],
    combatStats: ctx.actor.combatStats ? {
      ...ctx.actor.combatStats,
      tags: Array.isArray(ctx.actor.combatStats.tags) ? [...ctx.actor.combatStats.tags] : []
    } : ctx.actor.combatStats
  };
  let player = { ...ctx.player };
  const enemies = ctx.enemies.map((e2) => ({ ...e2 }));
  const actionSpec = actionDefinitionToActionSpec(action2);
  const activeMasteryIds = (actionSpec.tags ?? []).filter((tag) => typeof tag === "string" && tag.startsWith("wm-active:")).map((tag) => tag.replace(/^wm-active:/, "")).filter(Boolean);
  if (activeMasteryIds.length > 0) {
    const tagSet = new Set(actor.tags ?? []);
    activeMasteryIds.forEach((id2) => tagSet.add(`wm-active:${id2}`));
    actor.tags = Array.from(tagSet);
  }
  if (Array.isArray(actor.tags) && actor.tags.some((tag) => tag === "wm-ralentissement" || tag.startsWith("wm-ralentissement:"))) {
    const baseRange = typeof actor.moveRange === "number" ? actor.moveRange : (_a = actor.combatStats) == null ? void 0 : _a.moveRange;
    if (typeof baseRange === "number") {
      actor.moveRange = Math.max(0, baseRange - 3);
    }
  }
  const masteryTriggerTags = buildWeaponMasteryTriggerTags({
    activeMasteryIds,
    masteryActions: (opts == null ? void 0 : opts.weaponMasteryActions) ?? []
  });
  if (masteryTriggerTags.length > 0) {
    const currentTags = actionSpec.tags ?? [];
    actionSpec.tags = Array.from(/* @__PURE__ */ new Set([...currentTags, ...masteryTriggerTags]));
  }
  const plan = compileActionPlan({
    action: actionSpec,
    actor,
    target: target.kind === "token" ? target.token : target.kind === "tokens" ? { kind: "tokens", tokens: target.tokens } : target.kind === "cell" ? { x: target.x, y: target.y } : null
  });
  let computedAdvantageMode = opts == null ? void 0 : opts.advantageMode;
  if (action2.category === "attack" && target.kind === "token") {
    const tags2 = actionSpec.tags ?? [];
    let penaltyScore = 0;
    const targetStatuses = Array.isArray(target.token.statuses) ? target.token.statuses : [];
    const targetIsDodging = targetStatuses.some((status) => String(status.id).toLowerCase() === "dodge");
    if (targetIsDodging) {
      penaltyScore -= 1;
    }
    const normalRange = parseWeaponTagNumber(tags2, "weapon:range-normal:");
    if (typeof normalRange === "number" && normalRange > 0) {
      const dist = distanceBetweenTokens(actor, target.token);
      if (dist > normalRange) penaltyScore -= 1;
    }
    if (tags2.includes("weapon:heavy")) {
      const modeIsRanged = tags2.includes("weapon:mode:ranged");
      if (modeIsRanged) {
        const dexScore = getAbilityScoreForActor({
          actor,
          ability: "DEX",
          sampleCharacter: ctx.sampleCharacter
        });
        if (dexScore < 13) penaltyScore -= 1;
      } else {
        const strScore = getAbilityScoreForActor({
          actor,
          ability: "FOR",
          sampleCharacter: ctx.sampleCharacter
        });
        if (strScore < 13) penaltyScore -= 1;
      }
    }
    computedAdvantageMode = mergeAdvantageMode(opts == null ? void 0 : opts.advantageMode, penaltyScore);
  }
  const applyMoveTo = (params) => {
    var _a2, _b2, _c;
    const { state, targetCell } = params;
    const targetX = targetCell.x;
    const targetY = targetCell.y;
    let maxSteps = params.maxSteps ?? null;
    if (typeof maxSteps === "number") {
      maxSteps = metersToCells(maxSteps);
    }
    if (maxSteps === null) {
      maxSteps = typeof state.actor.moveRange === "number" ? metersToCells(state.actor.moveRange) : typeof ((_a2 = state.actor.movementProfile) == null ? void 0 : _a2.speed) === "number" ? metersToCells(state.actor.movementProfile.speed) : 3;
    }
    const cols = ((_b2 = ctx.grid) == null ? void 0 : _b2.cols) ?? GRID_COLS;
    const rows = ((_c = ctx.grid) == null ? void 0 : _c.rows) ?? GRID_ROWS;
    const clampedX = clamp$5(targetX, 0, cols - 1);
    const clampedY = clamp$5(targetY, 0, rows - 1);
    if (!isCellInsideGrid(clampedX, clampedY, cols, rows)) return;
    if (ctx.playableCells && ctx.playableCells.size > 0) {
      const k2 = `${clampedX},${clampedY}`;
      if (!ctx.playableCells.has(k2)) return;
    }
    const tokensForPath = (() => {
      var _a3, _b3;
      if (!ctx.heightMap || typeof ctx.activeLevel !== "number") {
        return [state.player, ...state.enemies];
      }
      const cols2 = ((_a3 = ctx.grid) == null ? void 0 : _a3.cols) ?? GRID_COLS;
      const rows2 = ((_b3 = ctx.grid) == null ? void 0 : _b3.rows) ?? GRID_ROWS;
      return [state.player, ...state.enemies].filter((t2) => {
        const baseHeight = getHeightAtGrid(ctx.heightMap, cols2, rows2, t2.x, t2.y);
        return baseHeight === ctx.activeLevel;
      });
    })();
    const path2 = computePathTowards(state.actor, { x: clampedX, y: clampedY }, tokensForPath, {
      maxDistance: Math.max(0, maxSteps),
      allowTargetOccupied: false,
      blockedCells: ctx.blockedMovementCells ?? null,
      wallEdges: ctx.blockedMovementEdges ?? null,
      playableCells: ctx.playableCells ?? null,
      grid: ctx.grid ?? null,
      heightMap: ctx.heightMap ?? null,
      floorIds: ctx.floorIds ?? null,
      activeLevel: ctx.activeLevel ?? null
    });
    state.actor.plannedPath = path2;
    if (path2.length === 0) return;
    const destination = path2[path2.length - 1];
    state.actor.x = destination.x;
    state.actor.y = destination.y;
    if (state.actor.type === "enemy") {
      const idx = state.enemies.findIndex((e2) => e2.id === state.actor.id);
      if (idx >= 0) state.enemies[idx] = state.actor;
    } else {
      state.player = state.actor;
    }
  };
  const exec = executePlan({
    plan,
    state: {
      round: ctx.round,
      phase: ctx.phase,
      actor,
      player,
      enemies,
      effects: []
    },
    opts: {
      isTargetAllowed: (token) => validateActionTarget(action2, ctx, { kind: "token", token }).ok,
      getResourceAmount: ctx.getResourceAmount,
      spendResource: ctx.spendResource,
      spawnEntity: ctx.spawnEntity,
      despawnEntity: ctx.despawnEntity,
      controlSummon: ctx.controlSummon,
      rollOverrides: opts == null ? void 0 : opts.rollOverrides,
      onLog: log2,
      onEmitEvent: ctx.emitEvent,
      onMoveTo: applyMoveTo,
      onMoveForced: (params) => {
        const token = resolveTokenInState(params.state, params.targetId);
        if (!token) return;
        applyForcedMove({
          ctx,
          state: params.state,
          token,
          to: params.to
        });
      },
      onTeleport: (params) => {
        const token = resolveTokenInState(params.state, params.targetId);
        if (!token) return;
        applyTeleport({
          ctx,
          state: params.state,
          token,
          to: params.to
        });
      },
      onSwapPositions: (params) => {
        const a2 = resolveTokenInState(params.state, params.aId);
        const b2 = resolveTokenInState(params.state, params.bId);
        if (!a2 || !b2) return;
        applySwapPositions({ ctx, state: params.state, a: a2, b: b2 });
      },
      onDisplace: (params) => {
        const token = resolveTokenInState(params.state, params.targetId);
        if (!token) return;
        applyDisplace({
          ctx,
          state: params.state,
          token,
          direction: params.direction,
          distance: params.distance
        });
      },
      onModifyPathLimit: ctx.onModifyPathLimit,
      onToggleTorch: ctx.onToggleTorch,
      onSetKillerInstinctTarget: ctx.onSetKillerInstinctTarget,
      onGrantTempHp: ctx.onGrantTempHp,
      onPlayVisualEffect: ctx.onPlayVisualEffect
    },
    advantageMode: computedAdvantageMode
  });
  if (!exec.ok) {
    return {
      ok: false,
      reason: exec.interrupted ? "Interruption par reaction." : "Echec de resolution.",
      logs: exec.logs.length ? exec.logs : logs
    };
  }
  player = exec.state.player;
  const enemiesAfter = exec.state.enemies.map((enemy) => ({ ...enemy }));
  const actorAfter = actor.type === "player" ? exec.state.player : enemiesAfter.find((e2) => e2.id === actor.id) ?? actor;
  return {
    ok: true,
    logs: exec.logs.length ? exec.logs : logs,
    actorAfter,
    playerAfter: player,
    enemiesAfter,
    outcomeKind: (_b = exec.outcome) == null ? void 0 : _b.kind
  };
}
function extractMasteryId(action2) {
  if (typeof action2.id === "string" && action2.id.startsWith("wm-")) {
    const id2 = action2.id.slice("wm-".length);
    return id2 || null;
  }
  const tags2 = Array.isArray(action2.tags) ? action2.tags : [];
  const candidate = tags2.find((tag) => {
    if (tag === "weaponMastery") return false;
    if (tag.startsWith("wm-trigger:")) return false;
    return true;
  });
  return candidate ?? null;
}
function getMasteryTrigger(action2) {
  const tags2 = Array.isArray(action2.tags) ? action2.tags : [];
  const triggerTag = tags2.find((tag) => tag.startsWith("wm-trigger:"));
  if (triggerTag === "wm-trigger:on_miss") return "on_miss";
  if (triggerTag === "wm-trigger:on_intent") return "on_intent";
  return "on_hit";
}
function buildWeaponMasteryTriggerTags(params) {
  const { activeMasteryIds, masteryActions } = params;
  if (!activeMasteryIds.length || !masteryActions.length) return [];
  const activeSet = new Set(activeMasteryIds);
  const tags2 = [];
  for (const mastery of masteryActions) {
    const masteryId = extractMasteryId(mastery);
    if (!masteryId || !activeSet.has(masteryId)) continue;
    const trigger2 = getMasteryTrigger(mastery);
    tags2.push(`wm-trigger:${masteryId}:${trigger2}`);
  }
  return tags2;
}
function buildActionPlan(params) {
  const steps = [];
  if (!params.action) return { steps };
  if (params.stage === "draft") {
    const blocked = params.availability ? !params.availability.enabled : false;
    steps.push({
      id: "validate",
      type: "validate",
      title: "Valider l'action",
      status: blocked ? "blocked" : "available",
      detail: blocked ? "Action indisponible." : void 0
    });
  }
  if (params.resource) {
    const hasEnough = params.resource.current >= params.resource.min;
    steps.push({
      id: "resource",
      type: "resource",
      title: `${params.resource.label}: ${params.resource.current}/${params.resource.min}`,
      status: hasEnough ? "done" : "blocked",
      detail: hasEnough ? void 0 : "Ressource insuffisante."
    });
  }
  if (params.needsTarget) {
    let status = "locked";
    if (params.stage === "active") {
      status = params.targetSelected ? "done" : "available";
    }
    steps.push({
      id: "target",
      type: "target",
      title: "Selectionner une cible",
      status
    });
  }
  if (params.hasAttack) {
    let status = "locked";
    if (params.stage === "active" && (!params.needsTarget || params.targetSelected)) {
      status = params.attackRoll ? "done" : "available";
    }
    steps.push({
      id: "attack-roll",
      type: "attack-roll",
      title: "Jet de touche",
      status
    });
  }
  if (params.hasDamage) {
    let status = "locked";
    let detail;
    if (params.hasAttack) {
      if (params.attackOutcome === "miss") {
        status = "blocked";
        detail = "Attaque ratee.";
      } else if (params.attackOutcome === "hit") {
        status = params.damageRoll ? "done" : "available";
      } else {
        status = params.attackRoll ? "available" : "locked";
      }
    } else if (params.stage === "active") {
      status = params.damageRoll ? "done" : "available";
    }
    steps.push({
      id: "damage-roll",
      type: "damage-roll",
      title: "Jet de degats",
      status,
      detail
    });
  }
  return { steps };
}
const SUPPORTED_STATS = /* @__PURE__ */ new Set([
  "modFOR",
  "modDEX",
  "modCON",
  "modINT",
  "modSAG",
  "modCHA",
  "armorClass",
  "maxHp",
  "moveRange",
  "attackBonus",
  "maxAttacksPerTurn",
  "actionsPerTurn",
  "bonusActionsPerTurn"
]);
function getEquippedInventoryEntries(character) {
  const inventory = Array.isArray(character == null ? void 0 : character.inventoryItems) ? character.inventoryItems : [];
  return inventory.filter((item) => Boolean(item == null ? void 0 : item.equippedSlot) && !(item == null ? void 0 : item.storedIn));
}
function getItemGrants(item) {
  if (!item) return [];
  const grants2 = item == null ? void 0 : item.grants;
  return Array.isArray(grants2) ? grants2 : [];
}
function resolveEquippedItems(params) {
  const equipped = getEquippedInventoryEntries(params.character);
  const out2 = [];
  for (const entry of equipped) {
    const itemId = String(entry.id ?? "");
    const itemType = String(entry.type ?? "");
    const instanceId = typeof entry.instanceId === "string" ? entry.instanceId : null;
    const slot = typeof entry.equippedSlot === "string" ? entry.equippedSlot : null;
    if (!itemId || !itemType) continue;
    if (itemType === "weapon") {
      const weapon = params.weaponById.get(itemId);
      if (!weapon) continue;
      const harmonisable2 = Boolean(weapon == null ? void 0 : weapon.harmonisable);
      const harmonized = isEquippedItemHarmonized(params.character, entry);
      out2.push({ itemId, instanceId, itemType: "weapon", slot, harmonisable: harmonisable2, harmonized, weapon });
      continue;
    }
    if (itemType === "armor") {
      const armor = params.armorById.get(itemId);
      if (!armor) continue;
      const harmonisable2 = Boolean(armor == null ? void 0 : armor.harmonisable);
      const harmonized = isEquippedItemHarmonized(params.character, entry);
      out2.push({ itemId, instanceId, itemType: "armor", slot, harmonisable: harmonisable2, harmonized, armor });
      continue;
    }
    if (itemType === "object") {
      const object = params.objectById.get(itemId);
      if (!object) continue;
      const harmonisable2 = Boolean(object == null ? void 0 : object.harmonisable);
      const harmonized = isEquippedItemHarmonized(params.character, entry);
      out2.push({ itemId, instanceId, itemType: "object", slot, harmonisable: harmonisable2, harmonized, object });
    }
  }
  return out2;
}
function isEquippedItemHarmonized(character, entry) {
  var _a, _b;
  if (entry.harmonized === true || entry.isHarmonized === true || entry.attuned === true) return true;
  if (((_a = entry.attunement) == null ? void 0 : _a.state) === "harmonized") return true;
  if (typeof ((_b = entry.attunement) == null ? void 0 : _b.harmonizedAt) === "string" && entry.attunement.harmonizedAt.length > 0) {
    return true;
  }
  const instanceId = typeof entry.instanceId === "string" ? entry.instanceId : null;
  const itemId = typeof entry.id === "string" ? entry.id : null;
  const attunements = character == null ? void 0 : character.attunements;
  if (!attunements || typeof attunements !== "object") return false;
  if (instanceId && (attunements[instanceId] === true || attunements[`instance:${instanceId}`] === true)) {
    return true;
  }
  if (itemId && (attunements[itemId] === true || attunements[`item:${itemId}`] === true)) {
    return true;
  }
  return false;
}
function uniquePush(target, value2) {
  if (!value2) return;
  if (!target.includes(value2)) target.push(value2);
}
function buildEquipmentContextTags(params) {
  const equipped = resolveEquippedItems(params);
  const tags2 = [];
  for (const item of equipped) {
    uniquePush(tags2, `equip:item:${item.itemId}`);
    uniquePush(tags2, `equip:type:${item.itemType}`);
    if (item.slot) uniquePush(tags2, `equip:slot:${item.slot}`);
    if (item.itemType === "weapon" && item.weapon) {
      if (item.weapon.category) {
        uniquePush(tags2, `equip:weaponCategory:${item.weapon.category}`);
      }
    } else if (item.itemType === "armor" && item.armor) {
      if (item.armor.armorCategory) {
        uniquePush(tags2, `equip:armorCategory:${item.armor.armorCategory}`);
      }
    } else if (item.itemType === "object" && item.object) {
      if (item.object.category) {
        uniquePush(tags2, `equip:objectCategory:${item.object.category}`);
      }
    }
  }
  return tags2;
}
function collectBonusEntries(params) {
  const equipped = resolveEquippedItems(params);
  const out2 = [];
  for (const resolved of equipped) {
    if (resolved.harmonisable && !resolved.harmonized) continue;
    const item = resolved.weapon ?? resolved.armor ?? resolved.object ?? null;
    if (!item) continue;
    const grants2 = getItemGrants(item);
    for (const grant of grants2) {
      if ((grant == null ? void 0 : grant.kind) !== "bonus") continue;
      const ids = Array.isArray(grant.ids) ? grant.ids : [];
      ids.forEach((id2) => {
        const def = params.bonusById.get(String(id2));
        if (!def) return;
        out2.push({
          bonus: def,
          sourceItemId: resolved.itemId,
          sourceItemType: resolved.itemType,
          sourceSlot: resolved.slot
        });
      });
      const inline = Array.isArray(grant.inline) ? grant.inline : [];
      inline.forEach((def) => {
        if (!def || typeof def !== "object") return;
        out2.push({
          bonus: def,
          sourceItemId: resolved.itemId,
          sourceItemType: resolved.itemType,
          sourceSlot: resolved.slot
        });
      });
    }
  }
  return out2;
}
function getStatValue(stats, stat) {
  if (stat === "modFOR") return Number(stats.mods.modFOR ?? 0);
  if (stat === "modDEX") return Number(stats.mods.modDEX ?? 0);
  if (stat === "modCON") return Number(stats.mods.modCON ?? 0);
  if (stat === "modINT") return Number(stats.mods.modINT ?? 0);
  if (stat === "modSAG") return Number(stats.mods.modSAG ?? 0);
  if (stat === "modCHA") return Number(stats.mods.modCHA ?? 0);
  if (stat === "armorClass") return Number(stats.armorClass ?? 0);
  if (stat === "maxHp") return Number(stats.maxHp ?? 0);
  if (stat === "moveRange") return Number(stats.moveRange ?? 0);
  if (stat === "attackBonus") return Number(stats.attackBonus ?? 0);
  if (stat === "maxAttacksPerTurn") return Number(stats.maxAttacksPerTurn ?? 0);
  if (stat === "actionsPerTurn") return Number(stats.actionsPerTurn ?? 0);
  if (stat === "bonusActionsPerTurn") return Number(stats.bonusActionsPerTurn ?? 0);
  return 0;
}
function setStatValue(stats, stat, value2) {
  if (stat === "modFOR") stats.mods.modFOR = value2;
  else if (stat === "modDEX") stats.mods.modDEX = value2;
  else if (stat === "modCON") stats.mods.modCON = value2;
  else if (stat === "modINT") stats.mods.modINT = value2;
  else if (stat === "modSAG") stats.mods.modSAG = value2;
  else if (stat === "modCHA") stats.mods.modCHA = value2;
  else if (stat === "armorClass") stats.armorClass = value2;
  else if (stat === "maxHp") stats.maxHp = value2;
  else if (stat === "moveRange") stats.moveRange = value2;
  else if (stat === "attackBonus") stats.attackBonus = value2;
  else if (stat === "maxAttacksPerTurn") stats.maxAttacksPerTurn = value2;
  else if (stat === "actionsPerTurn") stats.actionsPerTurn = value2;
  else if (stat === "bonusActionsPerTurn") stats.bonusActionsPerTurn = value2;
}
function buildActorForBonusRequirements(params) {
  var _a;
  return {
    id: params.character.id ?? "bonus-eval",
    type: "player",
    x: 0,
    y: 0,
    hp: Number(((_a = params.character) == null ? void 0 : _a.pvActuels) ?? params.stats.maxHp ?? 1) || 1,
    maxHp: Number(params.stats.maxHp ?? 1) || 1,
    combatStats: {
      ...params.stats,
      tags: [...params.tags]
    },
    tags: [...params.tags]
  };
}
function bonusRequirementsPass(params) {
  var _a;
  const requirements = Array.isArray((_a = params.bonus) == null ? void 0 : _a.requirements) ? params.bonus.requirements : [];
  if (requirements.length === 0) return true;
  const actorTagsRaw = params.actor.tags;
  const actorTags = Array.isArray(actorTagsRaw) ? [...actorTagsRaw, ...params.itemTags] : [...params.itemTags];
  const actor = { ...params.actor };
  actor.tags = Array.from(new Set(actorTags));
  if (params.actor.combatStats) {
    actor.combatStats = {
      ...params.actor.combatStats,
      tags: Array.from(/* @__PURE__ */ new Set([...params.actor.combatStats.tags ?? [], ...params.itemTags]))
    };
  }
  return evaluateAllConditions(requirements, { actor, phase: "BUILD_INTENT" });
}
function buildItemTags(entry) {
  const tags2 = [];
  uniquePush(tags2, `equip:item:${entry.sourceItemId}`);
  uniquePush(tags2, `equip:type:${entry.sourceItemType}`);
  if (entry.sourceSlot) uniquePush(tags2, `equip:slot:${entry.sourceSlot}`);
  return tags2;
}
function applyEquipmentBonusesToCombatStats(params) {
  const equipTags = buildEquipmentContextTags(params);
  const next = {
    ...params.baseStats,
    mods: { ...params.baseStats.mods },
    resources: { ...params.baseStats.resources ?? {} },
    tags: Array.from(
      /* @__PURE__ */ new Set([...Array.isArray(params.baseStats.tags) ? params.baseStats.tags : [], ...equipTags])
    )
  };
  const entries = collectBonusEntries(params);
  const applied = [];
  for (const entry of entries) {
    const bonus = entry.bonus;
    const stat = String((bonus == null ? void 0 : bonus.stat) ?? "");
    if (!SUPPORTED_STATS.has(stat)) continue;
    const value2 = Number((bonus == null ? void 0 : bonus.value) ?? 0);
    if (!Number.isFinite(value2)) continue;
    const actorForRequirements = buildActorForBonusRequirements({
      character: params.character,
      stats: next,
      tags: next.tags ?? []
    });
    if (!bonusRequirementsPass({ bonus, actor: actorForRequirements, itemTags: buildItemTags(entry) })) {
      continue;
    }
    const mode = bonus == null ? void 0 : bonus.mode;
    const current = getStatValue(next, stat);
    let resolved = current;
    if (mode === "set") resolved = value2;
    else if (mode === "max") resolved = Math.max(current, value2);
    else resolved = current + value2;
    setStatValue(next, stat, resolved);
    applied.push({ bonusId: String((bonus == null ? void 0 : bonus.id) ?? "bonus-inline"), sourceItemId: entry.sourceItemId });
  }
  return { stats: next, applied };
}
const DEFAULT_POLICY = {
  ignoreTwoHandedShieldRestriction: false,
  allowSomaticWithOccupiedHands: false,
  extraWeaponInteractionsPerTurn: 0,
  allowWeaponSwapWithoutInteraction: false,
  drawWeaponFromPackAsInteraction: false
};
function isEquippedInHands(entry) {
  return Boolean(entry == null ? void 0 : entry.equippedSlot) && !(entry == null ? void 0 : entry.storedIn);
}
function parsePolicyModifier(entry) {
  const applyTo = String((entry == null ? void 0 : entry.applyTo) ?? "").trim().toLowerCase();
  if (!["equipment", "equipmentpolicy", "hands"].includes(applyTo)) {
    return {};
  }
  const stat = String((entry == null ? void 0 : entry.stat) ?? (entry == null ? void 0 : entry.mode) ?? (entry == null ? void 0 : entry.policy) ?? "").trim().toLowerCase();
  const value2 = typeof (entry == null ? void 0 : entry.value) === "number" ? entry.value : typeof (entry == null ? void 0 : entry.enabled) === "boolean" ? entry.enabled ? 1 : 0 : 1;
  if (value2 <= 0) return {};
  if (stat === "ignoretwohandedshieldrestriction" || stat === "allow_two_handed_with_shield" || stat === "allowtwohandedwithshield") {
    return { ignoreTwoHandedShieldRestriction: true };
  }
  if (stat === "allowsomaticwithoccupiedhands" || stat === "allow_somatic_with_occupied_hands" || stat === "allowsomaticwithoutfreehand") {
    return { allowSomaticWithOccupiedHands: true };
  }
  if (stat === "extraweaponinteractionsperturn" || stat === "extra_weapon_interactions_per_turn") {
    return { extraWeaponInteractionsPerTurn: Math.max(0, Math.floor(value2)) };
  }
  if (stat === "allowweaponswapwithoutinteraction" || stat === "allow_weapon_swap_without_interaction") {
    return { allowWeaponSwapWithoutInteraction: true };
  }
  if (stat === "drawweaponfrompackasinteraction" || stat === "draw_weapon_from_pack_as_interaction") {
    return { drawWeaponFromPackAsInteraction: true };
  }
  return {};
}
function resolveEquipmentRuntimePolicy(params) {
  var _a, _b;
  const features2 = Array.isArray(params.features) ? params.features : [];
  const policy = { ...DEFAULT_POLICY };
  for (const feature of features2) {
    const modifiers = Array.isArray((_a = feature == null ? void 0 : feature.rules) == null ? void 0 : _a.modifiers) ? (_b = feature.rules) == null ? void 0 : _b.modifiers : [];
    for (const modifier of modifiers) {
      const parsed = parsePolicyModifier(modifier);
      if (parsed.ignoreTwoHandedShieldRestriction) {
        policy.ignoreTwoHandedShieldRestriction = true;
      }
      if (parsed.allowSomaticWithOccupiedHands) {
        policy.allowSomaticWithOccupiedHands = true;
      }
      if (typeof parsed.extraWeaponInteractionsPerTurn === "number") {
        policy.extraWeaponInteractionsPerTurn += Math.max(0, parsed.extraWeaponInteractionsPerTurn);
      }
      if (parsed.allowWeaponSwapWithoutInteraction) {
        policy.allowWeaponSwapWithoutInteraction = true;
      }
      if (parsed.drawWeaponFromPackAsInteraction) {
        policy.drawWeaponFromPackAsInteraction = true;
      }
    }
  }
  return policy;
}
function getHandUsageState(params) {
  const inventory = Array.isArray(params.inventoryItems) ? params.inventoryItems : [];
  const primaryReadyWeapons = inventory.filter((entry) => {
    if ((entry == null ? void 0 : entry.type) !== "weapon") return false;
    if (!(entry == null ? void 0 : entry.isPrimaryWeapon)) return false;
    return isEquippedInHands(entry);
  });
  const readyWeapons = primaryReadyWeapons.length > 0 ? primaryReadyWeapons : inventory.filter((entry) => (entry == null ? void 0 : entry.type) === "weapon" && isEquippedInHands(entry)).slice(0, 1);
  const readyShields = inventory.filter((entry) => {
    if ((entry == null ? void 0 : entry.type) !== "armor") return false;
    if (!(entry == null ? void 0 : entry.equippedSlot) || (entry == null ? void 0 : entry.storedIn)) return false;
    const def = params.armorById.get(String(entry.id ?? ""));
    return (def == null ? void 0 : def.armorCategory) === "shield";
  });
  const strictTwoHandedReady = readyWeapons.some((entry) => {
    var _a;
    const def = params.weaponById.get(String(entry.id ?? ""));
    return Boolean((_a = def == null ? void 0 : def.properties) == null ? void 0 : _a.twoHanded);
  });
  const readyWeaponCount = readyWeapons.length;
  const readyShieldCount = readyShields.length;
  const hasShieldInHands = readyShieldCount > 0;
  const hasOffhandWeapon = !strictTwoHandedReady && readyWeaponCount >= 2;
  const occupiedHands = strictTwoHandedReady ? 2 : Math.min(2, readyShieldCount + Math.min(2, readyWeaponCount));
  const freeHands = Math.max(0, 2 - occupiedHands);
  return {
    readyWeaponCount,
    readyShieldCount,
    strictTwoHandedReady,
    hasShieldInHands,
    hasOffhandWeapon,
    occupiedHands,
    freeHands
  };
}
function getEquipmentConstraintIssues(params) {
  var _a, _b, _c;
  const issues = [];
  const handState = getHandUsageState({
    inventoryItems: params.inventoryItems,
    weaponById: params.weaponById,
    armorById: params.armorById
  });
  const policy = {
    ...resolveEquipmentRuntimePolicy({ features: params.features }),
    ...params.customPolicy ?? {}
  };
  const weapon = params.selectedWeapon ?? null;
  if (((_a = weapon == null ? void 0 : weapon.properties) == null ? void 0 : _a.twoHanded) && handState.hasShieldInHands && !policy.ignoreTwoHandedShieldRestriction) {
    issues.push("Arme a deux mains incompatible avec un bouclier equipe.");
  }
  const needsSomatic = Boolean((_c = (_b = params.action) == null ? void 0 : _b.components) == null ? void 0 : _c.somatic);
  if (needsSomatic && handState.freeHands <= 0 && !policy.allowSomaticWithOccupiedHands) {
    issues.push("Composante somatique impossible (aucune main libre).");
  }
  return issues;
}
function getTokenAt(pos, tokens) {
  return tokens.find((t2) => {
    if (t2.hp <= 0) return false;
    return getTokenOccupiedCells(t2).some((c2) => c2.x === pos.x && c2.y === pos.y);
  }) ?? null;
}
const buffer = {
  active: false,
  round: null,
  stateStart: null,
  events: [],
  enemySpeeches: [],
  lastSpeechByEnemyThisRound: /* @__PURE__ */ new Map()
};
let eventCounter = 0;
const lastSpeechByEnemyGlobal = /* @__PURE__ */ new Map();
function beginRoundNarrationBuffer(round2, stateStart) {
  buffer.active = true;
  buffer.round = round2;
  buffer.stateStart = stateStart;
  buffer.events = [];
  buffer.enemySpeeches = [];
  buffer.lastSpeechByEnemyThisRound = /* @__PURE__ */ new Map();
}
function recordCombatEvent(input) {
  if (!buffer.active) return;
  if (buffer.round !== null && input.round !== buffer.round) {
    return;
  }
  const evt = {
    id: `evt-${Date.now()}-${eventCounter++}`,
    round: input.round,
    phase: input.phase,
    kind: input.kind,
    actorId: input.actorId,
    actorKind: input.actorKind,
    targetId: input.targetId ?? null,
    targetKind: input.targetKind ?? null,
    summary: input.summary,
    data: input.data ?? {},
    timestamp: Date.now()
  };
  buffer.events.push(evt);
}
function recordEnemySpeech(enemyId, line) {
  if (!buffer.active) return;
  const trimmed = (line ?? "").trim();
  if (!trimmed) return;
  buffer.enemySpeeches.push({ enemyId, line: trimmed });
  buffer.lastSpeechByEnemyThisRound.set(enemyId, trimmed);
  lastSpeechByEnemyGlobal.set(enemyId, trimmed);
  if (buffer.round !== null) {
    recordCombatEvent({
      round: buffer.round,
      phase: "enemies",
      kind: "speech",
      actorId: enemyId,
      actorKind: "enemy",
      summary: `${enemyId} dit: "${trimmed}"`,
      data: { line: trimmed }
    });
  }
}
function getPriorEnemySpeechesThisRound() {
  return buffer.enemySpeeches.slice();
}
function getLastSpeechForEnemy(enemyId) {
  return lastSpeechByEnemyGlobal.get(enemyId) ?? null;
}
function getRecentCombatEvents(limit) {
  if (!Number.isFinite(limit) || limit <= 0) return buffer.events.slice();
  return buffer.events.slice(-Math.floor(limit));
}
function buildRoundNarrationRequest(input) {
  if (!buffer.active || !buffer.stateStart || buffer.round === null) return null;
  return {
    language: "fr",
    focusSide: "player",
    focusActorId: input.focusActorId,
    stateStart: buffer.stateStart,
    stateEnd: input.stateEnd,
    events: buffer.events.slice(),
    enemySpeeches: buffer.enemySpeeches.slice()
  };
}
function clearRoundNarrationBuffer() {
  buffer.active = false;
  buffer.round = null;
  buffer.stateStart = null;
  buffer.events = [];
  buffer.enemySpeeches = [];
  buffer.lastSpeechByEnemyThisRound = /* @__PURE__ */ new Map();
}
async function requestRoundNarration(payload) {
  const response = await fetch("/api/narration", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(payload)
  });
  if (!response.ok) {
    return { summary: "", error: "IA non fonctionnel." };
  }
  const data = await response.json();
  if (!data || typeof data.summary !== "string") {
    return { summary: "", error: "IA non fonctionnel." };
  }
  if (data.error && typeof data.error === "string") {
    return { summary: "", error: data.error };
  }
  return { summary: data.summary };
}
async function requestEnemySpeech(payload) {
  const response = await fetch("/api/enemy-speech", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(payload)
  });
  if (!response.ok) {
    return { line: "" };
  }
  const data = await response.json();
  if (!data || typeof data.line !== "string") {
    return { line: "" };
  }
  return { line: data.line };
}
function getInteractionAvailability(params) {
  const {
    interaction,
    target,
    player,
    wallSegments,
    obstacles,
    wallTypeById,
    obstacleTypeById,
    canPayCost,
    getWallDistance,
    getObstacleDistance
  } = params;
  if (target.kind === "wall") {
    const wall = wallSegments.find((w2) => w2.id === target.segmentId) ?? null;
    if (!wall) return { ok: false, reason: "Mur introuvable." };
    const def2 = wall.typeId ? wallTypeById.get(wall.typeId) ?? null : null;
    const dist2 = getWallDistance(player, wall);
    if (dist2 > 1) return { ok: false, reason: "Trop loin." };
    return resolveWallInteraction(interaction, wall, def2, canPayCost);
  }
  const obstacle = obstacles.find((o2) => o2.id === target.obstacleId) ?? null;
  if (!obstacle) return { ok: false, reason: "Obstacle introuvable." };
  const def = obstacleTypeById.get(obstacle.typeId) ?? null;
  const dist = getObstacleDistance(player, obstacle, def, target.cell);
  if (dist > 1) return { ok: false, reason: "Trop loin." };
  return resolveObstacleInteraction(interaction, obstacle, def, canPayCost);
}
function resolveWallInteraction(interaction, segment, def, canPayCost) {
  const costCheck = canPayCost(interaction.cost);
  if (!costCheck.ok) return costCheck;
  if (interaction.kind === "open") {
    if (segment.kind !== "door") {
      return { ok: false, reason: "Interaction reservee aux portes." };
    }
    if (segment.state === "open") {
      return { ok: false, reason: "La porte est deja ouverte." };
    }
    return { ok: true };
  }
  if (interaction.kind === "break") {
    if (segment.kind !== "door") {
      return { ok: false, reason: "Interaction reservee aux portes." };
    }
    if (segment.state === "open") {
      return { ok: false, reason: "La porte est deja ouverte." };
    }
    if (!isWallDestructible$1(def)) {
      return { ok: false, reason: "Porte indestructible." };
    }
    if (typeof interaction.forceDc !== "number") {
      return { ok: false, reason: "DD de force manquant." };
    }
    return { ok: true };
  }
  return { ok: true };
}
function resolveObstacleInteraction(interaction, obstacle, def, canPayCost) {
  var _a, _b;
  const costCheck = canPayCost(interaction.cost);
  if (!costCheck.ok) return costCheck;
  if (interaction.kind === "open") {
    return { ok: false, reason: "Interaction reservee aux portes." };
  }
  if (interaction.kind === "break") {
    if (((_a = def == null ? void 0 : def.durability) == null ? void 0 : _a.destructible) === false) {
      return { ok: false, reason: "Obstacle indestructible." };
    }
    if (obstacle.hp <= 0) {
      return { ok: false, reason: "Obstacle deja detruit." };
    }
    if (typeof interaction.forceDc !== "number") {
      return { ok: false, reason: "DD de force manquant." };
    }
  }
  if (interaction.kind === "toggle") {
    const targetLit = typeof interaction.setLit === "boolean" ? interaction.setLit : null;
    if (targetLit !== null) {
      const currentLit = ((_b = obstacle.state) == null ? void 0 : _b.lit) !== false;
      if (currentLit === targetLit) {
        return { ok: false, reason: targetLit ? "Deja allume." : "Deja eteint." };
      }
    }
  }
  return { ok: true };
}
function applyInteraction(params) {
  const { interaction, target, wallTypeById, setWallSegments, setObstacles } = params;
  if (target.kind === "wall") {
    setWallSegments((prev) => {
      const idx = prev.findIndex((w2) => w2.id === target.segmentId);
      if (idx === -1) return prev;
      const copy = [...prev];
      const segment = { ...copy[idx] };
      const def = segment.typeId ? wallTypeById.get(segment.typeId) ?? null : null;
      if (interaction.kind === "open") {
        if (segment.kind === "door" && segment.state !== "open") {
          segment.state = "open";
          copy[idx] = segment;
        }
      } else if (interaction.kind === "break") {
        if (segment.kind === "door" && segment.state !== "open" && isWallDestructible$1(def)) {
          const maxHp = typeof segment.maxHp === "number" ? segment.maxHp : typeof segment.hp === "number" ? segment.hp : null;
          if (maxHp !== null) {
            const fraction = typeof interaction.damageFraction === "number" ? interaction.damageFraction : 0.5;
            const damage2 = Math.max(0, Math.round(maxHp * fraction));
            const beforeHp = typeof segment.hp === "number" ? segment.hp : maxHp;
            segment.hp = Math.max(0, beforeHp - damage2);
            segment.maxHp = maxHp;
          }
          segment.state = "open";
          copy[idx] = segment;
        }
      }
      return copy.filter((w2) => w2.hp === void 0 || w2.hp > 0);
    });
    return;
  }
  setObstacles((prev) => {
    var _a;
    const idx = prev.findIndex((o2) => o2.id === target.obstacleId);
    if (idx === -1) return prev;
    const copy = [...prev];
    const obstacle = { ...copy[idx] };
    if (interaction.kind === "break" && obstacle.hp > 0) {
      const fraction = typeof interaction.damageFraction === "number" ? interaction.damageFraction : 0.5;
      const maxHp = typeof obstacle.maxHp === "number" ? obstacle.maxHp : obstacle.hp;
      const damage2 = Math.max(0, Math.round(maxHp * fraction));
      obstacle.hp = Math.max(0, obstacle.hp - damage2);
      copy[idx] = obstacle;
    } else if (interaction.kind === "toggle") {
      const nextLit = typeof interaction.setLit === "boolean" ? interaction.setLit : !(((_a = obstacle.state) == null ? void 0 : _a.lit) !== false);
      obstacle.state = { ...obstacle.state ?? {}, lit: nextLit };
      copy[idx] = obstacle;
    }
    return copy.filter((o2) => o2.hp > 0);
  });
}
const scriptRel = "modulepreload";
const assetsURL = function(dep) {
  return "/" + dep;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  let promise2 = Promise.resolve();
  if (deps && deps.length > 0) {
    let allSettled2 = function(promises) {
      return Promise.all(
        promises.map(
          (p2) => Promise.resolve(p2).then(
            (value2) => ({ status: "fulfilled", value: value2 }),
            (reason) => ({ status: "rejected", reason })
          )
        )
      );
    };
    document.getElementsByTagName("link");
    const cspNonceMeta = document.querySelector(
      "meta[property=csp-nonce]"
    );
    const cspNonce = (cspNonceMeta == null ? void 0 : cspNonceMeta.nonce) || (cspNonceMeta == null ? void 0 : cspNonceMeta.getAttribute("nonce"));
    promise2 = allSettled2(
      deps.map((dep) => {
        dep = assetsURL(dep);
        if (dep in seen) return;
        seen[dep] = true;
        const isCss = dep.endsWith(".css");
        const cssSelector = isCss ? '[rel="stylesheet"]' : "";
        if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
          return;
        }
        const link = document.createElement("link");
        link.rel = isCss ? "stylesheet" : scriptRel;
        if (!isCss) {
          link.as = "script";
        }
        link.crossOrigin = "";
        link.href = dep;
        if (cspNonce) {
          link.setAttribute("nonce", cspNonce);
        }
        document.head.appendChild(link);
        if (isCss) {
          return new Promise((res, rej) => {
            link.addEventListener("load", res);
            link.addEventListener(
              "error",
              () => rej(new Error(`Unable to preload CSS for ${dep}`))
            );
          });
        }
      })
    );
  }
  function handlePreloadError(err) {
    const e2 = new Event("vite:preloadError", {
      cancelable: true
    });
    e2.payload = err;
    window.dispatchEvent(e2);
    if (!e2.defaultPrevented) {
      throw err;
    }
  }
  return promise2.then((res) => {
    for (const item of res || []) {
      if (item.status !== "rejected") continue;
      handlePreloadError(item.reason);
    }
    return baseModule().catch(handlePreloadError);
  });
};
var ExtensionType = /* @__PURE__ */ ((ExtensionType2) => {
  ExtensionType2["Application"] = "application";
  ExtensionType2["WebGLPipes"] = "webgl-pipes";
  ExtensionType2["WebGLPipesAdaptor"] = "webgl-pipes-adaptor";
  ExtensionType2["WebGLSystem"] = "webgl-system";
  ExtensionType2["WebGPUPipes"] = "webgpu-pipes";
  ExtensionType2["WebGPUPipesAdaptor"] = "webgpu-pipes-adaptor";
  ExtensionType2["WebGPUSystem"] = "webgpu-system";
  ExtensionType2["CanvasSystem"] = "canvas-system";
  ExtensionType2["CanvasPipesAdaptor"] = "canvas-pipes-adaptor";
  ExtensionType2["CanvasPipes"] = "canvas-pipes";
  ExtensionType2["Asset"] = "asset";
  ExtensionType2["LoadParser"] = "load-parser";
  ExtensionType2["ResolveParser"] = "resolve-parser";
  ExtensionType2["CacheParser"] = "cache-parser";
  ExtensionType2["DetectionParser"] = "detection-parser";
  ExtensionType2["MaskEffect"] = "mask-effect";
  ExtensionType2["BlendMode"] = "blend-mode";
  ExtensionType2["TextureSource"] = "texture-source";
  ExtensionType2["Environment"] = "environment";
  ExtensionType2["ShapeBuilder"] = "shape-builder";
  ExtensionType2["Batcher"] = "batcher";
  return ExtensionType2;
})(ExtensionType || {});
const normalizeExtension = (ext) => {
  if (typeof ext === "function" || typeof ext === "object" && ext.extension) {
    if (!ext.extension) {
      throw new Error("Extension class must have an extension object");
    }
    const metadata = typeof ext.extension !== "object" ? { type: ext.extension } : ext.extension;
    ext = { ...metadata, ref: ext };
  }
  if (typeof ext === "object") {
    ext = { ...ext };
  } else {
    throw new Error("Invalid extension type");
  }
  if (typeof ext.type === "string") {
    ext.type = [ext.type];
  }
  return ext;
};
const normalizeExtensionPriority = (ext, defaultPriority) => normalizeExtension(ext).priority ?? defaultPriority;
const extensions = {
  /** @ignore */
  _addHandlers: {},
  /** @ignore */
  _removeHandlers: {},
  /** @ignore */
  _queue: {},
  /**
   * Remove extensions from PixiJS.
   * @param extensions - Extensions to be removed. Can be:
   * - Extension class with static `extension` property
   * - Extension format object with `type` and `ref`
   * - Multiple extensions as separate arguments
   * @returns {extensions} this for chaining
   * @example
   * ```ts
   * // Remove a single extension
   * extensions.remove(MyRendererPlugin);
   *
   * // Remove multiple extensions
   * extensions.remove(
   *     MyRendererPlugin,
   *     MySystemPlugin
   * );
   * ```
   * @see {@link ExtensionType} For available extension types
   * @see {@link ExtensionFormat} For extension format details
   */
  remove(...extensions2) {
    extensions2.map(normalizeExtension).forEach((ext) => {
      ext.type.forEach((type2) => {
        var _a, _b;
        return (_b = (_a = this._removeHandlers)[type2]) == null ? void 0 : _b.call(_a, ext);
      });
    });
    return this;
  },
  /**
   * Register new extensions with PixiJS. Extensions can be registered in multiple formats:
   * - As a class with a static `extension` property
   * - As an extension format object
   * - As multiple extensions passed as separate arguments
   * @param extensions - Extensions to add to PixiJS. Each can be:
   * - A class with static `extension` property
   * - An extension format object with `type` and `ref`
   * - Multiple extensions as separate arguments
   * @returns This extensions instance for chaining
   * @example
   * ```ts
   * // Register a simple extension
   * extensions.add(MyRendererPlugin);
   *
   * // Register multiple extensions
   * extensions.add(
   *     MyRendererPlugin,
   *     MySystemPlugin,
   * });
   * ```
   * @see {@link ExtensionType} For available extension types
   * @see {@link ExtensionFormat} For extension format details
   * @see {@link extensions.remove} For removing registered extensions
   */
  add(...extensions2) {
    extensions2.map(normalizeExtension).forEach((ext) => {
      ext.type.forEach((type2) => {
        var _a, _b;
        const handlers = this._addHandlers;
        const queue = this._queue;
        if (!handlers[type2]) {
          queue[type2] = queue[type2] || [];
          (_a = queue[type2]) == null ? void 0 : _a.push(ext);
        } else {
          (_b = handlers[type2]) == null ? void 0 : _b.call(handlers, ext);
        }
      });
    });
    return this;
  },
  /**
   * Internal method to handle extensions by name.
   * @param type - The extension type.
   * @param onAdd  - Function handler when extensions are added/registered {@link StrictExtensionFormat}.
   * @param onRemove  - Function handler when extensions are removed/unregistered {@link StrictExtensionFormat}.
   * @returns this for chaining.
   * @internal
   * @ignore
   */
  handle(type2, onAdd, onRemove) {
    var _a;
    const addHandlers = this._addHandlers;
    const removeHandlers = this._removeHandlers;
    if (addHandlers[type2] || removeHandlers[type2]) {
      throw new Error(`Extension type ${type2} already has a handler`);
    }
    addHandlers[type2] = onAdd;
    removeHandlers[type2] = onRemove;
    const queue = this._queue;
    if (queue[type2]) {
      (_a = queue[type2]) == null ? void 0 : _a.forEach((ext) => onAdd(ext));
      delete queue[type2];
    }
    return this;
  },
  /**
   * Handle a type, but using a map by `name` property.
   * @param type - Type of extension to handle.
   * @param map - The object map of named extensions.
   * @returns this for chaining.
   * @ignore
   */
  handleByMap(type2, map) {
    return this.handle(
      type2,
      (extension) => {
        if (extension.name) {
          map[extension.name] = extension.ref;
        }
      },
      (extension) => {
        if (extension.name) {
          delete map[extension.name];
        }
      }
    );
  },
  /**
   * Handle a type, but using a list of extensions with a `name` property.
   * @param type - Type of extension to handle.
   * @param map - The array of named extensions.
   * @param defaultPriority - Fallback priority if none is defined.
   * @returns this for chaining.
   * @ignore
   */
  handleByNamedList(type2, map, defaultPriority = -1) {
    return this.handle(
      type2,
      (extension) => {
        const index = map.findIndex((item) => item.name === extension.name);
        if (index >= 0)
          return;
        map.push({ name: extension.name, value: extension.ref });
        map.sort((a2, b2) => normalizeExtensionPriority(b2.value, defaultPriority) - normalizeExtensionPriority(a2.value, defaultPriority));
      },
      (extension) => {
        const index = map.findIndex((item) => item.name === extension.name);
        if (index !== -1) {
          map.splice(index, 1);
        }
      }
    );
  },
  /**
   * Handle a type, but using a list of extensions.
   * @param type - Type of extension to handle.
   * @param list - The list of extensions.
   * @param defaultPriority - The default priority to use if none is specified.
   * @returns this for chaining.
   * @ignore
   */
  handleByList(type2, list, defaultPriority = -1) {
    return this.handle(
      type2,
      (extension) => {
        if (list.includes(extension.ref)) {
          return;
        }
        list.push(extension.ref);
        list.sort((a2, b2) => normalizeExtensionPriority(b2, defaultPriority) - normalizeExtensionPriority(a2, defaultPriority));
      },
      (extension) => {
        const index = list.indexOf(extension.ref);
        if (index !== -1) {
          list.splice(index, 1);
        }
      }
    );
  },
  /**
   * Mixin the source object(s) properties into the target class's prototype.
   * Copies all property descriptors from source objects to the target's prototype.
   * @param Target - The target class to mix properties into
   * @param sources - One or more source objects containing properties to mix in
   * @example
   * ```ts
   * // Create a mixin with shared properties
   * const moveable = {
   *     x: 0,
   *     y: 0,
   *     move(x: number, y: number) {
   *         this.x += x;
   *         this.y += y;
   *     }
   * };
   *
   * // Create a mixin with computed properties
   * const scalable = {
   *     scale: 1,
   *     get scaled() {
   *         return this.scale > 1;
   *     }
   * };
   *
   * // Apply mixins to a class
   * extensions.mixin(Sprite, moveable, scalable);
   *
   * // Use mixed-in properties
   * const sprite = new Sprite();
   * sprite.move(10, 20);
   * console.log(sprite.x, sprite.y); // 10, 20
   * ```
   * @remarks
   * - Copies all properties including getters/setters
   * - Does not modify source objects
   * - Preserves property descriptors
   * @see {@link Object.defineProperties} For details on property descriptors
   * @see {@link Object.getOwnPropertyDescriptors} For details on property copying
   */
  mixin(Target, ...sources2) {
    for (const source2 of sources2) {
      Object.defineProperties(Target.prototype, Object.getOwnPropertyDescriptors(source2));
    }
  }
};
const browserExt = {
  extension: {
    type: ExtensionType.Environment,
    name: "browser",
    priority: -1
  },
  test: () => true,
  load: async () => {
    await __vitePreload(() => import("./browserAll-Cplxpe42.js"), true ? __vite__mapDeps([0,1,2]) : void 0);
  }
};
const webworkerExt = {
  extension: {
    type: ExtensionType.Environment,
    name: "webworker",
    priority: 0
  },
  test: () => typeof self !== "undefined" && self.WorkerGlobalScope !== void 0,
  load: async () => {
    await __vitePreload(() => import("./webworkerAll-CyzMB49c.js"), true ? __vite__mapDeps([1,2]) : void 0);
  }
};
class ObservablePoint {
  /**
   * Creates a new `ObservablePoint`
   * @param observer - Observer to pass to listen for change events.
   * @param {number} [x=0] - position of the point on the x axis
   * @param {number} [y=0] - position of the point on the y axis
   */
  constructor(observer, x2, y2) {
    this._x = x2 || 0;
    this._y = y2 || 0;
    this._observer = observer;
  }
  /**
   * Creates a clone of this point.
   * @example
   * ```ts
   * // Basic cloning
   * const point = new ObservablePoint(observer, 100, 200);
   * const copy = point.clone();
   *
   * // Clone with new observer
   * const newObserver = {
   *     _onUpdate: (p) => console.log(`Clone updated: (${p.x}, ${p.y})`)
   * };
   * const watched = point.clone(newObserver);
   *
   * // Verify independence
   * watched.set(300, 400); // Only triggers new observer
   * ```
   * @param observer - Optional observer to pass to the new observable point
   * @returns A copy of this observable point
   * @see {@link ObservablePoint.copyFrom} For copying into existing point
   * @see {@link Observer} For observer interface details
   */
  clone(observer) {
    return new ObservablePoint(observer ?? this._observer, this._x, this._y);
  }
  /**
   * Sets the point to a new x and y position.
   *
   * If y is omitted, both x and y will be set to x.
   * @example
   * ```ts
   * // Basic position setting
   * const point = new ObservablePoint(observer);
   * point.set(100, 200);
   *
   * // Set both x and y to same value
   * point.set(50); // x=50, y=50
   * ```
   * @param x - Position on the x axis
   * @param y - Position on the y axis, defaults to x
   * @returns The point instance itself
   * @see {@link ObservablePoint.copyFrom} For copying from another point
   * @see {@link ObservablePoint.equals} For comparing positions
   */
  set(x2 = 0, y2 = x2) {
    if (this._x !== x2 || this._y !== y2) {
      this._x = x2;
      this._y = y2;
      this._observer._onUpdate(this);
    }
    return this;
  }
  /**
   * Copies x and y from the given point into this point.
   * @example
   * ```ts
   * // Basic copying
   * const source = new ObservablePoint(observer, 100, 200);
   * const target = new ObservablePoint();
   * target.copyFrom(source);
   *
   * // Copy and chain operations
   * const point = new ObservablePoint()
   *     .copyFrom(source)
   *     .set(x + 50, y + 50);
   *
   * // Copy from any PointData
   * const data = { x: 10, y: 20 };
   * point.copyFrom(data);
   * ```
   * @param p - The point to copy from
   * @returns The point instance itself
   * @see {@link ObservablePoint.copyTo} For copying to another point
   * @see {@link ObservablePoint.clone} For creating new point copy
   */
  copyFrom(p2) {
    if (this._x !== p2.x || this._y !== p2.y) {
      this._x = p2.x;
      this._y = p2.y;
      this._observer._onUpdate(this);
    }
    return this;
  }
  /**
   * Copies this point's x and y into the given point.
   * @example
   * ```ts
   * // Basic copying
   * const source = new ObservablePoint(100, 200);
   * const target = new ObservablePoint();
   * source.copyTo(target);
   * ```
   * @param p - The point to copy to. Can be any type that is or extends `PointLike`
   * @returns The point (`p`) with values updated
   * @see {@link ObservablePoint.copyFrom} For copying from another point
   * @see {@link ObservablePoint.clone} For creating new point copy
   */
  copyTo(p2) {
    p2.set(this._x, this._y);
    return p2;
  }
  /**
   * Checks if another point is equal to this point.
   *
   * Compares x and y values using strict equality.
   * @example
   * ```ts
   * // Basic equality check
   * const p1 = new ObservablePoint(100, 200);
   * const p2 = new ObservablePoint(100, 200);
   * console.log(p1.equals(p2)); // true
   *
   * // Compare with PointData
   * const data = { x: 100, y: 200 };
   * console.log(p1.equals(data)); // true
   *
   * // Check different points
   * const p3 = new ObservablePoint(200, 300);
   * console.log(p1.equals(p3)); // false
   * ```
   * @param p - The point to check
   * @returns `true` if both `x` and `y` are equal
   * @see {@link ObservablePoint.copyFrom} For making points equal
   * @see {@link PointData} For point data interface
   */
  equals(p2) {
    return p2.x === this._x && p2.y === this._y;
  }
  toString() {
    return `[pixi.js/math:ObservablePoint x=${this._x} y=${this._y} scope=${this._observer}]`;
  }
  /**
   * Position of the observable point on the x axis.
   * Triggers observer callback when value changes.
   * @example
   * ```ts
   * // Basic x position
   * const point = new ObservablePoint(observer);
   * point.x = 100; // Triggers observer
   *
   * // Use in calculations
   * const width = rightPoint.x - leftPoint.x;
   * ```
   * @default 0
   */
  get x() {
    return this._x;
  }
  set x(value2) {
    if (this._x !== value2) {
      this._x = value2;
      this._observer._onUpdate(this);
    }
  }
  /**
   * Position of the observable point on the y axis.
   * Triggers observer callback when value changes.
   * @example
   * ```ts
   * // Basic y position
   * const point = new ObservablePoint(observer);
   * point.y = 200; // Triggers observer
   *
   * // Use in calculations
   * const height = bottomPoint.y - topPoint.y;
   * ```
   * @default 0
   */
  get y() {
    return this._y;
  }
  set y(value2) {
    if (this._y !== value2) {
      this._y = value2;
      this._observer._onUpdate(this);
    }
  }
}
var eventemitter3 = { exports: {} };
var hasRequiredEventemitter3;
function requireEventemitter3() {
  if (hasRequiredEventemitter3) return eventemitter3.exports;
  hasRequiredEventemitter3 = 1;
  (function(module) {
    var has = Object.prototype.hasOwnProperty, prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn, context2, once) {
      this.fn = fn;
      this.context = context2;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context2, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context2 || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names = [], events, name2;
      if (this._eventsCount === 0) return names;
      for (name2 in events = this._events) {
        if (has.call(events, name2)) names.push(prefix ? name2.slice(1) : name2);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i2 = 0, l2 = handlers.length, ee = new Array(l2); i2 < l2; i2++) {
        ee[i2] = handlers[i2].fn;
      }
      return ee;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i2;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i2 = 1, args = new Array(len - 1); i2 < len; i2++) {
          args[i2 - 1] = arguments[i2];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j2;
        for (i2 = 0; i2 < length; i2++) {
          if (listeners[i2].once) this.removeListener(event, listeners[i2].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i2].fn.call(listeners[i2].context);
              break;
            case 2:
              listeners[i2].fn.call(listeners[i2].context, a1);
              break;
            case 3:
              listeners[i2].fn.call(listeners[i2].context, a1, a2);
              break;
            case 4:
              listeners[i2].fn.call(listeners[i2].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j2 = 1, args = new Array(len - 1); j2 < len; j2++) {
                args[j2 - 1] = arguments[j2];
              }
              listeners[i2].fn.apply(listeners[i2].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn, context2) {
      return addListener(this, event, fn, context2, false);
    };
    EventEmitter2.prototype.once = function once(event, fn, context2) {
      return addListener(this, event, fn, context2, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn, context2, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context2 || listeners.context === context2)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i2 = 0, events = [], length = listeners.length; i2 < length; i2++) {
          if (listeners[i2].fn !== fn || once && !listeners[i2].once || context2 && listeners[i2].context !== context2) {
            events.push(listeners[i2]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix;
    EventEmitter2.EventEmitter = EventEmitter2;
    {
      module.exports = EventEmitter2;
    }
  })(eventemitter3);
  return eventemitter3.exports;
}
var eventemitter3Exports = requireEventemitter3();
const EventEmitter = /* @__PURE__ */ getDefaultExportFromCjs(eventemitter3Exports);
const PI_2 = Math.PI * 2;
const RAD_TO_DEG = 180 / Math.PI;
const DEG_TO_RAD = Math.PI / 180;
class Point {
  /**
   * Creates a new `Point`
   * @param {number} [x=0] - position of the point on the x axis
   * @param {number} [y=0] - position of the point on the y axis
   */
  constructor(x2 = 0, y2 = 0) {
    this.x = 0;
    this.y = 0;
    this.x = x2;
    this.y = y2;
  }
  /**
   * Creates a clone of this point, which is a new instance with the same `x` and `y` values.
   * @example
   * ```ts
   * // Basic point cloning
   * const original = new Point(100, 200);
   * const copy = original.clone();
   *
   * // Clone and modify
   * const modified = original.clone();
   * modified.set(300, 400);
   *
   * // Verify independence
   * console.log(original); // Point(100, 200)
   * console.log(modified); // Point(300, 400)
   * ```
   * @remarks
   * - Creates new Point instance
   * - Deep copies x and y values
   * - Independent from original
   * - Useful for preserving values
   * @returns A clone of this point
   * @see {@link Point.copyFrom} For copying into existing point
   * @see {@link Point.copyTo} For copying to existing point
   */
  clone() {
    return new Point(this.x, this.y);
  }
  /**
   * Copies x and y from the given point into this point.
   * @example
   * ```ts
   * // Basic copying
   * const source = new Point(100, 200);
   * const target = new Point();
   * target.copyFrom(source);
   *
   * // Copy and chain operations
   * const point = new Point()
   *     .copyFrom(source)
   *     .set(x + 50, y + 50);
   *
   * // Copy from any PointData
   * const data = { x: 10, y: 20 };
   * point.copyFrom(data);
   * ```
   * @param p - The point to copy from
   * @returns The point instance itself
   * @see {@link Point.copyTo} For copying to another point
   * @see {@link Point.clone} For creating new point copy
   */
  copyFrom(p2) {
    this.set(p2.x, p2.y);
    return this;
  }
  /**
   * Copies this point's x and y into the given point.
   * @example
   * ```ts
   * // Basic copying
   * const source = new Point(100, 200);
   * const target = new Point();
   * source.copyTo(target);
   * ```
   * @param p - The point to copy to. Can be any type that is or extends `PointLike`
   * @returns The point (`p`) with values updated
   * @see {@link Point.copyFrom} For copying from another point
   * @see {@link Point.clone} For creating new point copy
   */
  copyTo(p2) {
    p2.set(this.x, this.y);
    return p2;
  }
  /**
   * Checks if another point is equal to this point.
   *
   * Compares x and y values using strict equality.
   * @example
   * ```ts
   * // Basic equality check
   * const p1 = new Point(100, 200);
   * const p2 = new Point(100, 200);
   * console.log(p1.equals(p2)); // true
   *
   * // Compare with PointData
   * const data = { x: 100, y: 200 };
   * console.log(p1.equals(data)); // true
   *
   * // Check different points
   * const p3 = new Point(200, 300);
   * console.log(p1.equals(p3)); // false
   * ```
   * @param p - The point to check
   * @returns `true` if both `x` and `y` are equal
   * @see {@link Point.copyFrom} For making points equal
   * @see {@link PointData} For point data interface
   */
  equals(p2) {
    return p2.x === this.x && p2.y === this.y;
  }
  /**
   * Sets the point to a new x and y position.
   *
   * If y is omitted, both x and y will be set to x.
   * @example
   * ```ts
   * // Basic position setting
   * const point = new Point();
   * point.set(100, 200);
   *
   * // Set both x and y to same value
   * point.set(50); // x=50, y=50
   *
   * // Chain with other operations
   * point
   *     .set(10, 20)
   *     .copyTo(otherPoint);
   * ```
   * @param x - Position on the x axis
   * @param y - Position on the y axis, defaults to x
   * @returns The point instance itself
   * @see {@link Point.copyFrom} For copying from another point
   * @see {@link Point.equals} For comparing positions
   */
  set(x2 = 0, y2 = x2) {
    this.x = x2;
    this.y = y2;
    return this;
  }
  toString() {
    return `[pixi.js/math:Point x=${this.x} y=${this.y}]`;
  }
  /**
   * A static Point object with `x` and `y` values of `0`.
   *
   * This shared instance is reset to zero values when accessed.
   *
   * > [!IMPORTANT] This point is shared and temporary. Do not store references to it.
   * @example
   * ```ts
   * // Use for temporary calculations
   * const tempPoint = Point.shared;
   * tempPoint.set(100, 200);
   * matrix.apply(tempPoint);
   *
   * // Will be reset to (0,0) on next access
   * const fresh = Point.shared; // x=0, y=0
   * ```
   * @readonly
   * @returns A fresh zeroed point for temporary use
   * @see {@link Point.constructor} For creating new points
   * @see {@link PointData} For basic point interface
   */
  static get shared() {
    tempPoint.x = 0;
    tempPoint.y = 0;
    return tempPoint;
  }
}
const tempPoint = new Point();
class Matrix {
  /**
   * @param a - x scale
   * @param b - y skew
   * @param c - x skew
   * @param d - y scale
   * @param tx - x translation
   * @param ty - y translation
   */
  constructor(a2 = 1, b2 = 0, c2 = 0, d2 = 1, tx = 0, ty = 0) {
    this.array = null;
    this.a = a2;
    this.b = b2;
    this.c = c2;
    this.d = d2;
    this.tx = tx;
    this.ty = ty;
  }
  /**
   * Creates a Matrix object based on the given array.
   * Populates matrix components from a flat array in column-major order.
   *
   * > [!NOTE] Array mapping order:
   * > ```
   * > array[0] = a  (x scale)
   * > array[1] = b  (y skew)
   * > array[2] = tx (x translation)
   * > array[3] = c  (x skew)
   * > array[4] = d  (y scale)
   * > array[5] = ty (y translation)
   * > ```
   * @example
   * ```ts
   * // Create matrix from array
   * const matrix = new Matrix();
   * matrix.fromArray([
   *     2, 0,  100,  // a, b, tx
   *     0, 2,  100   // c, d, ty
   * ]);
   *
   * // Create matrix from typed array
   * const float32Array = new Float32Array([
   *     1, 0, 0,     // Scale x1, no skew
   *     0, 1, 0      // No skew, scale x1
   * ]);
   * matrix.fromArray(float32Array);
   * ```
   * @param array - The array to populate the matrix from
   * @see {@link Matrix.toArray} For converting matrix to array
   * @see {@link Matrix.set} For setting values directly
   */
  fromArray(array) {
    this.a = array[0];
    this.b = array[1];
    this.c = array[3];
    this.d = array[4];
    this.tx = array[2];
    this.ty = array[5];
  }
  /**
   * Sets the matrix properties directly.
   * All matrix components can be set in one call.
   * @example
   * ```ts
   * // Set to identity matrix
   * matrix.set(1, 0, 0, 1, 0, 0);
   *
   * // Set to scale matrix
   * matrix.set(2, 0, 0, 2, 0, 0); // Scale 2x
   *
   * // Set to translation matrix
   * matrix.set(1, 0, 0, 1, 100, 50); // Move 100,50
   * ```
   * @param a - Scale on x axis
   * @param b - Shear on y axis
   * @param c - Shear on x axis
   * @param d - Scale on y axis
   * @param tx - Translation on x axis
   * @param ty - Translation on y axis
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.identity} For resetting to identity
   * @see {@link Matrix.fromArray} For setting from array
   */
  set(a2, b2, c2, d2, tx, ty) {
    this.a = a2;
    this.b = b2;
    this.c = c2;
    this.d = d2;
    this.tx = tx;
    this.ty = ty;
    return this;
  }
  /**
   * Creates an array from the current Matrix object.
   *
   * > [!NOTE] The array format is:
   * > ```
   * > Non-transposed:
   * > [a, c, tx,
   * > b, d, ty,
   * > 0, 0, 1]
   * >
   * > Transposed:
   * > [a, b, 0,
   * > c, d, 0,
   * > tx,ty,1]
   * > ```
   * @example
   * ```ts
   * // Basic array conversion
   * const matrix = new Matrix(2, 0, 0, 2, 100, 100);
   * const array = matrix.toArray();
   *
   * // Using existing array
   * const float32Array = new Float32Array(9);
   * matrix.toArray(false, float32Array);
   *
   * // Get transposed array
   * const transposed = matrix.toArray(true);
   * ```
   * @param transpose - Whether to transpose the matrix
   * @param out - Optional Float32Array to store the result
   * @returns The array containing the matrix values
   * @see {@link Matrix.fromArray} For creating matrix from array
   * @see {@link Matrix.array} For cached array storage
   */
  toArray(transpose, out2) {
    if (!this.array) {
      this.array = new Float32Array(9);
    }
    const array = out2 || this.array;
    if (transpose) {
      array[0] = this.a;
      array[1] = this.b;
      array[2] = 0;
      array[3] = this.c;
      array[4] = this.d;
      array[5] = 0;
      array[6] = this.tx;
      array[7] = this.ty;
      array[8] = 1;
    } else {
      array[0] = this.a;
      array[1] = this.c;
      array[2] = this.tx;
      array[3] = this.b;
      array[4] = this.d;
      array[5] = this.ty;
      array[6] = 0;
      array[7] = 0;
      array[8] = 1;
    }
    return array;
  }
  /**
   * Get a new position with the current transformation applied.
   *
   * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
   * @example
   * ```ts
   * // Basic point transformation
   * const matrix = new Matrix().translate(100, 50).rotate(Math.PI / 4);
   * const point = new Point(10, 20);
   * const transformed = matrix.apply(point);
   *
   * // Reuse existing point
   * const output = new Point();
   * matrix.apply(point, output);
   * ```
   * @param pos - The origin point to transform
   * @param newPos - Optional point to store the result
   * @returns The transformed point
   * @see {@link Matrix.applyInverse} For inverse transformation
   * @see {@link Point} For point operations
   */
  apply(pos, newPos) {
    newPos = newPos || new Point();
    const x2 = pos.x;
    const y2 = pos.y;
    newPos.x = this.a * x2 + this.c * y2 + this.tx;
    newPos.y = this.b * x2 + this.d * y2 + this.ty;
    return newPos;
  }
  /**
   * Get a new position with the inverse of the current transformation applied.
   *
   * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
   * @example
   * ```ts
   * // Basic inverse transformation
   * const matrix = new Matrix().translate(100, 50).rotate(Math.PI / 4);
   * const worldPoint = new Point(150, 100);
   * const localPoint = matrix.applyInverse(worldPoint);
   *
   * // Reuse existing point
   * const output = new Point();
   * matrix.applyInverse(worldPoint, output);
   *
   * // Convert mouse position to local space
   * const mousePoint = new Point(mouseX, mouseY);
   * const localMouse = matrix.applyInverse(mousePoint);
   * ```
   * @param pos - The origin point to inverse-transform
   * @param newPos - Optional point to store the result
   * @returns The inverse-transformed point
   * @see {@link Matrix.apply} For forward transformation
   * @see {@link Matrix.invert} For getting inverse matrix
   */
  applyInverse(pos, newPos) {
    newPos = newPos || new Point();
    const a2 = this.a;
    const b2 = this.b;
    const c2 = this.c;
    const d2 = this.d;
    const tx = this.tx;
    const ty = this.ty;
    const id2 = 1 / (a2 * d2 + c2 * -b2);
    const x2 = pos.x;
    const y2 = pos.y;
    newPos.x = d2 * id2 * x2 + -c2 * id2 * y2 + (ty * c2 - tx * d2) * id2;
    newPos.y = a2 * id2 * y2 + -b2 * id2 * x2 + (-ty * a2 + tx * b2) * id2;
    return newPos;
  }
  /**
   * Translates the matrix on the x and y axes.
   * Adds to the position values while preserving scale, rotation and skew.
   * @example
   * ```ts
   * // Basic translation
   * const matrix = new Matrix();
   * matrix.translate(100, 50); // Move right 100, down 50
   *
   * // Chain with other transformations
   * matrix
   *     .scale(2, 2)
   *     .translate(100, 0)
   *     .rotate(Math.PI / 4);
   * ```
   * @param x - How much to translate on the x axis
   * @param y - How much to translate on the y axis
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.set} For setting position directly
   * @see {@link Matrix.setTransform} For complete transform setup
   */
  translate(x2, y2) {
    this.tx += x2;
    this.ty += y2;
    return this;
  }
  /**
   * Applies a scale transformation to the matrix.
   * Multiplies the scale values with existing matrix components.
   * @example
   * ```ts
   * // Basic scaling
   * const matrix = new Matrix();
   * matrix.scale(2, 3); // Scale 2x horizontally, 3x vertically
   *
   * // Chain with other transformations
   * matrix
   *     .translate(100, 100)
   *     .scale(2, 2)     // Scales after translation
   *     .rotate(Math.PI / 4);
   * ```
   * @param x - The amount to scale horizontally
   * @param y - The amount to scale vertically
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.setTransform} For setting scale directly
   * @see {@link Matrix.append} For combining transformations
   */
  scale(x2, y2) {
    this.a *= x2;
    this.d *= y2;
    this.c *= x2;
    this.b *= y2;
    this.tx *= x2;
    this.ty *= y2;
    return this;
  }
  /**
   * Applies a rotation transformation to the matrix.
   *
   * Rotates around the origin (0,0) by the given angle in radians.
   * @example
   * ```ts
   * // Basic rotation
   * const matrix = new Matrix();
   * matrix.rotate(Math.PI / 4); // Rotate 45 degrees
   *
   * // Chain with other transformations
   * matrix
   *     .translate(100, 100) // Move to rotation center
   *     .rotate(Math.PI)     // Rotate 180 degrees
   *     .scale(2, 2);        // Scale after rotation
   *
   * // Common angles
   * matrix.rotate(Math.PI / 2);  // 90 degrees
   * matrix.rotate(Math.PI);      // 180 degrees
   * matrix.rotate(Math.PI * 2);  // 360 degrees
   * ```
   * @remarks
   * - Rotates around origin point (0,0)
   * - Affects position if translation was set
   * - Uses counter-clockwise rotation
   * - Order of operations matters when chaining
   * @param angle - The angle in radians
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.setTransform} For setting rotation directly
   * @see {@link Matrix.append} For combining transformations
   */
  rotate(angle) {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    const a1 = this.a;
    const c1 = this.c;
    const tx1 = this.tx;
    this.a = a1 * cos - this.b * sin;
    this.b = a1 * sin + this.b * cos;
    this.c = c1 * cos - this.d * sin;
    this.d = c1 * sin + this.d * cos;
    this.tx = tx1 * cos - this.ty * sin;
    this.ty = tx1 * sin + this.ty * cos;
    return this;
  }
  /**
   * Appends the given Matrix to this Matrix.
   * Combines two matrices by multiplying them together: this = this * matrix
   * @example
   * ```ts
   * // Basic matrix combination
   * const matrix = new Matrix();
   * const other = new Matrix().translate(100, 0).rotate(Math.PI / 4);
   * matrix.append(other);
   * ```
   * @remarks
   * - Order matters: A.append(B) !== B.append(A)
   * - Modifies current matrix
   * - Preserves transformation order
   * - Commonly used for combining transforms
   * @param matrix - The matrix to append
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.prepend} For prepending transformations
   * @see {@link Matrix.appendFrom} For appending two external matrices
   */
  append(matrix) {
    const a1 = this.a;
    const b1 = this.b;
    const c1 = this.c;
    const d1 = this.d;
    this.a = matrix.a * a1 + matrix.b * c1;
    this.b = matrix.a * b1 + matrix.b * d1;
    this.c = matrix.c * a1 + matrix.d * c1;
    this.d = matrix.c * b1 + matrix.d * d1;
    this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;
    this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;
    return this;
  }
  /**
   * Appends two matrices and sets the result to this matrix.
   * Performs matrix multiplication: this = A * B
   * @example
   * ```ts
   * // Basic matrix multiplication
   * const result = new Matrix();
   * const matrixA = new Matrix().scale(2, 2);
   * const matrixB = new Matrix().rotate(Math.PI / 4);
   * result.appendFrom(matrixA, matrixB);
   * ```
   * @remarks
   * - Order matters: A * B !== B * A
   * - Creates a new transformation from two others
   * - More efficient than append() for multiple operations
   * - Does not modify input matrices
   * @param a - The first matrix to multiply
   * @param b - The second matrix to multiply
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.append} For single matrix combination
   * @see {@link Matrix.prepend} For reverse order multiplication
   */
  appendFrom(a2, b2) {
    const a1 = a2.a;
    const b1 = a2.b;
    const c1 = a2.c;
    const d1 = a2.d;
    const tx = a2.tx;
    const ty = a2.ty;
    const a22 = b2.a;
    const b22 = b2.b;
    const c2 = b2.c;
    const d2 = b2.d;
    this.a = a1 * a22 + b1 * c2;
    this.b = a1 * b22 + b1 * d2;
    this.c = c1 * a22 + d1 * c2;
    this.d = c1 * b22 + d1 * d2;
    this.tx = tx * a22 + ty * c2 + b2.tx;
    this.ty = tx * b22 + ty * d2 + b2.ty;
    return this;
  }
  /**
   * Sets the matrix based on all the available properties.
   * Combines position, scale, rotation, skew and pivot in a single operation.
   * @example
   * ```ts
   * // Basic transform setup
   * const matrix = new Matrix();
   * matrix.setTransform(
   *     100, 100,    // position
   *     0, 0,        // pivot
   *     2, 2,        // scale
   *     Math.PI / 4, // rotation (45 degrees)
   *     0, 0         // skew
   * );
   * ```
   * @remarks
   * - Updates all matrix components at once
   * - More efficient than separate transform calls
   * - Uses radians for rotation and skew
   * - Pivot affects rotation center
   * @param x - Position on the x axis
   * @param y - Position on the y axis
   * @param pivotX - Pivot on the x axis
   * @param pivotY - Pivot on the y axis
   * @param scaleX - Scale on the x axis
   * @param scaleY - Scale on the y axis
   * @param rotation - Rotation in radians
   * @param skewX - Skew on the x axis
   * @param skewY - Skew on the y axis
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.decompose} For extracting transform properties
   * @see {@link TransformableObject} For transform data structure
   */
  setTransform(x2, y2, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {
    this.a = Math.cos(rotation + skewY) * scaleX;
    this.b = Math.sin(rotation + skewY) * scaleX;
    this.c = -Math.sin(rotation - skewX) * scaleY;
    this.d = Math.cos(rotation - skewX) * scaleY;
    this.tx = x2 - (pivotX * this.a + pivotY * this.c);
    this.ty = y2 - (pivotX * this.b + pivotY * this.d);
    return this;
  }
  /**
   * Prepends the given Matrix to this Matrix.
   * Combines two matrices by multiplying them together: this = matrix * this
   * @example
   * ```ts
   * // Basic matrix prepend
   * const matrix = new Matrix().scale(2, 2);
   * const other = new Matrix().translate(100, 0);
   * matrix.prepend(other); // Translation happens before scaling
   * ```
   * @remarks
   * - Order matters: A.prepend(B) !== B.prepend(A)
   * - Modifies current matrix
   * - Reverses transformation order compared to append()
   * @param matrix - The matrix to prepend
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.append} For appending transformations
   * @see {@link Matrix.appendFrom} For combining external matrices
   */
  prepend(matrix) {
    const tx1 = this.tx;
    if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
      const a1 = this.a;
      const c1 = this.c;
      this.a = a1 * matrix.a + this.b * matrix.c;
      this.b = a1 * matrix.b + this.b * matrix.d;
      this.c = c1 * matrix.a + this.d * matrix.c;
      this.d = c1 * matrix.b + this.d * matrix.d;
    }
    this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;
    this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;
    return this;
  }
  /**
   * Decomposes the matrix into its individual transform components.
   * Extracts position, scale, rotation and skew values from the matrix.
   * @example
   * ```ts
   * // Basic decomposition
   * const matrix = new Matrix()
   *     .translate(100, 100)
   *     .rotate(Math.PI / 4)
   *     .scale(2, 2);
   *
   * const transform = {
   *     position: new Point(),
   *     scale: new Point(),
   *     pivot: new Point(),
   *     skew: new Point(),
   *     rotation: 0
   * };
   *
   * matrix.decompose(transform);
   * console.log(transform.position); // Point(100, 100)
   * console.log(transform.rotation); // ~0.785 (PI/4)
   * console.log(transform.scale); // Point(2, 2)
   * ```
   * @remarks
   * - Handles combined transformations
   * - Accounts for pivot points
   * - Chooses between rotation/skew based on transform type
   * - Uses radians for rotation and skew
   * @param transform - The transform object to store the decomposed values
   * @returns The transform with the newly applied properties
   * @see {@link Matrix.setTransform} For composing from components
   * @see {@link TransformableObject} For transform structure
   */
  decompose(transform) {
    const a2 = this.a;
    const b2 = this.b;
    const c2 = this.c;
    const d2 = this.d;
    const pivot = transform.pivot;
    const skewX = -Math.atan2(-c2, d2);
    const skewY = Math.atan2(b2, a2);
    const delta = Math.abs(skewX + skewY);
    if (delta < 1e-5 || Math.abs(PI_2 - delta) < 1e-5) {
      transform.rotation = skewY;
      transform.skew.x = transform.skew.y = 0;
    } else {
      transform.rotation = 0;
      transform.skew.x = skewX;
      transform.skew.y = skewY;
    }
    transform.scale.x = Math.sqrt(a2 * a2 + b2 * b2);
    transform.scale.y = Math.sqrt(c2 * c2 + d2 * d2);
    transform.position.x = this.tx + (pivot.x * a2 + pivot.y * c2);
    transform.position.y = this.ty + (pivot.x * b2 + pivot.y * d2);
    return transform;
  }
  /**
   * Inverts this matrix.
   * Creates the matrix that when multiplied with this matrix results in an identity matrix.
   * @example
   * ```ts
   * // Basic matrix inversion
   * const matrix = new Matrix()
   *     .translate(100, 50)
   *     .scale(2, 2);
   *
   * matrix.invert(); // Now transforms in opposite direction
   *
   * // Verify inversion
   * const point = new Point(50, 50);
   * const transformed = matrix.apply(point);
   * const original = matrix.invert().apply(transformed);
   * // original  point
   * ```
   * @remarks
   * - Modifies the current matrix
   * - Useful for reversing transformations
   * - Cannot invert matrices with zero determinant
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.identity} For resetting to identity
   * @see {@link Matrix.applyInverse} For inverse transformations
   */
  invert() {
    const a1 = this.a;
    const b1 = this.b;
    const c1 = this.c;
    const d1 = this.d;
    const tx1 = this.tx;
    const n2 = a1 * d1 - b1 * c1;
    this.a = d1 / n2;
    this.b = -b1 / n2;
    this.c = -c1 / n2;
    this.d = a1 / n2;
    this.tx = (c1 * this.ty - d1 * tx1) / n2;
    this.ty = -(a1 * this.ty - b1 * tx1) / n2;
    return this;
  }
  /**
   * Checks if this matrix is an identity matrix.
   *
   * An identity matrix has no transformations applied (default state).
   * @example
   * ```ts
   * // Check if matrix is identity
   * const matrix = new Matrix();
   * console.log(matrix.isIdentity()); // true
   *
   * // Check after transformations
   * matrix.translate(100, 0);
   * console.log(matrix.isIdentity()); // false
   *
   * // Reset and verify
   * matrix.identity();
   * console.log(matrix.isIdentity()); // true
   * ```
   * @remarks
   * - Verifies a = 1, d = 1 (no scale)
   * - Verifies b = 0, c = 0 (no skew)
   * - Verifies tx = 0, ty = 0 (no translation)
   * @returns True if matrix has no transformations
   * @see {@link Matrix.identity} For resetting to identity
   * @see {@link Matrix.IDENTITY} For constant identity matrix
   */
  isIdentity() {
    return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;
  }
  /**
   * Resets this Matrix to an identity (default) matrix.
   * Sets all components to their default values: scale=1, no skew, no translation.
   * @example
   * ```ts
   * // Reset transformed matrix
   * const matrix = new Matrix()
   *     .scale(2, 2)
   *     .rotate(Math.PI / 4);
   * matrix.identity(); // Back to default state
   *
   * // Chain after reset
   * matrix
   *     .identity()
   *     .translate(100, 100)
   *     .scale(2, 2);
   *
   * // Compare with identity constant
   * const isDefault = matrix.equals(Matrix.IDENTITY);
   * ```
   * @remarks
   * - Sets a=1, d=1 (default scale)
   * - Sets b=0, c=0 (no skew)
   * - Sets tx=0, ty=0 (no translation)
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.IDENTITY} For constant identity matrix
   * @see {@link Matrix.isIdentity} For checking identity state
   */
  identity() {
    this.a = 1;
    this.b = 0;
    this.c = 0;
    this.d = 1;
    this.tx = 0;
    this.ty = 0;
    return this;
  }
  /**
   * Creates a new Matrix object with the same values as this one.
   * @returns A copy of this matrix. Good for chaining method calls.
   */
  clone() {
    const matrix = new Matrix();
    matrix.a = this.a;
    matrix.b = this.b;
    matrix.c = this.c;
    matrix.d = this.d;
    matrix.tx = this.tx;
    matrix.ty = this.ty;
    return matrix;
  }
  /**
   * Creates a new Matrix object with the same values as this one.
   * @param matrix
   * @example
   * ```ts
   * // Basic matrix cloning
   * const matrix = new Matrix()
   *     .translate(100, 100)
   *     .rotate(Math.PI / 4);
   * const copy = matrix.clone();
   *
   * // Clone and modify
   * const modified = matrix.clone()
   *     .scale(2, 2);
   *
   * // Compare matrices
   * console.log(matrix.equals(copy));     // true
   * console.log(matrix.equals(modified)); // false
   * ```
   * @returns A copy of this matrix. Good for chaining method calls.
   * @see {@link Matrix.copyTo} For copying to existing matrix
   * @see {@link Matrix.copyFrom} For copying from another matrix
   */
  copyTo(matrix) {
    matrix.a = this.a;
    matrix.b = this.b;
    matrix.c = this.c;
    matrix.d = this.d;
    matrix.tx = this.tx;
    matrix.ty = this.ty;
    return matrix;
  }
  /**
   * Changes the values of the matrix to be the same as the ones in given matrix.
   * @example
   * ```ts
   * // Basic matrix copying
   * const source = new Matrix()
   *     .translate(100, 100)
   *     .rotate(Math.PI / 4);
   * const target = new Matrix();
   * target.copyFrom(source);
   * ```
   * @param matrix - The matrix to copy from
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.clone} For creating new matrix copy
   * @see {@link Matrix.copyTo} For copying to another matrix
   */
  copyFrom(matrix) {
    this.a = matrix.a;
    this.b = matrix.b;
    this.c = matrix.c;
    this.d = matrix.d;
    this.tx = matrix.tx;
    this.ty = matrix.ty;
    return this;
  }
  /**
   * Checks if this matrix equals another matrix.
   * Compares all components for exact equality.
   * @example
   * ```ts
   * // Basic equality check
   * const m1 = new Matrix();
   * const m2 = new Matrix();
   * console.log(m1.equals(m2)); // true
   *
   * // Compare transformed matrices
   * const transform = new Matrix()
   *     .translate(100, 100)
   * const clone = new Matrix()
   *     .scale(2, 2);
   * console.log(transform.equals(clone)); // false
   * ```
   * @param matrix - The matrix to compare to
   * @returns True if matrices are identical
   * @see {@link Matrix.copyFrom} For copying matrix values
   * @see {@link Matrix.isIdentity} For identity comparison
   */
  equals(matrix) {
    return matrix.a === this.a && matrix.b === this.b && matrix.c === this.c && matrix.d === this.d && matrix.tx === this.tx && matrix.ty === this.ty;
  }
  toString() {
    return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
  }
  /**
   * A default (identity) matrix with no transformations applied.
   *
   * > [!IMPORTANT] This is a shared read-only object. Create a new Matrix if you need to modify it.
   * @example
   * ```ts
   * // Get identity matrix reference
   * const identity = Matrix.IDENTITY;
   * console.log(identity.isIdentity()); // true
   *
   * // Compare with identity
   * const matrix = new Matrix();
   * console.log(matrix.equals(Matrix.IDENTITY)); // true
   *
   * // Create new matrix instead of modifying IDENTITY
   * const transform = new Matrix()
   *     .copyFrom(Matrix.IDENTITY)
   *     .translate(100, 100);
   * ```
   * @readonly
   * @returns A read-only identity matrix
   * @see {@link Matrix.shared} For temporary calculations
   * @see {@link Matrix.identity} For resetting matrices
   */
  static get IDENTITY() {
    return identityMatrix$1.identity();
  }
  /**
   * A static Matrix that can be used to avoid creating new objects.
   * Will always ensure the matrix is reset to identity when requested.
   *
   * > [!IMPORTANT] This matrix is shared and temporary. Do not store references to it.
   * @example
   * ```ts
   * // Use for temporary calculations
   * const tempMatrix = Matrix.shared;
   * tempMatrix.translate(100, 100).rotate(Math.PI / 4);
   * const point = tempMatrix.apply({ x: 10, y: 20 });
   *
   * // Will be reset to identity on next access
   * const fresh = Matrix.shared; // Back to identity
   * ```
   * @remarks
   * - Always returns identity matrix
   * - Safe to modify temporarily
   * - Not safe to store references
   * - Useful for one-off calculations
   * @readonly
   * @returns A fresh identity matrix for temporary use
   * @see {@link Matrix.IDENTITY} For immutable identity matrix
   * @see {@link Matrix.identity} For resetting matrices
   */
  static get shared() {
    return tempMatrix$3.identity();
  }
}
const tempMatrix$3 = new Matrix();
const identityMatrix$1 = new Matrix();
const ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];
const uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];
const vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];
const vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];
const rotationCayley = [];
const rotationMatrices = [];
const signum = Math.sign;
function init() {
  for (let i2 = 0; i2 < 16; i2++) {
    const row = [];
    rotationCayley.push(row);
    for (let j2 = 0; j2 < 16; j2++) {
      const _ux = signum(ux[i2] * ux[j2] + vx[i2] * uy[j2]);
      const _uy = signum(uy[i2] * ux[j2] + vy[i2] * uy[j2]);
      const _vx = signum(ux[i2] * vx[j2] + vx[i2] * vy[j2]);
      const _vy = signum(uy[i2] * vx[j2] + vy[i2] * vy[j2]);
      for (let k2 = 0; k2 < 16; k2++) {
        if (ux[k2] === _ux && uy[k2] === _uy && vx[k2] === _vx && vy[k2] === _vy) {
          row.push(k2);
          break;
        }
      }
    }
  }
  for (let i2 = 0; i2 < 16; i2++) {
    const mat = new Matrix();
    mat.set(ux[i2], uy[i2], vx[i2], vy[i2], 0, 0);
    rotationMatrices.push(mat);
  }
}
init();
const groupD8 = {
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 0       | East      |
   * @group groupD8
   * @type {GD8Symmetry}
   */
  E: 0,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 45     | Southeast |
   * @group groupD8
   * @type {GD8Symmetry}
   */
  SE: 1,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 90     | South     |
   * @group groupD8
   * @type {GD8Symmetry}
   */
  S: 2,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 135    | Southwest |
   * @group groupD8
   * @type {GD8Symmetry}
   */
  SW: 3,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 180     | West      |
   * @group groupD8
   * @type {GD8Symmetry}
   */
  W: 4,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -135/225 | Northwest    |
   * @group groupD8
   * @type {GD8Symmetry}
   */
  NW: 5,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -90/270  | North        |
   * @group groupD8
   * @type {GD8Symmetry}
   */
  N: 6,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -45/315  | Northeast    |
   * @group groupD8
   * @type {GD8Symmetry}
   */
  NE: 7,
  /**
   * Reflection about Y-axis.
   * @group groupD8
   * @type {GD8Symmetry}
   */
  MIRROR_VERTICAL: 8,
  /**
   * Reflection about the main diagonal.
   * @group groupD8
   * @type {GD8Symmetry}
   */
  MAIN_DIAGONAL: 10,
  /**
   * Reflection about X-axis.
   * @group groupD8
   * @type {GD8Symmetry}
   */
  MIRROR_HORIZONTAL: 12,
  /**
   * Reflection about reverse diagonal.
   * @group groupD8
   * @type {GD8Symmetry}
   */
  REVERSE_DIAGONAL: 14,
  /**
   * @group groupD8
   * @param {GD8Symmetry} ind - sprite rotation angle.
   * @returns {GD8Symmetry} The X-component of the U-axis
   *    after rotating the axes.
   */
  uX: (ind) => ux[ind],
  /**
   * @group groupD8
   * @param {GD8Symmetry} ind - sprite rotation angle.
   * @returns {GD8Symmetry} The Y-component of the U-axis
   *    after rotating the axes.
   */
  uY: (ind) => uy[ind],
  /**
   * @group groupD8
   * @param {GD8Symmetry} ind - sprite rotation angle.
   * @returns {GD8Symmetry} The X-component of the V-axis
   *    after rotating the axes.
   */
  vX: (ind) => vx[ind],
  /**
   * @group groupD8
   * @param {GD8Symmetry} ind - sprite rotation angle.
   * @returns {GD8Symmetry} The Y-component of the V-axis
   *    after rotating the axes.
   */
  vY: (ind) => vy[ind],
  /**
   * @group groupD8
   * @param {GD8Symmetry} rotation - symmetry whose opposite
   *   is needed. Only rotations have opposite symmetries while
   *   reflections don't.
   * @returns {GD8Symmetry} The opposite symmetry of `rotation`
   */
  inv: (rotation) => {
    if (rotation & 8) {
      return rotation & 15;
    }
    return -rotation & 7;
  },
  /**
   * Composes the two D8 operations.
   *
   * Taking `^` as reflection:
   *
   * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |
   * |-------|-----|-----|-----|-----|------|-------|-------|-------|
   * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |
   * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |
   * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |
   * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |
   * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |
   * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |
   * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |
   * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |
   *
   * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}
   * @group groupD8
   * @param {GD8Symmetry} rotationSecond - Second operation, which
   *   is the row in the above cayley table.
   * @param {GD8Symmetry} rotationFirst - First operation, which
   *   is the column in the above cayley table.
   * @returns {GD8Symmetry} Composed operation
   */
  add: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][rotationFirst],
  /**
   * Reverse of `add`.
   * @group groupD8
   * @param {GD8Symmetry} rotationSecond - Second operation
   * @param {GD8Symmetry} rotationFirst - First operation
   * @returns {GD8Symmetry} Result
   */
  sub: (rotationSecond, rotationFirst) => rotationCayley[rotationSecond][groupD8.inv(rotationFirst)],
  /**
   * Adds 180 degrees to rotation, which is a commutative
   * operation.
   * @group groupD8
   * @param {number} rotation - The number to rotate.
   * @returns {number} Rotated number
   */
  rotate180: (rotation) => rotation ^ 4,
  /**
   * Checks if the rotation angle is vertical, i.e. south
   * or north. It doesn't work for reflections.
   * @group groupD8
   * @param {GD8Symmetry} rotation - The number to check.
   * @returns {boolean} Whether or not the direction is vertical
   */
  isVertical: (rotation) => (rotation & 3) === 2,
  // rotation % 4 === 2
  /**
   * Approximates the vector `V(dx,dy)` into one of the
   * eight directions provided by `groupD8`.
   * @group groupD8
   * @param {number} dx - X-component of the vector
   * @param {number} dy - Y-component of the vector
   * @returns {GD8Symmetry} Approximation of the vector into
   *  one of the eight symmetries.
   */
  byDirection: (dx, dy) => {
    if (Math.abs(dx) * 2 <= Math.abs(dy)) {
      if (dy >= 0) {
        return groupD8.S;
      }
      return groupD8.N;
    } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {
      if (dx > 0) {
        return groupD8.E;
      }
      return groupD8.W;
    } else if (dy > 0) {
      if (dx > 0) {
        return groupD8.SE;
      }
      return groupD8.SW;
    } else if (dx > 0) {
      return groupD8.NE;
    }
    return groupD8.NW;
  },
  /**
   * Helps sprite to compensate texture packer rotation.
   * @group groupD8
   * @param {Matrix} matrix - sprite world matrix
   * @param {GD8Symmetry} rotation - The rotation factor to use.
   * @param {number} tx - sprite anchoring
   * @param {number} ty - sprite anchoring
   */
  matrixAppendRotationInv: (matrix, rotation, tx = 0, ty = 0) => {
    const mat = rotationMatrices[groupD8.inv(rotation)];
    mat.tx = tx;
    mat.ty = ty;
    matrix.append(mat);
  },
  /**
   * Transforms rectangle coordinates based on texture packer rotation.
   * Used when texture atlas pages are rotated and coordinates need to be adjusted.
   * @group groupD8
   * @param {RectangleLike} rect - Rectangle with original coordinates to transform
   * @param {RectangleLike} sourceFrame - Source texture frame (includes offset and dimensions)
   * @param {GD8Symmetry} rotation - The groupD8 rotation value
   * @param {Rectangle} out - Rectangle to store the result
   * @returns {Rectangle} Transformed coordinates (includes source frame offset)
   */
  transformRectCoords: (rect, sourceFrame, rotation, out2) => {
    const { x: x2, y: y2, width, height } = rect;
    const { x: frameX, y: frameY, width: frameWidth, height: frameHeight } = sourceFrame;
    if (rotation === groupD8.E) {
      out2.set(x2 + frameX, y2 + frameY, width, height);
      return out2;
    } else if (rotation === groupD8.S) {
      return out2.set(
        frameWidth - y2 - height + frameX,
        x2 + frameY,
        height,
        width
      );
    } else if (rotation === groupD8.W) {
      return out2.set(
        frameWidth - x2 - width + frameX,
        frameHeight - y2 - height + frameY,
        width,
        height
      );
    } else if (rotation === groupD8.N) {
      return out2.set(
        y2 + frameX,
        frameHeight - x2 - width + frameY,
        height,
        width
      );
    }
    return out2.set(x2 + frameX, y2 + frameY, width, height);
  }
};
const tempPoints = [new Point(), new Point(), new Point(), new Point()];
class Rectangle {
  /**
   * @param x - The X coordinate of the upper-left corner of the rectangle
   * @param y - The Y coordinate of the upper-left corner of the rectangle
   * @param width - The overall width of the rectangle
   * @param height - The overall height of the rectangle
   */
  constructor(x2 = 0, y2 = 0, width = 0, height = 0) {
    this.type = "rectangle";
    this.x = Number(x2);
    this.y = Number(y2);
    this.width = Number(width);
    this.height = Number(height);
  }
  /**
   * Returns the left edge (x-coordinate) of the rectangle.
   * @example
   * ```ts
   * // Get left edge position
   * const rect = new Rectangle(100, 100, 200, 150);
   * console.log(rect.left); // 100
   *
   * // Use in alignment calculations
   * sprite.x = rect.left + padding;
   *
   * // Compare positions
   * if (point.x > rect.left) {
   *     console.log('Point is right of rectangle');
   * }
   * ```
   * @readonly
   * @returns The x-coordinate of the left edge
   * @see {@link Rectangle.right} For right edge position
   * @see {@link Rectangle.x} For direct x-coordinate access
   */
  get left() {
    return this.x;
  }
  /**
   * Returns the right edge (x + width) of the rectangle.
   * @example
   * ```ts
   * // Get right edge position
   * const rect = new Rectangle(100, 100, 200, 150);
   * console.log(rect.right); // 300
   *
   * // Align to right edge
   * sprite.x = rect.right - sprite.width;
   *
   * // Check boundaries
   * if (point.x < rect.right) {
   *     console.log('Point is inside right bound');
   * }
   * ```
   * @readonly
   * @returns The x-coordinate of the right edge
   * @see {@link Rectangle.left} For left edge position
   * @see {@link Rectangle.width} For width value
   */
  get right() {
    return this.x + this.width;
  }
  /**
   * Returns the top edge (y-coordinate) of the rectangle.
   * @example
   * ```ts
   * // Get top edge position
   * const rect = new Rectangle(100, 100, 200, 150);
   * console.log(rect.top); // 100
   *
   * // Position above rectangle
   * sprite.y = rect.top - sprite.height;
   *
   * // Check vertical position
   * if (point.y > rect.top) {
   *     console.log('Point is below top edge');
   * }
   * ```
   * @readonly
   * @returns The y-coordinate of the top edge
   * @see {@link Rectangle.bottom} For bottom edge position
   * @see {@link Rectangle.y} For direct y-coordinate access
   */
  get top() {
    return this.y;
  }
  /**
   * Returns the bottom edge (y + height) of the rectangle.
   * @example
   * ```ts
   * // Get bottom edge position
   * const rect = new Rectangle(100, 100, 200, 150);
   * console.log(rect.bottom); // 250
   *
   * // Stack below rectangle
   * sprite.y = rect.bottom + margin;
   *
   * // Check vertical bounds
   * if (point.y < rect.bottom) {
   *     console.log('Point is above bottom edge');
   * }
   * ```
   * @readonly
   * @returns The y-coordinate of the bottom edge
   * @see {@link Rectangle.top} For top edge position
   * @see {@link Rectangle.height} For height value
   */
  get bottom() {
    return this.y + this.height;
  }
  /**
   * Determines whether the Rectangle is empty (has no area).
   * @example
   * ```ts
   * // Check zero dimensions
   * const rect = new Rectangle(100, 100, 0, 50);
   * console.log(rect.isEmpty()); // true
   * ```
   * @returns True if the rectangle has no area
   * @see {@link Rectangle.width} For width value
   * @see {@link Rectangle.height} For height value
   */
  isEmpty() {
    return this.left === this.right || this.top === this.bottom;
  }
  /**
   * A constant empty rectangle. This is a new object every time the property is accessed.
   * @example
   * ```ts
   * // Get fresh empty rectangle
   * const empty = Rectangle.EMPTY;
   * console.log(empty.isEmpty()); // true
   * ```
   * @returns A new empty rectangle instance
   * @see {@link Rectangle.isEmpty} For empty state testing
   */
  static get EMPTY() {
    return new Rectangle(0, 0, 0, 0);
  }
  /**
   * Creates a clone of this Rectangle
   * @example
   * ```ts
   * // Basic cloning
   * const original = new Rectangle(100, 100, 200, 150);
   * const copy = original.clone();
   *
   * // Clone and modify
   * const modified = original.clone();
   * modified.width *= 2;
   * modified.height += 50;
   *
   * // Verify independence
   * console.log(original.width);  // 200
   * console.log(modified.width);  // 400
   * ```
   * @returns A copy of the rectangle
   * @see {@link Rectangle.copyFrom} For copying into existing rectangle
   * @see {@link Rectangle.copyTo} For copying to another rectangle
   */
  clone() {
    return new Rectangle(this.x, this.y, this.width, this.height);
  }
  /**
   * Converts a Bounds object to a Rectangle object.
   * @example
   * ```ts
   * // Convert bounds to rectangle
   * const bounds = container.getBounds();
   * const rect = new Rectangle().copyFromBounds(bounds);
   * ```
   * @param bounds - The bounds to copy and convert to a rectangle
   * @returns Returns itself
   * @see {@link Bounds} For bounds object structure
   * @see {@link Rectangle.getBounds} For getting rectangle bounds
   */
  copyFromBounds(bounds) {
    this.x = bounds.minX;
    this.y = bounds.minY;
    this.width = bounds.maxX - bounds.minX;
    this.height = bounds.maxY - bounds.minY;
    return this;
  }
  /**
   * Copies another rectangle to this one.
   * @example
   * ```ts
   * // Basic copying
   * const source = new Rectangle(100, 100, 200, 150);
   * const target = new Rectangle();
   * target.copyFrom(source);
   *
   * // Chain with other operations
   * const rect = new Rectangle()
   *     .copyFrom(source)
   *     .pad(10);
   * ```
   * @param rectangle - The rectangle to copy from
   * @returns Returns itself
   * @see {@link Rectangle.copyTo} For copying to another rectangle
   * @see {@link Rectangle.clone} For creating new rectangle copy
   */
  copyFrom(rectangle) {
    this.x = rectangle.x;
    this.y = rectangle.y;
    this.width = rectangle.width;
    this.height = rectangle.height;
    return this;
  }
  /**
   * Copies this rectangle to another one.
   * @example
   * ```ts
   * // Basic copying
   * const source = new Rectangle(100, 100, 200, 150);
   * const target = new Rectangle();
   * source.copyTo(target);
   *
   * // Chain with other operations
   * const result = source
   *     .copyTo(new Rectangle())
   *     .getBounds();
   * ```
   * @param rectangle - The rectangle to copy to
   * @returns Returns given parameter
   * @see {@link Rectangle.copyFrom} For copying from another rectangle
   * @see {@link Rectangle.clone} For creating new rectangle copy
   */
  copyTo(rectangle) {
    rectangle.copyFrom(this);
    return rectangle;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this Rectangle
   * @example
   * ```ts
   * // Basic containment check
   * const rect = new Rectangle(100, 100, 200, 150);
   * const isInside = rect.contains(150, 125); // true
   * // Check edge cases
   * console.log(rect.contains(100, 100)); // true (on edge)
   * console.log(rect.contains(300, 250)); // false (outside)
   * ```
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coordinates are within this Rectangle
   * @see {@link Rectangle.containsRect} For rectangle containment
   * @see {@link Rectangle.strokeContains} For checking stroke intersection
   */
  contains(x2, y2) {
    if (this.width <= 0 || this.height <= 0) {
      return false;
    }
    if (x2 >= this.x && x2 < this.x + this.width) {
      if (y2 >= this.y && y2 < this.y + this.height) {
        return true;
      }
    }
    return false;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.
   * @example
   * ```ts
   * // Basic stroke check
   * const rect = new Rectangle(100, 100, 200, 150);
   * const isOnStroke = rect.strokeContains(150, 100, 4); // 4px line width
   *
   * // Check with different alignments
   * const innerStroke = rect.strokeContains(150, 100, 4, 1);   // Inside
   * const centerStroke = rect.strokeContains(150, 100, 4, 0.5); // Centered
   * const outerStroke = rect.strokeContains(150, 100, 4, 0);   // Outside
   * ```
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @param strokeWidth - The width of the line to check
   * @param alignment - The alignment of the stroke (1 = inner, 0.5 = centered, 0 = outer)
   * @returns Whether the x/y coordinates are within this rectangle's stroke
   * @see {@link Rectangle.contains} For checking fill containment
   * @see {@link Rectangle.getBounds} For getting stroke bounds
   */
  strokeContains(x2, y2, strokeWidth, alignment = 0.5) {
    const { width, height } = this;
    if (width <= 0 || height <= 0)
      return false;
    const _x = this.x;
    const _y = this.y;
    const strokeWidthOuter = strokeWidth * (1 - alignment);
    const strokeWidthInner = strokeWidth - strokeWidthOuter;
    const outerLeft = _x - strokeWidthOuter;
    const outerRight = _x + width + strokeWidthOuter;
    const outerTop = _y - strokeWidthOuter;
    const outerBottom = _y + height + strokeWidthOuter;
    const innerLeft = _x + strokeWidthInner;
    const innerRight = _x + width - strokeWidthInner;
    const innerTop = _y + strokeWidthInner;
    const innerBottom = _y + height - strokeWidthInner;
    return x2 >= outerLeft && x2 <= outerRight && y2 >= outerTop && y2 <= outerBottom && !(x2 > innerLeft && x2 < innerRight && y2 > innerTop && y2 < innerBottom);
  }
  /**
   * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.
   * Returns true only if the area of the intersection is >0, this means that Rectangles
   * sharing a side are not overlapping. Another side effect is that an arealess rectangle
   * (width or height equal to zero) can't intersect any other rectangle.
   * @param {Rectangle} other - The Rectangle to intersect with `this`.
   * @param {Matrix} transform - The transformation matrix of `other`.
   * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.
   */
  /**
   * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.
   *
   * Returns true only if the area of the intersection is greater than 0.
   * This means that rectangles sharing only a side are not considered intersecting.
   * @example
   * ```ts
   * // Basic intersection check
   * const rect1 = new Rectangle(0, 0, 100, 100);
   * const rect2 = new Rectangle(50, 50, 100, 100);
   * console.log(rect1.intersects(rect2)); // true
   *
   * // With transformation matrix
   * const matrix = new Matrix();
   * matrix.rotate(Math.PI / 4); // 45 degrees
   * console.log(rect1.intersects(rect2, matrix)); // Checks with rotation
   *
   * // Edge cases
   * const zeroWidth = new Rectangle(0, 0, 0, 100);
   * console.log(rect1.intersects(zeroWidth)); // false (no area)
   * ```
   * @remarks
   * - Returns true only if intersection area is > 0
   * - Rectangles sharing only a side are not intersecting
   * - Zero-area rectangles cannot intersect anything
   * - Supports optional transformation matrix
   * @param other - The Rectangle to intersect with `this`
   * @param transform - Optional transformation matrix of `other`
   * @returns True if the transformed `other` Rectangle intersects with `this`
   * @see {@link Rectangle.containsRect} For containment testing
   * @see {@link Rectangle.contains} For point testing
   */
  intersects(other, transform) {
    if (!transform) {
      const x02 = this.x < other.x ? other.x : this.x;
      const x12 = this.right > other.right ? other.right : this.right;
      if (x12 <= x02) {
        return false;
      }
      const y02 = this.y < other.y ? other.y : this.y;
      const y12 = this.bottom > other.bottom ? other.bottom : this.bottom;
      return y12 > y02;
    }
    const x0 = this.left;
    const x1 = this.right;
    const y0 = this.top;
    const y1 = this.bottom;
    if (x1 <= x0 || y1 <= y0) {
      return false;
    }
    const lt = tempPoints[0].set(other.left, other.top);
    const lb = tempPoints[1].set(other.left, other.bottom);
    const rt = tempPoints[2].set(other.right, other.top);
    const rb = tempPoints[3].set(other.right, other.bottom);
    if (rt.x <= lt.x || lb.y <= lt.y) {
      return false;
    }
    const s2 = Math.sign(transform.a * transform.d - transform.b * transform.c);
    if (s2 === 0) {
      return false;
    }
    transform.apply(lt, lt);
    transform.apply(lb, lb);
    transform.apply(rt, rt);
    transform.apply(rb, rb);
    if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0 || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1 || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0 || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1) {
      return false;
    }
    const nx = s2 * (lb.y - lt.y);
    const ny = s2 * (lt.x - lb.x);
    const n00 = nx * x0 + ny * y0;
    const n10 = nx * x1 + ny * y0;
    const n01 = nx * x0 + ny * y1;
    const n11 = nx * x1 + ny * y1;
    if (Math.max(n00, n10, n01, n11) <= nx * lt.x + ny * lt.y || Math.min(n00, n10, n01, n11) >= nx * rb.x + ny * rb.y) {
      return false;
    }
    const mx = s2 * (lt.y - rt.y);
    const my = s2 * (rt.x - lt.x);
    const m00 = mx * x0 + my * y0;
    const m10 = mx * x1 + my * y0;
    const m01 = mx * x0 + my * y1;
    const m11 = mx * x1 + my * y1;
    if (Math.max(m00, m10, m01, m11) <= mx * lt.x + my * lt.y || Math.min(m00, m10, m01, m11) >= mx * rb.x + my * rb.y) {
      return false;
    }
    return true;
  }
  /**
   * Pads the rectangle making it grow in all directions.
   *
   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.
   * @example
   * ```ts
   * // Basic padding
   * const rect = new Rectangle(100, 100, 200, 150);
   * rect.pad(10); // Adds 10px padding on all sides
   *
   * // Different horizontal and vertical padding
   * const uiRect = new Rectangle(0, 0, 100, 50);
   * uiRect.pad(20, 10); // 20px horizontal, 10px vertical
   * ```
   * @remarks
   * - Adjusts x/y by subtracting padding
   * - Increases width/height by padding * 2
   * - Common in UI layout calculations
   * - Chainable with other methods
   * @param paddingX - The horizontal padding amount
   * @param paddingY - The vertical padding amount
   * @returns Returns itself
   * @see {@link Rectangle.enlarge} For growing to include another rectangle
   * @see {@link Rectangle.fit} For shrinking to fit within another rectangle
   */
  pad(paddingX = 0, paddingY = paddingX) {
    this.x -= paddingX;
    this.y -= paddingY;
    this.width += paddingX * 2;
    this.height += paddingY * 2;
    return this;
  }
  /**
   * Fits this rectangle around the passed one.
   * @example
   * ```ts
   * // Basic fitting
   * const container = new Rectangle(0, 0, 100, 100);
   * const content = new Rectangle(25, 25, 200, 200);
   * content.fit(container); // Clips to container bounds
   * ```
   * @param rectangle - The rectangle to fit around
   * @returns Returns itself
   * @see {@link Rectangle.enlarge} For growing to include another rectangle
   * @see {@link Rectangle.pad} For adding padding around the rectangle
   */
  fit(rectangle) {
    const x1 = Math.max(this.x, rectangle.x);
    const x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);
    const y1 = Math.max(this.y, rectangle.y);
    const y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);
    this.x = x1;
    this.width = Math.max(x2 - x1, 0);
    this.y = y1;
    this.height = Math.max(y2 - y1, 0);
    return this;
  }
  /**
   * Enlarges rectangle so that its corners lie on a grid defined by resolution.
   * @example
   * ```ts
   * // Basic grid alignment
   * const rect = new Rectangle(10.2, 10.6, 100.8, 100.4);
   * rect.ceil(); // Aligns to whole pixels
   *
   * // Custom resolution grid
   * const uiRect = new Rectangle(5.3, 5.7, 50.2, 50.8);
   * uiRect.ceil(0.5); // Aligns to half pixels
   *
   * // Use with precision value
   * const preciseRect = new Rectangle(20.001, 20.999, 100.001, 100.999);
   * preciseRect.ceil(1, 0.01); // Handles small decimal variations
   * ```
   * @param resolution - The grid size to align to (1 = whole pixels)
   * @param eps - Small number to prevent floating point errors
   * @returns Returns itself
   * @see {@link Rectangle.fit} For constraining to bounds
   * @see {@link Rectangle.enlarge} For growing dimensions
   */
  ceil(resolution2 = 1, eps = 1e-3) {
    const x2 = Math.ceil((this.x + this.width - eps) * resolution2) / resolution2;
    const y2 = Math.ceil((this.y + this.height - eps) * resolution2) / resolution2;
    this.x = Math.floor((this.x + eps) * resolution2) / resolution2;
    this.y = Math.floor((this.y + eps) * resolution2) / resolution2;
    this.width = x2 - this.x;
    this.height = y2 - this.y;
    return this;
  }
  /**
   * Scales the rectangle's dimensions and position by the specified factors.
   * @example
   * ```ts
   * const rect = new Rectangle(50, 50, 100, 100);
   *
   * // Scale uniformly
   * rect.scale(0.5, 0.5);
   * // rect is now: x=25, y=25, width=50, height=50
   *
   * // non-uniformly
   * rect.scale(0.5, 1);
   * // rect is now: x=25, y=50, width=50, height=100
   * ```
   * @param x - The factor by which to scale the horizontal properties (x, width).
   * @param y - The factor by which to scale the vertical properties (y, height).
   * @returns Returns itself
   */
  scale(x2, y2 = x2) {
    this.x *= x2;
    this.y *= y2;
    this.width *= x2;
    this.height *= y2;
    return this;
  }
  /**
   * Enlarges this rectangle to include the passed rectangle.
   * @example
   * ```ts
   * // Basic enlargement
   * const rect = new Rectangle(50, 50, 100, 100);
   * const other = new Rectangle(0, 0, 200, 75);
   * rect.enlarge(other);
   * // rect is now: x=0, y=0, width=200, height=150
   *
   * // Use for bounding box calculation
   * const bounds = new Rectangle();
   * objects.forEach((obj) => {
   *     bounds.enlarge(obj.getBounds());
   * });
   * ```
   * @param rectangle - The rectangle to include
   * @returns Returns itself
   * @see {@link Rectangle.fit} For shrinking to fit within another rectangle
   * @see {@link Rectangle.pad} For adding padding around the rectangle
   */
  enlarge(rectangle) {
    const x1 = Math.min(this.x, rectangle.x);
    const x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);
    const y1 = Math.min(this.y, rectangle.y);
    const y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);
    this.x = x1;
    this.width = x2 - x1;
    this.y = y1;
    this.height = y2 - y1;
    return this;
  }
  /**
   * Returns the framing rectangle of the rectangle as a Rectangle object
   * @example
   * ```ts
   * // Basic bounds retrieval
   * const rect = new Rectangle(100, 100, 200, 150);
   * const bounds = rect.getBounds();
   *
   * // Reuse existing rectangle
   * const out = new Rectangle();
   * rect.getBounds(out);
   * ```
   * @param out - Optional rectangle to store the result
   * @returns The framing rectangle
   * @see {@link Rectangle.copyFrom} For direct copying
   * @see {@link Rectangle.clone} For creating new copy
   */
  getBounds(out2) {
    out2 || (out2 = new Rectangle());
    out2.copyFrom(this);
    return out2;
  }
  /**
   * Determines whether another Rectangle is fully contained within this Rectangle.
   *
   * Rectangles that occupy the same space are considered to be containing each other.
   *
   * Rectangles without area (width or height equal to zero) can't contain anything,
   * not even other arealess rectangles.
   * @example
   * ```ts
   * // Check if one rectangle contains another
   * const container = new Rectangle(0, 0, 100, 100);
   * const inner = new Rectangle(25, 25, 50, 50);
   *
   * console.log(container.containsRect(inner)); // true
   *
   * // Check overlapping rectangles
   * const partial = new Rectangle(75, 75, 50, 50);
   * console.log(container.containsRect(partial)); // false
   *
   * // Zero-area rectangles
   * const empty = new Rectangle(0, 0, 0, 100);
   * console.log(container.containsRect(empty)); // false
   * ```
   * @param other - The Rectangle to check for containment
   * @returns True if other is fully contained within this Rectangle
   * @see {@link Rectangle.contains} For point containment
   * @see {@link Rectangle.intersects} For overlap testing
   */
  containsRect(other) {
    if (this.width <= 0 || this.height <= 0)
      return false;
    const x1 = other.x;
    const y1 = other.y;
    const x2 = other.x + other.width;
    const y2 = other.y + other.height;
    return x1 >= this.x && x1 < this.x + this.width && y1 >= this.y && y1 < this.y + this.height && x2 >= this.x && x2 < this.x + this.width && y2 >= this.y && y2 < this.y + this.height;
  }
  /**
   * Sets the position and dimensions of the rectangle.
   * @example
   * ```ts
   * // Basic usage
   * const rect = new Rectangle();
   * rect.set(100, 100, 200, 150);
   *
   * // Chain with other operations
   * const bounds = new Rectangle()
   *     .set(0, 0, 100, 100)
   *     .pad(10);
   * ```
   * @param x - The X coordinate of the upper-left corner of the rectangle
   * @param y - The Y coordinate of the upper-left corner of the rectangle
   * @param width - The overall width of the rectangle
   * @param height - The overall height of the rectangle
   * @returns Returns itself for method chaining
   * @see {@link Rectangle.copyFrom} For copying from another rectangle
   * @see {@link Rectangle.clone} For creating a new copy
   */
  set(x2, y2, width, height) {
    this.x = x2;
    this.y = y2;
    this.width = width;
    this.height = height;
    return this;
  }
  toString() {
    return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
  }
}
const uidCache = {
  default: -1
};
function uid(name2 = "default") {
  if (uidCache[name2] === void 0) {
    uidCache[name2] = -1;
  }
  return ++uidCache[name2];
}
const warnings = /* @__PURE__ */ new Set();
const v8_0_0 = "8.0.0";
const v8_3_4 = "8.3.4";
const deprecationState = {
  quiet: false,
  noColor: false
};
const deprecation = (version, message, ignoreDepth = 3) => {
  if (deprecationState.quiet || warnings.has(message))
    return;
  let stack = new Error().stack;
  const deprecationMessage = `${message}
Deprecated since v${version}`;
  const useGroup = typeof console.groupCollapsed === "function" && !deprecationState.noColor;
  if (typeof stack === "undefined") {
    console.warn("PixiJS Deprecation Warning: ", deprecationMessage);
  } else {
    stack = stack.split("\n").splice(ignoreDepth).join("\n");
    if (useGroup) {
      console.groupCollapsed(
        "%cPixiJS Deprecation Warning: %c%s",
        "color:#614108;background:#fffbe6",
        "font-weight:normal;color:#614108;background:#fffbe6",
        deprecationMessage
      );
      console.warn(stack);
      console.groupEnd();
    } else {
      console.warn("PixiJS Deprecation Warning: ", deprecationMessage);
      console.warn(stack);
    }
  }
  warnings.add(message);
};
Object.defineProperties(deprecation, {
  quiet: {
    get: () => deprecationState.quiet,
    set: (value2) => {
      deprecationState.quiet = value2;
    },
    enumerable: true,
    configurable: false
  },
  noColor: {
    get: () => deprecationState.noColor,
    set: (value2) => {
      deprecationState.noColor = value2;
    },
    enumerable: true,
    configurable: false
  }
});
const NOOP = () => {
};
function nextPow2(v2) {
  v2 += v2 === 0 ? 1 : 0;
  --v2;
  v2 |= v2 >>> 1;
  v2 |= v2 >>> 2;
  v2 |= v2 >>> 4;
  v2 |= v2 >>> 8;
  v2 |= v2 >>> 16;
  return v2 + 1;
}
function isPow2(v2) {
  return !(v2 & v2 - 1) && !!v2;
}
function definedProps(obj) {
  const result = {};
  for (const key2 in obj) {
    if (obj[key2] !== void 0) {
      result[key2] = obj[key2];
    }
  }
  return result;
}
const idHash$1 = /* @__PURE__ */ Object.create(null);
function createResourceIdFromString(value2) {
  const id2 = idHash$1[value2];
  if (id2 === void 0) {
    idHash$1[value2] = uid("resource");
  }
  return id2;
}
const _TextureStyle = class _TextureStyle2 extends EventEmitter {
  /**
   * @param options - options for the style
   */
  constructor(options = {}) {
    super();
    this._resourceType = "textureSampler";
    this._touched = 0;
    this._maxAnisotropy = 1;
    this.destroyed = false;
    options = { ..._TextureStyle2.defaultOptions, ...options };
    this.addressMode = options.addressMode;
    this.addressModeU = options.addressModeU ?? this.addressModeU;
    this.addressModeV = options.addressModeV ?? this.addressModeV;
    this.addressModeW = options.addressModeW ?? this.addressModeW;
    this.scaleMode = options.scaleMode;
    this.magFilter = options.magFilter ?? this.magFilter;
    this.minFilter = options.minFilter ?? this.minFilter;
    this.mipmapFilter = options.mipmapFilter ?? this.mipmapFilter;
    this.lodMinClamp = options.lodMinClamp;
    this.lodMaxClamp = options.lodMaxClamp;
    this.compare = options.compare;
    this.maxAnisotropy = options.maxAnisotropy ?? 1;
  }
  set addressMode(value2) {
    this.addressModeU = value2;
    this.addressModeV = value2;
    this.addressModeW = value2;
  }
  /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */
  get addressMode() {
    return this.addressModeU;
  }
  set wrapMode(value2) {
    deprecation(v8_0_0, "TextureStyle.wrapMode is now TextureStyle.addressMode");
    this.addressMode = value2;
  }
  get wrapMode() {
    return this.addressMode;
  }
  set scaleMode(value2) {
    this.magFilter = value2;
    this.minFilter = value2;
    this.mipmapFilter = value2;
  }
  /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */
  get scaleMode() {
    return this.magFilter;
  }
  /** Specifies the maximum anisotropy value clamp used by the sampler. */
  set maxAnisotropy(value2) {
    this._maxAnisotropy = Math.min(value2, 16);
    if (this._maxAnisotropy > 1) {
      this.scaleMode = "linear";
    }
  }
  get maxAnisotropy() {
    return this._maxAnisotropy;
  }
  // TODO - move this to WebGL?
  get _resourceId() {
    return this._sharedResourceId || this._generateResourceId();
  }
  update() {
    this.emit("change", this);
    this._sharedResourceId = null;
  }
  _generateResourceId() {
    const bigKey = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;
    this._sharedResourceId = createResourceIdFromString(bigKey);
    return this._resourceId;
  }
  /** Destroys the style */
  destroy() {
    this.destroyed = true;
    this.emit("destroy", this);
    this.emit("change", this);
    this.removeAllListeners();
  }
};
_TextureStyle.defaultOptions = {
  addressMode: "clamp-to-edge",
  scaleMode: "linear"
};
let TextureStyle = _TextureStyle;
const _TextureSource = class _TextureSource2 extends EventEmitter {
  /**
   * @param options - options for creating a new TextureSource
   */
  constructor(options = {}) {
    super();
    this.options = options;
    this.uid = uid("textureSource");
    this._resourceType = "textureSource";
    this._resourceId = uid("resource");
    this.uploadMethodId = "unknown";
    this._resolution = 1;
    this.pixelWidth = 1;
    this.pixelHeight = 1;
    this.width = 1;
    this.height = 1;
    this.sampleCount = 1;
    this.mipLevelCount = 1;
    this.autoGenerateMipmaps = false;
    this.format = "rgba8unorm";
    this.dimension = "2d";
    this.antialias = false;
    this._touched = 0;
    this._batchTick = -1;
    this._textureBindLocation = -1;
    options = { ..._TextureSource2.defaultOptions, ...options };
    this.label = options.label ?? "";
    this.resource = options.resource;
    this.autoGarbageCollect = options.autoGarbageCollect;
    this._resolution = options.resolution;
    if (options.width) {
      this.pixelWidth = options.width * this._resolution;
    } else {
      this.pixelWidth = this.resource ? this.resourceWidth ?? 1 : 1;
    }
    if (options.height) {
      this.pixelHeight = options.height * this._resolution;
    } else {
      this.pixelHeight = this.resource ? this.resourceHeight ?? 1 : 1;
    }
    this.width = this.pixelWidth / this._resolution;
    this.height = this.pixelHeight / this._resolution;
    this.format = options.format;
    this.dimension = options.dimensions;
    this.mipLevelCount = options.mipLevelCount;
    this.autoGenerateMipmaps = options.autoGenerateMipmaps;
    this.sampleCount = options.sampleCount;
    this.antialias = options.antialias;
    this.alphaMode = options.alphaMode;
    this.style = new TextureStyle(definedProps(options));
    this.destroyed = false;
    this._refreshPOT();
  }
  /** returns itself */
  get source() {
    return this;
  }
  /** the style of the texture */
  get style() {
    return this._style;
  }
  set style(value2) {
    var _a, _b;
    if (this.style === value2)
      return;
    (_a = this._style) == null ? void 0 : _a.off("change", this._onStyleChange, this);
    this._style = value2;
    (_b = this._style) == null ? void 0 : _b.on("change", this._onStyleChange, this);
    this._onStyleChange();
  }
  /** Specifies the maximum anisotropy value clamp used by the sampler. */
  set maxAnisotropy(value2) {
    this._style.maxAnisotropy = value2;
  }
  get maxAnisotropy() {
    return this._style.maxAnisotropy;
  }
  /** setting this will set wrapModeU, wrapModeV and wrapModeW all at once! */
  get addressMode() {
    return this._style.addressMode;
  }
  set addressMode(value2) {
    this._style.addressMode = value2;
  }
  /** setting this will set wrapModeU, wrapModeV and wrapModeW all at once! */
  get repeatMode() {
    return this._style.addressMode;
  }
  set repeatMode(value2) {
    this._style.addressMode = value2;
  }
  /** Specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */
  get magFilter() {
    return this._style.magFilter;
  }
  set magFilter(value2) {
    this._style.magFilter = value2;
  }
  /** Specifies the sampling behavior when the sample footprint is larger than one texel. */
  get minFilter() {
    return this._style.minFilter;
  }
  set minFilter(value2) {
    this._style.minFilter = value2;
  }
  /** Specifies behavior for sampling between mipmap levels. */
  get mipmapFilter() {
    return this._style.mipmapFilter;
  }
  set mipmapFilter(value2) {
    this._style.mipmapFilter = value2;
  }
  /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */
  get lodMinClamp() {
    return this._style.lodMinClamp;
  }
  set lodMinClamp(value2) {
    this._style.lodMinClamp = value2;
  }
  /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */
  get lodMaxClamp() {
    return this._style.lodMaxClamp;
  }
  set lodMaxClamp(value2) {
    this._style.lodMaxClamp = value2;
  }
  _onStyleChange() {
    this.emit("styleChange", this);
  }
  /** call this if you have modified the texture outside of the constructor */
  update() {
    if (this.resource) {
      const resolution2 = this._resolution;
      const didResize = this.resize(this.resourceWidth / resolution2, this.resourceHeight / resolution2);
      if (didResize)
        return;
    }
    this.emit("update", this);
  }
  /** Destroys this texture source */
  destroy() {
    this.destroyed = true;
    this.emit("destroy", this);
    this.emit("change", this);
    if (this._style) {
      this._style.destroy();
      this._style = null;
    }
    this.uploadMethodId = null;
    this.resource = null;
    this.removeAllListeners();
  }
  /**
   * This will unload the Texture source from the GPU. This will free up the GPU memory
   * As soon as it is required fore rendering, it will be re-uploaded.
   */
  unload() {
    this._resourceId = uid("resource");
    this.emit("change", this);
    this.emit("unload", this);
  }
  /** the width of the resource. This is the REAL pure number, not accounting resolution   */
  get resourceWidth() {
    const { resource } = this;
    return resource.naturalWidth || resource.videoWidth || resource.displayWidth || resource.width;
  }
  /** the height of the resource. This is the REAL pure number, not accounting resolution */
  get resourceHeight() {
    const { resource } = this;
    return resource.naturalHeight || resource.videoHeight || resource.displayHeight || resource.height;
  }
  /**
   * the resolution of the texture. Changing this number, will not change the number of pixels in the actual texture
   * but will the size of the texture when rendered.
   *
   * changing the resolution of this texture to 2 for example will make it appear twice as small when rendered (as pixel
   * density will have increased)
   */
  get resolution() {
    return this._resolution;
  }
  set resolution(resolution2) {
    if (this._resolution === resolution2)
      return;
    this._resolution = resolution2;
    this.width = this.pixelWidth / resolution2;
    this.height = this.pixelHeight / resolution2;
  }
  /**
   * Resize the texture, this is handy if you want to use the texture as a render texture
   * @param width - the new width of the texture
   * @param height - the new height of the texture
   * @param resolution - the new resolution of the texture
   * @returns - if the texture was resized
   */
  resize(width, height, resolution2) {
    resolution2 || (resolution2 = this._resolution);
    width || (width = this.width);
    height || (height = this.height);
    const newPixelWidth = Math.round(width * resolution2);
    const newPixelHeight = Math.round(height * resolution2);
    this.width = newPixelWidth / resolution2;
    this.height = newPixelHeight / resolution2;
    this._resolution = resolution2;
    if (this.pixelWidth === newPixelWidth && this.pixelHeight === newPixelHeight) {
      return false;
    }
    this._refreshPOT();
    this.pixelWidth = newPixelWidth;
    this.pixelHeight = newPixelHeight;
    this.emit("resize", this);
    this._resourceId = uid("resource");
    this.emit("change", this);
    return true;
  }
  /**
   * Lets the renderer know that this texture has been updated and its mipmaps should be re-generated.
   * This is only important for RenderTexture instances, as standard Texture instances will have their
   * mipmaps generated on upload. You should call this method after you make any change to the texture
   *
   * The reason for this is is can be quite expensive to update mipmaps for a texture. So by default,
   * We want you, the developer to specify when this action should happen.
   *
   * Generally you don't want to have mipmaps generated on Render targets that are changed every frame,
   */
  updateMipmaps() {
    if (this.autoGenerateMipmaps && this.mipLevelCount > 1) {
      this.emit("updateMipmaps", this);
    }
  }
  set wrapMode(value2) {
    this._style.wrapMode = value2;
  }
  get wrapMode() {
    return this._style.wrapMode;
  }
  set scaleMode(value2) {
    this._style.scaleMode = value2;
  }
  /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */
  get scaleMode() {
    return this._style.scaleMode;
  }
  /**
   * Refresh check for isPowerOfTwo texture based on size
   * @private
   */
  _refreshPOT() {
    this.isPowerOfTwo = isPow2(this.pixelWidth) && isPow2(this.pixelHeight);
  }
  static test(_resource) {
    throw new Error("Unimplemented");
  }
};
_TextureSource.defaultOptions = {
  resolution: 1,
  format: "bgra8unorm",
  alphaMode: "premultiply-alpha-on-upload",
  dimensions: "2d",
  mipLevelCount: 1,
  autoGenerateMipmaps: false,
  sampleCount: 1,
  antialias: false,
  autoGarbageCollect: false
};
let TextureSource = _TextureSource;
class BufferImageSource extends TextureSource {
  constructor(options) {
    const buffer2 = options.resource || new Float32Array(options.width * options.height * 4);
    let format = options.format;
    if (!format) {
      if (buffer2 instanceof Float32Array) {
        format = "rgba32float";
      } else if (buffer2 instanceof Int32Array) {
        format = "rgba32uint";
      } else if (buffer2 instanceof Uint32Array) {
        format = "rgba32uint";
      } else if (buffer2 instanceof Int16Array) {
        format = "rgba16uint";
      } else if (buffer2 instanceof Uint16Array) {
        format = "rgba16uint";
      } else if (buffer2 instanceof Int8Array) {
        format = "bgra8unorm";
      } else {
        format = "bgra8unorm";
      }
    }
    super({
      ...options,
      resource: buffer2,
      format
    });
    this.uploadMethodId = "buffer";
  }
  static test(resource) {
    return resource instanceof Int8Array || resource instanceof Uint8Array || resource instanceof Uint8ClampedArray || resource instanceof Int16Array || resource instanceof Uint16Array || resource instanceof Int32Array || resource instanceof Uint32Array || resource instanceof Float32Array;
  }
}
BufferImageSource.extension = ExtensionType.TextureSource;
const tempMat = new Matrix();
class TextureMatrix {
  /**
   * @param texture - observed texture
   * @param clampMargin - Changes frame clamping, 0.5 by default. Use -0.5 for extra border.
   */
  constructor(texture, clampMargin) {
    this.mapCoord = new Matrix();
    this.uClampFrame = new Float32Array(4);
    this.uClampOffset = new Float32Array(2);
    this._textureID = -1;
    this._updateID = 0;
    this.clampOffset = 0;
    if (typeof clampMargin === "undefined") {
      this.clampMargin = texture.width < 10 ? 0 : 0.5;
    } else {
      this.clampMargin = clampMargin;
    }
    this.isSimple = false;
    this.texture = texture;
  }
  /** Texture property. */
  get texture() {
    return this._texture;
  }
  set texture(value2) {
    var _a;
    if (this.texture === value2)
      return;
    (_a = this._texture) == null ? void 0 : _a.removeListener("update", this.update, this);
    this._texture = value2;
    this._texture.addListener("update", this.update, this);
    this.update();
  }
  /**
   * Multiplies uvs array to transform
   * @param uvs - mesh uvs
   * @param [out=uvs] - output
   * @returns - output
   */
  multiplyUvs(uvs, out2) {
    if (out2 === void 0) {
      out2 = uvs;
    }
    const mat = this.mapCoord;
    for (let i2 = 0; i2 < uvs.length; i2 += 2) {
      const x2 = uvs[i2];
      const y2 = uvs[i2 + 1];
      out2[i2] = x2 * mat.a + y2 * mat.c + mat.tx;
      out2[i2 + 1] = x2 * mat.b + y2 * mat.d + mat.ty;
    }
    return out2;
  }
  /**
   * Updates matrices if texture was changed
   * @returns - whether or not it was updated
   */
  update() {
    const tex = this._texture;
    this._updateID++;
    const uvs = tex.uvs;
    this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);
    const orig = tex.orig;
    const trim = tex.trim;
    if (trim) {
      tempMat.set(
        orig.width / trim.width,
        0,
        0,
        orig.height / trim.height,
        -trim.x / trim.width,
        -trim.y / trim.height
      );
      this.mapCoord.append(tempMat);
    }
    const texBase = tex.source;
    const frame = this.uClampFrame;
    const margin = this.clampMargin / texBase._resolution;
    const offset = this.clampOffset / texBase._resolution;
    frame[0] = (tex.frame.x + margin + offset) / texBase.width;
    frame[1] = (tex.frame.y + margin + offset) / texBase.height;
    frame[2] = (tex.frame.x + tex.frame.width - margin + offset) / texBase.width;
    frame[3] = (tex.frame.y + tex.frame.height - margin + offset) / texBase.height;
    this.uClampOffset[0] = this.clampOffset / texBase.pixelWidth;
    this.uClampOffset[1] = this.clampOffset / texBase.pixelHeight;
    this.isSimple = tex.frame.width === texBase.width && tex.frame.height === texBase.height && tex.rotate === 0;
    return true;
  }
}
class Texture extends EventEmitter {
  /**
   * @param {TextureOptions} options - Options for the texture
   */
  constructor({
    source: source2,
    label: label2,
    frame,
    orig,
    trim,
    defaultAnchor,
    defaultBorders,
    rotate,
    dynamic
  } = {}) {
    super();
    this.uid = uid("texture");
    this.uvs = { x0: 0, y0: 0, x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 };
    this.frame = new Rectangle();
    this.noFrame = false;
    this.dynamic = false;
    this.isTexture = true;
    this.label = label2;
    this.source = (source2 == null ? void 0 : source2.source) ?? new TextureSource();
    this.noFrame = !frame;
    if (frame) {
      this.frame.copyFrom(frame);
    } else {
      const { width, height } = this._source;
      this.frame.width = width;
      this.frame.height = height;
    }
    this.orig = orig || this.frame;
    this.trim = trim;
    this.rotate = rotate ?? 0;
    this.defaultAnchor = defaultAnchor;
    this.defaultBorders = defaultBorders;
    this.destroyed = false;
    this.dynamic = dynamic || false;
    this.updateUvs();
  }
  set source(value2) {
    if (this._source) {
      this._source.off("resize", this.update, this);
    }
    this._source = value2;
    value2.on("resize", this.update, this);
    this.emit("update", this);
  }
  /** the underlying source of the texture (equivalent of baseTexture in v7) */
  get source() {
    return this._source;
  }
  /** returns a TextureMatrix instance for this texture. By default, that object is not created because its heavy. */
  get textureMatrix() {
    if (!this._textureMatrix) {
      this._textureMatrix = new TextureMatrix(this);
    }
    return this._textureMatrix;
  }
  /** The width of the Texture in pixels. */
  get width() {
    return this.orig.width;
  }
  /** The height of the Texture in pixels. */
  get height() {
    return this.orig.height;
  }
  /** Call this function when you have modified the frame of this texture. */
  updateUvs() {
    const { uvs, frame } = this;
    const { width, height } = this._source;
    const nX = frame.x / width;
    const nY = frame.y / height;
    const nW = frame.width / width;
    const nH = frame.height / height;
    let rotate = this.rotate;
    if (rotate) {
      const w2 = nW / 2;
      const h2 = nH / 2;
      const cX = nX + w2;
      const cY = nY + h2;
      rotate = groupD8.add(rotate, groupD8.NW);
      uvs.x0 = cX + w2 * groupD8.uX(rotate);
      uvs.y0 = cY + h2 * groupD8.uY(rotate);
      rotate = groupD8.add(rotate, 2);
      uvs.x1 = cX + w2 * groupD8.uX(rotate);
      uvs.y1 = cY + h2 * groupD8.uY(rotate);
      rotate = groupD8.add(rotate, 2);
      uvs.x2 = cX + w2 * groupD8.uX(rotate);
      uvs.y2 = cY + h2 * groupD8.uY(rotate);
      rotate = groupD8.add(rotate, 2);
      uvs.x3 = cX + w2 * groupD8.uX(rotate);
      uvs.y3 = cY + h2 * groupD8.uY(rotate);
    } else {
      uvs.x0 = nX;
      uvs.y0 = nY;
      uvs.x1 = nX + nW;
      uvs.y1 = nY;
      uvs.x2 = nX + nW;
      uvs.y2 = nY + nH;
      uvs.x3 = nX;
      uvs.y3 = nY + nH;
    }
  }
  /**
   * Destroys this texture
   * @param destroySource - Destroy the source when the texture is destroyed.
   */
  destroy(destroySource = false) {
    if (this._source) {
      this._source.off("resize", this.update, this);
      if (destroySource) {
        this._source.destroy();
        this._source = null;
      }
    }
    this._textureMatrix = null;
    this.destroyed = true;
    this.emit("destroy", this);
    this.removeAllListeners();
  }
  /**
   * Call this if you have modified the `texture outside` of the constructor.
   *
   * If you have modified this texture's source, you must separately call `texture.source.update()` to see those changes.
   */
  update() {
    if (this.noFrame) {
      this.frame.width = this._source.width;
      this.frame.height = this._source.height;
    }
    this.updateUvs();
    this.emit("update", this);
  }
  /** @deprecated since 8.0.0 */
  get baseTexture() {
    deprecation(v8_0_0, "Texture.baseTexture is now Texture.source");
    return this._source;
  }
}
Texture.EMPTY = new Texture({
  label: "EMPTY",
  source: new TextureSource({
    label: "EMPTY"
  })
});
Texture.EMPTY.destroy = NOOP;
Texture.WHITE = new Texture({
  source: new BufferImageSource({
    resource: new Uint8Array([255, 255, 255, 255]),
    width: 1,
    height: 1,
    alphaMode: "premultiply-alpha-on-upload",
    label: "WHITE"
  }),
  label: "WHITE"
});
Texture.WHITE.destroy = NOOP;
function updateQuadBounds(bounds, anchor2, texture) {
  const { width, height } = texture.orig;
  const trim = texture.trim;
  if (trim) {
    const sourceWidth = trim.width;
    const sourceHeight = trim.height;
    bounds.minX = trim.x - anchor2._x * width;
    bounds.maxX = bounds.minX + sourceWidth;
    bounds.minY = trim.y - anchor2._y * height;
    bounds.maxY = bounds.minY + sourceHeight;
  } else {
    bounds.minX = -anchor2._x * width;
    bounds.maxX = bounds.minX + width;
    bounds.minY = -anchor2._y * height;
    bounds.maxY = bounds.minY + height;
  }
}
const defaultMatrix = new Matrix();
class Bounds {
  /**
   * Creates a new Bounds object.
   * @param minX - The minimum X coordinate of the bounds.
   * @param minY - The minimum Y coordinate of the bounds.
   * @param maxX - The maximum X coordinate of the bounds.
   * @param maxY - The maximum Y coordinate of the bounds.
   */
  constructor(minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity) {
    this.minX = Infinity;
    this.minY = Infinity;
    this.maxX = -Infinity;
    this.maxY = -Infinity;
    this.matrix = defaultMatrix;
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  }
  /**
   * Checks if bounds are empty, meaning either width or height is zero or negative.
   * Empty bounds occur when min values exceed max values on either axis.
   * @example
   * ```ts
   * const bounds = new Bounds();
   *
   * // Check if newly created bounds are empty
   * console.log(bounds.isEmpty()); // true, default bounds are empty
   *
   * // Add frame and check again
   * bounds.addFrame(0, 0, 100, 100);
   * console.log(bounds.isEmpty()); // false, bounds now have area
   *
   * // Clear bounds
   * bounds.clear();
   * console.log(bounds.isEmpty()); // true, bounds are empty again
   * ```
   * @returns True if bounds are empty (have no area)
   * @see {@link Bounds#clear} For resetting bounds
   * @see {@link Bounds#isValid} For checking validity
   */
  isEmpty() {
    return this.minX > this.maxX || this.minY > this.maxY;
  }
  /**
   * The bounding rectangle representation of these bounds.
   * Lazily creates and updates a Rectangle instance based on the current bounds.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   *
   * // Get rectangle representation
   * const rect = bounds.rectangle;
   * console.log(rect.x, rect.y, rect.width, rect.height);
   *
   * // Use for hit testing
   * if (bounds.rectangle.contains(mouseX, mouseY)) {
   *     console.log('Mouse is inside bounds!');
   * }
   * ```
   * @see {@link Rectangle} For rectangle methods
   * @see {@link Bounds.isEmpty} For bounds validation
   */
  get rectangle() {
    if (!this._rectangle) {
      this._rectangle = new Rectangle();
    }
    const rectangle = this._rectangle;
    if (this.minX > this.maxX || this.minY > this.maxY) {
      rectangle.x = 0;
      rectangle.y = 0;
      rectangle.width = 0;
      rectangle.height = 0;
    } else {
      rectangle.copyFromBounds(this);
    }
    return rectangle;
  }
  /**
   * Clears the bounds and resets all coordinates to their default values.
   * Resets the transformation matrix back to identity.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   * console.log(bounds.isEmpty()); // false
   * // Clear the bounds
   * bounds.clear();
   * console.log(bounds.isEmpty()); // true
   * ```
   * @returns This bounds object for chaining
   */
  clear() {
    this.minX = Infinity;
    this.minY = Infinity;
    this.maxX = -Infinity;
    this.maxY = -Infinity;
    this.matrix = defaultMatrix;
    return this;
  }
  /**
   * Sets the bounds directly using coordinate values.
   * Provides a way to set all bounds values at once.
   * @example
   * ```ts
   * const bounds = new Bounds();
   * bounds.set(0, 0, 100, 100);
   * ```
   * @param x0 - Left X coordinate of frame
   * @param y0 - Top Y coordinate of frame
   * @param x1 - Right X coordinate of frame
   * @param y1 - Bottom Y coordinate of frame
   * @see {@link Bounds#addFrame} For matrix-aware bounds setting
   * @see {@link Bounds#clear} For resetting bounds
   */
  set(x0, y0, x1, y1) {
    this.minX = x0;
    this.minY = y0;
    this.maxX = x1;
    this.maxY = y1;
  }
  /**
   * Adds a rectangular frame to the bounds, optionally transformed by a matrix.
   * Updates the bounds to encompass the new frame coordinates.
   * @example
   * ```ts
   * const bounds = new Bounds();
   * bounds.addFrame(0, 0, 100, 100);
   *
   * // Add transformed frame
   * const matrix = new Matrix()
   *     .translate(50, 50)
   *     .rotate(Math.PI / 4);
   * bounds.addFrame(0, 0, 100, 100, matrix);
   * ```
   * @param x0 - Left X coordinate of frame
   * @param y0 - Top Y coordinate of frame
   * @param x1 - Right X coordinate of frame
   * @param y1 - Bottom Y coordinate of frame
   * @param matrix - Optional transformation matrix
   * @see {@link Bounds#addRect} For adding Rectangle objects
   * @see {@link Bounds#addBounds} For adding other Bounds
   */
  addFrame(x0, y0, x1, y1, matrix) {
    matrix || (matrix = this.matrix);
    const a2 = matrix.a;
    const b2 = matrix.b;
    const c2 = matrix.c;
    const d2 = matrix.d;
    const tx = matrix.tx;
    const ty = matrix.ty;
    let minX = this.minX;
    let minY = this.minY;
    let maxX = this.maxX;
    let maxY = this.maxY;
    let x2 = a2 * x0 + c2 * y0 + tx;
    let y2 = b2 * x0 + d2 * y0 + ty;
    if (x2 < minX)
      minX = x2;
    if (y2 < minY)
      minY = y2;
    if (x2 > maxX)
      maxX = x2;
    if (y2 > maxY)
      maxY = y2;
    x2 = a2 * x1 + c2 * y0 + tx;
    y2 = b2 * x1 + d2 * y0 + ty;
    if (x2 < minX)
      minX = x2;
    if (y2 < minY)
      minY = y2;
    if (x2 > maxX)
      maxX = x2;
    if (y2 > maxY)
      maxY = y2;
    x2 = a2 * x0 + c2 * y1 + tx;
    y2 = b2 * x0 + d2 * y1 + ty;
    if (x2 < minX)
      minX = x2;
    if (y2 < minY)
      minY = y2;
    if (x2 > maxX)
      maxX = x2;
    if (y2 > maxY)
      maxY = y2;
    x2 = a2 * x1 + c2 * y1 + tx;
    y2 = b2 * x1 + d2 * y1 + ty;
    if (x2 < minX)
      minX = x2;
    if (y2 < minY)
      minY = y2;
    if (x2 > maxX)
      maxX = x2;
    if (y2 > maxY)
      maxY = y2;
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  }
  /**
   * Adds a rectangle to the bounds, optionally transformed by a matrix.
   * Updates the bounds to encompass the given rectangle.
   * @example
   * ```ts
   * const bounds = new Bounds();
   * // Add simple rectangle
   * const rect = new Rectangle(0, 0, 100, 100);
   * bounds.addRect(rect);
   *
   * // Add transformed rectangle
   * const matrix = new Matrix()
   *     .translate(50, 50)
   *     .rotate(Math.PI / 4);
   * bounds.addRect(rect, matrix);
   * ```
   * @param rect - The rectangle to be added
   * @param matrix - Optional transformation matrix
   * @see {@link Bounds#addFrame} For adding raw coordinates
   * @see {@link Bounds#addBounds} For adding other bounds
   */
  addRect(rect, matrix) {
    this.addFrame(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, matrix);
  }
  /**
   * Adds another bounds object to this one, optionally transformed by a matrix.
   * Expands the bounds to include the given bounds' area.
   * @example
   * ```ts
   * const bounds = new Bounds();
   *
   * // Add child bounds
   * const childBounds = sprite.getBounds();
   * bounds.addBounds(childBounds);
   *
   * // Add transformed bounds
   * const matrix = new Matrix()
   *     .scale(2, 2);
   * bounds.addBounds(childBounds, matrix);
   * ```
   * @param bounds - The bounds to be added
   * @param matrix - Optional transformation matrix
   * @see {@link Bounds#addFrame} For adding raw coordinates
   * @see {@link Bounds#addRect} For adding rectangles
   */
  addBounds(bounds, matrix) {
    this.addFrame(bounds.minX, bounds.minY, bounds.maxX, bounds.maxY, matrix);
  }
  /**
   * Adds other Bounds as a mask, creating an intersection of the two bounds.
   * Only keeps the overlapping region between current bounds and mask bounds.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   * // Create mask bounds
   * const mask = new Bounds();
   * mask.addFrame(50, 50, 150, 150);
   * // Apply mask - results in bounds of (50,50,100,100)
   * bounds.addBoundsMask(mask);
   * ```
   * @param mask - The Bounds to use as a mask
   * @see {@link Bounds#addBounds} For union operation
   * @see {@link Bounds#fit} For fitting to rectangle
   */
  addBoundsMask(mask) {
    this.minX = this.minX > mask.minX ? this.minX : mask.minX;
    this.minY = this.minY > mask.minY ? this.minY : mask.minY;
    this.maxX = this.maxX < mask.maxX ? this.maxX : mask.maxX;
    this.maxY = this.maxY < mask.maxY ? this.maxY : mask.maxY;
  }
  /**
   * Applies a transformation matrix to the bounds, updating its coordinates.
   * Transforms all corners of the bounds using the given matrix.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   * // Apply translation
   * const translateMatrix = new Matrix()
   *     .translate(50, 50);
   * bounds.applyMatrix(translateMatrix);
   * ```
   * @param matrix - The matrix to apply to the bounds
   * @see {@link Matrix} For matrix operations
   * @see {@link Bounds#addFrame} For adding transformed frames
   */
  applyMatrix(matrix) {
    const minX = this.minX;
    const minY = this.minY;
    const maxX = this.maxX;
    const maxY = this.maxY;
    const { a: a2, b: b2, c: c2, d: d2, tx, ty } = matrix;
    let x2 = a2 * minX + c2 * minY + tx;
    let y2 = b2 * minX + d2 * minY + ty;
    this.minX = x2;
    this.minY = y2;
    this.maxX = x2;
    this.maxY = y2;
    x2 = a2 * maxX + c2 * minY + tx;
    y2 = b2 * maxX + d2 * minY + ty;
    this.minX = x2 < this.minX ? x2 : this.minX;
    this.minY = y2 < this.minY ? y2 : this.minY;
    this.maxX = x2 > this.maxX ? x2 : this.maxX;
    this.maxY = y2 > this.maxY ? y2 : this.maxY;
    x2 = a2 * minX + c2 * maxY + tx;
    y2 = b2 * minX + d2 * maxY + ty;
    this.minX = x2 < this.minX ? x2 : this.minX;
    this.minY = y2 < this.minY ? y2 : this.minY;
    this.maxX = x2 > this.maxX ? x2 : this.maxX;
    this.maxY = y2 > this.maxY ? y2 : this.maxY;
    x2 = a2 * maxX + c2 * maxY + tx;
    y2 = b2 * maxX + d2 * maxY + ty;
    this.minX = x2 < this.minX ? x2 : this.minX;
    this.minY = y2 < this.minY ? y2 : this.minY;
    this.maxX = x2 > this.maxX ? x2 : this.maxX;
    this.maxY = y2 > this.maxY ? y2 : this.maxY;
  }
  /**
   * Resizes the bounds object to fit within the given rectangle.
   * Clips the bounds if they extend beyond the rectangle's edges.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 200, 200);
   * // Fit within viewport
   * const viewport = new Rectangle(50, 50, 100, 100);
   * bounds.fit(viewport);
   * // bounds are now (50, 50, 150, 150)
   * ```
   * @param rect - The rectangle to fit within
   * @returns This bounds object for chaining
   * @see {@link Bounds#addBoundsMask} For intersection
   * @see {@link Bounds#pad} For expanding bounds
   */
  fit(rect) {
    if (this.minX < rect.left)
      this.minX = rect.left;
    if (this.maxX > rect.right)
      this.maxX = rect.right;
    if (this.minY < rect.top)
      this.minY = rect.top;
    if (this.maxY > rect.bottom)
      this.maxY = rect.bottom;
    return this;
  }
  /**
   * Resizes the bounds object to include the given bounds.
   * Similar to fit() but works with raw coordinate values instead of a Rectangle.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 200, 200);
   * // Fit to specific coordinates
   * bounds.fitBounds(50, 150, 50, 150);
   * // bounds are now (50, 50, 150, 150)
   * ```
   * @param left - The left value of the bounds
   * @param right - The right value of the bounds
   * @param top - The top value of the bounds
   * @param bottom - The bottom value of the bounds
   * @returns This bounds object for chaining
   * @see {@link Bounds#fit} For fitting to Rectangle
   * @see {@link Bounds#addBoundsMask} For intersection
   */
  fitBounds(left, right, top, bottom) {
    if (this.minX < left)
      this.minX = left;
    if (this.maxX > right)
      this.maxX = right;
    if (this.minY < top)
      this.minY = top;
    if (this.maxY > bottom)
      this.maxY = bottom;
    return this;
  }
  /**
   * Pads bounds object, making it grow in all directions.
   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   *
   * // Add equal padding
   * bounds.pad(10);
   * // bounds are now (-10, -10, 110, 110)
   *
   * // Add different padding for x and y
   * bounds.pad(20, 10);
   * // bounds are now (-30, -20, 130, 120)
   * ```
   * @param paddingX - The horizontal padding amount
   * @param paddingY - The vertical padding amount
   * @returns This bounds object for chaining
   * @see {@link Bounds#fit} For constraining bounds
   * @see {@link Bounds#scale} For uniform scaling
   */
  pad(paddingX, paddingY = paddingX) {
    this.minX -= paddingX;
    this.maxX += paddingX;
    this.minY -= paddingY;
    this.maxY += paddingY;
    return this;
  }
  /**
   * Ceils the bounds by rounding up max values and rounding down min values.
   * Useful for pixel-perfect calculations and avoiding fractional pixels.
   * @example
   * ```ts
   * const bounds = new Bounds();
   * bounds.set(10.2, 10.9, 50.1, 50.8);
   *
   * // Round to whole pixels
   * bounds.ceil();
   * // bounds are now (10, 10, 51, 51)
   * ```
   * @returns This bounds object for chaining
   * @see {@link Bounds#scale} For size adjustments
   * @see {@link Bounds#fit} For constraining bounds
   */
  ceil() {
    this.minX = Math.floor(this.minX);
    this.minY = Math.floor(this.minY);
    this.maxX = Math.ceil(this.maxX);
    this.maxY = Math.ceil(this.maxY);
    return this;
  }
  /**
   * Creates a new Bounds instance with the same values.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   *
   * // Create a copy
   * const copy = bounds.clone();
   *
   * // Original and copy are independent
   * bounds.pad(10);
   * console.log(copy.width === bounds.width); // false
   * ```
   * @returns A new Bounds instance with the same values
   * @see {@link Bounds#copyFrom} For reusing existing bounds
   */
  clone() {
    return new Bounds(this.minX, this.minY, this.maxX, this.maxY);
  }
  /**
   * Scales the bounds by the given values, adjusting all edges proportionally.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   *
   * // Scale uniformly
   * bounds.scale(2);
   * // bounds are now (0, 0, 200, 200)
   *
   * // Scale non-uniformly
   * bounds.scale(0.5, 2);
   * // bounds are now (0, 0, 100, 400)
   * ```
   * @param x - The X value to scale by
   * @param y - The Y value to scale by (defaults to x)
   * @returns This bounds object for chaining
   * @see {@link Bounds#pad} For adding padding
   * @see {@link Bounds#fit} For constraining size
   */
  scale(x2, y2 = x2) {
    this.minX *= x2;
    this.minY *= y2;
    this.maxX *= x2;
    this.maxY *= y2;
    return this;
  }
  /**
   * The x position of the bounds in local space.
   * Setting this value will move the bounds while maintaining its width.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   * // Get x position
   * console.log(bounds.x); // 0
   *
   * // Move bounds horizontally
   * bounds.x = 50;
   * console.log(bounds.minX, bounds.maxX); // 50, 150
   *
   * // Width stays the same
   * console.log(bounds.width); // Still 100
   * ```
   */
  get x() {
    return this.minX;
  }
  set x(value2) {
    const width = this.maxX - this.minX;
    this.minX = value2;
    this.maxX = value2 + width;
  }
  /**
   * The y position of the bounds in local space.
   * Setting this value will move the bounds while maintaining its height.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   * // Get y position
   * console.log(bounds.y); // 0
   *
   * // Move bounds vertically
   * bounds.y = 50;
   * console.log(bounds.minY, bounds.maxY); // 50, 150
   *
   * // Height stays the same
   * console.log(bounds.height); // Still 100
   * ```
   */
  get y() {
    return this.minY;
  }
  set y(value2) {
    const height = this.maxY - this.minY;
    this.minY = value2;
    this.maxY = value2 + height;
  }
  /**
   * The width value of the bounds.
   * Represents the distance between minX and maxX coordinates.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   * // Get width
   * console.log(bounds.width); // 100
   * // Resize width
   * bounds.width = 200;
   * console.log(bounds.maxX - bounds.minX); // 200
   * ```
   */
  get width() {
    return this.maxX - this.minX;
  }
  set width(value2) {
    this.maxX = this.minX + value2;
  }
  /**
   * The height value of the bounds.
   * Represents the distance between minY and maxY coordinates.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   * // Get height
   * console.log(bounds.height); // 100
   * // Resize height
   * bounds.height = 150;
   * console.log(bounds.maxY - bounds.minY); // 150
   * ```
   */
  get height() {
    return this.maxY - this.minY;
  }
  set height(value2) {
    this.maxY = this.minY + value2;
  }
  /**
   * The left edge coordinate of the bounds.
   * Alias for minX.
   * @example
   * ```ts
   * const bounds = new Bounds(50, 0, 150, 100);
   * console.log(bounds.left); // 50
   * console.log(bounds.left === bounds.minX); // true
   * ```
   * @readonly
   */
  get left() {
    return this.minX;
  }
  /**
   * The right edge coordinate of the bounds.
   * Alias for maxX.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   * console.log(bounds.right); // 100
   * console.log(bounds.right === bounds.maxX); // true
   * ```
   * @readonly
   */
  get right() {
    return this.maxX;
  }
  /**
   * The top edge coordinate of the bounds.
   * Alias for minY.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 25, 100, 125);
   * console.log(bounds.top); // 25
   * console.log(bounds.top === bounds.minY); // true
   * ```
   * @readonly
   */
  get top() {
    return this.minY;
  }
  /**
   * The bottom edge coordinate of the bounds.
   * Alias for maxY.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 200);
   * console.log(bounds.bottom); // 200
   * console.log(bounds.bottom === bounds.maxY); // true
   * ```
   * @readonly
   */
  get bottom() {
    return this.maxY;
  }
  /**
   * Whether the bounds has positive width and height.
   * Checks if both dimensions are greater than zero.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   * // Check if bounds are positive
   * console.log(bounds.isPositive); // true
   *
   * // Negative bounds
   * bounds.maxX = bounds.minX;
   * console.log(bounds.isPositive); // false, width is 0
   * ```
   * @readonly
   * @see {@link Bounds#isEmpty} For checking empty state
   * @see {@link Bounds#isValid} For checking validity
   */
  get isPositive() {
    return this.maxX - this.minX > 0 && this.maxY - this.minY > 0;
  }
  /**
   * Whether the bounds has valid coordinates.
   * Checks if the bounds has been initialized with real values.
   * @example
   * ```ts
   * const bounds = new Bounds();
   * console.log(bounds.isValid); // false, default state
   *
   * // Set valid bounds
   * bounds.addFrame(0, 0, 100, 100);
   * console.log(bounds.isValid); // true
   * ```
   * @readonly
   * @see {@link Bounds#isEmpty} For checking empty state
   * @see {@link Bounds#isPositive} For checking dimensions
   */
  get isValid() {
    return this.minX + this.minY !== Infinity;
  }
  /**
   * Adds vertices from a Float32Array to the bounds, optionally transformed by a matrix.
   * Used for efficiently updating bounds from raw vertex data.
   * @example
   * ```ts
   * const bounds = new Bounds();
   *
   * // Add vertices from geometry
   * const vertices = new Float32Array([
   *     0, 0,    // Vertex 1
   *     100, 0,  // Vertex 2
   *     100, 100 // Vertex 3
   * ]);
   * bounds.addVertexData(vertices, 0, 6);
   *
   * // Add transformed vertices
   * const matrix = new Matrix()
   *     .translate(50, 50)
   *     .rotate(Math.PI / 4);
   * bounds.addVertexData(vertices, 0, 6, matrix);
   *
   * // Add subset of vertices
   * bounds.addVertexData(vertices, 2, 4); // Only second vertex
   * ```
   * @param vertexData - The array of vertices to add
   * @param beginOffset - Starting index in the vertex array
   * @param endOffset - Ending index in the vertex array (excluded)
   * @param matrix - Optional transformation matrix
   * @see {@link Bounds#addFrame} For adding rectangular frames
   * @see {@link Matrix} For transformation details
   */
  addVertexData(vertexData, beginOffset, endOffset, matrix) {
    let minX = this.minX;
    let minY = this.minY;
    let maxX = this.maxX;
    let maxY = this.maxY;
    matrix || (matrix = this.matrix);
    const a2 = matrix.a;
    const b2 = matrix.b;
    const c2 = matrix.c;
    const d2 = matrix.d;
    const tx = matrix.tx;
    const ty = matrix.ty;
    for (let i2 = beginOffset; i2 < endOffset; i2 += 2) {
      const localX = vertexData[i2];
      const localY = vertexData[i2 + 1];
      const x2 = a2 * localX + c2 * localY + tx;
      const y2 = b2 * localX + d2 * localY + ty;
      minX = x2 < minX ? x2 : minX;
      minY = y2 < minY ? y2 : minY;
      maxX = x2 > maxX ? x2 : maxX;
      maxY = y2 > maxY ? y2 : maxY;
    }
    this.minX = minX;
    this.minY = minY;
    this.maxX = maxX;
    this.maxY = maxY;
  }
  /**
   * Checks if a point is contained within the bounds.
   * Returns true if the point's coordinates fall within the bounds' area.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   * // Basic point check
   * console.log(bounds.containsPoint(50, 50)); // true
   * console.log(bounds.containsPoint(150, 150)); // false
   *
   * // Check edges
   * console.log(bounds.containsPoint(0, 0));   // true, includes edges
   * console.log(bounds.containsPoint(100, 100)); // true, includes edges
   * ```
   * @param x - x coordinate to check
   * @param y - y coordinate to check
   * @returns True if the point is inside the bounds
   * @see {@link Bounds#isPositive} For valid bounds check
   * @see {@link Bounds#rectangle} For Rectangle representation
   */
  containsPoint(x2, y2) {
    if (this.minX <= x2 && this.minY <= y2 && this.maxX >= x2 && this.maxY >= y2) {
      return true;
    }
    return false;
  }
  /**
   * Returns a string representation of the bounds.
   * Useful for debugging and logging bounds information.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   * console.log(bounds.toString()); // "[pixi.js:Bounds minX=0 minY=0 maxX=100 maxY=100 width=100 height=100]"
   * ```
   * @returns A string describing the bounds
   * @see {@link Bounds#copyFrom} For copying bounds
   * @see {@link Bounds#clone} For creating a new instance
   */
  toString() {
    return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;
  }
  /**
   * Copies the bounds from another bounds object.
   * Useful for reusing bounds objects and avoiding allocations.
   * @example
   * ```ts
   * const sourceBounds = new Bounds(0, 0, 100, 100);
   * // Copy bounds
   * const targetBounds = new Bounds();
   * targetBounds.copyFrom(sourceBounds);
   * ```
   * @param bounds - The bounds to copy from
   * @returns This bounds object for chaining
   * @see {@link Bounds#clone} For creating new instances
   */
  copyFrom(bounds) {
    this.minX = bounds.minX;
    this.minY = bounds.minY;
    this.maxX = bounds.maxX;
    this.maxY = bounds.maxY;
    return this;
  }
}
var r = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) }, t = function(r2) {
  return "string" == typeof r2 ? r2.length > 0 : "number" == typeof r2;
}, n = function(r2, t2, n2) {
  return void 0 === t2 && (t2 = 0), void 0 === n2 && (n2 = Math.pow(10, t2)), Math.round(n2 * r2) / n2 + 0;
}, e = function(r2, t2, n2) {
  return void 0 === t2 && (t2 = 0), void 0 === n2 && (n2 = 1), r2 > n2 ? n2 : r2 > t2 ? r2 : t2;
}, u = function(r2) {
  return (r2 = isFinite(r2) ? r2 % 360 : 0) > 0 ? r2 : r2 + 360;
}, a = function(r2) {
  return { r: e(r2.r, 0, 255), g: e(r2.g, 0, 255), b: e(r2.b, 0, 255), a: e(r2.a) };
}, o = function(r2) {
  return { r: n(r2.r), g: n(r2.g), b: n(r2.b), a: n(r2.a, 3) };
}, i = /^#([0-9a-f]{3,8})$/i, s = function(r2) {
  var t2 = r2.toString(16);
  return t2.length < 2 ? "0" + t2 : t2;
}, h = function(r2) {
  var t2 = r2.r, n2 = r2.g, e2 = r2.b, u2 = r2.a, a2 = Math.max(t2, n2, e2), o2 = a2 - Math.min(t2, n2, e2), i2 = o2 ? a2 === t2 ? (n2 - e2) / o2 : a2 === n2 ? 2 + (e2 - t2) / o2 : 4 + (t2 - n2) / o2 : 0;
  return { h: 60 * (i2 < 0 ? i2 + 6 : i2), s: a2 ? o2 / a2 * 100 : 0, v: a2 / 255 * 100, a: u2 };
}, b = function(r2) {
  var t2 = r2.h, n2 = r2.s, e2 = r2.v, u2 = r2.a;
  t2 = t2 / 360 * 6, n2 /= 100, e2 /= 100;
  var a2 = Math.floor(t2), o2 = e2 * (1 - n2), i2 = e2 * (1 - (t2 - a2) * n2), s2 = e2 * (1 - (1 - t2 + a2) * n2), h2 = a2 % 6;
  return { r: 255 * [e2, i2, o2, o2, s2, e2][h2], g: 255 * [s2, e2, e2, i2, o2, o2][h2], b: 255 * [o2, o2, s2, e2, e2, i2][h2], a: u2 };
}, g = function(r2) {
  return { h: u(r2.h), s: e(r2.s, 0, 100), l: e(r2.l, 0, 100), a: e(r2.a) };
}, d = function(r2) {
  return { h: n(r2.h), s: n(r2.s), l: n(r2.l), a: n(r2.a, 3) };
}, f = function(r2) {
  return b((n2 = (t2 = r2).s, { h: t2.h, s: (n2 *= ((e2 = t2.l) < 50 ? e2 : 100 - e2) / 100) > 0 ? 2 * n2 / (e2 + n2) * 100 : 0, v: e2 + n2, a: t2.a }));
  var t2, n2, e2;
}, c = function(r2) {
  return { h: (t2 = h(r2)).h, s: (u2 = (200 - (n2 = t2.s)) * (e2 = t2.v) / 100) > 0 && u2 < 200 ? n2 * e2 / 100 / (u2 <= 100 ? u2 : 200 - u2) * 100 : 0, l: u2 / 2, a: t2.a };
  var t2, n2, e2, u2;
}, l = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, p = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, v = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, m = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, y = { string: [[function(r2) {
  var t2 = i.exec(r2);
  return t2 ? (r2 = t2[1]).length <= 4 ? { r: parseInt(r2[0] + r2[0], 16), g: parseInt(r2[1] + r2[1], 16), b: parseInt(r2[2] + r2[2], 16), a: 4 === r2.length ? n(parseInt(r2[3] + r2[3], 16) / 255, 2) : 1 } : 6 === r2.length || 8 === r2.length ? { r: parseInt(r2.substr(0, 2), 16), g: parseInt(r2.substr(2, 2), 16), b: parseInt(r2.substr(4, 2), 16), a: 8 === r2.length ? n(parseInt(r2.substr(6, 2), 16) / 255, 2) : 1 } : null : null;
}, "hex"], [function(r2) {
  var t2 = v.exec(r2) || m.exec(r2);
  return t2 ? t2[2] !== t2[4] || t2[4] !== t2[6] ? null : a({ r: Number(t2[1]) / (t2[2] ? 100 / 255 : 1), g: Number(t2[3]) / (t2[4] ? 100 / 255 : 1), b: Number(t2[5]) / (t2[6] ? 100 / 255 : 1), a: void 0 === t2[7] ? 1 : Number(t2[7]) / (t2[8] ? 100 : 1) }) : null;
}, "rgb"], [function(t2) {
  var n2 = l.exec(t2) || p.exec(t2);
  if (!n2) return null;
  var e2, u2, a2 = g({ h: (e2 = n2[1], u2 = n2[2], void 0 === u2 && (u2 = "deg"), Number(e2) * (r[u2] || 1)), s: Number(n2[3]), l: Number(n2[4]), a: void 0 === n2[5] ? 1 : Number(n2[5]) / (n2[6] ? 100 : 1) });
  return f(a2);
}, "hsl"]], object: [[function(r2) {
  var n2 = r2.r, e2 = r2.g, u2 = r2.b, o2 = r2.a, i2 = void 0 === o2 ? 1 : o2;
  return t(n2) && t(e2) && t(u2) ? a({ r: Number(n2), g: Number(e2), b: Number(u2), a: Number(i2) }) : null;
}, "rgb"], [function(r2) {
  var n2 = r2.h, e2 = r2.s, u2 = r2.l, a2 = r2.a, o2 = void 0 === a2 ? 1 : a2;
  if (!t(n2) || !t(e2) || !t(u2)) return null;
  var i2 = g({ h: Number(n2), s: Number(e2), l: Number(u2), a: Number(o2) });
  return f(i2);
}, "hsl"], [function(r2) {
  var n2 = r2.h, a2 = r2.s, o2 = r2.v, i2 = r2.a, s2 = void 0 === i2 ? 1 : i2;
  if (!t(n2) || !t(a2) || !t(o2)) return null;
  var h2 = (function(r3) {
    return { h: u(r3.h), s: e(r3.s, 0, 100), v: e(r3.v, 0, 100), a: e(r3.a) };
  })({ h: Number(n2), s: Number(a2), v: Number(o2), a: Number(s2) });
  return b(h2);
}, "hsv"]] }, N = function(r2, t2) {
  for (var n2 = 0; n2 < t2.length; n2++) {
    var e2 = t2[n2][0](r2);
    if (e2) return [e2, t2[n2][1]];
  }
  return [null, void 0];
}, x = function(r2) {
  return "string" == typeof r2 ? N(r2.trim(), y.string) : "object" == typeof r2 && null !== r2 ? N(r2, y.object) : [null, void 0];
}, M = function(r2, t2) {
  var n2 = c(r2);
  return { h: n2.h, s: e(n2.s + 100 * t2, 0, 100), l: n2.l, a: n2.a };
}, H = function(r2) {
  return (299 * r2.r + 587 * r2.g + 114 * r2.b) / 1e3 / 255;
}, $ = function(r2, t2) {
  var n2 = c(r2);
  return { h: n2.h, s: n2.s, l: e(n2.l + 100 * t2, 0, 100), a: n2.a };
}, j = (function() {
  function r2(r3) {
    this.parsed = x(r3)[0], this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 };
  }
  return r2.prototype.isValid = function() {
    return null !== this.parsed;
  }, r2.prototype.brightness = function() {
    return n(H(this.rgba), 2);
  }, r2.prototype.isDark = function() {
    return H(this.rgba) < 0.5;
  }, r2.prototype.isLight = function() {
    return H(this.rgba) >= 0.5;
  }, r2.prototype.toHex = function() {
    return r3 = o(this.rgba), t2 = r3.r, e2 = r3.g, u2 = r3.b, i2 = (a2 = r3.a) < 1 ? s(n(255 * a2)) : "", "#" + s(t2) + s(e2) + s(u2) + i2;
    var r3, t2, e2, u2, a2, i2;
  }, r2.prototype.toRgb = function() {
    return o(this.rgba);
  }, r2.prototype.toRgbString = function() {
    return r3 = o(this.rgba), t2 = r3.r, n2 = r3.g, e2 = r3.b, (u2 = r3.a) < 1 ? "rgba(" + t2 + ", " + n2 + ", " + e2 + ", " + u2 + ")" : "rgb(" + t2 + ", " + n2 + ", " + e2 + ")";
    var r3, t2, n2, e2, u2;
  }, r2.prototype.toHsl = function() {
    return d(c(this.rgba));
  }, r2.prototype.toHslString = function() {
    return r3 = d(c(this.rgba)), t2 = r3.h, n2 = r3.s, e2 = r3.l, (u2 = r3.a) < 1 ? "hsla(" + t2 + ", " + n2 + "%, " + e2 + "%, " + u2 + ")" : "hsl(" + t2 + ", " + n2 + "%, " + e2 + "%)";
    var r3, t2, n2, e2, u2;
  }, r2.prototype.toHsv = function() {
    return r3 = h(this.rgba), { h: n(r3.h), s: n(r3.s), v: n(r3.v), a: n(r3.a, 3) };
    var r3;
  }, r2.prototype.invert = function() {
    return w({ r: 255 - (r3 = this.rgba).r, g: 255 - r3.g, b: 255 - r3.b, a: r3.a });
    var r3;
  }, r2.prototype.saturate = function(r3) {
    return void 0 === r3 && (r3 = 0.1), w(M(this.rgba, r3));
  }, r2.prototype.desaturate = function(r3) {
    return void 0 === r3 && (r3 = 0.1), w(M(this.rgba, -r3));
  }, r2.prototype.grayscale = function() {
    return w(M(this.rgba, -1));
  }, r2.prototype.lighten = function(r3) {
    return void 0 === r3 && (r3 = 0.1), w($(this.rgba, r3));
  }, r2.prototype.darken = function(r3) {
    return void 0 === r3 && (r3 = 0.1), w($(this.rgba, -r3));
  }, r2.prototype.rotate = function(r3) {
    return void 0 === r3 && (r3 = 15), this.hue(this.hue() + r3);
  }, r2.prototype.alpha = function(r3) {
    return "number" == typeof r3 ? w({ r: (t2 = this.rgba).r, g: t2.g, b: t2.b, a: r3 }) : n(this.rgba.a, 3);
    var t2;
  }, r2.prototype.hue = function(r3) {
    var t2 = c(this.rgba);
    return "number" == typeof r3 ? w({ h: r3, s: t2.s, l: t2.l, a: t2.a }) : n(t2.h);
  }, r2.prototype.isEqual = function(r3) {
    return this.toHex() === w(r3).toHex();
  }, r2;
})(), w = function(r2) {
  return r2 instanceof j ? r2 : new j(r2);
}, S = [], k = function(r2) {
  r2.forEach(function(r3) {
    S.indexOf(r3) < 0 && (r3(j, y), S.push(r3));
  });
};
function namesPlugin(e2, f2) {
  var a2 = { white: "#ffffff", bisque: "#ffe4c4", blue: "#0000ff", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", antiquewhite: "#faebd7", aqua: "#00ffff", azure: "#f0ffff", whitesmoke: "#f5f5f5", papayawhip: "#ffefd5", plum: "#dda0dd", blanchedalmond: "#ffebcd", black: "#000000", gold: "#ffd700", goldenrod: "#daa520", gainsboro: "#dcdcdc", cornsilk: "#fff8dc", cornflowerblue: "#6495ed", burlywood: "#deb887", aquamarine: "#7fffd4", beige: "#f5f5dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkkhaki: "#bdb76b", darkgray: "#a9a9a9", darkgreen: "#006400", darkgrey: "#a9a9a9", peachpuff: "#ffdab9", darkmagenta: "#8b008b", darkred: "#8b0000", darkorchid: "#9932cc", darkorange: "#ff8c00", darkslateblue: "#483d8b", gray: "#808080", darkslategray: "#2f4f4f", darkslategrey: "#2f4f4f", deeppink: "#ff1493", deepskyblue: "#00bfff", wheat: "#f5deb3", firebrick: "#b22222", floralwhite: "#fffaf0", ghostwhite: "#f8f8ff", darkviolet: "#9400d3", magenta: "#ff00ff", green: "#008000", dodgerblue: "#1e90ff", grey: "#808080", honeydew: "#f0fff0", hotpink: "#ff69b4", blueviolet: "#8a2be2", forestgreen: "#228b22", lawngreen: "#7cfc00", indianred: "#cd5c5c", indigo: "#4b0082", fuchsia: "#ff00ff", brown: "#a52a2a", maroon: "#800000", mediumblue: "#0000cd", lightcoral: "#f08080", darkturquoise: "#00ced1", lightcyan: "#e0ffff", ivory: "#fffff0", lightyellow: "#ffffe0", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", linen: "#faf0e6", mediumaquamarine: "#66cdaa", lemonchiffon: "#fffacd", lime: "#00ff00", khaki: "#f0e68c", mediumseagreen: "#3cb371", limegreen: "#32cd32", mediumspringgreen: "#00fa9a", lightskyblue: "#87cefa", lightblue: "#add8e6", midnightblue: "#191970", lightpink: "#ffb6c1", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", mintcream: "#f5fffa", lightslategray: "#778899", lightslategrey: "#778899", navajowhite: "#ffdead", navy: "#000080", mediumvioletred: "#c71585", powderblue: "#b0e0e6", palegoldenrod: "#eee8aa", oldlace: "#fdf5e6", paleturquoise: "#afeeee", mediumturquoise: "#48d1cc", mediumorchid: "#ba55d3", rebeccapurple: "#663399", lightsteelblue: "#b0c4de", mediumslateblue: "#7b68ee", thistle: "#d8bfd8", tan: "#d2b48c", orchid: "#da70d6", mediumpurple: "#9370db", purple: "#800080", pink: "#ffc0cb", skyblue: "#87ceeb", springgreen: "#00ff7f", palegreen: "#98fb98", red: "#ff0000", yellow: "#ffff00", slateblue: "#6a5acd", lavenderblush: "#fff0f5", peru: "#cd853f", palevioletred: "#db7093", violet: "#ee82ee", teal: "#008080", slategray: "#708090", slategrey: "#708090", aliceblue: "#f0f8ff", darkseagreen: "#8fbc8f", darkolivegreen: "#556b2f", greenyellow: "#adff2f", seagreen: "#2e8b57", seashell: "#fff5ee", tomato: "#ff6347", silver: "#c0c0c0", sienna: "#a0522d", lavender: "#e6e6fa", lightgreen: "#90ee90", orange: "#ffa500", orangered: "#ff4500", steelblue: "#4682b4", royalblue: "#4169e1", turquoise: "#40e0d0", yellowgreen: "#9acd32", salmon: "#fa8072", saddlebrown: "#8b4513", sandybrown: "#f4a460", rosybrown: "#bc8f8f", darksalmon: "#e9967a", lightgoldenrodyellow: "#fafad2", snow: "#fffafa", lightgrey: "#d3d3d3", lightgray: "#d3d3d3", dimgray: "#696969", dimgrey: "#696969", olivedrab: "#6b8e23", olive: "#808000" }, r2 = {};
  for (var d2 in a2) r2[a2[d2]] = d2;
  var l2 = {};
  e2.prototype.toName = function(f3) {
    if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b)) return "transparent";
    var d3, i2, n2 = r2[this.toHex()];
    if (n2) return n2;
    if (null == f3 ? void 0 : f3.closest) {
      var o2 = this.toRgb(), t2 = 1 / 0, b2 = "black";
      if (!l2.length) for (var c2 in a2) l2[c2] = new e2(a2[c2]).toRgb();
      for (var g2 in a2) {
        var u2 = (d3 = o2, i2 = l2[g2], Math.pow(d3.r - i2.r, 2) + Math.pow(d3.g - i2.g, 2) + Math.pow(d3.b - i2.b, 2));
        u2 < t2 && (t2 = u2, b2 = g2);
      }
      return b2;
    }
  };
  f2.string.push([function(f3) {
    var r3 = f3.toLowerCase(), d3 = "transparent" === r3 ? "#0000" : a2[r3];
    return d3 ? new e2(d3).toRgb() : null;
  }, "name"]);
}
k([namesPlugin]);
const _Color = class _Color2 {
  /**
   * @param {ColorSource} value - Optional value to use, if not provided, white is used.
   */
  constructor(value2 = 16777215) {
    this._value = null;
    this._components = new Float32Array(4);
    this._components.fill(1);
    this._int = 16777215;
    this.value = value2;
  }
  /**
   * Get the red component of the color, normalized between 0 and 1.
   * @example
   * ```ts
   * const color = new Color('red');
   * console.log(color.red); // 1
   *
   * const green = new Color('#00ff00');
   * console.log(green.red); // 0
   * ```
   */
  get red() {
    return this._components[0];
  }
  /**
   * Get the green component of the color, normalized between 0 and 1.
   * @example
   * ```ts
   * const color = new Color('lime');
   * console.log(color.green); // 1
   *
   * const red = new Color('#ff0000');
   * console.log(red.green); // 0
   * ```
   */
  get green() {
    return this._components[1];
  }
  /**
   * Get the blue component of the color, normalized between 0 and 1.
   * @example
   * ```ts
   * const color = new Color('blue');
   * console.log(color.blue); // 1
   *
   * const yellow = new Color('#ffff00');
   * console.log(yellow.blue); // 0
   * ```
   */
  get blue() {
    return this._components[2];
  }
  /**
   * Get the alpha component of the color, normalized between 0 and 1.
   * @example
   * ```ts
   * const color = new Color('red');
   * console.log(color.alpha); // 1 (fully opaque)
   *
   * const transparent = new Color('rgba(255, 0, 0, 0.5)');
   * console.log(transparent.alpha); // 0.5 (semi-transparent)
   * ```
   */
  get alpha() {
    return this._components[3];
  }
  /**
   * Sets the color value and returns the instance for chaining.
   *
   * This is a chainable version of setting the `value` property.
   * @param value - The color to set. Accepts various formats:
   * - Hex strings/numbers (e.g., '#ff0000', 0xff0000)
   * - RGB/RGBA values (arrays, objects)
   * - CSS color names
   * - HSL/HSLA values
   * - HSV/HSVA values
   * @returns The Color instance for chaining
   * @example
   * ```ts
   * // Basic usage
   * const color = new Color();
   * color.setValue('#ff0000')
   *     .setAlpha(0.5)
   *     .premultiply(0.8);
   *
   * // Different formats
   * color.setValue(0xff0000);          // Hex number
   * color.setValue('#ff0000');         // Hex string
   * color.setValue([1, 0, 0]);         // RGB array
   * color.setValue([1, 0, 0, 0.5]);    // RGBA array
   * color.setValue({ r: 1, g: 0, b: 0 }); // RGB object
   *
   * // Copy from another color
   * const red = new Color('red');
   * color.setValue(red);
   * ```
   * @throws {Error} If the color value is invalid or null
   * @see {@link Color.value} For the underlying value property
   */
  setValue(value2) {
    this.value = value2;
    return this;
  }
  /**
   * The current color source. This property allows getting and setting the color value
   * while preserving the original format where possible.
   * @remarks
   * When setting:
   * - Setting to a `Color` instance copies its source and components
   * - Setting to other valid sources normalizes and stores the value
   * - Setting to `null` throws an Error
   * - The color remains unchanged if normalization fails
   *
   * When getting:
   * - Returns `null` if color was modified by {@link Color.multiply} or {@link Color.premultiply}
   * - Otherwise returns the original color source
   * @example
   * ```ts
   * // Setting different color formats
   * const color = new Color();
   *
   * color.value = 0xff0000;         // Hex number
   * color.value = '#ff0000';        // Hex string
   * color.value = [1, 0, 0];        // RGB array
   * color.value = [1, 0, 0, 0.5];   // RGBA array
   * color.value = { r: 1, g: 0, b: 0 }; // RGB object
   *
   * // Copying from another color
   * const red = new Color('red');
   * color.value = red;  // Copies red's components
   *
   * // Getting the value
   * console.log(color.value);  // Returns original format
   *
   * // After modifications
   * color.multiply([0.5, 0.5, 0.5]);
   * console.log(color.value);  // Returns null
   * ```
   * @throws {Error} When attempting to set `null`
   */
  set value(value2) {
    if (value2 instanceof _Color2) {
      this._value = this._cloneSource(value2._value);
      this._int = value2._int;
      this._components.set(value2._components);
    } else if (value2 === null) {
      throw new Error("Cannot set Color#value to null");
    } else if (this._value === null || !this._isSourceEqual(this._value, value2)) {
      this._value = this._cloneSource(value2);
      this._normalize(this._value);
    }
  }
  get value() {
    return this._value;
  }
  /**
   * Copy a color source internally.
   * @param value - Color source
   */
  _cloneSource(value2) {
    if (typeof value2 === "string" || typeof value2 === "number" || value2 instanceof Number || value2 === null) {
      return value2;
    } else if (Array.isArray(value2) || ArrayBuffer.isView(value2)) {
      return value2.slice(0);
    } else if (typeof value2 === "object" && value2 !== null) {
      return { ...value2 };
    }
    return value2;
  }
  /**
   * Equality check for color sources.
   * @param value1 - First color source
   * @param value2 - Second color source
   * @returns `true` if the color sources are equal, `false` otherwise.
   */
  _isSourceEqual(value1, value2) {
    const type1 = typeof value1;
    const type2 = typeof value2;
    if (type1 !== type2) {
      return false;
    } else if (type1 === "number" || type1 === "string" || value1 instanceof Number) {
      return value1 === value2;
    } else if (Array.isArray(value1) && Array.isArray(value2) || ArrayBuffer.isView(value1) && ArrayBuffer.isView(value2)) {
      if (value1.length !== value2.length) {
        return false;
      }
      return value1.every((v2, i2) => v2 === value2[i2]);
    } else if (value1 !== null && value2 !== null) {
      const keys1 = Object.keys(value1);
      const keys2 = Object.keys(value2);
      if (keys1.length !== keys2.length) {
        return false;
      }
      return keys1.every((key2) => value1[key2] === value2[key2]);
    }
    return value1 === value2;
  }
  /**
   * Convert to a RGBA color object with normalized components (0-1).
   * @example
   * ```ts
   * import { Color } from 'pixi.js';
   *
   * // Convert colors to RGBA objects
   * new Color('white').toRgba();     // returns { r: 1, g: 1, b: 1, a: 1 }
   * new Color('#ff0000').toRgba();   // returns { r: 1, g: 0, b: 0, a: 1 }
   *
   * // With transparency
   * new Color('rgba(255,0,0,0.5)').toRgba(); // returns { r: 1, g: 0, b: 0, a: 0.5 }
   * ```
   * @returns An RGBA object with normalized components
   */
  toRgba() {
    const [r2, g2, b2, a2] = this._components;
    return { r: r2, g: g2, b: b2, a: a2 };
  }
  /**
   * Convert to a RGB color object with normalized components (0-1).
   *
   * Alpha component is omitted in the output.
   * @example
   * ```ts
   * import { Color } from 'pixi.js';
   *
   * // Convert colors to RGB objects
   * new Color('white').toRgb();     // returns { r: 1, g: 1, b: 1 }
   * new Color('#ff0000').toRgb();   // returns { r: 1, g: 0, b: 0 }
   *
   * // Alpha is ignored
   * new Color('rgba(255,0,0,0.5)').toRgb(); // returns { r: 1, g: 0, b: 0 }
   * ```
   * @returns An RGB object with normalized components
   */
  toRgb() {
    const [r2, g2, b2] = this._components;
    return { r: r2, g: g2, b: b2 };
  }
  /**
   * Convert to a CSS-style rgba string representation.
   *
   * RGB components are scaled to 0-255 range, alpha remains 0-1.
   * @example
   * ```ts
   * import { Color } from 'pixi.js';
   *
   * // Convert colors to RGBA strings
   * new Color('white').toRgbaString();     // returns "rgba(255,255,255,1)"
   * new Color('#ff0000').toRgbaString();   // returns "rgba(255,0,0,1)"
   *
   * // With transparency
   * new Color([1, 0, 0, 0.5]).toRgbaString(); // returns "rgba(255,0,0,0.5)"
   * ```
   * @returns A CSS-compatible rgba string
   */
  toRgbaString() {
    const [r2, g2, b2] = this.toUint8RgbArray();
    return `rgba(${r2},${g2},${b2},${this.alpha})`;
  }
  /**
   * Convert to an [R, G, B] array of clamped uint8 values (0 to 255).
   * @param {number[]|Uint8Array|Uint8ClampedArray} [out] - Optional output array. If not provided,
   * a cached array will be used and returned.
   * @returns Array containing RGB components as integers between 0-255
   * @example
   * ```ts
   * // Basic usage
   * new Color('white').toUint8RgbArray(); // returns [255, 255, 255]
   * new Color('#ff0000').toUint8RgbArray(); // returns [255, 0, 0]
   *
   * // Using custom output array
   * const rgb = new Uint8Array(3);
   * new Color('blue').toUint8RgbArray(rgb); // rgb is now [0, 0, 255]
   *
   * // Using different array types
   * new Color('red').toUint8RgbArray(new Uint8ClampedArray(3)); // [255, 0, 0]
   * new Color('red').toUint8RgbArray([]); // [255, 0, 0]
   * ```
   * @remarks
   * - Output values are always clamped between 0-255
   * - Alpha component is not included in output
   * - Reuses internal cache array if no output array provided
   */
  toUint8RgbArray(out2) {
    const [r2, g2, b2] = this._components;
    if (!this._arrayRgb) {
      this._arrayRgb = [];
    }
    out2 || (out2 = this._arrayRgb);
    out2[0] = Math.round(r2 * 255);
    out2[1] = Math.round(g2 * 255);
    out2[2] = Math.round(b2 * 255);
    return out2;
  }
  /**
   * Convert to an [R, G, B, A] array of normalized floats (numbers from 0.0 to 1.0).
   * @param {number[]|Float32Array} [out] - Optional output array. If not provided,
   * a cached array will be used and returned.
   * @returns Array containing RGBA components as floats between 0-1
   * @example
   * ```ts
   * // Basic usage
   * new Color('white').toArray();  // returns [1, 1, 1, 1]
   * new Color('red').toArray();    // returns [1, 0, 0, 1]
   *
   * // With alpha
   * new Color('rgba(255,0,0,0.5)').toArray(); // returns [1, 0, 0, 0.5]
   *
   * // Using custom output array
   * const rgba = new Float32Array(4);
   * new Color('blue').toArray(rgba); // rgba is now [0, 0, 1, 1]
   * ```
   * @remarks
   * - Output values are normalized between 0-1
   * - Includes alpha component as the fourth value
   * - Reuses internal cache array if no output array provided
   */
  toArray(out2) {
    if (!this._arrayRgba) {
      this._arrayRgba = [];
    }
    out2 || (out2 = this._arrayRgba);
    const [r2, g2, b2, a2] = this._components;
    out2[0] = r2;
    out2[1] = g2;
    out2[2] = b2;
    out2[3] = a2;
    return out2;
  }
  /**
   * Convert to an [R, G, B] array of normalized floats (numbers from 0.0 to 1.0).
   * @param {number[]|Float32Array} [out] - Optional output array. If not provided,
   * a cached array will be used and returned.
   * @returns Array containing RGB components as floats between 0-1
   * @example
   * ```ts
   * // Basic usage
   * new Color('white').toRgbArray(); // returns [1, 1, 1]
   * new Color('red').toRgbArray();   // returns [1, 0, 0]
   *
   * // Using custom output array
   * const rgb = new Float32Array(3);
   * new Color('blue').toRgbArray(rgb); // rgb is now [0, 0, 1]
   * ```
   * @remarks
   * - Output values are normalized between 0-1
   * - Alpha component is omitted from output
   * - Reuses internal cache array if no output array provided
   */
  toRgbArray(out2) {
    if (!this._arrayRgb) {
      this._arrayRgb = [];
    }
    out2 || (out2 = this._arrayRgb);
    const [r2, g2, b2] = this._components;
    out2[0] = r2;
    out2[1] = g2;
    out2[2] = b2;
    return out2;
  }
  /**
   * Convert to a hexadecimal number.
   * @returns The color as a 24-bit RGB integer
   * @example
   * ```ts
   * // Basic usage
   * new Color('white').toNumber(); // returns 0xffffff
   * new Color('red').toNumber();   // returns 0xff0000
   *
   * // Store as hex
   * const color = new Color('blue');
   * const hex = color.toNumber(); // 0x0000ff
   * ```
   */
  toNumber() {
    return this._int;
  }
  /**
   * Convert to a BGR number.
   *
   * Useful for platforms that expect colors in BGR format.
   * @returns The color as a 24-bit BGR integer
   * @example
   * ```ts
   * // Convert RGB to BGR
   * new Color(0xffcc99).toBgrNumber(); // returns 0x99ccff
   *
   * // Common use case: platform-specific color format
   * const color = new Color('orange');
   * const bgrColor = color.toBgrNumber(); // Color with swapped R/B channels
   * ```
   * @remarks
   * This swaps the red and blue channels compared to the normal RGB format:
   * - RGB 0xRRGGBB becomes BGR 0xBBGGRR
   */
  toBgrNumber() {
    const [r2, g2, b2] = this.toUint8RgbArray();
    return (b2 << 16) + (g2 << 8) + r2;
  }
  /**
   * Convert to a hexadecimal number in little endian format (e.g., BBGGRR).
   *
   * Useful for platforms that expect colors in little endian byte order.
   * @example
   * ```ts
   * import { Color } from 'pixi.js';
   *
   * // Convert RGB color to little endian format
   * new Color(0xffcc99).toLittleEndianNumber(); // returns 0x99ccff
   *
   * // Common use cases:
   * const color = new Color('orange');
   * const leColor = color.toLittleEndianNumber(); // Swaps byte order for LE systems
   *
   * // Multiple conversions
   * const colors = {
   *     normal: 0xffcc99,
   *     littleEndian: new Color(0xffcc99).toLittleEndianNumber(), // 0x99ccff
   *     backToNormal: new Color(0x99ccff).toLittleEndianNumber()  // 0xffcc99
   * };
   * ```
   * @remarks
   * - Swaps R and B channels in the color value
   * - RGB 0xRRGGBB becomes 0xBBGGRR
   * - Useful for systems that use little endian byte order
   * - Can be used to convert back and forth between formats
   * @returns The color as a number in little endian format (BBGGRR)
   * @see {@link Color.toBgrNumber} For BGR format without byte swapping
   */
  toLittleEndianNumber() {
    const value2 = this._int;
    return (value2 >> 16) + (value2 & 65280) + ((value2 & 255) << 16);
  }
  /**
   * Multiply with another color.
   *
   * This action is destructive and modifies the original color.
   * @param {ColorSource} value - The color to multiply by. Accepts any valid color format:
   * - Hex strings/numbers (e.g., '#ff0000', 0xff0000)
   * - RGB/RGBA arrays ([1, 0, 0], [1, 0, 0, 1])
   * - Color objects ({ r: 1, g: 0, b: 0 })
   * - CSS color names ('red', 'blue')
   * @returns this - The Color instance for chaining
   * @example
   * ```ts
   * // Basic multiplication
   * const color = new Color('#ff0000');
   * color.multiply(0x808080); // 50% darker red
   *
   * // With transparency
   * color.multiply([1, 1, 1, 0.5]); // 50% transparent
   *
   * // Chain operations
   * color
   *     .multiply('#808080')
   *     .multiply({ r: 1, g: 1, b: 1, a: 0.5 });
   * ```
   * @remarks
   * - Multiplies each RGB component and alpha separately
   * - Values are clamped between 0-1
   * - Original color format is lost (value becomes null)
   * - Operation cannot be undone
   */
  multiply(value2) {
    const [r2, g2, b2, a2] = _Color2._temp.setValue(value2)._components;
    this._components[0] *= r2;
    this._components[1] *= g2;
    this._components[2] *= b2;
    this._components[3] *= a2;
    this._refreshInt();
    this._value = null;
    return this;
  }
  /**
   * Converts color to a premultiplied alpha format.
   *
   * This action is destructive and modifies the original color.
   * @param alpha - The alpha value to multiply by (0-1)
   * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels
   * @returns {Color} The Color instance for chaining
   * @example
   * ```ts
   * // Basic premultiplication
   * const color = new Color('red');
   * color.premultiply(0.5); // 50% transparent red with premultiplied RGB
   *
   * // Alpha only (RGB unchanged)
   * color.premultiply(0.5, false); // 50% transparent, original RGB
   *
   * // Chain with other operations
   * color
   *     .multiply(0x808080)
   *     .premultiply(0.5)
   *     .toNumber();
   * ```
   * @remarks
   * - RGB channels are multiplied by alpha when applyToRGB is true
   * - Alpha is always set to the provided value
   * - Values are clamped between 0-1
   * - Original color format is lost (value becomes null)
   * - Operation cannot be undone
   */
  premultiply(alpha, applyToRGB = true) {
    if (applyToRGB) {
      this._components[0] *= alpha;
      this._components[1] *= alpha;
      this._components[2] *= alpha;
    }
    this._components[3] = alpha;
    this._refreshInt();
    this._value = null;
    return this;
  }
  /**
   * Returns the color as a 32-bit premultiplied alpha integer.
   *
   * Format: 0xAARRGGBB
   * @param {number} alpha - The alpha value to multiply by (0-1)
   * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels
   * @returns {number} The premultiplied color as a 32-bit integer
   * @example
   * ```ts
   * // Convert to premultiplied format
   * const color = new Color('red');
   *
   * // Full opacity (0xFFRRGGBB)
   * color.toPremultiplied(1.0); // 0xFFFF0000
   *
   * // 50% transparency with premultiplied RGB
   * color.toPremultiplied(0.5); // 0x7F7F0000
   *
   * // 50% transparency without RGB premultiplication
   * color.toPremultiplied(0.5, false); // 0x7FFF0000
   * ```
   * @remarks
   * - Returns full opacity (0xFF000000) when alpha is 1.0
   * - Returns 0 when alpha is 0.0 and applyToRGB is true
   * - RGB values are rounded during premultiplication
   */
  toPremultiplied(alpha, applyToRGB = true) {
    if (alpha === 1) {
      return (255 << 24) + this._int;
    }
    if (alpha === 0) {
      return applyToRGB ? 0 : this._int;
    }
    let r2 = this._int >> 16 & 255;
    let g2 = this._int >> 8 & 255;
    let b2 = this._int & 255;
    if (applyToRGB) {
      r2 = r2 * alpha + 0.5 | 0;
      g2 = g2 * alpha + 0.5 | 0;
      b2 = b2 * alpha + 0.5 | 0;
    }
    return (alpha * 255 << 24) + (r2 << 16) + (g2 << 8) + b2;
  }
  /**
   * Convert to a hexadecimal string (6 characters).
   * @returns A CSS-compatible hex color string (e.g., "#ff0000")
   * @example
   * ```ts
   * import { Color } from 'pixi.js';
   *
   * // Basic colors
   * new Color('red').toHex();    // returns "#ff0000"
   * new Color('white').toHex();  // returns "#ffffff"
   * new Color('black').toHex();  // returns "#000000"
   *
   * // From different formats
   * new Color(0xff0000).toHex(); // returns "#ff0000"
   * new Color([1, 0, 0]).toHex(); // returns "#ff0000"
   * new Color({ r: 1, g: 0, b: 0 }).toHex(); // returns "#ff0000"
   * ```
   * @remarks
   * - Always returns a 6-character hex string
   * - Includes leading "#" character
   * - Alpha channel is ignored
   * - Values are rounded to nearest hex value
   */
  toHex() {
    const hexString = this._int.toString(16);
    return `#${"000000".substring(0, 6 - hexString.length) + hexString}`;
  }
  /**
   * Convert to a hexadecimal string with alpha (8 characters).
   * @returns A CSS-compatible hex color string with alpha (e.g., "#ff0000ff")
   * @example
   * ```ts
   * import { Color } from 'pixi.js';
   *
   * // Fully opaque colors
   * new Color('red').toHexa();   // returns "#ff0000ff"
   * new Color('white').toHexa(); // returns "#ffffffff"
   *
   * // With transparency
   * new Color('rgba(255, 0, 0, 0.5)').toHexa(); // returns "#ff00007f"
   * new Color([1, 0, 0, 0]).toHexa(); // returns "#ff000000"
   * ```
   * @remarks
   * - Returns an 8-character hex string
   * - Includes leading "#" character
   * - Alpha is encoded in last two characters
   * - Values are rounded to nearest hex value
   */
  toHexa() {
    const alphaValue = Math.round(this._components[3] * 255);
    const alphaString = alphaValue.toString(16);
    return this.toHex() + "00".substring(0, 2 - alphaString.length) + alphaString;
  }
  /**
   * Set alpha (transparency) value while preserving color components.
   *
   * Provides a chainable interface for setting alpha.
   * @param alpha - Alpha value between 0 (fully transparent) and 1 (fully opaque)
   * @returns The Color instance for chaining
   * @example
   * ```ts
   * // Basic alpha setting
   * const color = new Color('red');
   * color.setAlpha(0.5);  // 50% transparent red
   *
   * // Chain with other operations
   * color
   *     .setValue('#ff0000')
   *     .setAlpha(0.8)    // 80% opaque
   *     .premultiply(0.5); // Further modify alpha
   *
   * // Reset to fully opaque
   * color.setAlpha(1);
   * ```
   * @remarks
   * - Alpha value is clamped between 0-1
   * - Can be chained with other color operations
   */
  setAlpha(alpha) {
    this._components[3] = this._clamp(alpha);
    return this;
  }
  /**
   * Normalize the input value into rgba
   * @param value - Input value
   */
  _normalize(value2) {
    let r2;
    let g2;
    let b2;
    let a2;
    if ((typeof value2 === "number" || value2 instanceof Number) && value2 >= 0 && value2 <= 16777215) {
      const int = value2;
      r2 = (int >> 16 & 255) / 255;
      g2 = (int >> 8 & 255) / 255;
      b2 = (int & 255) / 255;
      a2 = 1;
    } else if ((Array.isArray(value2) || value2 instanceof Float32Array) && value2.length >= 3 && value2.length <= 4) {
      value2 = this._clamp(value2);
      [r2, g2, b2, a2 = 1] = value2;
    } else if ((value2 instanceof Uint8Array || value2 instanceof Uint8ClampedArray) && value2.length >= 3 && value2.length <= 4) {
      value2 = this._clamp(value2, 0, 255);
      [r2, g2, b2, a2 = 255] = value2;
      r2 /= 255;
      g2 /= 255;
      b2 /= 255;
      a2 /= 255;
    } else if (typeof value2 === "string" || typeof value2 === "object") {
      if (typeof value2 === "string") {
        const match = _Color2.HEX_PATTERN.exec(value2);
        if (match) {
          value2 = `#${match[2]}`;
        }
      }
      const color = w(value2);
      if (color.isValid()) {
        ({ r: r2, g: g2, b: b2, a: a2 } = color.rgba);
        r2 /= 255;
        g2 /= 255;
        b2 /= 255;
      }
    }
    if (r2 !== void 0) {
      this._components[0] = r2;
      this._components[1] = g2;
      this._components[2] = b2;
      this._components[3] = a2;
      this._refreshInt();
    } else {
      throw new Error(`Unable to convert color ${value2}`);
    }
  }
  /** Refresh the internal color rgb number */
  _refreshInt() {
    this._clamp(this._components);
    const [r2, g2, b2] = this._components;
    this._int = (r2 * 255 << 16) + (g2 * 255 << 8) + (b2 * 255 | 0);
  }
  /**
   * Clamps values to a range. Will override original values
   * @param value - Value(s) to clamp
   * @param min - Minimum value
   * @param max - Maximum value
   */
  _clamp(value2, min = 0, max = 1) {
    if (typeof value2 === "number") {
      return Math.min(Math.max(value2, min), max);
    }
    value2.forEach((v2, i2) => {
      value2[i2] = Math.min(Math.max(v2, min), max);
    });
    return value2;
  }
  /**
   * Check if a value can be interpreted as a valid color format.
   * Supports all color formats that can be used with the Color class.
   * @param value - Value to check
   * @returns True if the value can be used as a color
   * @example
   * ```ts
   * import { Color } from 'pixi.js';
   *
   * // CSS colors and hex values
   * Color.isColorLike('red');          // true
   * Color.isColorLike('#ff0000');      // true
   * Color.isColorLike(0xff0000);       // true
   *
   * // Arrays (RGB/RGBA)
   * Color.isColorLike([1, 0, 0]);      // true
   * Color.isColorLike([1, 0, 0, 0.5]); // true
   *
   * // TypedArrays
   * Color.isColorLike(new Float32Array([1, 0, 0]));          // true
   * Color.isColorLike(new Uint8Array([255, 0, 0]));          // true
   * Color.isColorLike(new Uint8ClampedArray([255, 0, 0]));   // true
   *
   * // Object formats
   * Color.isColorLike({ r: 1, g: 0, b: 0 });            // true (RGB)
   * Color.isColorLike({ r: 1, g: 0, b: 0, a: 0.5 });    // true (RGBA)
   * Color.isColorLike({ h: 0, s: 100, l: 50 });         // true (HSL)
   * Color.isColorLike({ h: 0, s: 100, l: 50, a: 0.5 }); // true (HSLA)
   * Color.isColorLike({ h: 0, s: 100, v: 100 });        // true (HSV)
   * Color.isColorLike({ h: 0, s: 100, v: 100, a: 0.5 });// true (HSVA)
   *
   * // Color instances
   * Color.isColorLike(new Color('red')); // true
   *
   * // Invalid values
   * Color.isColorLike(null);           // false
   * Color.isColorLike(undefined);      // false
   * Color.isColorLike({});             // false
   * Color.isColorLike([]);             // false
   * Color.isColorLike('not-a-color');  // false
   * ```
   * @remarks
   * Checks for the following formats:
   * - Numbers (0x000000 to 0xffffff)
   * - CSS color strings
   * - RGB/RGBA arrays and objects
   * - HSL/HSLA objects
   * - HSV/HSVA objects
   * - TypedArrays (Float32Array, Uint8Array, Uint8ClampedArray)
   * - Color instances
   * @see {@link ColorSource} For supported color format types
   * @see {@link Color.setValue} For setting color values
   * @category utility
   */
  static isColorLike(value2) {
    return typeof value2 === "number" || typeof value2 === "string" || value2 instanceof Number || value2 instanceof _Color2 || Array.isArray(value2) || value2 instanceof Uint8Array || value2 instanceof Uint8ClampedArray || value2 instanceof Float32Array || value2.r !== void 0 && value2.g !== void 0 && value2.b !== void 0 || value2.r !== void 0 && value2.g !== void 0 && value2.b !== void 0 && value2.a !== void 0 || value2.h !== void 0 && value2.s !== void 0 && value2.l !== void 0 || value2.h !== void 0 && value2.s !== void 0 && value2.l !== void 0 && value2.a !== void 0 || value2.h !== void 0 && value2.s !== void 0 && value2.v !== void 0 || value2.h !== void 0 && value2.s !== void 0 && value2.v !== void 0 && value2.a !== void 0;
  }
};
_Color.shared = new _Color();
_Color._temp = new _Color();
_Color.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;
let Color = _Color;
const cullingMixin = {
  cullArea: null,
  cullable: false,
  cullableChildren: true
};
let warnCount = 0;
const maxWarnings = 500;
function warn(...args) {
  if (warnCount === maxWarnings)
    return;
  warnCount++;
  if (warnCount === maxWarnings) {
    console.warn("PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.");
  } else {
    console.warn("PixiJS Warning: ", ...args);
  }
}
const GlobalResourceRegistry = {
  /**
   * Set of registered pools and cleanable objects.
   * @private
   */
  _registeredResources: /* @__PURE__ */ new Set(),
  /**
   * Registers a pool or cleanable object for cleanup.
   * @param {Cleanable} pool - The pool or object to register.
   */
  register(pool) {
    this._registeredResources.add(pool);
  },
  /**
   * Unregisters a pool or cleanable object from cleanup.
   * @param {Cleanable} pool - The pool or object to unregister.
   */
  unregister(pool) {
    this._registeredResources.delete(pool);
  },
  /** Clears all registered pools and cleanable objects. This will call clear() on each registered item. */
  release() {
    this._registeredResources.forEach((pool) => pool.clear());
  },
  /**
   * Gets the number of registered pools and cleanable objects.
   * @returns {number} The count of registered items.
   */
  get registeredCount() {
    return this._registeredResources.size;
  },
  /**
   * Checks if a specific pool or cleanable object is registered.
   * @param {Cleanable} pool - The pool or object to check.
   * @returns {boolean} True if the item is registered, false otherwise.
   */
  isRegistered(pool) {
    return this._registeredResources.has(pool);
  },
  /**
   * Removes all registrations without clearing the pools.
   * Useful if you want to reset the collector without affecting the pools.
   */
  reset() {
    this._registeredResources.clear();
  }
};
class Pool {
  /**
   * Constructs a new Pool.
   * @param ClassType - The constructor of the items in the pool.
   * @param {number} [initialSize] - The initial size of the pool.
   */
  constructor(ClassType, initialSize) {
    this._pool = [];
    this._count = 0;
    this._index = 0;
    this._classType = ClassType;
    if (initialSize) {
      this.prepopulate(initialSize);
    }
  }
  /**
   * Prepopulates the pool with a given number of items.
   * @param total - The number of items to add to the pool.
   */
  prepopulate(total) {
    for (let i2 = 0; i2 < total; i2++) {
      this._pool[this._index++] = new this._classType();
    }
    this._count += total;
  }
  /**
   * Gets an item from the pool. Calls the item's `init` method if it exists.
   * If there are no items left in the pool, a new one will be created.
   * @param {unknown} [data] - Optional data to pass to the item's constructor.
   * @returns {T} The item from the pool.
   */
  get(data) {
    var _a;
    let item;
    if (this._index > 0) {
      item = this._pool[--this._index];
    } else {
      item = new this._classType();
      this._count++;
    }
    (_a = item.init) == null ? void 0 : _a.call(item, data);
    return item;
  }
  /**
   * Returns an item to the pool. Calls the item's `reset` method if it exists.
   * @param {T} item - The item to return to the pool.
   */
  return(item) {
    var _a;
    (_a = item.reset) == null ? void 0 : _a.call(item);
    this._pool[this._index++] = item;
  }
  /**
   * Gets the number of items in the pool.
   * @readonly
   */
  get totalSize() {
    return this._count;
  }
  /**
   * Gets the number of items in the pool that are free to use without needing to create more.
   * @readonly
   */
  get totalFree() {
    return this._index;
  }
  /**
   * Gets the number of items in the pool that are currently in use.
   * @readonly
   */
  get totalUsed() {
    return this._count - this._index;
  }
  /** clears the pool */
  clear() {
    if (this._pool.length > 0 && this._pool[0].destroy) {
      for (let i2 = 0; i2 < this._index; i2++) {
        this._pool[i2].destroy();
      }
    }
    this._pool.length = 0;
    this._count = 0;
    this._index = 0;
  }
}
class PoolGroupClass {
  constructor() {
    this._poolsByClass = /* @__PURE__ */ new Map();
  }
  /**
   * Prepopulates a specific pool with a given number of items.
   * @template T The type of items in the pool. Must extend PoolItem.
   * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.
   * @param {number} total - The number of items to add to the pool.
   */
  prepopulate(Class, total) {
    const classPool = this.getPool(Class);
    classPool.prepopulate(total);
  }
  /**
   * Gets an item from a specific pool.
   * @template T The type of items in the pool. Must extend PoolItem.
   * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.
   * @param {unknown} [data] - Optional data to pass to the item's constructor.
   * @returns {T} The item from the pool.
   */
  get(Class, data) {
    const pool = this.getPool(Class);
    return pool.get(data);
  }
  /**
   * Returns an item to its respective pool.
   * @param {PoolItem} item - The item to return to the pool.
   */
  return(item) {
    const pool = this.getPool(item.constructor);
    pool.return(item);
  }
  /**
   * Gets a specific pool based on the class type.
   * @template T The type of items in the pool. Must extend PoolItem.
   * @param {PoolItemConstructor<T>} ClassType - The constructor of the items in the pool.
   * @returns {Pool<T>} The pool of the given class type.
   */
  getPool(ClassType) {
    if (!this._poolsByClass.has(ClassType)) {
      this._poolsByClass.set(ClassType, new Pool(ClassType));
    }
    return this._poolsByClass.get(ClassType);
  }
  /** gets the usage stats of each pool in the system */
  stats() {
    const stats = {};
    this._poolsByClass.forEach((pool) => {
      const name2 = stats[pool._classType.name] ? pool._classType.name + pool._classType.ID : pool._classType.name;
      stats[name2] = {
        free: pool.totalFree,
        used: pool.totalUsed,
        size: pool.totalSize
      };
    });
    return stats;
  }
  /** Clears all pools in the group. This will reset all pools and free their resources. */
  clear() {
    this._poolsByClass.forEach((pool) => pool.clear());
    this._poolsByClass.clear();
  }
}
const BigPool = new PoolGroupClass();
GlobalResourceRegistry.register(BigPool);
const cacheAsTextureMixin = {
  get isCachedAsTexture() {
    var _a;
    return !!((_a = this.renderGroup) == null ? void 0 : _a.isCachedAsTexture);
  },
  cacheAsTexture(val) {
    if (typeof val === "boolean" && val === false) {
      this.disableRenderGroup();
    } else {
      this.enableRenderGroup();
      this.renderGroup.enableCacheAsTexture(val === true ? {} : val);
    }
  },
  updateCacheTexture() {
    var _a;
    (_a = this.renderGroup) == null ? void 0 : _a.updateCacheTexture();
  },
  get cacheAsBitmap() {
    return this.isCachedAsTexture;
  },
  set cacheAsBitmap(val) {
    deprecation("v8.6.0", "cacheAsBitmap is deprecated, use cacheAsTexture instead.");
    this.cacheAsTexture(val);
  }
};
function removeItems(arr, startIdx, removeCount) {
  const length = arr.length;
  let i2;
  if (startIdx >= length || removeCount === 0) {
    return;
  }
  removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;
  const len = length - removeCount;
  for (i2 = startIdx; i2 < len; ++i2) {
    arr[i2] = arr[i2 + removeCount];
  }
  arr.length = len;
}
const childrenHelperMixin = {
  allowChildren: true,
  removeChildren(beginIndex = 0, endIndex) {
    var _a;
    const end = endIndex ?? this.children.length;
    const range = end - beginIndex;
    const removed = [];
    if (range > 0 && range <= end) {
      for (let i2 = end - 1; i2 >= beginIndex; i2--) {
        const child = this.children[i2];
        if (!child)
          continue;
        removed.push(child);
        child.parent = null;
      }
      removeItems(this.children, beginIndex, end);
      const renderGroup = this.renderGroup || this.parentRenderGroup;
      if (renderGroup) {
        renderGroup.removeChildren(removed);
      }
      for (let i2 = 0; i2 < removed.length; ++i2) {
        const child = removed[i2];
        (_a = child.parentRenderLayer) == null ? void 0 : _a.detach(child);
        this.emit("childRemoved", child, this, i2);
        removed[i2].emit("removed", this);
      }
      if (removed.length > 0) {
        this._didViewChangeTick++;
      }
      return removed;
    } else if (range === 0 && this.children.length === 0) {
      return removed;
    }
    throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
  },
  removeChildAt(index) {
    const child = this.getChildAt(index);
    return this.removeChild(child);
  },
  getChildAt(index) {
    if (index < 0 || index >= this.children.length) {
      throw new Error(`getChildAt: Index (${index}) does not exist.`);
    }
    return this.children[index];
  },
  setChildIndex(child, index) {
    if (index < 0 || index >= this.children.length) {
      throw new Error(`The index ${index} supplied is out of bounds ${this.children.length}`);
    }
    this.getChildIndex(child);
    this.addChildAt(child, index);
  },
  getChildIndex(child) {
    const index = this.children.indexOf(child);
    if (index === -1) {
      throw new Error("The supplied Container must be a child of the caller");
    }
    return index;
  },
  addChildAt(child, index) {
    if (!this.allowChildren) {
      deprecation(v8_0_0, "addChildAt: Only Containers will be allowed to add children in v8.0.0");
    }
    const { children } = this;
    if (index < 0 || index > children.length) {
      throw new Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${children.length}`);
    }
    if (child.parent) {
      const currentIndex = child.parent.children.indexOf(child);
      if (child.parent === this && currentIndex === index) {
        return child;
      }
      if (currentIndex !== -1) {
        child.parent.children.splice(currentIndex, 1);
      }
    }
    if (index === children.length) {
      children.push(child);
    } else {
      children.splice(index, 0, child);
    }
    child.parent = this;
    child.didChange = true;
    child._updateFlags = 15;
    const renderGroup = this.renderGroup || this.parentRenderGroup;
    if (renderGroup) {
      renderGroup.addChild(child);
    }
    if (this.sortableChildren)
      this.sortDirty = true;
    this.emit("childAdded", child, this, index);
    child.emit("added", this);
    return child;
  },
  swapChildren(child, child2) {
    if (child === child2) {
      return;
    }
    const index1 = this.getChildIndex(child);
    const index2 = this.getChildIndex(child2);
    this.children[index1] = child2;
    this.children[index2] = child;
    const renderGroup = this.renderGroup || this.parentRenderGroup;
    if (renderGroup) {
      renderGroup.structureDidChange = true;
    }
    this._didContainerChangeTick++;
  },
  removeFromParent() {
    var _a;
    (_a = this.parent) == null ? void 0 : _a.removeChild(this);
  },
  reparentChild(...child) {
    if (child.length === 1) {
      return this.reparentChildAt(child[0], this.children.length);
    }
    child.forEach((c2) => this.reparentChildAt(c2, this.children.length));
    return child[0];
  },
  reparentChildAt(child, index) {
    if (child.parent === this) {
      this.setChildIndex(child, index);
      return child;
    }
    const childMat = child.worldTransform.clone();
    child.removeFromParent();
    this.addChildAt(child, index);
    const newMatrix = this.worldTransform.clone();
    newMatrix.invert();
    childMat.prepend(newMatrix);
    child.setFromMatrix(childMat);
    return child;
  },
  replaceChild(oldChild, newChild) {
    oldChild.updateLocalTransform();
    this.addChildAt(newChild, this.getChildIndex(oldChild));
    newChild.setFromMatrix(oldChild.localTransform);
    newChild.updateLocalTransform();
    this.removeChild(oldChild);
  }
};
const collectRenderablesMixin = {
  collectRenderables(instructionSet, renderer, currentLayer) {
    if (this.parentRenderLayer && this.parentRenderLayer !== currentLayer || this.globalDisplayStatus < 7 || !this.includeInBuild)
      return;
    if (this.sortableChildren) {
      this.sortChildren();
    }
    if (this.isSimple) {
      this.collectRenderablesSimple(instructionSet, renderer, currentLayer);
    } else if (this.renderGroup) {
      renderer.renderPipes.renderGroup.addRenderGroup(this.renderGroup, instructionSet);
    } else {
      this.collectRenderablesWithEffects(instructionSet, renderer, currentLayer);
    }
  },
  collectRenderablesSimple(instructionSet, renderer, currentLayer) {
    const children = this.children;
    const length = children.length;
    for (let i2 = 0; i2 < length; i2++) {
      children[i2].collectRenderables(instructionSet, renderer, currentLayer);
    }
  },
  collectRenderablesWithEffects(instructionSet, renderer, currentLayer) {
    const { renderPipes } = renderer;
    for (let i2 = 0; i2 < this.effects.length; i2++) {
      const effect = this.effects[i2];
      const pipe = renderPipes[effect.pipe];
      pipe.push(effect, this, instructionSet);
    }
    this.collectRenderablesSimple(instructionSet, renderer, currentLayer);
    for (let i2 = this.effects.length - 1; i2 >= 0; i2--) {
      const effect = this.effects[i2];
      const pipe = renderPipes[effect.pipe];
      pipe.pop(effect, this, instructionSet);
    }
  }
};
class FilterEffect {
  constructor() {
    this.pipe = "filter";
    this.priority = 1;
  }
  destroy() {
    for (let i2 = 0; i2 < this.filters.length; i2++) {
      this.filters[i2].destroy();
    }
    this.filters = null;
    this.filterArea = null;
  }
}
class MaskEffectManagerClass {
  constructor() {
    this._effectClasses = [];
    this._tests = [];
    this._initialized = false;
  }
  init() {
    if (this._initialized)
      return;
    this._initialized = true;
    this._effectClasses.forEach((test) => {
      this.add({
        test: test.test,
        maskClass: test
      });
    });
  }
  add(test) {
    this._tests.push(test);
  }
  getMaskEffect(item) {
    if (!this._initialized)
      this.init();
    for (let i2 = 0; i2 < this._tests.length; i2++) {
      const test = this._tests[i2];
      if (test.test(item)) {
        return BigPool.get(test.maskClass, item);
      }
    }
    return item;
  }
  returnMaskEffect(effect) {
    BigPool.return(effect);
  }
}
const MaskEffectManager = new MaskEffectManagerClass();
extensions.handleByList(ExtensionType.MaskEffect, MaskEffectManager._effectClasses);
const effectsMixin = {
  _maskEffect: null,
  _maskOptions: {
    inverse: false
  },
  _filterEffect: null,
  effects: [],
  _markStructureAsChanged() {
    const renderGroup = this.renderGroup || this.parentRenderGroup;
    if (renderGroup) {
      renderGroup.structureDidChange = true;
    }
  },
  addEffect(effect) {
    const index = this.effects.indexOf(effect);
    if (index !== -1)
      return;
    this.effects.push(effect);
    this.effects.sort((a2, b2) => a2.priority - b2.priority);
    this._markStructureAsChanged();
    this._updateIsSimple();
  },
  removeEffect(effect) {
    const index = this.effects.indexOf(effect);
    if (index === -1)
      return;
    this.effects.splice(index, 1);
    this._markStructureAsChanged();
    this._updateIsSimple();
  },
  set mask(value2) {
    const effect = this._maskEffect;
    if ((effect == null ? void 0 : effect.mask) === value2)
      return;
    if (effect) {
      this.removeEffect(effect);
      MaskEffectManager.returnMaskEffect(effect);
      this._maskEffect = null;
    }
    if (value2 === null || value2 === void 0)
      return;
    this._maskEffect = MaskEffectManager.getMaskEffect(value2);
    this.addEffect(this._maskEffect);
  },
  get mask() {
    var _a;
    return (_a = this._maskEffect) == null ? void 0 : _a.mask;
  },
  setMask(options) {
    this._maskOptions = {
      ...this._maskOptions,
      ...options
    };
    if (options.mask) {
      this.mask = options.mask;
    }
    this._markStructureAsChanged();
  },
  set filters(value2) {
    var _a;
    if (!Array.isArray(value2) && value2)
      value2 = [value2];
    const effect = this._filterEffect || (this._filterEffect = new FilterEffect());
    value2 = value2;
    const hasFilters = (value2 == null ? void 0 : value2.length) > 0;
    const hadFilters = ((_a = effect.filters) == null ? void 0 : _a.length) > 0;
    const didChange = hasFilters !== hadFilters;
    value2 = Array.isArray(value2) ? value2.slice(0) : value2;
    effect.filters = Object.freeze(value2);
    if (didChange) {
      if (hasFilters) {
        this.addEffect(effect);
      } else {
        this.removeEffect(effect);
        effect.filters = value2 ?? null;
      }
    }
  },
  get filters() {
    var _a;
    return (_a = this._filterEffect) == null ? void 0 : _a.filters;
  },
  set filterArea(value2) {
    this._filterEffect || (this._filterEffect = new FilterEffect());
    this._filterEffect.filterArea = value2;
  },
  get filterArea() {
    var _a;
    return (_a = this._filterEffect) == null ? void 0 : _a.filterArea;
  }
};
const findMixin = {
  label: null,
  get name() {
    deprecation(v8_0_0, "Container.name property has been removed, use Container.label instead");
    return this.label;
  },
  set name(value2) {
    deprecation(v8_0_0, "Container.name property has been removed, use Container.label instead");
    this.label = value2;
  },
  getChildByName(name2, deep = false) {
    return this.getChildByLabel(name2, deep);
  },
  getChildByLabel(label2, deep = false) {
    const children = this.children;
    for (let i2 = 0; i2 < children.length; i2++) {
      const child = children[i2];
      if (child.label === label2 || label2 instanceof RegExp && label2.test(child.label))
        return child;
    }
    if (deep) {
      for (let i2 = 0; i2 < children.length; i2++) {
        const child = children[i2];
        const found = child.getChildByLabel(label2, true);
        if (found) {
          return found;
        }
      }
    }
    return null;
  },
  getChildrenByLabel(label2, deep = false, out2 = []) {
    const children = this.children;
    for (let i2 = 0; i2 < children.length; i2++) {
      const child = children[i2];
      if (child.label === label2 || label2 instanceof RegExp && label2.test(child.label)) {
        out2.push(child);
      }
    }
    if (deep) {
      for (let i2 = 0; i2 < children.length; i2++) {
        children[i2].getChildrenByLabel(label2, true, out2);
      }
    }
    return out2;
  }
};
const matrixPool = BigPool.getPool(Matrix);
const boundsPool = BigPool.getPool(Bounds);
const tempMatrix$2 = new Matrix();
const getFastGlobalBoundsMixin = {
  getFastGlobalBounds(factorRenderLayers, bounds) {
    bounds || (bounds = new Bounds());
    bounds.clear();
    this._getGlobalBoundsRecursive(!!factorRenderLayers, bounds, this.parentRenderLayer);
    if (!bounds.isValid) {
      bounds.set(0, 0, 0, 0);
    }
    const renderGroup = this.renderGroup || this.parentRenderGroup;
    bounds.applyMatrix(renderGroup.worldTransform);
    return bounds;
  },
  _getGlobalBoundsRecursive(factorRenderLayers, bounds, currentLayer) {
    let localBounds = bounds;
    if (factorRenderLayers && this.parentRenderLayer && this.parentRenderLayer !== currentLayer)
      return;
    if (this.localDisplayStatus !== 7 || !this.measurable) {
      return;
    }
    const manageEffects = !!this.effects.length;
    if (this.renderGroup || manageEffects) {
      localBounds = boundsPool.get().clear();
    }
    if (this.boundsArea) {
      bounds.addRect(this.boundsArea, this.worldTransform);
    } else {
      if (this.renderPipeId) {
        const viewBounds = this.bounds;
        localBounds.addFrame(
          viewBounds.minX,
          viewBounds.minY,
          viewBounds.maxX,
          viewBounds.maxY,
          this.groupTransform
        );
      }
      const children = this.children;
      for (let i2 = 0; i2 < children.length; i2++) {
        children[i2]._getGlobalBoundsRecursive(factorRenderLayers, localBounds, currentLayer);
      }
    }
    if (manageEffects) {
      let advanced = false;
      const renderGroup = this.renderGroup || this.parentRenderGroup;
      for (let i2 = 0; i2 < this.effects.length; i2++) {
        if (this.effects[i2].addBounds) {
          if (!advanced) {
            advanced = true;
            localBounds.applyMatrix(renderGroup.worldTransform);
          }
          this.effects[i2].addBounds(localBounds, true);
        }
      }
      if (advanced) {
        localBounds.applyMatrix(renderGroup.worldTransform.copyTo(tempMatrix$2).invert());
      }
      bounds.addBounds(localBounds);
      boundsPool.return(localBounds);
    } else if (this.renderGroup) {
      bounds.addBounds(localBounds, this.relativeGroupTransform);
      boundsPool.return(localBounds);
    }
  }
};
function getGlobalBounds(target, skipUpdateTransform, bounds) {
  bounds.clear();
  let parentTransform;
  let pooledMatrix;
  if (target.parent) {
    if (!skipUpdateTransform) {
      pooledMatrix = matrixPool.get().identity();
      parentTransform = updateTransformBackwards(target, pooledMatrix);
    } else {
      parentTransform = target.parent.worldTransform;
    }
  } else {
    parentTransform = Matrix.IDENTITY;
  }
  _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform);
  if (pooledMatrix) {
    matrixPool.return(pooledMatrix);
  }
  if (!bounds.isValid) {
    bounds.set(0, 0, 0, 0);
  }
  return bounds;
}
function _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform) {
  var _a, _b;
  if (!target.visible || !target.measurable)
    return;
  let worldTransform;
  if (!skipUpdateTransform) {
    target.updateLocalTransform();
    worldTransform = matrixPool.get();
    worldTransform.appendFrom(target.localTransform, parentTransform);
  } else {
    worldTransform = target.worldTransform;
  }
  const parentBounds = bounds;
  const preserveBounds = !!target.effects.length;
  if (preserveBounds) {
    bounds = boundsPool.get().clear();
  }
  if (target.boundsArea) {
    bounds.addRect(target.boundsArea, worldTransform);
  } else {
    const renderableBounds = target.bounds;
    if (renderableBounds && !renderableBounds.isEmpty()) {
      bounds.matrix = worldTransform;
      bounds.addBounds(renderableBounds);
    }
    for (let i2 = 0; i2 < target.children.length; i2++) {
      _getGlobalBounds(target.children[i2], bounds, worldTransform, skipUpdateTransform);
    }
  }
  if (preserveBounds) {
    for (let i2 = 0; i2 < target.effects.length; i2++) {
      (_b = (_a = target.effects[i2]).addBounds) == null ? void 0 : _b.call(_a, bounds);
    }
    parentBounds.addBounds(bounds, Matrix.IDENTITY);
    boundsPool.return(bounds);
  }
  if (!skipUpdateTransform) {
    matrixPool.return(worldTransform);
  }
}
function updateTransformBackwards(target, parentTransform) {
  const parent = target.parent;
  if (parent) {
    updateTransformBackwards(parent, parentTransform);
    parent.updateLocalTransform();
    parentTransform.append(parent.localTransform);
  }
  return parentTransform;
}
function multiplyHexColors(color1, color2) {
  if (color1 === 16777215 || !color2)
    return color2;
  if (color2 === 16777215 || !color1)
    return color1;
  const r1 = color1 >> 16 & 255;
  const g1 = color1 >> 8 & 255;
  const b1 = color1 & 255;
  const r2 = color2 >> 16 & 255;
  const g2 = color2 >> 8 & 255;
  const b2 = color2 & 255;
  const r3 = r1 * r2 / 255 | 0;
  const g3 = g1 * g2 / 255 | 0;
  const b3 = b1 * b2 / 255 | 0;
  return (r3 << 16) + (g3 << 8) + b3;
}
const WHITE_BGR = 16777215;
function multiplyColors(localBGRColor, parentBGRColor) {
  if (localBGRColor === WHITE_BGR) {
    return parentBGRColor;
  }
  if (parentBGRColor === WHITE_BGR) {
    return localBGRColor;
  }
  return multiplyHexColors(localBGRColor, parentBGRColor);
}
function bgr2rgb(color) {
  return ((color & 255) << 16) + (color & 65280) + (color >> 16 & 255);
}
const getGlobalMixin = {
  getGlobalAlpha(skipUpdate) {
    if (skipUpdate) {
      if (this.renderGroup) {
        return this.renderGroup.worldAlpha;
      }
      if (this.parentRenderGroup) {
        return this.parentRenderGroup.worldAlpha * this.alpha;
      }
      return this.alpha;
    }
    let alpha = this.alpha;
    let current = this.parent;
    while (current) {
      alpha *= current.alpha;
      current = current.parent;
    }
    return alpha;
  },
  getGlobalTransform(matrix = new Matrix(), skipUpdate) {
    if (skipUpdate) {
      return matrix.copyFrom(this.worldTransform);
    }
    this.updateLocalTransform();
    const parentTransform = updateTransformBackwards(this, matrixPool.get().identity());
    matrix.appendFrom(this.localTransform, parentTransform);
    matrixPool.return(parentTransform);
    return matrix;
  },
  getGlobalTint(skipUpdate) {
    if (skipUpdate) {
      if (this.renderGroup) {
        return bgr2rgb(this.renderGroup.worldColor);
      }
      if (this.parentRenderGroup) {
        return bgr2rgb(
          multiplyColors(this.localColor, this.parentRenderGroup.worldColor)
        );
      }
      return this.tint;
    }
    let color = this.localColor;
    let parent = this.parent;
    while (parent) {
      color = multiplyColors(color, parent.localColor);
      parent = parent.parent;
    }
    return bgr2rgb(color);
  }
};
function getLocalBounds(target, bounds, relativeMatrix) {
  bounds.clear();
  relativeMatrix || (relativeMatrix = Matrix.IDENTITY);
  _getLocalBounds(target, bounds, relativeMatrix, target, true);
  if (!bounds.isValid) {
    bounds.set(0, 0, 0, 0);
  }
  return bounds;
}
function _getLocalBounds(target, bounds, parentTransform, rootContainer, isRoot) {
  var _a, _b;
  let relativeTransform;
  if (!isRoot) {
    if (!target.visible || !target.measurable)
      return;
    target.updateLocalTransform();
    const localTransform = target.localTransform;
    relativeTransform = matrixPool.get();
    relativeTransform.appendFrom(localTransform, parentTransform);
  } else {
    relativeTransform = matrixPool.get();
    relativeTransform = parentTransform.copyTo(relativeTransform);
  }
  const parentBounds = bounds;
  const preserveBounds = !!target.effects.length;
  if (preserveBounds) {
    bounds = boundsPool.get().clear();
  }
  if (target.boundsArea) {
    bounds.addRect(target.boundsArea, relativeTransform);
  } else {
    if (target.renderPipeId) {
      bounds.matrix = relativeTransform;
      bounds.addBounds(target.bounds);
    }
    const children = target.children;
    for (let i2 = 0; i2 < children.length; i2++) {
      _getLocalBounds(children[i2], bounds, relativeTransform, rootContainer, false);
    }
  }
  if (preserveBounds) {
    for (let i2 = 0; i2 < target.effects.length; i2++) {
      (_b = (_a = target.effects[i2]).addLocalBounds) == null ? void 0 : _b.call(_a, bounds, rootContainer);
    }
    parentBounds.addBounds(bounds, Matrix.IDENTITY);
    boundsPool.return(bounds);
  }
  matrixPool.return(relativeTransform);
}
function checkChildrenDidChange(container, previousData) {
  const children = container.children;
  for (let i2 = 0; i2 < children.length; i2++) {
    const child = children[i2];
    const uid2 = child.uid;
    const didChange = (child._didViewChangeTick & 65535) << 16 | child._didContainerChangeTick & 65535;
    const index = previousData.index;
    if (previousData.data[index] !== uid2 || previousData.data[index + 1] !== didChange) {
      previousData.data[previousData.index] = uid2;
      previousData.data[previousData.index + 1] = didChange;
      previousData.didChange = true;
    }
    previousData.index = index + 2;
    if (child.children.length) {
      checkChildrenDidChange(child, previousData);
    }
  }
  return previousData.didChange;
}
const tempMatrix$1 = new Matrix();
const measureMixin = {
  _localBoundsCacheId: -1,
  _localBoundsCacheData: null,
  _setWidth(value2, localWidth) {
    const sign2 = Math.sign(this.scale.x) || 1;
    if (localWidth !== 0) {
      this.scale.x = value2 / localWidth * sign2;
    } else {
      this.scale.x = sign2;
    }
  },
  _setHeight(value2, localHeight) {
    const sign2 = Math.sign(this.scale.y) || 1;
    if (localHeight !== 0) {
      this.scale.y = value2 / localHeight * sign2;
    } else {
      this.scale.y = sign2;
    }
  },
  getLocalBounds() {
    if (!this._localBoundsCacheData) {
      this._localBoundsCacheData = {
        data: [],
        index: 1,
        didChange: false,
        localBounds: new Bounds()
      };
    }
    const localBoundsCacheData = this._localBoundsCacheData;
    localBoundsCacheData.index = 1;
    localBoundsCacheData.didChange = false;
    if (localBoundsCacheData.data[0] !== this._didViewChangeTick) {
      localBoundsCacheData.didChange = true;
      localBoundsCacheData.data[0] = this._didViewChangeTick;
    }
    checkChildrenDidChange(this, localBoundsCacheData);
    if (localBoundsCacheData.didChange) {
      getLocalBounds(this, localBoundsCacheData.localBounds, tempMatrix$1);
    }
    return localBoundsCacheData.localBounds;
  },
  getBounds(skipUpdate, bounds) {
    return getGlobalBounds(this, skipUpdate, bounds || new Bounds());
  }
};
const onRenderMixin = {
  _onRender: null,
  set onRender(func) {
    const renderGroup = this.renderGroup || this.parentRenderGroup;
    if (!func) {
      if (this._onRender) {
        renderGroup == null ? void 0 : renderGroup.removeOnRender(this);
      }
      this._onRender = null;
      return;
    }
    if (!this._onRender) {
      renderGroup == null ? void 0 : renderGroup.addOnRender(this);
    }
    this._onRender = func;
  },
  get onRender() {
    return this._onRender;
  }
};
const sortMixin = {
  _zIndex: 0,
  sortDirty: false,
  sortableChildren: false,
  get zIndex() {
    return this._zIndex;
  },
  set zIndex(value2) {
    if (this._zIndex === value2)
      return;
    this._zIndex = value2;
    this.depthOfChildModified();
  },
  depthOfChildModified() {
    if (this.parent) {
      this.parent.sortableChildren = true;
      this.parent.sortDirty = true;
    }
    if (this.parentRenderGroup) {
      this.parentRenderGroup.structureDidChange = true;
    }
  },
  sortChildren() {
    if (!this.sortDirty)
      return;
    this.sortDirty = false;
    this.children.sort(sortChildren);
  }
};
function sortChildren(a2, b2) {
  return a2._zIndex - b2._zIndex;
}
const toLocalGlobalMixin = {
  getGlobalPosition(point = new Point(), skipUpdate = false) {
    if (this.parent) {
      this.parent.toGlobal(this._position, point, skipUpdate);
    } else {
      point.x = this._position.x;
      point.y = this._position.y;
    }
    return point;
  },
  toGlobal(position, point, skipUpdate = false) {
    const globalMatrix = this.getGlobalTransform(matrixPool.get(), skipUpdate);
    point = globalMatrix.apply(position, point);
    matrixPool.return(globalMatrix);
    return point;
  },
  toLocal(position, from, point, skipUpdate) {
    if (from) {
      position = from.toGlobal(position, point, skipUpdate);
    }
    const globalMatrix = this.getGlobalTransform(matrixPool.get(), skipUpdate);
    point = globalMatrix.applyInverse(position, point);
    matrixPool.return(globalMatrix);
    return point;
  }
};
class InstructionSet {
  constructor() {
    this.uid = uid("instructionSet");
    this.instructions = [];
    this.instructionSize = 0;
    this.renderables = [];
    this.gcTick = 0;
  }
  /** reset the instruction set so it can be reused set size back to 0 */
  reset() {
    this.instructionSize = 0;
  }
  /**
   * Destroy the instruction set, clearing the instructions and renderables.
   * @internal
   */
  destroy() {
    this.instructions.length = 0;
    this.renderables.length = 0;
    this.renderPipes = null;
    this.gcTick = 0;
  }
  /**
   * Add an instruction to the set
   * @param instruction - add an instruction to the set
   */
  add(instruction) {
    this.instructions[this.instructionSize++] = instruction;
  }
  /**
   * Log the instructions to the console (for debugging)
   * @internal
   */
  log() {
    this.instructions.length = this.instructionSize;
    console.table(this.instructions, ["type", "action"]);
  }
}
let count = 0;
class TexturePoolClass {
  /**
   * @param textureOptions - options that will be passed to BaseRenderTexture constructor
   * @param {SCALE_MODE} [textureOptions.scaleMode] - See {@link SCALE_MODE} for possible values.
   */
  constructor(textureOptions) {
    this._poolKeyHash = /* @__PURE__ */ Object.create(null);
    this._texturePool = {};
    this.textureOptions = textureOptions || {};
    this.enableFullScreen = false;
    this.textureStyle = new TextureStyle(this.textureOptions);
  }
  /**
   * Creates texture with params that were specified in pool constructor.
   * @param pixelWidth - Width of texture in pixels.
   * @param pixelHeight - Height of texture in pixels.
   * @param antialias
   */
  createTexture(pixelWidth, pixelHeight, antialias) {
    const textureSource = new TextureSource({
      ...this.textureOptions,
      width: pixelWidth,
      height: pixelHeight,
      resolution: 1,
      antialias,
      autoGarbageCollect: false
    });
    return new Texture({
      source: textureSource,
      label: `texturePool_${count++}`
    });
  }
  /**
   * Gets a Power-of-Two render texture or fullScreen texture
   * @param frameWidth - The minimum width of the render texture.
   * @param frameHeight - The minimum height of the render texture.
   * @param resolution - The resolution of the render texture.
   * @param antialias
   * @returns The new render texture.
   */
  getOptimalTexture(frameWidth, frameHeight, resolution2 = 1, antialias) {
    let po2Width = Math.ceil(frameWidth * resolution2 - 1e-6);
    let po2Height = Math.ceil(frameHeight * resolution2 - 1e-6);
    po2Width = nextPow2(po2Width);
    po2Height = nextPow2(po2Height);
    const key2 = (po2Width << 17) + (po2Height << 1) + (antialias ? 1 : 0);
    if (!this._texturePool[key2]) {
      this._texturePool[key2] = [];
    }
    let texture = this._texturePool[key2].pop();
    if (!texture) {
      texture = this.createTexture(po2Width, po2Height, antialias);
    }
    texture.source._resolution = resolution2;
    texture.source.width = po2Width / resolution2;
    texture.source.height = po2Height / resolution2;
    texture.source.pixelWidth = po2Width;
    texture.source.pixelHeight = po2Height;
    texture.frame.x = 0;
    texture.frame.y = 0;
    texture.frame.width = frameWidth;
    texture.frame.height = frameHeight;
    texture.updateUvs();
    this._poolKeyHash[texture.uid] = key2;
    return texture;
  }
  /**
   * Gets extra texture of the same size as input renderTexture
   * @param texture - The texture to check what size it is.
   * @param antialias - Whether to use antialias.
   * @returns A texture that is a power of two
   */
  getSameSizeTexture(texture, antialias = false) {
    const source2 = texture.source;
    return this.getOptimalTexture(texture.width, texture.height, source2._resolution, antialias);
  }
  /**
   * Place a render texture back into the pool. Optionally reset the style of the texture to the default texture style.
   * useful if you modified the style of the texture after getting it from the pool.
   * @param renderTexture - The renderTexture to free
   * @param resetStyle - Whether to reset the style of the texture to the default texture style
   */
  returnTexture(renderTexture, resetStyle = false) {
    const key2 = this._poolKeyHash[renderTexture.uid];
    if (resetStyle) {
      renderTexture.source.style = this.textureStyle;
    }
    this._texturePool[key2].push(renderTexture);
  }
  /**
   * Clears the pool.
   * @param destroyTextures - Destroy all stored textures.
   */
  clear(destroyTextures) {
    destroyTextures = destroyTextures !== false;
    if (destroyTextures) {
      for (const i2 in this._texturePool) {
        const textures = this._texturePool[i2];
        if (textures) {
          for (let j2 = 0; j2 < textures.length; j2++) {
            textures[j2].destroy(true);
          }
        }
      }
    }
    this._texturePool = {};
  }
}
const TexturePool = new TexturePoolClass();
GlobalResourceRegistry.register(TexturePool);
class RenderGroup {
  constructor() {
    this.renderPipeId = "renderGroup";
    this.root = null;
    this.canBundle = false;
    this.renderGroupParent = null;
    this.renderGroupChildren = [];
    this.worldTransform = new Matrix();
    this.worldColorAlpha = 4294967295;
    this.worldColor = 16777215;
    this.worldAlpha = 1;
    this.childrenToUpdate = /* @__PURE__ */ Object.create(null);
    this.updateTick = 0;
    this.gcTick = 0;
    this.childrenRenderablesToUpdate = { list: [], index: 0 };
    this.structureDidChange = true;
    this.instructionSet = new InstructionSet();
    this._onRenderContainers = [];
    this.textureNeedsUpdate = true;
    this.isCachedAsTexture = false;
    this._matrixDirty = 7;
  }
  init(root) {
    this.root = root;
    if (root._onRender)
      this.addOnRender(root);
    root.didChange = true;
    const children = root.children;
    for (let i2 = 0; i2 < children.length; i2++) {
      const child = children[i2];
      child._updateFlags = 15;
      this.addChild(child);
    }
  }
  enableCacheAsTexture(options = {}) {
    this.textureOptions = options;
    this.isCachedAsTexture = true;
    this.textureNeedsUpdate = true;
  }
  disableCacheAsTexture() {
    this.isCachedAsTexture = false;
    if (this.texture) {
      TexturePool.returnTexture(this.texture, true);
      this.texture = null;
    }
  }
  updateCacheTexture() {
    this.textureNeedsUpdate = true;
    const cachedParent = this._parentCacheAsTextureRenderGroup;
    if (cachedParent && !cachedParent.textureNeedsUpdate) {
      cachedParent.updateCacheTexture();
    }
  }
  reset() {
    this.renderGroupChildren.length = 0;
    for (const i2 in this.childrenToUpdate) {
      const childrenAtDepth = this.childrenToUpdate[i2];
      childrenAtDepth.list.fill(null);
      childrenAtDepth.index = 0;
    }
    this.childrenRenderablesToUpdate.index = 0;
    this.childrenRenderablesToUpdate.list.fill(null);
    this.root = null;
    this.updateTick = 0;
    this.structureDidChange = true;
    this._onRenderContainers.length = 0;
    this.renderGroupParent = null;
    this.disableCacheAsTexture();
  }
  get localTransform() {
    return this.root.localTransform;
  }
  addRenderGroupChild(renderGroupChild) {
    if (renderGroupChild.renderGroupParent) {
      renderGroupChild.renderGroupParent._removeRenderGroupChild(renderGroupChild);
    }
    renderGroupChild.renderGroupParent = this;
    this.renderGroupChildren.push(renderGroupChild);
  }
  _removeRenderGroupChild(renderGroupChild) {
    const index = this.renderGroupChildren.indexOf(renderGroupChild);
    if (index > -1) {
      this.renderGroupChildren.splice(index, 1);
    }
    renderGroupChild.renderGroupParent = null;
  }
  addChild(child) {
    this.structureDidChange = true;
    child.parentRenderGroup = this;
    child.updateTick = -1;
    if (child.parent === this.root) {
      child.relativeRenderGroupDepth = 1;
    } else {
      child.relativeRenderGroupDepth = child.parent.relativeRenderGroupDepth + 1;
    }
    child.didChange = true;
    this.onChildUpdate(child);
    if (child.renderGroup) {
      this.addRenderGroupChild(child.renderGroup);
      return;
    }
    if (child._onRender)
      this.addOnRender(child);
    const children = child.children;
    for (let i2 = 0; i2 < children.length; i2++) {
      this.addChild(children[i2]);
    }
  }
  removeChild(child) {
    this.structureDidChange = true;
    if (child._onRender) {
      if (!child.renderGroup) {
        this.removeOnRender(child);
      }
    }
    child.parentRenderGroup = null;
    if (child.renderGroup) {
      this._removeRenderGroupChild(child.renderGroup);
      return;
    }
    const children = child.children;
    for (let i2 = 0; i2 < children.length; i2++) {
      this.removeChild(children[i2]);
    }
  }
  removeChildren(children) {
    for (let i2 = 0; i2 < children.length; i2++) {
      this.removeChild(children[i2]);
    }
  }
  onChildUpdate(child) {
    let childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth];
    if (!childrenToUpdate) {
      childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth] = {
        index: 0,
        list: []
      };
    }
    childrenToUpdate.list[childrenToUpdate.index++] = child;
  }
  updateRenderable(renderable) {
    if (renderable.globalDisplayStatus < 7)
      return;
    this.instructionSet.renderPipes[renderable.renderPipeId].updateRenderable(renderable);
    renderable.didViewUpdate = false;
  }
  onChildViewUpdate(child) {
    this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = child;
  }
  get isRenderable() {
    return this.root.localDisplayStatus === 7 && this.worldAlpha > 0;
  }
  /**
   * adding a container to the onRender list will make sure the user function
   * passed in to the user defined 'onRender` callBack
   * @param container - the container to add to the onRender list
   */
  addOnRender(container) {
    this._onRenderContainers.push(container);
  }
  removeOnRender(container) {
    this._onRenderContainers.splice(this._onRenderContainers.indexOf(container), 1);
  }
  runOnRender(renderer) {
    for (let i2 = 0; i2 < this._onRenderContainers.length; i2++) {
      this._onRenderContainers[i2]._onRender(renderer);
    }
  }
  destroy() {
    this.disableCacheAsTexture();
    this.renderGroupParent = null;
    this.root = null;
    this.childrenRenderablesToUpdate = null;
    this.childrenToUpdate = null;
    this.renderGroupChildren = null;
    this._onRenderContainers = null;
    this.instructionSet = null;
  }
  getChildren(out2 = []) {
    const children = this.root.children;
    for (let i2 = 0; i2 < children.length; i2++) {
      this._getChildren(children[i2], out2);
    }
    return out2;
  }
  _getChildren(container, out2 = []) {
    out2.push(container);
    if (container.renderGroup)
      return out2;
    const children = container.children;
    for (let i2 = 0; i2 < children.length; i2++) {
      this._getChildren(children[i2], out2);
    }
    return out2;
  }
  invalidateMatrices() {
    this._matrixDirty = 7;
  }
  /**
   * Returns the inverse of the world transform matrix.
   * @returns {Matrix} The inverse of the world transform matrix.
   */
  get inverseWorldTransform() {
    if ((this._matrixDirty & 1) === 0)
      return this._inverseWorldTransform;
    this._matrixDirty &= -2;
    this._inverseWorldTransform || (this._inverseWorldTransform = new Matrix());
    return this._inverseWorldTransform.copyFrom(this.worldTransform).invert();
  }
  /**
   * Returns the inverse of the texture offset transform matrix.
   * @returns {Matrix} The inverse of the texture offset transform matrix.
   */
  get textureOffsetInverseTransform() {
    if ((this._matrixDirty & 2) === 0)
      return this._textureOffsetInverseTransform;
    this._matrixDirty &= -3;
    this._textureOffsetInverseTransform || (this._textureOffsetInverseTransform = new Matrix());
    return this._textureOffsetInverseTransform.copyFrom(this.inverseWorldTransform).translate(
      -this._textureBounds.x,
      -this._textureBounds.y
    );
  }
  /**
   * Returns the inverse of the parent texture transform matrix.
   * This is used to properly transform coordinates when rendering into cached textures.
   * @returns {Matrix} The inverse of the parent texture transform matrix.
   */
  get inverseParentTextureTransform() {
    if ((this._matrixDirty & 4) === 0)
      return this._inverseParentTextureTransform;
    this._matrixDirty &= -5;
    const parentCacheAsTexture = this._parentCacheAsTextureRenderGroup;
    if (parentCacheAsTexture) {
      this._inverseParentTextureTransform || (this._inverseParentTextureTransform = new Matrix());
      return this._inverseParentTextureTransform.copyFrom(this.worldTransform).prepend(parentCacheAsTexture.inverseWorldTransform).translate(
        -parentCacheAsTexture._textureBounds.x,
        -parentCacheAsTexture._textureBounds.y
      );
    }
    return this.worldTransform;
  }
  /**
   * Returns a matrix that transforms coordinates to the correct coordinate space of the texture being rendered to.
   * This is the texture offset inverse transform of the closest parent RenderGroup that is cached as a texture.
   * @returns {Matrix | null} The transform matrix for the cached texture coordinate space,
   * or null if no parent is cached as texture.
   */
  get cacheToLocalTransform() {
    if (this.isCachedAsTexture) {
      return this.textureOffsetInverseTransform;
    }
    if (!this._parentCacheAsTextureRenderGroup)
      return null;
    return this._parentCacheAsTextureRenderGroup.textureOffsetInverseTransform;
  }
}
function assignWithIgnore(target, options, ignore = {}) {
  for (const key2 in options) {
    if (!ignore[key2] && options[key2] !== void 0) {
      target[key2] = options[key2];
    }
  }
}
const defaultSkew = new ObservablePoint(null);
const defaultPivot = new ObservablePoint(null);
const defaultScale = new ObservablePoint(null, 1, 1);
const defaultOrigin = new ObservablePoint(null);
const UPDATE_COLOR = 1;
const UPDATE_BLEND = 2;
const UPDATE_VISIBLE = 4;
class Container extends EventEmitter {
  constructor(options = {}) {
    var _a, _b;
    super();
    this.uid = uid("renderable");
    this._updateFlags = 15;
    this.renderGroup = null;
    this.parentRenderGroup = null;
    this.parentRenderGroupIndex = 0;
    this.didChange = false;
    this.didViewUpdate = false;
    this.relativeRenderGroupDepth = 0;
    this.children = [];
    this.parent = null;
    this.includeInBuild = true;
    this.measurable = true;
    this.isSimple = true;
    this.parentRenderLayer = null;
    this.updateTick = -1;
    this.localTransform = new Matrix();
    this.relativeGroupTransform = new Matrix();
    this.groupTransform = this.relativeGroupTransform;
    this.destroyed = false;
    this._position = new ObservablePoint(this, 0, 0);
    this._scale = defaultScale;
    this._pivot = defaultPivot;
    this._origin = defaultOrigin;
    this._skew = defaultSkew;
    this._cx = 1;
    this._sx = 0;
    this._cy = 0;
    this._sy = 1;
    this._rotation = 0;
    this.localColor = 16777215;
    this.localAlpha = 1;
    this.groupAlpha = 1;
    this.groupColor = 16777215;
    this.groupColorAlpha = 4294967295;
    this.localBlendMode = "inherit";
    this.groupBlendMode = "normal";
    this.localDisplayStatus = 7;
    this.globalDisplayStatus = 7;
    this._didContainerChangeTick = 0;
    this._didViewChangeTick = 0;
    this._didLocalTransformChangeId = -1;
    this.effects = [];
    assignWithIgnore(this, options, {
      children: true,
      parent: true,
      effects: true
    });
    (_a = options.children) == null ? void 0 : _a.forEach((child) => this.addChild(child));
    (_b = options.parent) == null ? void 0 : _b.addChild(this);
  }
  /**
   * Mixes all enumerable properties and methods from a source object to Container.
   * @param source - The source of properties and methods to mix in.
   * @deprecated since 8.8.0
   */
  static mixin(source2) {
    deprecation("8.8.0", "Container.mixin is deprecated, please use extensions.mixin instead.");
    extensions.mixin(Container, source2);
  }
  // = 'default';
  /**
   * We now use the _didContainerChangeTick and _didViewChangeTick to track changes
   * @deprecated since 8.2.6
   * @ignore
   */
  set _didChangeId(value2) {
    this._didViewChangeTick = value2 >> 12 & 4095;
    this._didContainerChangeTick = value2 & 4095;
  }
  /** @ignore */
  get _didChangeId() {
    return this._didContainerChangeTick & 4095 | (this._didViewChangeTick & 4095) << 12;
  }
  /**
   * Adds one or more children to the container.
   * The children will be rendered as part of this container's display list.
   * @example
   * ```ts
   * // Add a single child
   * container.addChild(sprite);
   *
   * // Add multiple children
   * container.addChild(background, player, foreground);
   *
   * // Add with type checking
   * const sprite = container.addChild<Sprite>(new Sprite(texture));
   * sprite.tint = 'red';
   * ```
   * @param children - The Container(s) to add to the container
   * @returns The first child that was added
   * @see {@link Container#removeChild} For removing children
   * @see {@link Container#addChildAt} For adding at specific index
   */
  addChild(...children) {
    if (!this.allowChildren) {
      deprecation(v8_0_0, "addChild: Only Containers will be allowed to add children in v8.0.0");
    }
    if (children.length > 1) {
      for (let i2 = 0; i2 < children.length; i2++) {
        this.addChild(children[i2]);
      }
      return children[0];
    }
    const child = children[0];
    const renderGroup = this.renderGroup || this.parentRenderGroup;
    if (child.parent === this) {
      this.children.splice(this.children.indexOf(child), 1);
      this.children.push(child);
      if (renderGroup) {
        renderGroup.structureDidChange = true;
      }
      return child;
    }
    if (child.parent) {
      child.parent.removeChild(child);
    }
    this.children.push(child);
    if (this.sortableChildren)
      this.sortDirty = true;
    child.parent = this;
    child.didChange = true;
    child._updateFlags = 15;
    if (renderGroup) {
      renderGroup.addChild(child);
    }
    this.emit("childAdded", child, this, this.children.length - 1);
    child.emit("added", this);
    this._didViewChangeTick++;
    if (child._zIndex !== 0) {
      child.depthOfChildModified();
    }
    return child;
  }
  /**
   * Removes one or more children from the container.
   * When removing multiple children, events will be triggered for each child in sequence.
   * @example
   * ```ts
   * // Remove a single child
   * const removed = container.removeChild(sprite);
   *
   * // Remove multiple children
   * const bg = container.removeChild(background, player, userInterface);
   *
   * // Remove with type checking
   * const sprite = container.removeChild<Sprite>(childSprite);
   * sprite.texture = newTexture;
   * ```
   * @param children - The Container(s) to remove
   * @returns The first child that was removed
   * @see {@link Container#addChild} For adding children
   * @see {@link Container#removeChildren} For removing multiple children
   */
  removeChild(...children) {
    if (children.length > 1) {
      for (let i2 = 0; i2 < children.length; i2++) {
        this.removeChild(children[i2]);
      }
      return children[0];
    }
    const child = children[0];
    const index = this.children.indexOf(child);
    if (index > -1) {
      this._didViewChangeTick++;
      this.children.splice(index, 1);
      if (this.renderGroup) {
        this.renderGroup.removeChild(child);
      } else if (this.parentRenderGroup) {
        this.parentRenderGroup.removeChild(child);
      }
      if (child.parentRenderLayer) {
        child.parentRenderLayer.detach(child);
      }
      child.parent = null;
      this.emit("childRemoved", child, this, index);
      child.emit("removed", this);
    }
    return child;
  }
  /** @ignore */
  _onUpdate(point) {
    if (point) {
      if (point === this._skew) {
        this._updateSkew();
      }
    }
    this._didContainerChangeTick++;
    if (this.didChange)
      return;
    this.didChange = true;
    if (this.parentRenderGroup) {
      this.parentRenderGroup.onChildUpdate(this);
    }
  }
  set isRenderGroup(value2) {
    if (!!this.renderGroup === value2)
      return;
    if (value2) {
      this.enableRenderGroup();
    } else {
      this.disableRenderGroup();
    }
  }
  /**
   * Returns true if this container is a render group.
   * This means that it will be rendered as a separate pass, with its own set of instructions
   * @advanced
   */
  get isRenderGroup() {
    return !!this.renderGroup;
  }
  /**
   * Calling this enables a render group for this container.
   * This means it will be rendered as a separate set of instructions.
   * The transform of the container will also be handled on the GPU rather than the CPU.
   * @advanced
   */
  enableRenderGroup() {
    if (this.renderGroup)
      return;
    const parentRenderGroup = this.parentRenderGroup;
    parentRenderGroup == null ? void 0 : parentRenderGroup.removeChild(this);
    this.renderGroup = BigPool.get(RenderGroup, this);
    this.groupTransform = Matrix.IDENTITY;
    parentRenderGroup == null ? void 0 : parentRenderGroup.addChild(this);
    this._updateIsSimple();
  }
  /**
   * This will disable the render group for this container.
   * @advanced
   */
  disableRenderGroup() {
    if (!this.renderGroup)
      return;
    const parentRenderGroup = this.parentRenderGroup;
    parentRenderGroup == null ? void 0 : parentRenderGroup.removeChild(this);
    BigPool.return(this.renderGroup);
    this.renderGroup = null;
    this.groupTransform = this.relativeGroupTransform;
    parentRenderGroup == null ? void 0 : parentRenderGroup.addChild(this);
    this._updateIsSimple();
  }
  /** @ignore */
  _updateIsSimple() {
    this.isSimple = !this.renderGroup && this.effects.length === 0;
  }
  /**
   * Current transform of the object based on world (parent) factors.
   *
   * This matrix represents the absolute transformation in the scene graph.
   * @example
   * ```ts
   * // Get world position
   * const worldPos = container.worldTransform;
   * console.log(`World position: (${worldPos.tx}, ${worldPos.ty})`);
   * ```
   * @readonly
   * @see {@link Container#localTransform} For local space transform
   */
  get worldTransform() {
    this._worldTransform || (this._worldTransform = new Matrix());
    if (this.renderGroup) {
      this._worldTransform.copyFrom(this.renderGroup.worldTransform);
    } else if (this.parentRenderGroup) {
      this._worldTransform.appendFrom(this.relativeGroupTransform, this.parentRenderGroup.worldTransform);
    }
    return this._worldTransform;
  }
  /**
   * The position of the container on the x axis relative to the local coordinates of the parent.
   *
   * An alias to position.x
   * @example
   * ```ts
   * // Basic position
   * container.x = 100;
   * ```
   */
  get x() {
    return this._position.x;
  }
  set x(value2) {
    this._position.x = value2;
  }
  /**
   * The position of the container on the y axis relative to the local coordinates of the parent.
   *
   * An alias to position.y
   * @example
   * ```ts
   * // Basic position
   * container.y = 200;
   * ```
   */
  get y() {
    return this._position.y;
  }
  set y(value2) {
    this._position.y = value2;
  }
  /**
   * The coordinate of the object relative to the local coordinates of the parent.
   * @example
   * ```ts
   * // Basic position setting
   * container.position.set(100, 200);
   * container.position.set(100); // Sets both x and y to 100
   * // Using point data
   * container.position = { x: 50, y: 75 };
   * ```
   * @since 4.0.0
   */
  get position() {
    return this._position;
  }
  set position(value2) {
    this._position.copyFrom(value2);
  }
  /**
   * The rotation of the object in radians.
   *
   * > [!NOTE] 'rotation' and 'angle' have the same effect on a display object;
   * > rotation is in radians, angle is in degrees.
   * @example
   * ```ts
   * // Basic rotation
   * container.rotation = Math.PI / 4; // 45 degrees
   *
   * // Convert from degrees
   * const degrees = 45;
   * container.rotation = degrees * Math.PI / 180;
   *
   * // Rotate around center
   * container.pivot.set(container.width / 2, container.height / 2);
   * container.rotation = Math.PI; // 180 degrees
   *
   * // Rotate around center with origin
   * container.origin.set(container.width / 2, container.height / 2);
   * container.rotation = Math.PI; // 180 degrees
   * ```
   */
  get rotation() {
    return this._rotation;
  }
  set rotation(value2) {
    if (this._rotation !== value2) {
      this._rotation = value2;
      this._onUpdate(this._skew);
    }
  }
  /**
   * The angle of the object in degrees.
   *
   * > [!NOTE] 'rotation' and 'angle' have the same effect on a display object;
   * > rotation is in radians, angle is in degrees.
   * @example
   * ```ts
   * // Basic angle rotation
   * sprite.angle = 45; // 45 degrees
   *
   * // Rotate around center
   * sprite.pivot.set(sprite.width / 2, sprite.height / 2);
   * sprite.angle = 180; // Half rotation
   *
   * // Rotate around center with origin
   * sprite.origin.set(sprite.width / 2, sprite.height / 2);
   * sprite.angle = 180; // Half rotation
   *
   * // Reset rotation
   * sprite.angle = 0;
   * ```
   */
  get angle() {
    return this.rotation * RAD_TO_DEG;
  }
  set angle(value2) {
    this.rotation = value2 * DEG_TO_RAD;
  }
  /**
   * The center of rotation, scaling, and skewing for this display object in its local space.
   * The `position` is the projection of `pivot` in the parent's local space.
   *
   * By default, the pivot is the origin (0, 0).
   * @example
   * ```ts
   * // Rotate around center
   * container.pivot.set(container.width / 2, container.height / 2);
   * container.rotation = Math.PI; // Rotates around center
   * ```
   * @since 4.0.0
   */
  get pivot() {
    if (this._pivot === defaultPivot) {
      this._pivot = new ObservablePoint(this, 0, 0);
    }
    return this._pivot;
  }
  set pivot(value2) {
    if (this._pivot === defaultPivot) {
      this._pivot = new ObservablePoint(this, 0, 0);
      if (this._origin !== defaultOrigin) {
        warn(`Setting both a pivot and origin on a Container is not recommended. This can lead to unexpected behavior if not handled carefully.`);
      }
    }
    typeof value2 === "number" ? this._pivot.set(value2) : this._pivot.copyFrom(value2);
  }
  /**
   * The skew factor for the object in radians. Skewing is a transformation that distorts
   * the object by rotating it differently at each point, creating a non-uniform shape.
   * @example
   * ```ts
   * // Basic skewing
   * container.skew.set(0.5, 0); // Skew horizontally
   * container.skew.set(0, 0.5); // Skew vertically
   *
   * // Skew with point data
   * container.skew = { x: 0.3, y: 0.3 }; // Diagonal skew
   *
   * // Reset skew
   * container.skew.set(0, 0);
   *
   * // Animate skew
   * app.ticker.add(() => {
   *     // Create wave effect
   *     container.skew.x = Math.sin(Date.now() / 1000) * 0.3;
   * });
   *
   * // Combine with rotation
   * container.rotation = Math.PI / 4; // 45 degrees
   * container.skew.set(0.2, 0.2); // Skew the rotated object
   * ```
   * @since 4.0.0
   * @type {ObservablePoint} Point-like object with x/y properties in radians
   * @default {x: 0, y: 0}
   */
  get skew() {
    if (this._skew === defaultSkew) {
      this._skew = new ObservablePoint(this, 0, 0);
    }
    return this._skew;
  }
  set skew(value2) {
    if (this._skew === defaultSkew) {
      this._skew = new ObservablePoint(this, 0, 0);
    }
    this._skew.copyFrom(value2);
  }
  /**
   * The scale factors of this object along the local coordinate axes.
   *
   * The default scale is (1, 1).
   * @example
   * ```ts
   * // Basic scaling
   * container.scale.set(2, 2); // Scales to double size
   * container.scale.set(2); // Scales uniformly to double size
   * container.scale = 2; // Scales uniformly to double size
   * // Scale to a specific width and height
   * container.setSize(200, 100); // Sets width to 200 and height to 100
   * ```
   * @since 4.0.0
   */
  get scale() {
    if (this._scale === defaultScale) {
      this._scale = new ObservablePoint(this, 1, 1);
    }
    return this._scale;
  }
  set scale(value2) {
    if (this._scale === defaultScale) {
      this._scale = new ObservablePoint(this, 0, 0);
    }
    if (typeof value2 === "string") {
      value2 = parseFloat(value2);
    }
    typeof value2 === "number" ? this._scale.set(value2) : this._scale.copyFrom(value2);
  }
  /**
   * @experimental
   * The origin point around which the container rotates and scales without affecting its position.
   * Unlike pivot, changing the origin will not move the container's position.
   * @example
   * ```ts
   * // Rotate around center point
   * container.origin.set(container.width / 2, container.height / 2);
   * container.rotation = Math.PI; // Rotates around center
   *
   * // Reset origin
   * container.origin.set(0, 0);
   * ```
   */
  get origin() {
    if (this._origin === defaultOrigin) {
      this._origin = new ObservablePoint(this, 0, 0);
    }
    return this._origin;
  }
  set origin(value2) {
    if (this._origin === defaultOrigin) {
      this._origin = new ObservablePoint(this, 0, 0);
      if (this._pivot !== defaultPivot) {
        warn(`Setting both a pivot and origin on a Container is not recommended. This can lead to unexpected behavior if not handled carefully.`);
      }
    }
    typeof value2 === "number" ? this._origin.set(value2) : this._origin.copyFrom(value2);
  }
  /**
   * The width of the Container, setting this will actually modify the scale to achieve the value set.
   * > [!NOTE] Changing the width will adjust the scale.x property of the container while maintaining its aspect ratio.
   * > [!NOTE] If you want to set both width and height at the same time, use {@link Container#setSize}
   * as it is more optimized by not recalculating the local bounds twice.
   * @example
   * ```ts
   * // Basic width setting
   * container.width = 100;
   * // Optimized width setting
   * container.setSize(100, 100);
   * ```
   */
  get width() {
    return Math.abs(this.scale.x * this.getLocalBounds().width);
  }
  set width(value2) {
    const localWidth = this.getLocalBounds().width;
    this._setWidth(value2, localWidth);
  }
  /**
   * The height of the Container,
   * > [!NOTE] Changing the height will adjust the scale.y property of the container while maintaining its aspect ratio.
   * > [!NOTE] If you want to set both width and height at the same time, use {@link Container#setSize}
   * as it is more optimized by not recalculating the local bounds twice.
   * @example
   * ```ts
   * // Basic height setting
   * container.height = 200;
   * // Optimized height setting
   * container.setSize(100, 200);
   * ```
   */
  get height() {
    return Math.abs(this.scale.y * this.getLocalBounds().height);
  }
  set height(value2) {
    const localHeight = this.getLocalBounds().height;
    this._setHeight(value2, localHeight);
  }
  /**
   * Retrieves the size of the container as a [Size]{@link Size} object.
   *
   * This is faster than get the width and height separately.
   * @example
   * ```ts
   * // Basic size retrieval
   * const size = container.getSize();
   * console.log(`Size: ${size.width}x${size.height}`);
   *
   * // Reuse existing size object
   * const reuseSize = { width: 0, height: 0 };
   * container.getSize(reuseSize);
   * ```
   * @param out - Optional object to store the size in.
   * @returns The size of the container.
   */
  getSize(out2) {
    if (!out2) {
      out2 = {};
    }
    const bounds = this.getLocalBounds();
    out2.width = Math.abs(this.scale.x * bounds.width);
    out2.height = Math.abs(this.scale.y * bounds.height);
    return out2;
  }
  /**
   * Sets the size of the container to the specified width and height.
   * This is more efficient than setting width and height separately as it only recalculates bounds once.
   * @example
   * ```ts
   * // Basic size setting
   * container.setSize(100, 200);
   *
   * // Set uniform size
   * container.setSize(100); // Sets both width and height to 100
   * ```
   * @param value - This can be either a number or a [Size]{@link Size} object.
   * @param height - The height to set. Defaults to the value of `width` if not provided.
   */
  setSize(value2, height) {
    const size2 = this.getLocalBounds();
    if (typeof value2 === "object") {
      height = value2.height ?? value2.width;
      value2 = value2.width;
    } else {
      height ?? (height = value2);
    }
    value2 !== void 0 && this._setWidth(value2, size2.width);
    height !== void 0 && this._setHeight(height, size2.height);
  }
  /** Called when the skew or the rotation changes. */
  _updateSkew() {
    const rotation = this._rotation;
    const skew = this._skew;
    this._cx = Math.cos(rotation + skew._y);
    this._sx = Math.sin(rotation + skew._y);
    this._cy = -Math.sin(rotation - skew._x);
    this._sy = Math.cos(rotation - skew._x);
  }
  /**
   * Updates the transform properties of the container.
   * Allows partial updates of transform properties for optimized manipulation.
   * @example
   * ```ts
   * // Basic transform update
   * container.updateTransform({
   *     x: 100,
   *     y: 200,
   *     rotation: Math.PI / 4
   * });
   *
   * // Scale and rotate around center
   * sprite.updateTransform({
   *     pivotX: sprite.width / 2,
   *     pivotY: sprite.height / 2,
   *     scaleX: 2,
   *     scaleY: 2,
   *     rotation: Math.PI
   * });
   *
   * // Update position only
   * button.updateTransform({
   *     x: button.x + 10, // Move right
   *     y: button.y      // Keep same y
   * });
   * ```
   * @param opts - Transform options to update
   * @param opts.x - The x position
   * @param opts.y - The y position
   * @param opts.scaleX - The x-axis scale factor
   * @param opts.scaleY - The y-axis scale factor
   * @param opts.rotation - The rotation in radians
   * @param opts.skewX - The x-axis skew factor
   * @param opts.skewY - The y-axis skew factor
   * @param opts.pivotX - The x-axis pivot point
   * @param opts.pivotY - The y-axis pivot point
   * @returns This container, for chaining
   * @see {@link Container#setFromMatrix} For matrix-based transforms
   * @see {@link Container#position} For direct position access
   */
  updateTransform(opts) {
    this.position.set(
      typeof opts.x === "number" ? opts.x : this.position.x,
      typeof opts.y === "number" ? opts.y : this.position.y
    );
    this.scale.set(
      typeof opts.scaleX === "number" ? opts.scaleX || 1 : this.scale.x,
      typeof opts.scaleY === "number" ? opts.scaleY || 1 : this.scale.y
    );
    this.rotation = typeof opts.rotation === "number" ? opts.rotation : this.rotation;
    this.skew.set(
      typeof opts.skewX === "number" ? opts.skewX : this.skew.x,
      typeof opts.skewY === "number" ? opts.skewY : this.skew.y
    );
    this.pivot.set(
      typeof opts.pivotX === "number" ? opts.pivotX : this.pivot.x,
      typeof opts.pivotY === "number" ? opts.pivotY : this.pivot.y
    );
    this.origin.set(
      typeof opts.originX === "number" ? opts.originX : this.origin.x,
      typeof opts.originY === "number" ? opts.originY : this.origin.y
    );
    return this;
  }
  /**
   * Updates the local transform properties by decomposing the given matrix.
   * Extracts position, scale, rotation, and skew from a transformation matrix.
   * @example
   * ```ts
   * // Basic matrix transform
   * const matrix = new Matrix()
   *     .translate(100, 100)
   *     .rotate(Math.PI / 4)
   *     .scale(2, 2);
   *
   * container.setFromMatrix(matrix);
   *
   * // Copy transform from another container
   * const source = new Container();
   * source.position.set(100, 100);
   * source.rotation = Math.PI / 2;
   *
   * target.setFromMatrix(source.localTransform);
   *
   * // Reset transform
   * container.setFromMatrix(Matrix.IDENTITY);
   * ```
   * @param matrix - The matrix to use for updating the transform
   * @see {@link Container#updateTransform} For property-based updates
   * @see {@link Matrix#decompose} For matrix decomposition details
   */
  setFromMatrix(matrix) {
    matrix.decompose(this);
  }
  /** Updates the local transform. */
  updateLocalTransform() {
    const localTransformChangeId = this._didContainerChangeTick;
    if (this._didLocalTransformChangeId === localTransformChangeId)
      return;
    this._didLocalTransformChangeId = localTransformChangeId;
    const lt = this.localTransform;
    const scale = this._scale;
    const pivot = this._pivot;
    const origin = this._origin;
    const position = this._position;
    const sx = scale._x;
    const sy = scale._y;
    const px = pivot._x;
    const py = pivot._y;
    const ox = -origin._x;
    const oy = -origin._y;
    lt.a = this._cx * sx;
    lt.b = this._sx * sx;
    lt.c = this._cy * sy;
    lt.d = this._sy * sy;
    lt.tx = position._x - (px * lt.a + py * lt.c) + (ox * lt.a + oy * lt.c) - ox;
    lt.ty = position._y - (px * lt.b + py * lt.d) + (ox * lt.b + oy * lt.d) - oy;
  }
  // / ///// color related stuff
  set alpha(value2) {
    if (value2 === this.localAlpha)
      return;
    this.localAlpha = value2;
    this._updateFlags |= UPDATE_COLOR;
    this._onUpdate();
  }
  /**
   * The opacity of the object relative to its parent's opacity.
   * Value ranges from 0 (fully transparent) to 1 (fully opaque).
   * @example
   * ```ts
   * // Basic transparency
   * sprite.alpha = 0.5; // 50% opacity
   *
   * // Inherited opacity
   * container.alpha = 0.5;
   * const child = new Sprite(texture);
   * child.alpha = 0.5;
   * container.addChild(child);
   * // child's effective opacity is 0.25 (0.5 * 0.5)
   * ```
   * @default 1
   * @see {@link Container#visible} For toggling visibility
   * @see {@link Container#renderable} For render control
   */
  get alpha() {
    return this.localAlpha;
  }
  set tint(value2) {
    const tempColor = Color.shared.setValue(value2 ?? 16777215);
    const bgr = tempColor.toBgrNumber();
    if (bgr === this.localColor)
      return;
    this.localColor = bgr;
    this._updateFlags |= UPDATE_COLOR;
    this._onUpdate();
  }
  /**
   * The tint applied to the sprite.
   *
   * This can be any valid {@link ColorSource}.
   * @example
   * ```ts
   * // Basic color tinting
   * container.tint = 0xff0000; // Red tint
   * container.tint = 'red';    // Same as above
   * container.tint = '#00ff00'; // Green
   * container.tint = 'rgb(0,0,255)'; // Blue
   *
   * // Remove tint
   * container.tint = 0xffffff; // White = no tint
   * container.tint = null;     // Also removes tint
   * ```
   * @default 0xFFFFFF
   * @see {@link Container#alpha} For transparency
   * @see {@link Container#visible} For visibility control
   */
  get tint() {
    return bgr2rgb(this.localColor);
  }
  // / //////////////// blend related stuff
  set blendMode(value2) {
    if (this.localBlendMode === value2)
      return;
    if (this.parentRenderGroup) {
      this.parentRenderGroup.structureDidChange = true;
    }
    this._updateFlags |= UPDATE_BLEND;
    this.localBlendMode = value2;
    this._onUpdate();
  }
  /**
   * The blend mode to be applied to the sprite. Controls how pixels are blended when rendering.
   *
   * Setting to 'normal' will reset to default blending.
   * > [!NOTE] More blend modes are available after importing the `pixi.js/advanced-blend-modes` sub-export.
   * @example
   * ```ts
   * // Basic blend modes
   * sprite.blendMode = 'add';        // Additive blending
   * sprite.blendMode = 'multiply';   // Multiply colors
   * sprite.blendMode = 'screen';     // Screen blend
   *
   * // Reset blend mode
   * sprite.blendMode = 'normal';     // Normal blending
   * ```
   * @default 'normal'
   * @see {@link Container#alpha} For transparency
   * @see {@link Container#tint} For color adjustments
   */
  get blendMode() {
    return this.localBlendMode;
  }
  // / ///////// VISIBILITY / RENDERABLE /////////////////
  /**
   * The visibility of the object. If false the object will not be drawn,
   * and the transform will not be updated.
   * @example
   * ```ts
   * // Basic visibility toggle
   * sprite.visible = false; // Hide sprite
   * sprite.visible = true;  // Show sprite
   * ```
   * @default true
   * @see {@link Container#renderable} For render-only control
   * @see {@link Container#alpha} For transparency
   */
  get visible() {
    return !!(this.localDisplayStatus & 2);
  }
  set visible(value2) {
    const valueNumber = value2 ? 2 : 0;
    if ((this.localDisplayStatus & 2) === valueNumber)
      return;
    if (this.parentRenderGroup) {
      this.parentRenderGroup.structureDidChange = true;
    }
    this._updateFlags |= UPDATE_VISIBLE;
    this.localDisplayStatus ^= 2;
    this._onUpdate();
  }
  /** @ignore */
  get culled() {
    return !(this.localDisplayStatus & 4);
  }
  /** @ignore */
  set culled(value2) {
    const valueNumber = value2 ? 0 : 4;
    if ((this.localDisplayStatus & 4) === valueNumber)
      return;
    if (this.parentRenderGroup) {
      this.parentRenderGroup.structureDidChange = true;
    }
    this._updateFlags |= UPDATE_VISIBLE;
    this.localDisplayStatus ^= 4;
    this._onUpdate();
  }
  /**
   * Controls whether this object can be rendered. If false the object will not be drawn,
   * but the transform will still be updated. This is different from visible, which skips
   * transform updates.
   * @example
   * ```ts
   * // Basic render control
   * sprite.renderable = false; // Skip rendering
   * sprite.renderable = true;  // Enable rendering
   * ```
   * @default true
   * @see {@link Container#visible} For skipping transform updates
   * @see {@link Container#alpha} For transparency
   */
  get renderable() {
    return !!(this.localDisplayStatus & 1);
  }
  set renderable(value2) {
    const valueNumber = value2 ? 1 : 0;
    if ((this.localDisplayStatus & 1) === valueNumber)
      return;
    this._updateFlags |= UPDATE_VISIBLE;
    this.localDisplayStatus ^= 1;
    if (this.parentRenderGroup) {
      this.parentRenderGroup.structureDidChange = true;
    }
    this._onUpdate();
  }
  /**
   * Whether or not the object should be rendered.
   * @advanced
   */
  get isRenderable() {
    return this.localDisplayStatus === 7 && this.groupAlpha > 0;
  }
  /**
   * Removes all internal references and listeners as well as removes children from the display list.
   * Do not use a Container after calling `destroy`.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @example
   * ```ts
   * container.destroy();
   * container.destroy(true);
   * container.destroy({ children: true });
   * container.destroy({ children: true, texture: true, textureSource: true });
   * ```
   */
  destroy(options = false) {
    var _a;
    if (this.destroyed)
      return;
    this.destroyed = true;
    let oldChildren;
    if (this.children.length) {
      oldChildren = this.removeChildren(0, this.children.length);
    }
    this.removeFromParent();
    this.parent = null;
    this._maskEffect = null;
    this._filterEffect = null;
    this.effects = null;
    this._position = null;
    this._scale = null;
    this._pivot = null;
    this._origin = null;
    this._skew = null;
    this.emit("destroyed", this);
    this.removeAllListeners();
    const destroyChildren = typeof options === "boolean" ? options : options == null ? void 0 : options.children;
    if (destroyChildren && oldChildren) {
      for (let i2 = 0; i2 < oldChildren.length; ++i2) {
        oldChildren[i2].destroy(options);
      }
    }
    (_a = this.renderGroup) == null ? void 0 : _a.destroy();
    this.renderGroup = null;
  }
}
extensions.mixin(
  Container,
  childrenHelperMixin,
  getFastGlobalBoundsMixin,
  toLocalGlobalMixin,
  onRenderMixin,
  measureMixin,
  effectsMixin,
  findMixin,
  sortMixin,
  cullingMixin,
  cacheAsTextureMixin,
  getGlobalMixin,
  collectRenderablesMixin
);
class ViewContainer extends Container {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor(options) {
    super(options);
    this.canBundle = true;
    this.allowChildren = false;
    this._roundPixels = 0;
    this._lastUsed = -1;
    this._gpuData = /* @__PURE__ */ Object.create(null);
    this._bounds = new Bounds(0, 1, 0, 0);
    this._boundsDirty = true;
  }
  /**
   * The local bounds of the view in its own coordinate space.
   * Bounds are automatically updated when the view's content changes.
   * @example
   * ```ts
   * // Get bounds dimensions
   * const bounds = view.bounds;
   * console.log(`Width: ${bounds.maxX - bounds.minX}`);
   * console.log(`Height: ${bounds.maxY - bounds.minY}`);
   * ```
   * @returns The rectangular bounds of the view
   * @see {@link Bounds} For bounds operations
   */
  get bounds() {
    if (!this._boundsDirty)
      return this._bounds;
    this.updateBounds();
    this._boundsDirty = false;
    return this._bounds;
  }
  /**
   * Whether or not to round the x/y position of the sprite.
   * @example
   * ```ts
   * // Enable pixel rounding for crisp rendering
   * view.roundPixels = true;
   * ```
   * @default false
   */
  get roundPixels() {
    return !!this._roundPixels;
  }
  set roundPixels(value2) {
    this._roundPixels = value2 ? 1 : 0;
  }
  /**
   * Checks if the object contains the given point in local coordinates.
   * Uses the view's bounds for hit testing.
   * @example
   * ```ts
   * // Basic point check
   * const localPoint = { x: 50, y: 25 };
   * const contains = view.containsPoint(localPoint);
   * console.log('Point is inside:', contains);
   * ```
   * @param point - The point to check in local coordinates
   * @returns True if the point is within the view's bounds
   * @see {@link ViewContainer#bounds} For the bounds used in hit testing
   * @see {@link Container#toLocal} For converting global coordinates to local
   */
  containsPoint(point) {
    const bounds = this.bounds;
    const { x: x2, y: y2 } = point;
    return x2 >= bounds.minX && x2 <= bounds.maxX && y2 >= bounds.minY && y2 <= bounds.maxY;
  }
  /** @private */
  onViewUpdate() {
    this._didViewChangeTick++;
    this._boundsDirty = true;
    if (this.didViewUpdate)
      return;
    this.didViewUpdate = true;
    const renderGroup = this.renderGroup || this.parentRenderGroup;
    if (renderGroup) {
      renderGroup.onChildViewUpdate(this);
    }
  }
  destroy(options) {
    var _a, _b;
    super.destroy(options);
    this._bounds = null;
    for (const key2 in this._gpuData) {
      (_b = (_a = this._gpuData[key2]).destroy) == null ? void 0 : _b.call(_a);
    }
    this._gpuData = null;
  }
  /**
   * Collects renderables for the view container.
   * @param instructionSet - The instruction set to collect renderables for.
   * @param renderer - The renderer to collect renderables for.
   * @param currentLayer - The current render layer.
   * @internal
   */
  collectRenderablesSimple(instructionSet, renderer, currentLayer) {
    const { renderPipes } = renderer;
    renderPipes.blendMode.pushBlendMode(this, this.groupBlendMode, instructionSet);
    const rp = renderPipes;
    rp[this.renderPipeId].addRenderable(this, instructionSet);
    this.didViewUpdate = false;
    const children = this.children;
    const length = children.length;
    for (let i2 = 0; i2 < length; i2++) {
      children[i2].collectRenderables(instructionSet, renderer, currentLayer);
    }
    renderPipes.blendMode.popBlendMode(instructionSet);
  }
}
class Sprite extends ViewContainer {
  /**
   * @param options - The options for creating the sprite.
   */
  constructor(options = Texture.EMPTY) {
    if (options instanceof Texture) {
      options = { texture: options };
    }
    const { texture = Texture.EMPTY, anchor: anchor2, roundPixels, width, height, ...rest } = options;
    super({
      label: "Sprite",
      ...rest
    });
    this.renderPipeId = "sprite";
    this.batched = true;
    this._visualBounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };
    this._anchor = new ObservablePoint(
      {
        _onUpdate: () => {
          this.onViewUpdate();
        }
      }
    );
    if (anchor2) {
      this.anchor = anchor2;
    } else if (texture.defaultAnchor) {
      this.anchor = texture.defaultAnchor;
    }
    this.texture = texture;
    this.allowChildren = false;
    this.roundPixels = roundPixels ?? false;
    if (width !== void 0)
      this.width = width;
    if (height !== void 0)
      this.height = height;
  }
  /**
   * Creates a new sprite based on a source texture, image, video, or canvas element.
   * This is a convenience method that automatically creates and manages textures.
   * @example
   * ```ts
   * // Create from path or URL
   * const sprite = Sprite.from('assets/image.png');
   *
   * // Create from existing texture
   * const sprite = Sprite.from(texture);
   *
   * // Create from canvas
   * const canvas = document.createElement('canvas');
   * const sprite = Sprite.from(canvas, true); // Skip caching new texture
   * ```
   * @param source - The source to create the sprite from. Can be a path to an image, a texture,
   * or any valid texture source (canvas, video, etc.)
   * @param skipCache - Whether to skip adding to the texture cache when creating a new texture
   * @returns A new sprite based on the source
   * @see {@link Texture.from} For texture creation details
   * @see {@link Assets} For asset loading and management
   */
  static from(source2, skipCache = false) {
    if (source2 instanceof Texture) {
      return new Sprite(source2);
    }
    return new Sprite(Texture.from(source2, skipCache));
  }
  set texture(value2) {
    value2 || (value2 = Texture.EMPTY);
    const currentTexture = this._texture;
    if (currentTexture === value2)
      return;
    if (currentTexture && currentTexture.dynamic)
      currentTexture.off("update", this.onViewUpdate, this);
    if (value2.dynamic)
      value2.on("update", this.onViewUpdate, this);
    this._texture = value2;
    if (this._width) {
      this._setWidth(this._width, this._texture.orig.width);
    }
    if (this._height) {
      this._setHeight(this._height, this._texture.orig.height);
    }
    this.onViewUpdate();
  }
  /**
   * The texture that is displayed by the sprite. When changed, automatically updates
   * the sprite dimensions and manages texture event listeners.
   * @example
   * ```ts
   * // Create sprite with texture
   * const sprite = new Sprite({
   *     texture: Texture.from('sprite.png')
   * });
   *
   * // Update texture
   * sprite.texture = Texture.from('newSprite.png');
   *
   * // Use texture from spritesheet
   * const sheet = await Assets.load('spritesheet.json');
   * sprite.texture = sheet.textures['frame1.png'];
   *
   * // Reset to empty texture
   * sprite.texture = Texture.EMPTY;
   * ```
   * @see {@link Texture} For texture creation and management
   * @see {@link Assets} For asset loading
   */
  get texture() {
    return this._texture;
  }
  /**
   * The bounds of the sprite, taking into account the texture's trim area.
   * @example
   * ```ts
   * const texture = new Texture({
   *     source: new TextureSource({ width: 300, height: 300 }),
   *     frame: new Rectangle(196, 66, 58, 56),
   *     trim: new Rectangle(4, 4, 58, 56),
   *     orig: new Rectangle(0, 0, 64, 64),
   *     rotate: 2,
   * });
   * const sprite = new Sprite(texture);
   * const visualBounds = sprite.visualBounds;
   * // console.log(visualBounds); // { minX: -4, maxX: 62, minY: -4, maxY: 60 }
   */
  get visualBounds() {
    updateQuadBounds(this._visualBounds, this._anchor, this._texture);
    return this._visualBounds;
  }
  /**
   * @deprecated
   * @ignore
   */
  get sourceBounds() {
    deprecation("8.6.1", "Sprite.sourceBounds is deprecated, use visualBounds instead.");
    return this.visualBounds;
  }
  /** @private */
  updateBounds() {
    const anchor2 = this._anchor;
    const texture = this._texture;
    const bounds = this._bounds;
    const { width, height } = texture.orig;
    bounds.minX = -anchor2._x * width;
    bounds.maxX = bounds.minX + width;
    bounds.minY = -anchor2._y * height;
    bounds.maxY = bounds.minY + height;
  }
  /**
   * Destroys this sprite renderable and optionally its texture.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @example
   * sprite.destroy();
   * sprite.destroy(true);
   * sprite.destroy({ texture: true, textureSource: true });
   */
  destroy(options = false) {
    super.destroy(options);
    const destroyTexture = typeof options === "boolean" ? options : options == null ? void 0 : options.texture;
    if (destroyTexture) {
      const destroyTextureSource = typeof options === "boolean" ? options : options == null ? void 0 : options.textureSource;
      this._texture.destroy(destroyTextureSource);
    }
    this._texture = null;
    this._visualBounds = null;
    this._bounds = null;
    this._anchor = null;
    this._gpuData = null;
  }
  /**
   * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}
   * and passed to the constructor.
   *
   * - The default is `(0,0)`, this means the sprite's origin is the top left.
   * - Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.
   * - Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.
   *
   * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.
   * @example
   * ```ts
   * // Center the anchor point
   * sprite.anchor = 0.5; // Sets both x and y to 0.5
   * sprite.position.set(400, 300); // Sprite will be centered at this position
   *
   * // Set specific x/y anchor points
   * sprite.anchor = {
   *     x: 1, // Right edge
   *     y: 0  // Top edge
   * };
   *
   * // Using individual coordinates
   * sprite.anchor.set(0.5, 1); // Center-bottom
   *
   * // For rotation around center
   * sprite.anchor.set(0.5);
   * sprite.rotation = Math.PI / 4; // 45 degrees around center
   *
   * // For scaling from center
   * sprite.anchor.set(0.5);
   * sprite.scale.set(2); // Scales from center point
   * ```
   */
  get anchor() {
    return this._anchor;
  }
  set anchor(value2) {
    typeof value2 === "number" ? this._anchor.set(value2) : this._anchor.copyFrom(value2);
  }
  /**
   * The width of the sprite, setting this will actually modify the scale to achieve the value set.
   * @example
   * ```ts
   * // Set width directly
   * sprite.width = 200;
   * console.log(sprite.scale.x); // Scale adjusted to match width
   *
   * // Set width while preserving aspect ratio
   * const ratio = sprite.height / sprite.width;
   * sprite.width = 300;
   * sprite.height = 300 * ratio;
   *
   * // For better performance when setting both width and height
   * sprite.setSize(300, 400); // Avoids recalculating bounds twice
   *
   * // Reset to original texture size
   * sprite.width = sprite.texture.orig.width;
   * ```
   */
  get width() {
    return Math.abs(this.scale.x) * this._texture.orig.width;
  }
  set width(value2) {
    this._setWidth(value2, this._texture.orig.width);
    this._width = value2;
  }
  /**
   * The height of the sprite, setting this will actually modify the scale to achieve the value set.
   * @example
   * ```ts
   * // Set height directly
   * sprite.height = 150;
   * console.log(sprite.scale.y); // Scale adjusted to match height
   *
   * // Set height while preserving aspect ratio
   * const ratio = sprite.width / sprite.height;
   * sprite.height = 200;
   * sprite.width = 200 * ratio;
   *
   * // For better performance when setting both width and height
   * sprite.setSize(300, 400); // Avoids recalculating bounds twice
   *
   * // Reset to original texture size
   * sprite.height = sprite.texture.orig.height;
   * ```
   */
  get height() {
    return Math.abs(this.scale.y) * this._texture.orig.height;
  }
  set height(value2) {
    this._setHeight(value2, this._texture.orig.height);
    this._height = value2;
  }
  /**
   * Retrieves the size of the Sprite as a [Size]{@link Size} object based on the texture dimensions and scale.
   * This is faster than getting width and height separately as it only calculates the bounds once.
   * @example
   * ```ts
   * // Basic size retrieval
   * const sprite = new Sprite(Texture.from('sprite.png'));
   * const size = sprite.getSize();
   * console.log(`Size: ${size.width}x${size.height}`);
   *
   * // Reuse existing size object
   * const reuseSize = { width: 0, height: 0 };
   * sprite.getSize(reuseSize);
   * ```
   * @param out - Optional object to store the size in, to avoid allocating a new object
   * @returns The size of the Sprite
   * @see {@link Sprite#width} For getting just the width
   * @see {@link Sprite#height} For getting just the height
   * @see {@link Sprite#setSize} For setting both width and height
   */
  getSize(out2) {
    out2 || (out2 = {});
    out2.width = Math.abs(this.scale.x) * this._texture.orig.width;
    out2.height = Math.abs(this.scale.y) * this._texture.orig.height;
    return out2;
  }
  /**
   * Sets the size of the Sprite to the specified width and height.
   * This is faster than setting width and height separately as it only recalculates bounds once.
   * @example
   * ```ts
   * // Basic size setting
   * const sprite = new Sprite(Texture.from('sprite.png'));
   * sprite.setSize(100, 200); // Width: 100, Height: 200
   *
   * // Set uniform size
   * sprite.setSize(100); // Sets both width and height to 100
   *
   * // Set size with object
   * sprite.setSize({
   *     width: 200,
   *     height: 300
   * });
   *
   * // Reset to texture size
   * sprite.setSize(
   *     sprite.texture.orig.width,
   *     sprite.texture.orig.height
   * );
   * ```
   * @param value - This can be either a number or a {@link Size} object
   * @param height - The height to set. Defaults to the value of `width` if not provided
   * @see {@link Sprite#width} For setting width only
   * @see {@link Sprite#height} For setting height only
   * @see {@link Sprite#texture} For the source dimensions
   */
  setSize(value2, height) {
    if (typeof value2 === "object") {
      height = value2.height ?? value2.width;
      value2 = value2.width;
    } else {
      height ?? (height = value2);
    }
    value2 !== void 0 && this._setWidth(value2, this._texture.orig.width);
    height !== void 0 && this._setHeight(height, this._texture.orig.height);
  }
}
const tempBounds = new Bounds();
function addMaskBounds(mask, bounds, skipUpdateTransform) {
  const boundsToMask = tempBounds;
  mask.measurable = true;
  getGlobalBounds(mask, skipUpdateTransform, boundsToMask);
  bounds.addBoundsMask(boundsToMask);
  mask.measurable = false;
}
function addMaskLocalBounds(mask, bounds, localRoot) {
  const boundsToMask = boundsPool.get();
  mask.measurable = true;
  const tempMatrix2 = matrixPool.get().identity();
  const relativeMask = getMatrixRelativeToParent(mask, localRoot, tempMatrix2);
  getLocalBounds(mask, boundsToMask, relativeMask);
  mask.measurable = false;
  bounds.addBoundsMask(boundsToMask);
  matrixPool.return(tempMatrix2);
  boundsPool.return(boundsToMask);
}
function getMatrixRelativeToParent(target, root, matrix) {
  if (!target) {
    warn("Mask bounds, renderable is not inside the root container");
    return matrix;
  }
  if (target !== root) {
    getMatrixRelativeToParent(target.parent, root, matrix);
    target.updateLocalTransform();
    matrix.append(target.localTransform);
  }
  return matrix;
}
class AlphaMask {
  constructor(options) {
    this.priority = 0;
    this.inverse = false;
    this.pipe = "alphaMask";
    if (options == null ? void 0 : options.mask) {
      this.init(options.mask);
    }
  }
  init(mask) {
    this.mask = mask;
    this.renderMaskToTexture = !(mask instanceof Sprite);
    this.mask.renderable = this.renderMaskToTexture;
    this.mask.includeInBuild = !this.renderMaskToTexture;
    this.mask.measurable = false;
  }
  reset() {
    if (this.mask === null)
      return;
    this.mask.measurable = true;
    this.mask = null;
  }
  addBounds(bounds, skipUpdateTransform) {
    if (!this.inverse) {
      addMaskBounds(this.mask, bounds, skipUpdateTransform);
    }
  }
  addLocalBounds(bounds, localRoot) {
    addMaskLocalBounds(this.mask, bounds, localRoot);
  }
  containsPoint(point, hitTestFn) {
    const mask = this.mask;
    return hitTestFn(mask, point);
  }
  destroy() {
    this.reset();
  }
  static test(mask) {
    return mask instanceof Sprite;
  }
}
AlphaMask.extension = ExtensionType.MaskEffect;
class ColorMask {
  constructor(options) {
    this.priority = 0;
    this.pipe = "colorMask";
    if (options == null ? void 0 : options.mask) {
      this.init(options.mask);
    }
  }
  init(mask) {
    this.mask = mask;
  }
  destroy() {
  }
  static test(mask) {
    return typeof mask === "number";
  }
}
ColorMask.extension = ExtensionType.MaskEffect;
class StencilMask {
  constructor(options) {
    this.priority = 0;
    this.pipe = "stencilMask";
    if (options == null ? void 0 : options.mask) {
      this.init(options.mask);
    }
  }
  init(mask) {
    this.mask = mask;
    this.mask.includeInBuild = false;
    this.mask.measurable = false;
  }
  reset() {
    if (this.mask === null)
      return;
    this.mask.measurable = true;
    this.mask.includeInBuild = true;
    this.mask = null;
  }
  addBounds(bounds, skipUpdateTransform) {
    addMaskBounds(this.mask, bounds, skipUpdateTransform);
  }
  addLocalBounds(bounds, localRoot) {
    addMaskLocalBounds(this.mask, bounds, localRoot);
  }
  containsPoint(point, hitTestFn) {
    const mask = this.mask;
    return hitTestFn(mask, point);
  }
  destroy() {
    this.reset();
  }
  static test(mask) {
    return mask instanceof Container;
  }
}
StencilMask.extension = ExtensionType.MaskEffect;
const BrowserAdapter = {
  createCanvas: (width, height) => {
    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    return canvas;
  },
  createImage: () => new Image(),
  getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
  getWebGLRenderingContext: () => WebGLRenderingContext,
  getNavigator: () => navigator,
  getBaseUrl: () => document.baseURI ?? window.location.href,
  getFontFaceSet: () => document.fonts,
  fetch: (url, options) => fetch(url, options),
  parseXML: (xml) => {
    const parser = new DOMParser();
    return parser.parseFromString(xml, "text/xml");
  }
};
let currentAdapter = BrowserAdapter;
const DOMAdapter = {
  /**
   * Returns the current adapter.
   * @returns {environment.Adapter} The current adapter.
   */
  get() {
    return currentAdapter;
  },
  /**
   * Sets the current adapter.
   * @param adapter - The new adapter.
   */
  set(adapter) {
    currentAdapter = adapter;
  }
};
class CanvasSource extends TextureSource {
  constructor(options) {
    if (!options.resource) {
      options.resource = DOMAdapter.get().createCanvas();
    }
    if (!options.width) {
      options.width = options.resource.width;
      if (!options.autoDensity) {
        options.width /= options.resolution;
      }
    }
    if (!options.height) {
      options.height = options.resource.height;
      if (!options.autoDensity) {
        options.height /= options.resolution;
      }
    }
    super(options);
    this.uploadMethodId = "image";
    this.autoDensity = options.autoDensity;
    this.resizeCanvas();
    this.transparent = !!options.transparent;
  }
  resizeCanvas() {
    if (this.autoDensity && "style" in this.resource) {
      this.resource.style.width = `${this.width}px`;
      this.resource.style.height = `${this.height}px`;
    }
    if (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight) {
      this.resource.width = this.pixelWidth;
      this.resource.height = this.pixelHeight;
    }
  }
  resize(width = this.width, height = this.height, resolution2 = this._resolution) {
    const didResize = super.resize(width, height, resolution2);
    if (didResize) {
      this.resizeCanvas();
    }
    return didResize;
  }
  static test(resource) {
    return globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement || globalThis.OffscreenCanvas && resource instanceof OffscreenCanvas;
  }
  /**
   * Returns the 2D rendering context for the canvas.
   * Caches the context after creating it.
   * @returns The 2D rendering context of the canvas.
   */
  get context2D() {
    return this._context2D || (this._context2D = this.resource.getContext("2d"));
  }
}
CanvasSource.extension = ExtensionType.TextureSource;
class ImageSource extends TextureSource {
  constructor(options) {
    super(options);
    this.uploadMethodId = "image";
    this.autoGarbageCollect = true;
  }
  static test(resource) {
    return globalThis.HTMLImageElement && resource instanceof HTMLImageElement || typeof ImageBitmap !== "undefined" && resource instanceof ImageBitmap || globalThis.VideoFrame && resource instanceof VideoFrame;
  }
}
ImageSource.extension = ExtensionType.TextureSource;
var UPDATE_PRIORITY = /* @__PURE__ */ ((UPDATE_PRIORITY2) => {
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["INTERACTION"] = 50] = "INTERACTION";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["HIGH"] = 25] = "HIGH";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["NORMAL"] = 0] = "NORMAL";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["LOW"] = -25] = "LOW";
  UPDATE_PRIORITY2[UPDATE_PRIORITY2["UTILITY"] = -50] = "UTILITY";
  return UPDATE_PRIORITY2;
})(UPDATE_PRIORITY || {});
class TickerListener {
  /**
   * Constructor
   * @private
   * @param fn - The listener function to be added for one update
   * @param context - The listener context
   * @param priority - The priority for emitting
   * @param once - If the handler should fire once
   */
  constructor(fn, context2 = null, priority = 0, once = false) {
    this.next = null;
    this.previous = null;
    this._destroyed = false;
    this._fn = fn;
    this._context = context2;
    this.priority = priority;
    this._once = once;
  }
  /**
   * Simple compare function to figure out if a function and context match.
   * @param fn - The listener function to be added for one update
   * @param context - The listener context
   * @returns `true` if the listener match the arguments
   */
  match(fn, context2 = null) {
    return this._fn === fn && this._context === context2;
  }
  /**
   * Emit by calling the current function.
   * @param ticker - The ticker emitting.
   * @returns Next ticker
   */
  emit(ticker) {
    if (this._fn) {
      if (this._context) {
        this._fn.call(this._context, ticker);
      } else {
        this._fn(ticker);
      }
    }
    const redirect = this.next;
    if (this._once) {
      this.destroy(true);
    }
    if (this._destroyed) {
      this.next = null;
    }
    return redirect;
  }
  /**
   * Connect to the list.
   * @param previous - Input node, previous listener
   */
  connect(previous) {
    this.previous = previous;
    if (previous.next) {
      previous.next.previous = this;
    }
    this.next = previous.next;
    previous.next = this;
  }
  /**
   * Destroy and don't use after this.
   * @param hard - `true` to remove the `next` reference, this
   *        is considered a hard destroy. Soft destroy maintains the next reference.
   * @returns The listener to redirect while emitting or removing.
   */
  destroy(hard = false) {
    this._destroyed = true;
    this._fn = null;
    this._context = null;
    if (this.previous) {
      this.previous.next = this.next;
    }
    if (this.next) {
      this.next.previous = this.previous;
    }
    const redirect = this.next;
    this.next = hard ? null : redirect;
    this.previous = null;
    return redirect;
  }
}
const _Ticker = class _Ticker2 {
  constructor() {
    this.autoStart = false;
    this.deltaTime = 1;
    this.lastTime = -1;
    this.speed = 1;
    this.started = false;
    this._requestId = null;
    this._maxElapsedMS = 100;
    this._minElapsedMS = 0;
    this._protected = false;
    this._lastFrame = -1;
    this._head = new TickerListener(null, null, Infinity);
    this.deltaMS = 1 / _Ticker2.targetFPMS;
    this.elapsedMS = 1 / _Ticker2.targetFPMS;
    this._tick = (time) => {
      this._requestId = null;
      if (this.started) {
        this.update(time);
        if (this.started && this._requestId === null && this._head.next) {
          this._requestId = requestAnimationFrame(this._tick);
        }
      }
    };
  }
  /**
   * Conditionally requests a new animation frame.
   * If a frame has not already been requested, and if the internal
   * emitter has listeners, a new frame is requested.
   */
  _requestIfNeeded() {
    if (this._requestId === null && this._head.next) {
      this.lastTime = performance.now();
      this._lastFrame = this.lastTime;
      this._requestId = requestAnimationFrame(this._tick);
    }
  }
  /** Conditionally cancels a pending animation frame. */
  _cancelIfNeeded() {
    if (this._requestId !== null) {
      cancelAnimationFrame(this._requestId);
      this._requestId = null;
    }
  }
  /**
   * Conditionally requests a new animation frame.
   * If the ticker has been started it checks if a frame has not already
   * been requested, and if the internal emitter has listeners. If these
   * conditions are met, a new frame is requested. If the ticker has not
   * been started, but autoStart is `true`, then the ticker starts now,
   * and continues with the previous conditions to request a new frame.
   */
  _startIfPossible() {
    if (this.started) {
      this._requestIfNeeded();
    } else if (this.autoStart) {
      this.start();
    }
  }
  /**
   * Register a handler for tick events.
   * @param fn - The listener function to add. Receives the Ticker instance as parameter
   * @param context - The context for the listener
   * @param priority - The priority of the listener
   * @example
   * ```ts
   * // Access time properties through the ticker parameter
   * ticker.add((ticker) => {
   *     // Use deltaTime (dimensionless scalar) for frame-independent animations
   *     sprite.rotation += 0.1 * ticker.deltaTime;
   *
   *     // Use deltaMS (milliseconds) for time-based calculations
   *     const progress = ticker.deltaMS / animationDuration;
   *
   *     // Use elapsedMS for raw timing measurements
   *     console.log(`Raw frame time: ${ticker.elapsedMS}ms`);
   * });
   * ```
   */
  add(fn, context2, priority = UPDATE_PRIORITY.NORMAL) {
    return this._addListener(new TickerListener(fn, context2, priority));
  }
  /**
   * Add a handler for the tick event which is only executed once on the next frame.
   * @example
   * ```ts
   * // Basic one-time update
   * ticker.addOnce(() => {
   *     console.log('Runs next frame only');
   * });
   *
   * // With specific context
   * const game = {
   *     init(ticker) {
   *         this.loadResources();
   *         console.log('Game initialized');
   *     }
   * };
   * ticker.addOnce(game.init, game);
   *
   * // With priority
   * ticker.addOnce(
   *     () => {
   *         // High priority one-time setup
   *         physics.init();
   *     },
   *     undefined,
   *     UPDATE_PRIORITY.HIGH
   * );
   * ```
   * @param fn - The listener function to be added for one update
   * @param context - The listener context
   * @param priority - The priority for emitting (default: UPDATE_PRIORITY.NORMAL)
   * @returns This instance of a ticker
   * @see {@link Ticker#add} For continuous updates
   * @see {@link Ticker#remove} For removing handlers
   */
  addOnce(fn, context2, priority = UPDATE_PRIORITY.NORMAL) {
    return this._addListener(new TickerListener(fn, context2, priority, true));
  }
  /**
   * Internally adds the event handler so that it can be sorted by priority.
   * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run
   * before the rendering.
   * @private
   * @param listener - Current listener being added.
   * @returns This instance of a ticker
   */
  _addListener(listener) {
    let current = this._head.next;
    let previous = this._head;
    if (!current) {
      listener.connect(previous);
    } else {
      while (current) {
        if (listener.priority > current.priority) {
          listener.connect(previous);
          break;
        }
        previous = current;
        current = current.next;
      }
      if (!listener.previous) {
        listener.connect(previous);
      }
    }
    this._startIfPossible();
    return this;
  }
  /**
   * Removes any handlers matching the function and context parameters.
   * If no handlers are left after removing, then it cancels the animation frame.
   * @example
   * ```ts
   * // Basic removal
   * const onTick = () => {
   *     sprite.rotation += 0.1;
   * };
   * ticker.add(onTick);
   * ticker.remove(onTick);
   *
   * // Remove with context
   * const game = {
   *     update(ticker) {
   *         this.physics.update(ticker.deltaTime);
   *     }
   * };
   * ticker.add(game.update, game);
   * ticker.remove(game.update, game);
   *
   * // Remove all matching handlers
   * // (if same function was added multiple times)
   * ticker.add(onTick);
   * ticker.add(onTick);
   * ticker.remove(onTick); // Removes all instances
   * ```
   * @param fn - The listener function to be removed
   * @param context - The listener context to be removed
   * @returns This instance of a ticker
   * @see {@link Ticker#add} For adding handlers
   * @see {@link Ticker#addOnce} For one-time handlers
   */
  remove(fn, context2) {
    let listener = this._head.next;
    while (listener) {
      if (listener.match(fn, context2)) {
        listener = listener.destroy();
      } else {
        listener = listener.next;
      }
    }
    if (!this._head.next) {
      this._cancelIfNeeded();
    }
    return this;
  }
  /**
   * The number of listeners on this ticker, calculated by walking through linked list.
   * @example
   * ```ts
   * // Check number of active listeners
   * const ticker = new Ticker();
   * console.log(ticker.count); // 0
   *
   * // Add some listeners
   * ticker.add(() => {});
   * ticker.add(() => {});
   * console.log(ticker.count); // 2
   *
   * // Check after cleanup
   * ticker.destroy();
   * console.log(ticker.count); // 0
   * ```
   * @readonly
   * @see {@link Ticker#add} For adding listeners
   * @see {@link Ticker#remove} For removing listeners
   */
  get count() {
    if (!this._head) {
      return 0;
    }
    let count2 = 0;
    let current = this._head;
    while (current = current.next) {
      count2++;
    }
    return count2;
  }
  /**
   * Starts the ticker. If the ticker has listeners a new animation frame is requested at this point.
   * @example
   * ```ts
   * // Basic manual start
   * const ticker = new Ticker();
   * ticker.add(() => {
   *     // Animation code here
   * });
   * ticker.start();
   * ```
   * @see {@link Ticker#stop} For stopping the ticker
   * @see {@link Ticker#autoStart} For automatic starting
   * @see {@link Ticker#started} For checking ticker state
   */
  start() {
    if (!this.started) {
      this.started = true;
      this._requestIfNeeded();
    }
  }
  /**
   * Stops the ticker. If the ticker has requested an animation frame it is canceled at this point.
   * @example
   * ```ts
   * // Basic stop
   * const ticker = new Ticker();
   * ticker.stop();
   * ```
   * @see {@link Ticker#start} For starting the ticker
   * @see {@link Ticker#started} For checking ticker state
   * @see {@link Ticker#destroy} For cleaning up the ticker
   */
  stop() {
    if (this.started) {
      this.started = false;
      this._cancelIfNeeded();
    }
  }
  /**
   * Destroy the ticker and don't use after this. Calling this method removes all references to internal events.
   * @example
   * ```ts
   * // Clean up with active listeners
   * const ticker = new Ticker();
   * ticker.add(() => {});
   * ticker.destroy(); // Removes all listeners
   * ```
   * @see {@link Ticker#stop} For stopping without destroying
   * @see {@link Ticker#remove} For removing specific listeners
   */
  destroy() {
    if (!this._protected) {
      this.stop();
      let listener = this._head.next;
      while (listener) {
        listener = listener.destroy(true);
      }
      this._head.destroy();
      this._head = null;
    }
  }
  /**
   * Triggers an update.
   *
   * An update entails setting the
   * current {@link Ticker#elapsedMS|elapsedMS},
   * the current {@link Ticker#deltaTime|deltaTime},
   * invoking all listeners with current deltaTime,
   * and then finally setting {@link Ticker#lastTime|lastTime}
   * with the value of currentTime that was provided.
   *
   * This method will be called automatically by animation
   * frame callbacks if the ticker instance has been started
   * and listeners are added.
   * @example
   * ```ts
   * // Basic manual update
   * const ticker = new Ticker();
   * ticker.update(performance.now());
   * ```
   * @param currentTime - The current time of execution (defaults to performance.now())
   * @see {@link Ticker#deltaTime} For frame delta value
   * @see {@link Ticker#elapsedMS} For raw elapsed time
   */
  update(currentTime = performance.now()) {
    let elapsedMS;
    if (currentTime > this.lastTime) {
      elapsedMS = this.elapsedMS = currentTime - this.lastTime;
      if (elapsedMS > this._maxElapsedMS) {
        elapsedMS = this._maxElapsedMS;
      }
      elapsedMS *= this.speed;
      if (this._minElapsedMS) {
        const delta = currentTime - this._lastFrame | 0;
        if (delta < this._minElapsedMS) {
          return;
        }
        this._lastFrame = currentTime - delta % this._minElapsedMS;
      }
      this.deltaMS = elapsedMS;
      this.deltaTime = this.deltaMS * _Ticker2.targetFPMS;
      const head = this._head;
      let listener = head.next;
      while (listener) {
        listener = listener.emit(this);
      }
      if (!head.next) {
        this._cancelIfNeeded();
      }
    } else {
      this.deltaTime = this.deltaMS = this.elapsedMS = 0;
    }
    this.lastTime = currentTime;
  }
  /**
   * The frames per second at which this ticker is running.
   * The default is approximately 60 in most modern browsers.
   * > [!NOTE] This does not factor in the value of
   * > {@link Ticker#speed|speed}, which is specific
   * > to scaling {@link Ticker#deltaTime|deltaTime}.
   * @example
   * ```ts
   * // Basic FPS monitoring
   * ticker.add(() => {
   *     console.log(`Current FPS: ${Math.round(ticker.FPS)}`);
   * });
   * ```
   * @readonly
   */
  get FPS() {
    return 1e3 / this.elapsedMS;
  }
  /**
   * Manages the maximum amount of milliseconds allowed to
   * elapse between invoking {@link Ticker#update|update}.
   *
   * This value is used to cap {@link Ticker#deltaTime|deltaTime},
   * but does not effect the measured value of {@link Ticker#FPS|FPS}.
   *
   * When setting this property it is clamped to a value between
   * `0` and `Ticker.targetFPMS * 1000`.
   * @example
   * ```ts
   * // Set minimum acceptable frame rate
   * const ticker = new Ticker();
   * ticker.minFPS = 30; // Never go below 30 FPS
   *
   * // Use with maxFPS for frame rate clamping
   * ticker.minFPS = 30;
   * ticker.maxFPS = 60;
   *
   * // Monitor delta capping
   * ticker.add(() => {
   *     // Delta time will be capped based on minFPS
   *     console.log(`Delta time: ${ticker.deltaTime}`);
   * });
   * ```
   * @default 10
   */
  get minFPS() {
    return 1e3 / this._maxElapsedMS;
  }
  set minFPS(fps) {
    const minFPS = Math.min(this.maxFPS, fps);
    const minFPMS = Math.min(Math.max(0, minFPS) / 1e3, _Ticker2.targetFPMS);
    this._maxElapsedMS = 1 / minFPMS;
  }
  /**
   * Manages the minimum amount of milliseconds required to
   * elapse between invoking {@link Ticker#update|update}.
   *
   * This will effect the measured value of {@link Ticker#FPS|FPS}.
   *
   * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.
   * Otherwise it will be at least `minFPS`
   * @example
   * ```ts
   * // Set minimum acceptable frame rate
   * const ticker = new Ticker();
   * ticker.maxFPS = 60; // Never go above 60 FPS
   *
   * // Use with maxFPS for frame rate clamping
   * ticker.minFPS = 30;
   * ticker.maxFPS = 60;
   *
   * // Monitor delta capping
   * ticker.add(() => {
   *     // Delta time will be capped based on maxFPS
   *     console.log(`Delta time: ${ticker.deltaTime}`);
   * });
   * ```
   * @default 0
   */
  get maxFPS() {
    if (this._minElapsedMS) {
      return Math.round(1e3 / this._minElapsedMS);
    }
    return 0;
  }
  set maxFPS(fps) {
    if (fps === 0) {
      this._minElapsedMS = 0;
    } else {
      const maxFPS = Math.max(this.minFPS, fps);
      this._minElapsedMS = 1 / (maxFPS / 1e3);
    }
  }
  /**
   * The shared ticker instance used by {@link AnimatedSprite} and by
   * {@link VideoSource} to update animation frames / video textures.
   *
   * It may also be used by {@link Application} if created with the `sharedTicker` option property set to true.
   *
   * The property {@link Ticker#autoStart|autoStart} is set to `true` for this instance.
   * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.
   * @example
   * import { Ticker } from 'pixi.js';
   *
   * const ticker = Ticker.shared;
   * // Set this to prevent starting this ticker when listeners are added.
   * // By default this is true only for the Ticker.shared instance.
   * ticker.autoStart = false;
   *
   * // FYI, call this to ensure the ticker is stopped. It should be stopped
   * // if you have not attempted to render anything yet.
   * ticker.stop();
   *
   * // Call this when you are ready for a running shared ticker.
   * ticker.start();
   * @example
   * import { autoDetectRenderer, Container } from 'pixi.js';
   *
   * // You may use the shared ticker to render...
   * const renderer = autoDetectRenderer();
   * const stage = new Container();
   * document.body.appendChild(renderer.view);
   * ticker.add((time) => renderer.render(stage));
   *
   * // Or you can just update it manually.
   * ticker.autoStart = false;
   * ticker.stop();
   * const animate = (time) => {
   *     ticker.update(time);
   *     renderer.render(stage);
   *     requestAnimationFrame(animate);
   * };
   * animate(performance.now());
   * @type {Ticker}
   * @readonly
   */
  static get shared() {
    if (!_Ticker2._shared) {
      const shared = _Ticker2._shared = new _Ticker2();
      shared.autoStart = true;
      shared._protected = true;
    }
    return _Ticker2._shared;
  }
  /**
   * The system ticker instance used by {@link PrepareBase} for core timing
   * functionality that shouldn't usually need to be paused, unlike the `shared`
   * ticker which drives visual animations and rendering which may want to be paused.
   *
   * The property {@link Ticker#autoStart|autoStart} is set to `true` for this instance.
   * @type {Ticker}
   * @readonly
   * @advanced
   */
  static get system() {
    if (!_Ticker2._system) {
      const system = _Ticker2._system = new _Ticker2();
      system.autoStart = true;
      system._protected = true;
    }
    return _Ticker2._system;
  }
};
_Ticker.targetFPMS = 0.06;
let Ticker = _Ticker;
let promise;
async function detectVideoAlphaMode() {
  promise ?? (promise = (async () => {
    var _a;
    const canvas = DOMAdapter.get().createCanvas(1, 1);
    const gl = canvas.getContext("webgl");
    if (!gl) {
      return "premultiply-alpha-on-upload";
    }
    const video = await new Promise((resolve) => {
      const video2 = document.createElement("video");
      video2.onloadeddata = () => resolve(video2);
      video2.onerror = () => resolve(null);
      video2.autoplay = false;
      video2.crossOrigin = "anonymous";
      video2.preload = "auto";
      video2.src = "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=";
      video2.load();
    });
    if (!video) {
      return "premultiply-alpha-on-upload";
    }
    const texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    const framebuffer = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
    gl.framebufferTexture2D(
      gl.FRAMEBUFFER,
      gl.COLOR_ATTACHMENT0,
      gl.TEXTURE_2D,
      texture,
      0
    );
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);
    const pixel = new Uint8Array(4);
    gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);
    gl.deleteFramebuffer(framebuffer);
    gl.deleteTexture(texture);
    (_a = gl.getExtension("WEBGL_lose_context")) == null ? void 0 : _a.loseContext();
    return pixel[0] <= pixel[3] ? "premultiplied-alpha" : "premultiply-alpha-on-upload";
  })());
  return promise;
}
const _VideoSource = class _VideoSource2 extends TextureSource {
  constructor(options) {
    super(options);
    this.isReady = false;
    this.uploadMethodId = "video";
    options = {
      ..._VideoSource2.defaultOptions,
      ...options
    };
    this._autoUpdate = true;
    this._isConnectedToTicker = false;
    this._updateFPS = options.updateFPS || 0;
    this._msToNextUpdate = 0;
    this.autoPlay = options.autoPlay !== false;
    this.alphaMode = options.alphaMode ?? "premultiply-alpha-on-upload";
    this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this);
    this._videoFrameRequestCallbackHandle = null;
    this._load = null;
    this._resolve = null;
    this._reject = null;
    this._onCanPlay = this._onCanPlay.bind(this);
    this._onCanPlayThrough = this._onCanPlayThrough.bind(this);
    this._onError = this._onError.bind(this);
    this._onPlayStart = this._onPlayStart.bind(this);
    this._onPlayStop = this._onPlayStop.bind(this);
    this._onSeeked = this._onSeeked.bind(this);
    if (options.autoLoad !== false) {
      void this.load();
    }
  }
  /** Update the video frame if the source is not destroyed and meets certain conditions. */
  updateFrame() {
    if (this.destroyed) {
      return;
    }
    if (this._updateFPS) {
      const elapsedMS = Ticker.shared.elapsedMS * this.resource.playbackRate;
      this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);
    }
    if (!this._updateFPS || this._msToNextUpdate <= 0) {
      this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0;
    }
    if (this.isValid) {
      this.update();
    }
  }
  /** Callback to update the video frame and potentially request the next frame update. */
  _videoFrameRequestCallback() {
    this.updateFrame();
    if (this.destroyed) {
      this._videoFrameRequestCallbackHandle = null;
    } else {
      this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(
        this._videoFrameRequestCallback
      );
    }
  }
  /**
   * Checks if the resource has valid dimensions.
   * @returns {boolean} True if width and height are set, otherwise false.
   */
  get isValid() {
    return !!this.resource.videoWidth && !!this.resource.videoHeight;
  }
  /**
   * Start preloading the video resource.
   * @returns {Promise<this>} Handle the validate event
   */
  async load() {
    if (this._load) {
      return this._load;
    }
    const source2 = this.resource;
    const options = this.options;
    if ((source2.readyState === source2.HAVE_ENOUGH_DATA || source2.readyState === source2.HAVE_FUTURE_DATA) && source2.width && source2.height) {
      source2.complete = true;
    }
    source2.addEventListener("play", this._onPlayStart);
    source2.addEventListener("pause", this._onPlayStop);
    source2.addEventListener("seeked", this._onSeeked);
    if (!this._isSourceReady()) {
      if (!options.preload) {
        source2.addEventListener("canplay", this._onCanPlay);
      }
      source2.addEventListener("canplaythrough", this._onCanPlayThrough);
      source2.addEventListener("error", this._onError, true);
    } else {
      this._mediaReady();
    }
    this.alphaMode = await detectVideoAlphaMode();
    this._load = new Promise((resolve, reject) => {
      if (this.isValid) {
        resolve(this);
      } else {
        this._resolve = resolve;
        this._reject = reject;
        if (options.preloadTimeoutMs !== void 0) {
          this._preloadTimeout = setTimeout(() => {
            this._onError(new ErrorEvent(`Preload exceeded timeout of ${options.preloadTimeoutMs}ms`));
          });
        }
        source2.load();
      }
    });
    return this._load;
  }
  /**
   * Handle video error events.
   * @param event - The error event
   */
  _onError(event) {
    this.resource.removeEventListener("error", this._onError, true);
    this.emit("error", event);
    if (this._reject) {
      this._reject(event);
      this._reject = null;
      this._resolve = null;
    }
  }
  /**
   * Checks if the underlying source is playing.
   * @returns True if playing.
   */
  _isSourcePlaying() {
    const source2 = this.resource;
    return !source2.paused && !source2.ended;
  }
  /**
   * Checks if the underlying source is ready for playing.
   * @returns True if ready.
   */
  _isSourceReady() {
    const source2 = this.resource;
    return source2.readyState > 2;
  }
  /** Runs the update loop when the video is ready to play. */
  _onPlayStart() {
    if (!this.isValid) {
      this._mediaReady();
    }
    this._configureAutoUpdate();
  }
  /** Stops the update loop when a pause event is triggered. */
  _onPlayStop() {
    this._configureAutoUpdate();
  }
  /** Handles behavior when the video completes seeking to the current playback position. */
  _onSeeked() {
    if (this._autoUpdate && !this._isSourcePlaying()) {
      this._msToNextUpdate = 0;
      this.updateFrame();
      this._msToNextUpdate = 0;
    }
  }
  _onCanPlay() {
    const source2 = this.resource;
    source2.removeEventListener("canplay", this._onCanPlay);
    this._mediaReady();
  }
  _onCanPlayThrough() {
    const source2 = this.resource;
    source2.removeEventListener("canplaythrough", this._onCanPlay);
    if (this._preloadTimeout) {
      clearTimeout(this._preloadTimeout);
      this._preloadTimeout = void 0;
    }
    this._mediaReady();
  }
  /** Fired when the video is loaded and ready to play. */
  _mediaReady() {
    const source2 = this.resource;
    if (this.isValid) {
      this.isReady = true;
      this.resize(source2.videoWidth, source2.videoHeight);
    }
    this._msToNextUpdate = 0;
    this.updateFrame();
    this._msToNextUpdate = 0;
    if (this._resolve) {
      this._resolve(this);
      this._resolve = null;
      this._reject = null;
    }
    if (this._isSourcePlaying()) {
      this._onPlayStart();
    } else if (this.autoPlay) {
      void this.resource.play();
    }
  }
  /** Cleans up resources and event listeners associated with this texture. */
  destroy() {
    this._configureAutoUpdate();
    const source2 = this.resource;
    if (source2) {
      source2.removeEventListener("play", this._onPlayStart);
      source2.removeEventListener("pause", this._onPlayStop);
      source2.removeEventListener("seeked", this._onSeeked);
      source2.removeEventListener("canplay", this._onCanPlay);
      source2.removeEventListener("canplaythrough", this._onCanPlayThrough);
      source2.removeEventListener("error", this._onError, true);
      source2.pause();
      source2.src = "";
      source2.load();
    }
    super.destroy();
  }
  /** Should the base texture automatically update itself, set to true by default. */
  get autoUpdate() {
    return this._autoUpdate;
  }
  set autoUpdate(value2) {
    if (value2 !== this._autoUpdate) {
      this._autoUpdate = value2;
      this._configureAutoUpdate();
    }
  }
  /**
   * How many times a second to update the texture from the video.
   * Leave at 0 to update at every render.
   * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.
   */
  get updateFPS() {
    return this._updateFPS;
  }
  set updateFPS(value2) {
    if (value2 !== this._updateFPS) {
      this._updateFPS = value2;
      this._configureAutoUpdate();
    }
  }
  /**
   * Configures the updating mechanism based on the current state and settings.
   *
   * This method decides between using the browser's native video frame callback or a custom ticker
   * for updating the video frame. It ensures optimal performance and responsiveness
   * based on the video's state, playback status, and the desired frames-per-second setting.
   *
   * - If `_autoUpdate` is enabled and the video source is playing:
   *   - It will prefer the native video frame callback if available and no specific FPS is set.
   *   - Otherwise, it will use a custom ticker for manual updates.
   * - If `_autoUpdate` is disabled or the video isn't playing, any active update mechanisms are halted.
   */
  _configureAutoUpdate() {
    if (this._autoUpdate && this._isSourcePlaying()) {
      if (!this._updateFPS && this.resource.requestVideoFrameCallback) {
        if (this._isConnectedToTicker) {
          Ticker.shared.remove(this.updateFrame, this);
          this._isConnectedToTicker = false;
          this._msToNextUpdate = 0;
        }
        if (this._videoFrameRequestCallbackHandle === null) {
          this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(
            this._videoFrameRequestCallback
          );
        }
      } else {
        if (this._videoFrameRequestCallbackHandle !== null) {
          this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);
          this._videoFrameRequestCallbackHandle = null;
        }
        if (!this._isConnectedToTicker) {
          Ticker.shared.add(this.updateFrame, this);
          this._isConnectedToTicker = true;
          this._msToNextUpdate = 0;
        }
      }
    } else {
      if (this._videoFrameRequestCallbackHandle !== null) {
        this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);
        this._videoFrameRequestCallbackHandle = null;
      }
      if (this._isConnectedToTicker) {
        Ticker.shared.remove(this.updateFrame, this);
        this._isConnectedToTicker = false;
        this._msToNextUpdate = 0;
      }
    }
  }
  static test(resource) {
    return globalThis.HTMLVideoElement && resource instanceof HTMLVideoElement;
  }
};
_VideoSource.extension = ExtensionType.TextureSource;
_VideoSource.defaultOptions = {
  ...TextureSource.defaultOptions,
  /** If true, the video will start loading immediately. */
  autoLoad: true,
  /** If true, the video will start playing as soon as it is loaded. */
  autoPlay: true,
  /** The number of times a second to update the texture from the video. Leave at 0 to update at every render. */
  updateFPS: 0,
  /** If true, the video will be loaded with the `crossorigin` attribute. */
  crossorigin: true,
  /** If true, the video will loop when it ends. */
  loop: false,
  /** If true, the video will be muted. */
  muted: true,
  /** If true, the video will play inline. */
  playsinline: true,
  /** If true, the video will be preloaded. */
  preload: false
};
_VideoSource.MIME_TYPES = {
  ogv: "video/ogg",
  mov: "video/quicktime",
  m4v: "video/mp4"
};
let VideoSource = _VideoSource;
const convertToList = (input, transform, forceTransform = false) => {
  if (!Array.isArray(input)) {
    input = [input];
  }
  if (!transform) {
    return input;
  }
  return input.map((item) => {
    if (typeof item === "string" || forceTransform) {
      return transform(item);
    }
    return item;
  });
};
class CacheClass {
  constructor() {
    this._parsers = [];
    this._cache = /* @__PURE__ */ new Map();
    this._cacheMap = /* @__PURE__ */ new Map();
  }
  /** Clear all entries. */
  reset() {
    this._cacheMap.clear();
    this._cache.clear();
  }
  /**
   * Check if the key exists
   * @param key - The key to check
   */
  has(key2) {
    return this._cache.has(key2);
  }
  /**
   * Fetch entry by key
   * @param key - The key of the entry to get
   */
  get(key2) {
    const result = this._cache.get(key2);
    if (!result) {
      warn(`[Assets] Asset id ${key2} was not found in the Cache`);
    }
    return result;
  }
  /**
   * Set a value by key or keys name
   * @param key - The key or keys to set
   * @param value - The value to store in the cache or from which cacheable assets will be derived.
   */
  set(key2, value2) {
    const keys = convertToList(key2);
    let cacheableAssets;
    for (let i2 = 0; i2 < this.parsers.length; i2++) {
      const parser = this.parsers[i2];
      if (parser.test(value2)) {
        cacheableAssets = parser.getCacheableAssets(keys, value2);
        break;
      }
    }
    const cacheableMap = new Map(Object.entries(cacheableAssets || {}));
    if (!cacheableAssets) {
      keys.forEach((key22) => {
        cacheableMap.set(key22, value2);
      });
    }
    const cacheKeys = [...cacheableMap.keys()];
    const cachedAssets = {
      cacheKeys,
      keys
    };
    keys.forEach((key22) => {
      this._cacheMap.set(key22, cachedAssets);
    });
    cacheKeys.forEach((key22) => {
      const val = cacheableAssets ? cacheableAssets[key22] : value2;
      if (this._cache.has(key22) && this._cache.get(key22) !== val) {
        warn("[Cache] already has key:", key22);
      }
      this._cache.set(key22, cacheableMap.get(key22));
    });
  }
  /**
   * Remove entry by key
   *
   * This function will also remove any associated alias from the cache also.
   * @param key - The key of the entry to remove
   */
  remove(key2) {
    if (!this._cacheMap.has(key2)) {
      warn(`[Assets] Asset id ${key2} was not found in the Cache`);
      return;
    }
    const cacheMap2 = this._cacheMap.get(key2);
    const cacheKeys = cacheMap2.cacheKeys;
    cacheKeys.forEach((key22) => {
      this._cache.delete(key22);
    });
    cacheMap2.keys.forEach((key22) => {
      this._cacheMap.delete(key22);
    });
  }
  /**
   * All loader parsers registered
   * @advanced
   */
  get parsers() {
    return this._parsers;
  }
}
const Cache = new CacheClass();
const sources = [];
extensions.handleByList(ExtensionType.TextureSource, sources);
function textureSourceFrom(options = {}) {
  const hasResource = options && options.resource;
  const res = hasResource ? options.resource : options;
  const opts = hasResource ? options : { resource: options };
  for (let i2 = 0; i2 < sources.length; i2++) {
    const Source = sources[i2];
    if (Source.test(res)) {
      return new Source(opts);
    }
  }
  throw new Error(`Could not find a source type for resource: ${opts.resource}`);
}
function resourceToTexture(options = {}, skipCache = false) {
  const hasResource = options && options.resource;
  const resource = hasResource ? options.resource : options;
  const opts = hasResource ? options : { resource: options };
  if (!skipCache && Cache.has(resource)) {
    return Cache.get(resource);
  }
  const texture = new Texture({ source: textureSourceFrom(opts) });
  texture.on("destroy", () => {
    if (Cache.has(resource)) {
      Cache.remove(resource);
    }
  });
  if (!skipCache) {
    Cache.set(resource, texture);
  }
  return texture;
}
function textureFrom(id2, skipCache = false) {
  if (typeof id2 === "string") {
    return Cache.get(id2);
  } else if (id2 instanceof TextureSource) {
    return new Texture({ source: id2 });
  }
  return resourceToTexture(id2, skipCache);
}
Texture.from = textureFrom;
TextureSource.from = textureSourceFrom;
extensions.add(AlphaMask, ColorMask, StencilMask, VideoSource, ImageSource, CanvasSource, BufferImageSource);
var LoaderParserPriority = /* @__PURE__ */ ((LoaderParserPriority2) => {
  LoaderParserPriority2[LoaderParserPriority2["Low"] = 0] = "Low";
  LoaderParserPriority2[LoaderParserPriority2["Normal"] = 1] = "Normal";
  LoaderParserPriority2[LoaderParserPriority2["High"] = 2] = "High";
  return LoaderParserPriority2;
})(LoaderParserPriority || {});
function assertPath(path2) {
  if (typeof path2 !== "string") {
    throw new TypeError(`Path must be a string. Received ${JSON.stringify(path2)}`);
  }
}
function removeUrlParams(url) {
  const re = url.split("?")[0];
  return re.split("#")[0];
}
function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function replaceAll(str, find, replace) {
  return str.replace(new RegExp(escapeRegExp(find), "g"), replace);
}
function normalizeStringPosix(path2, allowAboveRoot) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let code = -1;
  for (let i2 = 0; i2 <= path2.length; ++i2) {
    if (i2 < path2.length) {
      code = path2.charCodeAt(i2);
    } else if (code === 47) {
      break;
    } else {
      code = 47;
    }
    if (code === 47) {
      if (lastSlash === i2 - 1 || dots === 1) ;
      else if (lastSlash !== i2 - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf("/");
            if (lastSlashIndex !== res.length - 1) {
              if (lastSlashIndex === -1) {
                res = "";
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
              }
              lastSlash = i2;
              dots = 0;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = i2;
            dots = 0;
            continue;
          }
        }
      } else {
        if (res.length > 0) {
          res += `/${path2.slice(lastSlash + 1, i2)}`;
        } else {
          res = path2.slice(lastSlash + 1, i2);
        }
        lastSegmentLength = i2 - lastSlash - 1;
      }
      lastSlash = i2;
      dots = 0;
    } else if (code === 46 && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
const path = {
  /**
   * Converts a path to posix format.
   * @param path - The path to convert to posix
   * @example
   * ```ts
   * // Convert a Windows path to POSIX format
   * path.toPosix('C:\\Users\\User\\Documents\\file.txt');
   * // -> 'C:/Users/User/Documents/file.txt'
   * ```
   */
  toPosix(path2) {
    return replaceAll(path2, "\\", "/");
  },
  /**
   * Checks if the path is a URL e.g. http://, https://
   * @param path - The path to check
   * @example
   * ```ts
   * // Check if a path is a URL
   * path.isUrl('http://www.example.com');
   * // -> true
   * path.isUrl('C:/Users/User/Documents/file.txt');
   * // -> false
   * ```
   */
  isUrl(path2) {
    return /^https?:/.test(this.toPosix(path2));
  },
  /**
   * Checks if the path is a data URL
   * @param path - The path to check
   * @example
   * ```ts
   * // Check if a path is a data URL
   * path.isDataUrl('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUA...');
   * // -> true
   * ```
   */
  isDataUrl(path2) {
    return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(path2);
  },
  /**
   * Checks if the path is a blob URL
   * @param path - The path to check
   * @example
   * ```ts
   * // Check if a path is a blob URL
   * path.isBlobUrl('blob:http://www.example.com/12345678-1234-1234-1234-123456789012');
   * // -> true
   * ```
   */
  isBlobUrl(path2) {
    return path2.startsWith("blob:");
  },
  /**
   * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/
   * This will return true for windows file paths
   * @param path - The path to check
   * @example
   * ```ts
   * // Check if a path has a protocol
   * path.hasProtocol('http://www.example.com');
   * // -> true
   * path.hasProtocol('C:/Users/User/Documents/file.txt');
   * // -> true
   * ```
   */
  hasProtocol(path2) {
    return /^[^/:]+:/.test(this.toPosix(path2));
  },
  /**
   * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/
   * @param path - The path to get the protocol from
   * @example
   * ```ts
   * // Get the protocol from a URL
   * path.getProtocol('http://www.example.com/path/to/resource');
   * // -> 'http://'
   * // Get the protocol from a file path
   * path.getProtocol('C:/Users/User/Documents/file.txt');
   * // -> 'C:/'
   * ```
   */
  getProtocol(path2) {
    assertPath(path2);
    path2 = this.toPosix(path2);
    const matchFile = /^file:\/\/\//.exec(path2);
    if (matchFile) {
      return matchFile[0];
    }
    const matchProtocol = /^[^/:]+:\/{0,2}/.exec(path2);
    if (matchProtocol) {
      return matchProtocol[0];
    }
    return "";
  },
  /**
   * Converts URL to an absolute path.
   * When loading from a Web Worker, we must use absolute paths.
   * If the URL is already absolute we return it as is
   * If it's not, we convert it
   * @param url - The URL to test
   * @param customBaseUrl - The base URL to use
   * @param customRootUrl - The root URL to use
   * @example
   * ```ts
   * // Convert a relative URL to an absolute path
   * path.toAbsolute('images/texture.png', 'http://example.com/assets/');
   * // -> 'http://example.com/assets/images/texture.png'
   * ```
   */
  toAbsolute(url, customBaseUrl, customRootUrl) {
    assertPath(url);
    if (this.isDataUrl(url) || this.isBlobUrl(url))
      return url;
    const baseUrl = removeUrlParams(this.toPosix(customBaseUrl ?? DOMAdapter.get().getBaseUrl()));
    const rootUrl = removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(baseUrl)));
    url = this.toPosix(url);
    if (url.startsWith("/")) {
      return path.join(rootUrl, url.slice(1));
    }
    const absolutePath = this.isAbsolute(url) ? url : this.join(baseUrl, url);
    return absolutePath;
  },
  /**
   * Normalizes the given path, resolving '..' and '.' segments
   * @param path - The path to normalize
   * @example
   * ```ts
   * // Normalize a path with relative segments
   * path.normalize('http://www.example.com/foo/bar/../baz');
   * // -> 'http://www.example.com/foo/baz'
   * // Normalize a file path with relative segments
   * path.normalize('C:\\Users\\User\\Documents\\..\\file.txt');
   * // -> 'C:/Users/User/file.txt'
   * ```
   */
  normalize(path2) {
    assertPath(path2);
    if (path2.length === 0)
      return ".";
    if (this.isDataUrl(path2) || this.isBlobUrl(path2))
      return path2;
    path2 = this.toPosix(path2);
    let protocol = "";
    const isAbsolute = path2.startsWith("/");
    if (this.hasProtocol(path2)) {
      protocol = this.rootname(path2);
      path2 = path2.slice(protocol.length);
    }
    const trailingSeparator = path2.endsWith("/");
    path2 = normalizeStringPosix(path2);
    if (path2.length > 0 && trailingSeparator)
      path2 += "/";
    if (isAbsolute)
      return `/${path2}`;
    return protocol + path2;
  },
  /**
   * Determines if path is an absolute path.
   * Absolute paths can be urls, data urls, or paths on disk
   * @param path - The path to test
   * @example
   * ```ts
   * // Check if a path is absolute
   * path.isAbsolute('http://www.example.com/foo/bar');
   * // -> true
   * path.isAbsolute('C:/Users/User/Documents/file.txt');
   * // -> true
   * ```
   */
  isAbsolute(path2) {
    assertPath(path2);
    path2 = this.toPosix(path2);
    if (this.hasProtocol(path2))
      return true;
    return path2.startsWith("/");
  },
  /**
   * Joins all given path segments together using the platform-specific separator as a delimiter,
   * then normalizes the resulting path
   * @param segments - The segments of the path to join
   * @example
   * ```ts
   * // Join multiple path segments
   * path.join('assets', 'images', 'sprite.png');
   * // -> 'assets/images/sprite.png'
   * // Join with relative segments
   * path.join('assets', 'images', '../textures', 'sprite.png');
   * // -> 'assets/textures/sprite.png'
   * ```
   */
  join(...segments) {
    if (segments.length === 0) {
      return ".";
    }
    let joined;
    for (let i2 = 0; i2 < segments.length; ++i2) {
      const arg = segments[i2];
      assertPath(arg);
      if (arg.length > 0) {
        if (joined === void 0)
          joined = arg;
        else {
          const prevArg = segments[i2 - 1] ?? "";
          if (this.joinExtensions.includes(this.extname(prevArg).toLowerCase())) {
            joined += `/../${arg}`;
          } else {
            joined += `/${arg}`;
          }
        }
      }
    }
    if (joined === void 0) {
      return ".";
    }
    return this.normalize(joined);
  },
  /**
   * Returns the directory name of a path
   * @param path - The path to parse
   * @example
   * ```ts
   * // Get the directory name of a path
   * path.dirname('http://www.example.com/foo/bar/baz.png');
   * // -> 'http://www.example.com/foo/bar'
   * // Get the directory name of a file path
   * path.dirname('C:/Users/User/Documents/file.txt');
   * // -> 'C:/Users/User/Documents'
   * ```
   */
  dirname(path2) {
    assertPath(path2);
    if (path2.length === 0)
      return ".";
    path2 = this.toPosix(path2);
    let code = path2.charCodeAt(0);
    const hasRoot = code === 47;
    let end = -1;
    let matchedSlash = true;
    const proto = this.getProtocol(path2);
    const origpath = path2;
    path2 = path2.slice(proto.length);
    for (let i2 = path2.length - 1; i2 >= 1; --i2) {
      code = path2.charCodeAt(i2);
      if (code === 47) {
        if (!matchedSlash) {
          end = i2;
          break;
        }
      } else {
        matchedSlash = false;
      }
    }
    if (end === -1)
      return hasRoot ? "/" : this.isUrl(origpath) ? proto + path2 : proto;
    if (hasRoot && end === 1)
      return "//";
    return proto + path2.slice(0, end);
  },
  /**
   * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/
   * @param path - The path to parse
   * @example
   * ```ts
   * // Get the root of a URL
   * path.rootname('http://www.example.com/foo/bar/baz.png');
   * // -> 'http://www.example.com/'
   * // Get the root of a file path
   * path.rootname('C:/Users/User/Documents/file.txt');
   * // -> 'C:/'
   * ```
   */
  rootname(path2) {
    assertPath(path2);
    path2 = this.toPosix(path2);
    let root = "";
    if (path2.startsWith("/"))
      root = "/";
    else {
      root = this.getProtocol(path2);
    }
    if (this.isUrl(path2)) {
      const index = path2.indexOf("/", root.length);
      if (index !== -1) {
        root = path2.slice(0, index);
      } else
        root = path2;
      if (!root.endsWith("/"))
        root += "/";
    }
    return root;
  },
  /**
   * Returns the last portion of a path
   * @param path - The path to test
   * @param ext - Optional extension to remove
   * @example
   * ```ts
   * // Get the basename of a URL
   * path.basename('http://www.example.com/foo/bar/baz.png');
   * // -> 'baz.png'
   * // Get the basename of a file path
   * path.basename('C:/Users/User/Documents/file.txt');
   * // -> 'file.txt'
   * ```
   */
  basename(path2, ext) {
    assertPath(path2);
    if (ext)
      assertPath(ext);
    path2 = removeUrlParams(this.toPosix(path2));
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i2;
    if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {
      if (ext.length === path2.length && ext === path2)
        return "";
      let extIdx = ext.length - 1;
      let firstNonSlashEnd = -1;
      for (i2 = path2.length - 1; i2 >= 0; --i2) {
        const code = path2.charCodeAt(i2);
        if (code === 47) {
          if (!matchedSlash) {
            start = i2 + 1;
            break;
          }
        } else {
          if (firstNonSlashEnd === -1) {
            matchedSlash = false;
            firstNonSlashEnd = i2 + 1;
          }
          if (extIdx >= 0) {
            if (code === ext.charCodeAt(extIdx)) {
              if (--extIdx === -1) {
                end = i2;
              }
            } else {
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }
      if (start === end)
        end = firstNonSlashEnd;
      else if (end === -1)
        end = path2.length;
      return path2.slice(start, end);
    }
    for (i2 = path2.length - 1; i2 >= 0; --i2) {
      if (path2.charCodeAt(i2) === 47) {
        if (!matchedSlash) {
          start = i2 + 1;
          break;
        }
      } else if (end === -1) {
        matchedSlash = false;
        end = i2 + 1;
      }
    }
    if (end === -1)
      return "";
    return path2.slice(start, end);
  },
  /**
   * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last
   * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than
   * the first character of the basename of path, an empty string is returned.
   * @param path - The path to parse
   * @example
   * ```ts
   * // Get the extension of a URL
   * path.extname('http://www.example.com/foo/bar/baz.png');
   * // -> '.png'
   * // Get the extension of a file path
   * path.extname('C:/Users/User/Documents/file.txt');
   * // -> '.txt'
   * ```
   */
  extname(path2) {
    assertPath(path2);
    path2 = removeUrlParams(this.toPosix(path2));
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for (let i2 = path2.length - 1; i2 >= 0; --i2) {
      const code = path2.charCodeAt(i2);
      if (code === 47) {
        if (!matchedSlash) {
          startPart = i2 + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        matchedSlash = false;
        end = i2 + 1;
      }
      if (code === 46) {
        if (startDot === -1)
          startDot = i2;
        else if (preDotState !== 1)
          preDotState = 1;
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      return "";
    }
    return path2.slice(startDot, end);
  },
  /**
   * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.
   * @param path - The path to parse
   * @example
   * ```ts
   * // Parse a URL
   * const parsed = path.parse('http://www.example.com/foo/bar/baz.png');
   * // -> {
   * //   root: 'http://www.example.com/',
   * //   dir: 'http://www.example.com/foo/bar',
   * //   base: 'baz.png',
   * //   ext: '.png',
   * //   name: 'baz'
   * // }
   * // Parse a file path
   * const parsedFile = path.parse('C:/Users/User/Documents/file.txt');
   * // -> {
   * //   root: 'C:/',
   * //   dir: 'C:/Users/User/Documents',
   * //   base: 'file.txt',
   * //   ext: '.txt',
   * //   name: 'file'
   * // }
   * ```
   */
  parse(path2) {
    assertPath(path2);
    const ret = { root: "", dir: "", base: "", ext: "", name: "" };
    if (path2.length === 0)
      return ret;
    path2 = removeUrlParams(this.toPosix(path2));
    let code = path2.charCodeAt(0);
    const isAbsolute = this.isAbsolute(path2);
    let start;
    ret.root = this.rootname(path2);
    if (isAbsolute || this.hasProtocol(path2)) {
      start = 1;
    } else {
      start = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i2 = path2.length - 1;
    let preDotState = 0;
    for (; i2 >= start; --i2) {
      code = path2.charCodeAt(i2);
      if (code === 47) {
        if (!matchedSlash) {
          startPart = i2 + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        matchedSlash = false;
        end = i2 + 1;
      }
      if (code === 46) {
        if (startDot === -1)
          startDot = i2;
        else if (preDotState !== 1)
          preDotState = 1;
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      if (end !== -1) {
        if (startPart === 0 && isAbsolute)
          ret.base = ret.name = path2.slice(1, end);
        else
          ret.base = ret.name = path2.slice(startPart, end);
      }
    } else {
      if (startPart === 0 && isAbsolute) {
        ret.name = path2.slice(1, startDot);
        ret.base = path2.slice(1, end);
      } else {
        ret.name = path2.slice(startPart, startDot);
        ret.base = path2.slice(startPart, end);
      }
      ret.ext = path2.slice(startDot, end);
    }
    ret.dir = this.dirname(path2);
    return ret;
  },
  sep: "/",
  delimiter: ":",
  joinExtensions: [".html"]
};
function processX(base, ids, depth2, result, tags2) {
  const id2 = ids[depth2];
  for (let i2 = 0; i2 < id2.length; i2++) {
    const value2 = id2[i2];
    if (depth2 < ids.length - 1) {
      processX(base.replace(result[depth2], value2), ids, depth2 + 1, result, tags2);
    } else {
      tags2.push(base.replace(result[depth2], value2));
    }
  }
}
function createStringVariations(string) {
  const regex = /\{(.*?)\}/g;
  const result = string.match(regex);
  const tags2 = [];
  if (result) {
    const ids = [];
    result.forEach((vars) => {
      const split = vars.substring(1, vars.length - 1).split(",");
      ids.push(split);
    });
    processX(string, ids, 0, result, tags2);
  } else {
    tags2.push(string);
  }
  return tags2;
}
const isSingleItem = (item) => !Array.isArray(item);
class Resolver {
  constructor() {
    this._defaultBundleIdentifierOptions = {
      connector: "-",
      createBundleAssetId: (bundleId, assetId) => `${bundleId}${this._bundleIdConnector}${assetId}`,
      extractAssetIdFromBundle: (bundleId, assetBundleId) => assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, "")
    };
    this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector;
    this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId;
    this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;
    this._assetMap = {};
    this._preferredOrder = [];
    this._parsers = [];
    this._resolverHash = {};
    this._bundles = {};
  }
  /**
   * Override how the resolver deals with generating bundle ids.
   * must be called before any bundles are added
   * @param bundleIdentifier - the bundle identifier options
   */
  setBundleIdentifier(bundleIdentifier) {
    this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;
    this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;
    this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;
    if (this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar") {
      throw new Error("[Resolver] GenerateBundleAssetId are not working correctly");
    }
  }
  /**
   * Let the resolver know which assets you prefer to use when resolving assets.
   * Multiple prefer user defined rules can be added.
   * @example
   * resolver.prefer({
   *     // first look for something with the correct format, and then then correct resolution
   *     priority: ['format', 'resolution'],
   *     params:{
   *         format:'webp', // prefer webp images
   *         resolution: 2, // prefer a resolution of 2
   *     }
   * })
   * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);
   * resolver.resolveUrl('foo') // => 'bar@2x.webp'
   * @param preferOrders - the prefer options
   */
  prefer(...preferOrders) {
    preferOrders.forEach((prefer) => {
      this._preferredOrder.push(prefer);
      if (!prefer.priority) {
        prefer.priority = Object.keys(prefer.params);
      }
    });
    this._resolverHash = {};
  }
  /**
   * Set the base path to prepend to all urls when resolving
   * @example
   * resolver.basePath = 'https://home.com/';
   * resolver.add('foo', 'bar.ong');
   * resolver.resolveUrl('foo', 'bar.png'); // => 'https://home.com/bar.png'
   * @param basePath - the base path to use
   */
  set basePath(basePath) {
    this._basePath = basePath;
  }
  get basePath() {
    return this._basePath;
  }
  /**
   * Set the root path for root-relative URLs. By default the `basePath`'s root is used. If no `basePath` is set, then the
   * default value for browsers is `window.location.origin`
   * @example
   * // Application hosted on https://home.com/some-path/index.html
   * resolver.basePath = 'https://home.com/some-path/';
   * resolver.rootPath = 'https://home.com/';
   * resolver.add('foo', '/bar.png');
   * resolver.resolveUrl('foo', '/bar.png'); // => 'https://home.com/bar.png'
   * @param rootPath - the root path to use
   */
  set rootPath(rootPath) {
    this._rootPath = rootPath;
  }
  get rootPath() {
    return this._rootPath;
  }
  /**
   * All the active URL parsers that help the parser to extract information and create
   * an asset object-based on parsing the URL itself.
   *
   * Can be added using the extensions API
   * @example
   * resolver.add('foo', [
   *     {
   *         resolution: 2,
   *         format: 'png',
   *         src: 'image@2x.png',
   *     },
   *     {
   *         resolution:1,
   *         format:'png',
   *         src: 'image.png',
   *     },
   * ]);
   *
   * // With a url parser the information such as resolution and file format could extracted from the url itself:
   * extensions.add({
   *     extension: ExtensionType.ResolveParser,
   *     test: loadTextures.test, // test if url ends in an image
   *     parse: (value: string) =>
   *     ({
   *         resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),
   *         format: value.split('.').pop(),
   *         src: value,
   *     }),
   * });
   *
   * // Now resolution and format can be extracted from the url
   * resolver.add('foo', [
   *     'image@2x.png',
   *     'image.png',
   * ]);
   */
  get parsers() {
    return this._parsers;
  }
  /** Used for testing, this resets the resolver to its initial state */
  reset() {
    this.setBundleIdentifier(this._defaultBundleIdentifierOptions);
    this._assetMap = {};
    this._preferredOrder = [];
    this._resolverHash = {};
    this._rootPath = null;
    this._basePath = null;
    this._manifest = null;
    this._bundles = {};
    this._defaultSearchParams = null;
  }
  /**
   * Sets the default URL search parameters for the URL resolver. The urls can be specified as a string or an object.
   * @param searchParams - the default url parameters to append when resolving urls
   */
  setDefaultSearchParams(searchParams) {
    if (typeof searchParams === "string") {
      this._defaultSearchParams = searchParams;
    } else {
      const queryValues = searchParams;
      this._defaultSearchParams = Object.keys(queryValues).map((key2) => `${encodeURIComponent(key2)}=${encodeURIComponent(queryValues[key2])}`).join("&");
    }
  }
  /**
   * Returns the aliases for a given asset
   * @param asset - the asset to get the aliases for
   */
  getAlias(asset) {
    const { alias, src } = asset;
    const aliasesToUse = convertToList(
      alias || src,
      (value2) => {
        if (typeof value2 === "string")
          return value2;
        if (Array.isArray(value2))
          return value2.map((v2) => (v2 == null ? void 0 : v2.src) ?? v2);
        if (value2 == null ? void 0 : value2.src)
          return value2.src;
        return value2;
      },
      true
    );
    return aliasesToUse;
  }
  /**
   * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.
   * generally a manifest would be built using a tool.
   * @param manifest - the manifest to add to the resolver
   */
  addManifest(manifest) {
    if (this._manifest) {
      warn("[Resolver] Manifest already exists, this will be overwritten");
    }
    this._manifest = manifest;
    manifest.bundles.forEach((bundle) => {
      this.addBundle(bundle.name, bundle.assets);
    });
  }
  /**
   * This adds a bundle of assets in one go so that you can resolve them as a group.
   * For example you could add a bundle for each screen in you pixi app
   * @example
   * resolver.addBundle('animals', [
   *  { alias: 'bunny', src: 'bunny.png' },
   *  { alias: 'chicken', src: 'chicken.png' },
   *  { alias: 'thumper', src: 'thumper.png' },
   * ]);
   * // or
   * resolver.addBundle('animals', {
   *     bunny: 'bunny.png',
   *     chicken: 'chicken.png',
   *     thumper: 'thumper.png',
   * });
   *
   * const resolvedAssets = await resolver.resolveBundle('animals');
   * @param bundleId - The id of the bundle to add
   * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key
   */
  addBundle(bundleId, assets) {
    const assetNames = [];
    let convertedAssets = assets;
    if (!Array.isArray(assets)) {
      convertedAssets = Object.entries(assets).map(([alias, src]) => {
        if (typeof src === "string" || Array.isArray(src)) {
          return { alias, src };
        }
        return { alias, ...src };
      });
    }
    convertedAssets.forEach((asset) => {
      const srcs = asset.src;
      const aliases = asset.alias;
      let ids;
      if (typeof aliases === "string") {
        const bundleAssetId = this._createBundleAssetId(bundleId, aliases);
        assetNames.push(bundleAssetId);
        ids = [aliases, bundleAssetId];
      } else {
        const bundleIds = aliases.map((name2) => this._createBundleAssetId(bundleId, name2));
        assetNames.push(...bundleIds);
        ids = [...aliases, ...bundleIds];
      }
      this.add({
        ...asset,
        ...{
          alias: ids,
          src: srcs
        }
      });
    });
    this._bundles[bundleId] = assetNames;
  }
  /**
   * Tells the resolver what keys are associated with witch asset.
   * The most important thing the resolver does
   * @example
   * // Single key, single asset:
   * resolver.add({alias: 'foo', src: 'bar.png');
   * resolver.resolveUrl('foo') // => 'bar.png'
   *
   * // Multiple keys, single asset:
   * resolver.add({alias: ['foo', 'boo'], src: 'bar.png'});
   * resolver.resolveUrl('foo') // => 'bar.png'
   * resolver.resolveUrl('boo') // => 'bar.png'
   *
   * // Multiple keys, multiple assets:
   * resolver.add({alias: ['foo', 'boo'], src: ['bar.png', 'bar.webp']});
   * resolver.resolveUrl('foo') // => 'bar.png'
   *
   * // Add custom data attached to the resolver
   * Resolver.add({
   *     alias: 'bunnyBooBooSmooth',
   *     src: 'bunny{png,webp}',
   *     data: { scaleMode:SCALE_MODES.NEAREST }, // Base texture options
   * });
   *
   * resolver.resolve('bunnyBooBooSmooth') // => { src: 'bunny.png', data: { scaleMode: SCALE_MODES.NEAREST } }
   * @param aliases - the UnresolvedAsset or array of UnresolvedAssets to add to the resolver
   */
  add(aliases) {
    const assets = [];
    if (Array.isArray(aliases)) {
      assets.push(...aliases);
    } else {
      assets.push(aliases);
    }
    let keyCheck;
    keyCheck = (key2) => {
      if (this.hasKey(key2)) {
        warn(`[Resolver] already has key: ${key2} overwriting`);
      }
    };
    const assetArray = convertToList(assets);
    assetArray.forEach((asset) => {
      const { src } = asset;
      let {
        data,
        format,
        loadParser: userDefinedLoadParser,
        parser: userDefinedParser
      } = asset;
      const srcsToUse = convertToList(src).map((src2) => {
        if (typeof src2 === "string") {
          return createStringVariations(src2);
        }
        return Array.isArray(src2) ? src2 : [src2];
      });
      const aliasesToUse = this.getAlias(asset);
      Array.isArray(aliasesToUse) ? aliasesToUse.forEach(keyCheck) : keyCheck(aliasesToUse);
      const resolvedAssets = [];
      const parseUrl = (url) => {
        const parser = this._parsers.find((p2) => p2.test(url));
        return {
          ...parser == null ? void 0 : parser.parse(url),
          src: url
        };
      };
      srcsToUse.forEach((srcs) => {
        srcs.forEach((src2) => {
          let formattedAsset = {};
          if (typeof src2 !== "object") {
            formattedAsset = parseUrl(src2);
          } else {
            data = src2.data ?? data;
            format = src2.format ?? format;
            if (src2.loadParser || src2.parser) {
              userDefinedLoadParser = src2.loadParser ?? userDefinedLoadParser;
              userDefinedParser = src2.parser ?? userDefinedParser;
            }
            formattedAsset = {
              ...parseUrl(src2.src),
              ...src2
            };
          }
          if (!aliasesToUse) {
            throw new Error(`[Resolver] alias is undefined for this asset: ${formattedAsset.src}`);
          }
          formattedAsset = this._buildResolvedAsset(formattedAsset, {
            aliases: aliasesToUse,
            data,
            format,
            loadParser: userDefinedLoadParser,
            parser: userDefinedParser,
            progressSize: asset.progressSize
          });
          resolvedAssets.push(formattedAsset);
        });
      });
      aliasesToUse.forEach((alias) => {
        this._assetMap[alias] = resolvedAssets;
      });
    });
  }
  // TODO: this needs an overload like load did in Assets
  /**
   * If the resolver has had a manifest set via setManifest, this will return the assets urls for
   * a given bundleId or bundleIds.
   * @example
   * // Manifest Example
   * const manifest = {
   *     bundles: [
   *         {
   *             name: 'load-screen',
   *             assets: [
   *                 {
   *                     alias: 'background',
   *                     src: 'sunset.png',
   *                 },
   *                 {
   *                     alias: 'bar',
   *                     src: 'load-bar.{png,webp}',
   *                 },
   *             ],
   *         },
   *         {
   *             name: 'game-screen',
   *             assets: [
   *                 {
   *                     alias: 'character',
   *                     src: 'robot.png',
   *                 },
   *                 {
   *                     alias: 'enemy',
   *                     src: 'bad-guy.png',
   *                 },
   *             ],
   *         },
   *     ]
   * };
   *
   * resolver.setManifest(manifest);
   * const resolved = resolver.resolveBundle('load-screen');
   * @param bundleIds - The bundle ids to resolve
   * @returns All the bundles assets or a hash of assets for each bundle specified
   */
  resolveBundle(bundleIds) {
    const singleAsset = isSingleItem(bundleIds);
    bundleIds = convertToList(bundleIds);
    const out2 = {};
    bundleIds.forEach((bundleId) => {
      const assetNames = this._bundles[bundleId];
      if (assetNames) {
        const results = this.resolve(assetNames);
        const assets = {};
        for (const key2 in results) {
          const asset = results[key2];
          assets[this._extractAssetIdFromBundle(bundleId, key2)] = asset;
        }
        out2[bundleId] = assets;
      }
    });
    return singleAsset ? out2[bundleIds[0]] : out2;
  }
  /**
   * Does exactly what resolve does, but returns just the URL rather than the whole asset object
   * @param key - The key or keys to resolve
   * @returns - The URLs associated with the key(s)
   */
  resolveUrl(key2) {
    const result = this.resolve(key2);
    if (typeof key2 !== "string") {
      const out2 = {};
      for (const i2 in result) {
        out2[i2] = result[i2].src;
      }
      return out2;
    }
    return result.src;
  }
  resolve(keys) {
    const singleAsset = isSingleItem(keys);
    keys = convertToList(keys);
    const result = {};
    keys.forEach((key2) => {
      if (!this._resolverHash[key2]) {
        if (this._assetMap[key2]) {
          let assets = this._assetMap[key2];
          const preferredOrder = this._getPreferredOrder(assets);
          preferredOrder == null ? void 0 : preferredOrder.priority.forEach((priorityKey) => {
            preferredOrder.params[priorityKey].forEach((value2) => {
              const filteredAssets = assets.filter((asset) => {
                if (asset[priorityKey]) {
                  return asset[priorityKey] === value2;
                }
                return false;
              });
              if (filteredAssets.length) {
                assets = filteredAssets;
              }
            });
          });
          this._resolverHash[key2] = assets[0];
        } else {
          this._resolverHash[key2] = this._buildResolvedAsset({
            alias: [key2],
            src: key2
          }, {});
        }
      }
      result[key2] = this._resolverHash[key2];
    });
    return singleAsset ? result[keys[0]] : result;
  }
  /**
   * Checks if an asset with a given key exists in the resolver
   * @param key - The key of the asset
   */
  hasKey(key2) {
    return !!this._assetMap[key2];
  }
  /**
   * Checks if a bundle with the given key exists in the resolver
   * @param key - The key of the bundle
   */
  hasBundle(key2) {
    return !!this._bundles[key2];
  }
  /**
   * Internal function for figuring out what prefer criteria an asset should use.
   * @param assets
   */
  _getPreferredOrder(assets) {
    for (let i2 = 0; i2 < assets.length; i2++) {
      const asset = assets[i2];
      const preferred = this._preferredOrder.find((preference) => preference.params.format.includes(asset.format));
      if (preferred) {
        return preferred;
      }
    }
    return this._preferredOrder[0];
  }
  /**
   * Appends the default url parameters to the url
   * @param url - The url to append the default parameters to
   * @returns - The url with the default parameters appended
   */
  _appendDefaultSearchParams(url) {
    if (!this._defaultSearchParams)
      return url;
    const paramConnector = /\?/.test(url) ? "&" : "?";
    return `${url}${paramConnector}${this._defaultSearchParams}`;
  }
  _buildResolvedAsset(formattedAsset, data) {
    const { aliases, data: assetData, loadParser, parser, format, progressSize } = data;
    if (this._basePath || this._rootPath) {
      formattedAsset.src = path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);
    }
    formattedAsset.alias = aliases ?? formattedAsset.alias ?? [formattedAsset.src];
    formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);
    formattedAsset.data = { ...assetData || {}, ...formattedAsset.data };
    formattedAsset.loadParser = loadParser ?? formattedAsset.loadParser;
    formattedAsset.parser = parser ?? formattedAsset.parser;
    formattedAsset.format = format ?? formattedAsset.format ?? getUrlExtension(formattedAsset.src);
    if (progressSize !== void 0) {
      formattedAsset.progressSize = progressSize;
    }
    return formattedAsset;
  }
}
Resolver.RETINA_PREFIX = /@([0-9\.]+)x/;
function getUrlExtension(url) {
  return url.split(".").pop().split("?").shift().split("#").shift();
}
const copySearchParams = (targetUrl, sourceUrl) => {
  const searchParams = sourceUrl.split("?")[1];
  if (searchParams) {
    targetUrl += `?${searchParams}`;
  }
  return targetUrl;
};
const _Spritesheet = class _Spritesheet2 {
  constructor(optionsOrTexture, arg1) {
    this.linkedSheets = [];
    let options = optionsOrTexture;
    if ((optionsOrTexture == null ? void 0 : optionsOrTexture.source) instanceof TextureSource) {
      options = {
        texture: optionsOrTexture,
        data: arg1
      };
    }
    const { texture, data, cachePrefix = "" } = options;
    this.cachePrefix = cachePrefix;
    this._texture = texture instanceof Texture ? texture : null;
    this.textureSource = texture.source;
    this.textures = {};
    this.animations = {};
    this.data = data;
    const metaResolution = parseFloat(data.meta.scale);
    if (metaResolution) {
      this.resolution = metaResolution;
      texture.source.resolution = this.resolution;
    } else {
      this.resolution = texture.source._resolution;
    }
    this._frames = this.data.frames;
    this._frameKeys = Object.keys(this._frames);
    this._batchIndex = 0;
    this._callback = null;
  }
  /**
   * Parser spritesheet from loaded data. This is done asynchronously
   * to prevent creating too many Texture within a single process.
   */
  parse() {
    return new Promise((resolve) => {
      this._callback = resolve;
      this._batchIndex = 0;
      if (this._frameKeys.length <= _Spritesheet2.BATCH_SIZE) {
        this._processFrames(0);
        this._processAnimations();
        this._parseComplete();
      } else {
        this._nextBatch();
      }
    });
  }
  /**
   * Process a batch of frames
   * @param initialFrameIndex - The index of frame to start.
   */
  _processFrames(initialFrameIndex) {
    let frameIndex = initialFrameIndex;
    const maxFrames = _Spritesheet2.BATCH_SIZE;
    while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {
      const i2 = this._frameKeys[frameIndex];
      const data = this._frames[i2];
      const rect = data.frame;
      if (rect) {
        let frame = null;
        let trim = null;
        const sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;
        const orig = new Rectangle(
          0,
          0,
          Math.floor(sourceSize.w) / this.resolution,
          Math.floor(sourceSize.h) / this.resolution
        );
        if (data.rotated) {
          frame = new Rectangle(
            Math.floor(rect.x) / this.resolution,
            Math.floor(rect.y) / this.resolution,
            Math.floor(rect.h) / this.resolution,
            Math.floor(rect.w) / this.resolution
          );
        } else {
          frame = new Rectangle(
            Math.floor(rect.x) / this.resolution,
            Math.floor(rect.y) / this.resolution,
            Math.floor(rect.w) / this.resolution,
            Math.floor(rect.h) / this.resolution
          );
        }
        if (data.trimmed !== false && data.spriteSourceSize) {
          trim = new Rectangle(
            Math.floor(data.spriteSourceSize.x) / this.resolution,
            Math.floor(data.spriteSourceSize.y) / this.resolution,
            Math.floor(rect.w) / this.resolution,
            Math.floor(rect.h) / this.resolution
          );
        }
        this.textures[i2] = new Texture({
          source: this.textureSource,
          frame,
          orig,
          trim,
          rotate: data.rotated ? 2 : 0,
          defaultAnchor: data.anchor,
          defaultBorders: data.borders,
          label: i2.toString()
        });
      }
      frameIndex++;
    }
  }
  /** Parse animations config. */
  _processAnimations() {
    const animations = this.data.animations || {};
    for (const animName in animations) {
      this.animations[animName] = [];
      for (let i2 = 0; i2 < animations[animName].length; i2++) {
        const frameName = animations[animName][i2];
        this.animations[animName].push(this.textures[frameName]);
      }
    }
  }
  /** The parse has completed. */
  _parseComplete() {
    const callback = this._callback;
    this._callback = null;
    this._batchIndex = 0;
    callback.call(this, this.textures);
  }
  /** Begin the next batch of textures. */
  _nextBatch() {
    this._processFrames(this._batchIndex * _Spritesheet2.BATCH_SIZE);
    this._batchIndex++;
    setTimeout(() => {
      if (this._batchIndex * _Spritesheet2.BATCH_SIZE < this._frameKeys.length) {
        this._nextBatch();
      } else {
        this._processAnimations();
        this._parseComplete();
      }
    }, 0);
  }
  /**
   * Destroy Spritesheet and don't use after this.
   * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well
   */
  destroy(destroyBase = false) {
    var _a;
    for (const i2 in this.textures) {
      this.textures[i2].destroy();
    }
    this._frames = null;
    this._frameKeys = null;
    this.data = null;
    this.textures = null;
    if (destroyBase) {
      (_a = this._texture) == null ? void 0 : _a.destroy();
      this.textureSource.destroy();
    }
    this._texture = null;
    this.textureSource = null;
    this.linkedSheets = [];
  }
};
_Spritesheet.BATCH_SIZE = 1e3;
let Spritesheet = _Spritesheet;
const validImages = [
  "jpg",
  "png",
  "jpeg",
  "avif",
  "webp",
  "basis",
  "etc2",
  "bc7",
  "bc6h",
  "bc5",
  "bc4",
  "bc3",
  "bc2",
  "bc1",
  "eac",
  "astc"
];
function getCacheableAssets(keys, asset, ignoreMultiPack) {
  const out2 = {};
  keys.forEach((key2) => {
    out2[key2] = asset;
  });
  Object.keys(asset.textures).forEach((key2) => {
    out2[`${asset.cachePrefix}${key2}`] = asset.textures[key2];
  });
  if (!ignoreMultiPack) {
    const basePath = path.dirname(keys[0]);
    asset.linkedSheets.forEach((item, i2) => {
      const out22 = getCacheableAssets([`${basePath}/${asset.data.meta.related_multi_packs[i2]}`], item, true);
      Object.assign(out2, out22);
    });
  }
  return out2;
}
const spritesheetAsset = {
  extension: ExtensionType.Asset,
  /** Handle the caching of the related Spritesheet Textures */
  cache: {
    test: (asset) => asset instanceof Spritesheet,
    getCacheableAssets: (keys, asset) => getCacheableAssets(keys, asset, false)
  },
  /** Resolve the resolution of the asset. */
  resolver: {
    extension: {
      type: ExtensionType.ResolveParser,
      name: "resolveSpritesheet"
    },
    test: (value2) => {
      const tempURL = value2.split("?")[0];
      const split = tempURL.split(".");
      const extension = split.pop();
      const format = split.pop();
      return extension === "json" && validImages.includes(format);
    },
    parse: (value2) => {
      var _a;
      const split = value2.split(".");
      return {
        resolution: parseFloat(((_a = Resolver.RETINA_PREFIX.exec(value2)) == null ? void 0 : _a[1]) ?? "1"),
        format: split[split.length - 2],
        src: value2
      };
    }
  },
  /**
   * Loader plugin that parses sprite sheets!
   * once the JSON has been loaded this checks to see if the JSON is spritesheet data.
   * If it is, we load the spritesheets image and parse the data into Spritesheet
   * All textures in the sprite sheet are then added to the cache
   */
  loader: {
    /** used for deprecation purposes */
    name: "spritesheetLoader",
    id: "spritesheet",
    extension: {
      type: ExtensionType.LoadParser,
      priority: LoaderParserPriority.Normal,
      name: "spritesheetLoader"
    },
    async testParse(asset, options) {
      return path.extname(options.src).toLowerCase() === ".json" && !!asset.frames;
    },
    async parse(asset, options, loader) {
      var _a, _b;
      const {
        texture: imageTexture,
        // if user need to use preloaded texture
        imageFilename,
        // if user need to use custom filename (not from jsonFile.meta.image)
        textureOptions,
        // if user need to set texture options on texture
        cachePrefix
        // if user need to use custom cache prefix
      } = (options == null ? void 0 : options.data) ?? {};
      let basePath = path.dirname(options.src);
      if (basePath && basePath.lastIndexOf("/") !== basePath.length - 1) {
        basePath += "/";
      }
      let texture;
      if (imageTexture instanceof Texture) {
        texture = imageTexture;
      } else {
        const imagePath = copySearchParams(basePath + (imageFilename ?? asset.meta.image), options.src);
        const assets = await loader.load([{ src: imagePath, data: textureOptions }]);
        texture = assets[imagePath];
      }
      const spritesheet = new Spritesheet({
        texture: texture.source,
        data: asset,
        cachePrefix
      });
      await spritesheet.parse();
      const multiPacks = (_a = asset == null ? void 0 : asset.meta) == null ? void 0 : _a.related_multi_packs;
      if (Array.isArray(multiPacks)) {
        const promises = [];
        for (const item of multiPacks) {
          if (typeof item !== "string") {
            continue;
          }
          let itemUrl = basePath + item;
          if ((_b = options.data) == null ? void 0 : _b.ignoreMultiPack) {
            continue;
          }
          itemUrl = copySearchParams(itemUrl, options.src);
          promises.push(loader.load({
            src: itemUrl,
            data: {
              textureOptions,
              ignoreMultiPack: true
            }
          }));
        }
        const res = await Promise.all(promises);
        spritesheet.linkedSheets = res;
        res.forEach((item) => {
          item.linkedSheets = [spritesheet].concat(spritesheet.linkedSheets.filter((sp) => sp !== item));
        });
      }
      return spritesheet;
    },
    async unload(spritesheet, _resolvedAsset, loader) {
      await loader.unload(spritesheet.textureSource._sourceOrigin);
      spritesheet.destroy(false);
    }
  }
};
extensions.add(spritesheetAsset);
const idCounts = /* @__PURE__ */ Object.create(null);
const idHash = /* @__PURE__ */ Object.create(null);
function createIdFromString(value2, groupId) {
  let id2 = idHash[value2];
  if (id2 === void 0) {
    if (idCounts[groupId] === void 0) {
      idCounts[groupId] = 1;
    }
    idHash[value2] = id2 = idCounts[groupId]++;
  }
  return id2;
}
let context;
function getTestContext() {
  if (!context || (context == null ? void 0 : context.isContextLost())) {
    const canvas = DOMAdapter.get().createCanvas();
    context = canvas.getContext("webgl", {});
  }
  return context;
}
let maxFragmentPrecision;
function getMaxFragmentPrecision() {
  if (!maxFragmentPrecision) {
    maxFragmentPrecision = "mediump";
    const gl = getTestContext();
    if (gl) {
      if (gl.getShaderPrecisionFormat) {
        const shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
        maxFragmentPrecision = shaderFragment.precision ? "highp" : "mediump";
      }
    }
  }
  return maxFragmentPrecision;
}
function addProgramDefines(src, isES300, isFragment) {
  if (isES300)
    return src;
  if (isFragment) {
    src = src.replace("out vec4 finalColor;", "");
    return `

        #ifdef GL_ES // This checks if it is WebGL1
        #define in varying
        #define finalColor gl_FragColor
        #define texture texture2D
        #endif
        ${src}
        `;
  }
  return `

        #ifdef GL_ES // This checks if it is WebGL1
        #define in attribute
        #define out varying
        #endif
        ${src}
        `;
}
function ensurePrecision(src, options, isFragment) {
  const maxSupportedPrecision = isFragment ? options.maxSupportedFragmentPrecision : options.maxSupportedVertexPrecision;
  if (src.substring(0, 9) !== "precision") {
    let precision = isFragment ? options.requestedFragmentPrecision : options.requestedVertexPrecision;
    if (precision === "highp" && maxSupportedPrecision !== "highp") {
      precision = "mediump";
    }
    return `precision ${precision} float;
${src}`;
  } else if (maxSupportedPrecision !== "highp" && src.substring(0, 15) === "precision highp") {
    return src.replace("precision highp", "precision mediump");
  }
  return src;
}
function insertVersion(src, isES300) {
  if (!isES300)
    return src;
  return `#version 300 es
${src}`;
}
const fragmentNameCache = {};
const VertexNameCache = {};
function setProgramName(src, { name: name2 = `pixi-program` }, isFragment = true) {
  name2 = name2.replace(/\s+/g, "-");
  name2 += isFragment ? "-fragment" : "-vertex";
  const nameCache = isFragment ? fragmentNameCache : VertexNameCache;
  if (nameCache[name2]) {
    nameCache[name2]++;
    name2 += `-${nameCache[name2]}`;
  } else {
    nameCache[name2] = 1;
  }
  if (src.indexOf("#define SHADER_NAME") !== -1)
    return src;
  const shaderName = `#define SHADER_NAME ${name2}`;
  return `${shaderName}
${src}`;
}
function stripVersion(src, isES300) {
  if (!isES300)
    return src;
  return src.replace("#version 300 es", "");
}
const processes = {
  // strips any version headers..
  stripVersion,
  // adds precision string if not already present
  ensurePrecision,
  // add some defines if WebGL1 to make it more compatible with WebGL2 shaders
  addProgramDefines,
  // add the program name to the shader
  setProgramName,
  // add the version string to the shader header
  insertVersion
};
const programCache$1 = /* @__PURE__ */ Object.create(null);
const _GlProgram = class _GlProgram2 {
  /**
   * Creates a shiny new GlProgram. Used by WebGL renderer.
   * @param options - The options for the program.
   */
  constructor(options) {
    options = { ..._GlProgram2.defaultOptions, ...options };
    const isES300 = options.fragment.indexOf("#version 300 es") !== -1;
    const preprocessorOptions = {
      stripVersion: isES300,
      ensurePrecision: {
        requestedFragmentPrecision: options.preferredFragmentPrecision,
        requestedVertexPrecision: options.preferredVertexPrecision,
        maxSupportedVertexPrecision: "highp",
        maxSupportedFragmentPrecision: getMaxFragmentPrecision()
      },
      setProgramName: {
        name: options.name
      },
      addProgramDefines: isES300,
      insertVersion: isES300
    };
    let fragment = options.fragment;
    let vertex = options.vertex;
    Object.keys(processes).forEach((processKey) => {
      const processOptions = preprocessorOptions[processKey];
      fragment = processes[processKey](fragment, processOptions, true);
      vertex = processes[processKey](vertex, processOptions, false);
    });
    this.fragment = fragment;
    this.vertex = vertex;
    this.transformFeedbackVaryings = options.transformFeedbackVaryings;
    this._key = createIdFromString(`${this.vertex}:${this.fragment}`, "gl-program");
  }
  /** destroys the program */
  destroy() {
    this.fragment = null;
    this.vertex = null;
    this._attributeData = null;
    this._uniformData = null;
    this._uniformBlockData = null;
    this.transformFeedbackVaryings = null;
    programCache$1[this._cacheKey] = null;
  }
  /**
   * Helper function that creates a program for a given source.
   * It will check the program cache if the program has already been created.
   * If it has that one will be returned, if not a new one will be created and cached.
   * @param options - The options for the program.
   * @returns A program using the same source
   */
  static from(options) {
    const key2 = `${options.vertex}:${options.fragment}`;
    if (!programCache$1[key2]) {
      programCache$1[key2] = new _GlProgram2(options);
      programCache$1[key2]._cacheKey = key2;
    }
    return programCache$1[key2];
  }
};
_GlProgram.defaultOptions = {
  preferredVertexPrecision: "highp",
  preferredFragmentPrecision: "mediump"
};
let GlProgram = _GlProgram;
const attributeFormatData = {
  uint8x2: { size: 2, stride: 2, normalised: false },
  uint8x4: { size: 4, stride: 4, normalised: false },
  sint8x2: { size: 2, stride: 2, normalised: false },
  sint8x4: { size: 4, stride: 4, normalised: false },
  unorm8x2: { size: 2, stride: 2, normalised: true },
  unorm8x4: { size: 4, stride: 4, normalised: true },
  snorm8x2: { size: 2, stride: 2, normalised: true },
  snorm8x4: { size: 4, stride: 4, normalised: true },
  uint16x2: { size: 2, stride: 4, normalised: false },
  uint16x4: { size: 4, stride: 8, normalised: false },
  sint16x2: { size: 2, stride: 4, normalised: false },
  sint16x4: { size: 4, stride: 8, normalised: false },
  unorm16x2: { size: 2, stride: 4, normalised: true },
  unorm16x4: { size: 4, stride: 8, normalised: true },
  snorm16x2: { size: 2, stride: 4, normalised: true },
  snorm16x4: { size: 4, stride: 8, normalised: true },
  float16x2: { size: 2, stride: 4, normalised: false },
  float16x4: { size: 4, stride: 8, normalised: false },
  float32: { size: 1, stride: 4, normalised: false },
  float32x2: { size: 2, stride: 8, normalised: false },
  float32x3: { size: 3, stride: 12, normalised: false },
  float32x4: { size: 4, stride: 16, normalised: false },
  uint32: { size: 1, stride: 4, normalised: false },
  uint32x2: { size: 2, stride: 8, normalised: false },
  uint32x3: { size: 3, stride: 12, normalised: false },
  uint32x4: { size: 4, stride: 16, normalised: false },
  sint32: { size: 1, stride: 4, normalised: false },
  sint32x2: { size: 2, stride: 8, normalised: false },
  sint32x3: { size: 3, stride: 12, normalised: false },
  sint32x4: { size: 4, stride: 16, normalised: false }
};
function getAttributeInfoFromFormat(format) {
  return attributeFormatData[format] ?? attributeFormatData.float32;
}
const WGSL_TO_VERTEX_TYPES = {
  f32: "float32",
  "vec2<f32>": "float32x2",
  "vec3<f32>": "float32x3",
  "vec4<f32>": "float32x4",
  vec2f: "float32x2",
  vec3f: "float32x3",
  vec4f: "float32x4",
  i32: "sint32",
  "vec2<i32>": "sint32x2",
  "vec3<i32>": "sint32x3",
  "vec4<i32>": "sint32x4",
  u32: "uint32",
  "vec2<u32>": "uint32x2",
  "vec3<u32>": "uint32x3",
  "vec4<u32>": "uint32x4",
  bool: "uint32",
  "vec2<bool>": "uint32x2",
  "vec3<bool>": "uint32x3",
  "vec4<bool>": "uint32x4"
};
function extractAttributesFromGpuProgram({ source: source2, entryPoint }) {
  const results = {};
  const mainVertStart = source2.indexOf(`fn ${entryPoint}`);
  if (mainVertStart !== -1) {
    const arrowFunctionStart = source2.indexOf("->", mainVertStart);
    if (arrowFunctionStart !== -1) {
      const functionArgsSubstring = source2.substring(mainVertStart, arrowFunctionStart);
      const inputsRegex = /@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|$)/g;
      let match;
      while ((match = inputsRegex.exec(functionArgsSubstring)) !== null) {
        const format = WGSL_TO_VERTEX_TYPES[match[3]] ?? "float32";
        results[match[2]] = {
          location: parseInt(match[1], 10),
          format,
          stride: getAttributeInfoFromFormat(format).stride,
          offset: 0,
          instance: false,
          start: 0
        };
      }
    }
  }
  return results;
}
function extractStructAndGroups(wgsl) {
  var _a, _b;
  const linePattern = /(^|[^/])@(group|binding)\(\d+\)[^;]+;/g;
  const groupPattern = /@group\((\d+)\)/;
  const bindingPattern = /@binding\((\d+)\)/;
  const namePattern = /var(<[^>]+>)? (\w+)/;
  const typePattern = /:\s*(\w+)/;
  const structPattern = /struct\s+(\w+)\s*{([^}]+)}/g;
  const structMemberPattern = /(\w+)\s*:\s*([\w\<\>]+)/g;
  const structName = /struct\s+(\w+)/;
  const groups = (_a = wgsl.match(linePattern)) == null ? void 0 : _a.map((item) => ({
    group: parseInt(item.match(groupPattern)[1], 10),
    binding: parseInt(item.match(bindingPattern)[1], 10),
    name: item.match(namePattern)[2],
    isUniform: item.match(namePattern)[1] === "<uniform>",
    type: item.match(typePattern)[1]
  }));
  if (!groups) {
    return {
      groups: [],
      structs: []
    };
  }
  const structs = ((_b = wgsl.match(structPattern)) == null ? void 0 : _b.map((struct) => {
    const name2 = struct.match(structName)[1];
    const members = struct.match(structMemberPattern).reduce((acc, member) => {
      const [name22, type2] = member.split(":");
      acc[name22.trim()] = type2.trim();
      return acc;
    }, {});
    if (!members) {
      return null;
    }
    return { name: name2, members };
  }).filter(({ name: name2 }) => groups.some((group) => group.type === name2))) ?? [];
  return {
    groups,
    structs
  };
}
var ShaderStage = /* @__PURE__ */ ((ShaderStage2) => {
  ShaderStage2[ShaderStage2["VERTEX"] = 1] = "VERTEX";
  ShaderStage2[ShaderStage2["FRAGMENT"] = 2] = "FRAGMENT";
  ShaderStage2[ShaderStage2["COMPUTE"] = 4] = "COMPUTE";
  return ShaderStage2;
})(ShaderStage || {});
function generateGpuLayoutGroups({ groups }) {
  const layout = [];
  for (let i2 = 0; i2 < groups.length; i2++) {
    const group = groups[i2];
    if (!layout[group.group]) {
      layout[group.group] = [];
    }
    if (group.isUniform) {
      layout[group.group].push({
        binding: group.binding,
        visibility: ShaderStage.VERTEX | ShaderStage.FRAGMENT,
        buffer: {
          type: "uniform"
        }
      });
    } else if (group.type === "sampler") {
      layout[group.group].push({
        binding: group.binding,
        visibility: ShaderStage.FRAGMENT,
        sampler: {
          type: "filtering"
        }
      });
    } else if (group.type === "texture_2d") {
      layout[group.group].push({
        binding: group.binding,
        visibility: ShaderStage.FRAGMENT,
        texture: {
          sampleType: "float",
          viewDimension: "2d",
          multisampled: false
        }
      });
    }
  }
  return layout;
}
function generateLayoutHash({ groups }) {
  const layout = [];
  for (let i2 = 0; i2 < groups.length; i2++) {
    const group = groups[i2];
    if (!layout[group.group]) {
      layout[group.group] = {};
    }
    layout[group.group][group.name] = group.binding;
  }
  return layout;
}
function removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups) {
  const structNameSet = /* @__PURE__ */ new Set();
  const dupeGroupKeySet = /* @__PURE__ */ new Set();
  const structs = [...vertexStructsAndGroups.structs, ...fragmentStructsAndGroups.structs].filter((struct) => {
    if (structNameSet.has(struct.name)) {
      return false;
    }
    structNameSet.add(struct.name);
    return true;
  });
  const groups = [...vertexStructsAndGroups.groups, ...fragmentStructsAndGroups.groups].filter((group) => {
    const key2 = `${group.name}-${group.binding}`;
    if (dupeGroupKeySet.has(key2)) {
      return false;
    }
    dupeGroupKeySet.add(key2);
    return true;
  });
  return { structs, groups };
}
const programCache = /* @__PURE__ */ Object.create(null);
class GpuProgram {
  /**
   * Create a new GpuProgram
   * @param options - The options for the gpu program
   */
  constructor(options) {
    var _a, _b;
    this._layoutKey = 0;
    this._attributeLocationsKey = 0;
    const { fragment, vertex, layout, gpuLayout, name: name2 } = options;
    this.name = name2;
    this.fragment = fragment;
    this.vertex = vertex;
    if (fragment.source === vertex.source) {
      const structsAndGroups = extractStructAndGroups(fragment.source);
      this.structsAndGroups = structsAndGroups;
    } else {
      const vertexStructsAndGroups = extractStructAndGroups(vertex.source);
      const fragmentStructsAndGroups = extractStructAndGroups(fragment.source);
      this.structsAndGroups = removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups);
    }
    this.layout = layout ?? generateLayoutHash(this.structsAndGroups);
    this.gpuLayout = gpuLayout ?? generateGpuLayoutGroups(this.structsAndGroups);
    this.autoAssignGlobalUniforms = !!(((_a = this.layout[0]) == null ? void 0 : _a.globalUniforms) !== void 0);
    this.autoAssignLocalUniforms = !!(((_b = this.layout[1]) == null ? void 0 : _b.localUniforms) !== void 0);
    this._generateProgramKey();
  }
  // TODO maker this pure
  _generateProgramKey() {
    const { vertex, fragment } = this;
    const bigKey = vertex.source + fragment.source + vertex.entryPoint + fragment.entryPoint;
    this._layoutKey = createIdFromString(bigKey, "program");
  }
  get attributeData() {
    this._attributeData ?? (this._attributeData = extractAttributesFromGpuProgram(this.vertex));
    return this._attributeData;
  }
  /** destroys the program */
  destroy() {
    this.gpuLayout = null;
    this.layout = null;
    this.structsAndGroups = null;
    this.fragment = null;
    this.vertex = null;
    programCache[this._cacheKey] = null;
  }
  /**
   * Helper function that creates a program for a given source.
   * It will check the program cache if the program has already been created.
   * If it has that one will be returned, if not a new one will be created and cached.
   * @param options - The options for the program.
   * @returns A program using the same source
   */
  static from(options) {
    const key2 = `${options.vertex.source}:${options.fragment.source}:${options.fragment.entryPoint}:${options.vertex.entryPoint}`;
    if (!programCache[key2]) {
      programCache[key2] = new GpuProgram(options);
      programCache[key2]._cacheKey = key2;
    }
    return programCache[key2];
  }
}
const UNIFORM_TYPES_VALUES = [
  "f32",
  "i32",
  "vec2<f32>",
  "vec3<f32>",
  "vec4<f32>",
  "mat2x2<f32>",
  "mat3x3<f32>",
  "mat4x4<f32>",
  "mat3x2<f32>",
  "mat4x2<f32>",
  "mat2x3<f32>",
  "mat4x3<f32>",
  "mat2x4<f32>",
  "mat3x4<f32>",
  "vec2<i32>",
  "vec3<i32>",
  "vec4<i32>"
];
const UNIFORM_TYPES_MAP = UNIFORM_TYPES_VALUES.reduce((acc, type2) => {
  acc[type2] = true;
  return acc;
}, {});
function getDefaultUniformValue(type2, size2) {
  switch (type2) {
    case "f32":
      return 0;
    case "vec2<f32>":
      return new Float32Array(2 * size2);
    case "vec3<f32>":
      return new Float32Array(3 * size2);
    case "vec4<f32>":
      return new Float32Array(4 * size2);
    case "mat2x2<f32>":
      return new Float32Array([
        1,
        0,
        0,
        1
      ]);
    case "mat3x3<f32>":
      return new Float32Array([
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ]);
    case "mat4x4<f32>":
      return new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
  }
  return null;
}
const _UniformGroup = class _UniformGroup2 {
  /**
   * Create a new Uniform group
   * @param uniformStructures - The structures of the uniform group
   * @param options - The optional parameters of this uniform group
   */
  constructor(uniformStructures, options) {
    this._touched = 0;
    this.uid = uid("uniform");
    this._resourceType = "uniformGroup";
    this._resourceId = uid("resource");
    this.isUniformGroup = true;
    this._dirtyId = 0;
    this.destroyed = false;
    options = { ..._UniformGroup2.defaultOptions, ...options };
    this.uniformStructures = uniformStructures;
    const uniforms = {};
    for (const i2 in uniformStructures) {
      const uniformData = uniformStructures[i2];
      uniformData.name = i2;
      uniformData.size = uniformData.size ?? 1;
      if (!UNIFORM_TYPES_MAP[uniformData.type]) {
        const arrayMatch = uniformData.type.match(/^array<(\w+(?:<\w+>)?),\s*(\d+)>$/);
        if (arrayMatch) {
          const [, innerType, size2] = arrayMatch;
          throw new Error(
            `Uniform type ${uniformData.type} is not supported. Use type: '${innerType}', size: ${size2} instead.`
          );
        }
        throw new Error(`Uniform type ${uniformData.type} is not supported. Supported uniform types are: ${UNIFORM_TYPES_VALUES.join(", ")}`);
      }
      uniformData.value ?? (uniformData.value = getDefaultUniformValue(uniformData.type, uniformData.size));
      uniforms[i2] = uniformData.value;
    }
    this.uniforms = uniforms;
    this._dirtyId = 1;
    this.ubo = options.ubo;
    this.isStatic = options.isStatic;
    this._signature = createIdFromString(Object.keys(uniforms).map(
      (i2) => `${i2}-${uniformStructures[i2].type}`
    ).join("-"), "uniform-group");
  }
  /** Call this if you want the uniform groups data to be uploaded to the GPU only useful if `isStatic` is true. */
  update() {
    this._dirtyId++;
  }
};
_UniformGroup.defaultOptions = {
  /** if true the UniformGroup is handled as an Uniform buffer object. */
  ubo: false,
  /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */
  isStatic: false
};
let UniformGroup = _UniformGroup;
class BindGroup {
  /**
   * Create a new instance eof the Bind Group.
   * @param resources - The resources that are bound together for use by a shader.
   */
  constructor(resources) {
    this.resources = /* @__PURE__ */ Object.create(null);
    this._dirty = true;
    let index = 0;
    for (const i2 in resources) {
      const resource = resources[i2];
      this.setResource(resource, index++);
    }
    this._updateKey();
  }
  /**
   * Updates the key if its flagged as dirty. This is used internally to
   * match this bind group to a WebGPU BindGroup.
   * @internal
   */
  _updateKey() {
    if (!this._dirty)
      return;
    this._dirty = false;
    const keyParts = [];
    let index = 0;
    for (const i2 in this.resources) {
      keyParts[index++] = this.resources[i2]._resourceId;
    }
    this._key = keyParts.join("|");
  }
  /**
   * Set a resource at a given index. this function will
   * ensure that listeners will be removed from the current resource
   * and added to the new resource.
   * @param resource - The resource to set.
   * @param index - The index to set the resource at.
   */
  setResource(resource, index) {
    var _a, _b;
    const currentResource = this.resources[index];
    if (resource === currentResource)
      return;
    if (currentResource) {
      (_a = resource.off) == null ? void 0 : _a.call(resource, "change", this.onResourceChange, this);
    }
    (_b = resource.on) == null ? void 0 : _b.call(resource, "change", this.onResourceChange, this);
    this.resources[index] = resource;
    this._dirty = true;
  }
  /**
   * Returns the resource at the current specified index.
   * @param index - The index of the resource to get.
   * @returns - The resource at the specified index.
   */
  getResource(index) {
    return this.resources[index];
  }
  /**
   * Used internally to 'touch' each resource, to ensure that the GC
   * knows that all resources in this bind group are still being used.
   * @param tick - The current tick.
   * @internal
   */
  _touch(tick) {
    const resources = this.resources;
    for (const i2 in resources) {
      resources[i2]._touched = tick;
    }
  }
  /** Destroys this bind group and removes all listeners. */
  destroy() {
    var _a;
    const resources = this.resources;
    for (const i2 in resources) {
      const resource = resources[i2];
      (_a = resource == null ? void 0 : resource.off) == null ? void 0 : _a.call(resource, "change", this.onResourceChange, this);
    }
    this.resources = null;
  }
  onResourceChange(resource) {
    this._dirty = true;
    if (resource.destroyed) {
      const resources = this.resources;
      for (const i2 in resources) {
        if (resources[i2] === resource) {
          resources[i2] = null;
        }
      }
    } else {
      this._updateKey();
    }
  }
}
var RendererType = /* @__PURE__ */ ((RendererType2) => {
  RendererType2[RendererType2["WEBGL"] = 1] = "WEBGL";
  RendererType2[RendererType2["WEBGPU"] = 2] = "WEBGPU";
  RendererType2[RendererType2["BOTH"] = 3] = "BOTH";
  return RendererType2;
})(RendererType || {});
class Shader extends EventEmitter {
  constructor(options) {
    super();
    this.uid = uid("shader");
    this._uniformBindMap = /* @__PURE__ */ Object.create(null);
    this._ownedBindGroups = [];
    this._destroyed = false;
    let {
      gpuProgram,
      glProgram,
      groups,
      resources,
      compatibleRenderers,
      groupMap
    } = options;
    this.gpuProgram = gpuProgram;
    this.glProgram = glProgram;
    if (compatibleRenderers === void 0) {
      compatibleRenderers = 0;
      if (gpuProgram)
        compatibleRenderers |= RendererType.WEBGPU;
      if (glProgram)
        compatibleRenderers |= RendererType.WEBGL;
    }
    this.compatibleRenderers = compatibleRenderers;
    const nameHash = {};
    if (!resources && !groups) {
      resources = {};
    }
    if (resources && groups) {
      throw new Error("[Shader] Cannot have both resources and groups");
    } else if (!gpuProgram && groups && !groupMap) {
      throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");
    } else if (!gpuProgram && groups && groupMap) {
      for (const i2 in groupMap) {
        for (const j2 in groupMap[i2]) {
          const uniformName = groupMap[i2][j2];
          nameHash[uniformName] = {
            group: i2,
            binding: j2,
            name: uniformName
          };
        }
      }
    } else if (gpuProgram && groups && !groupMap) {
      const groupData = gpuProgram.structsAndGroups.groups;
      groupMap = {};
      groupData.forEach((data) => {
        groupMap[data.group] = groupMap[data.group] || {};
        groupMap[data.group][data.binding] = data.name;
        nameHash[data.name] = data;
      });
    } else if (resources) {
      groups = {};
      groupMap = {};
      if (gpuProgram) {
        const groupData = gpuProgram.structsAndGroups.groups;
        groupData.forEach((data) => {
          groupMap[data.group] = groupMap[data.group] || {};
          groupMap[data.group][data.binding] = data.name;
          nameHash[data.name] = data;
        });
      }
      let bindTick = 0;
      for (const i2 in resources) {
        if (nameHash[i2])
          continue;
        if (!groups[99]) {
          groups[99] = new BindGroup();
          this._ownedBindGroups.push(groups[99]);
        }
        nameHash[i2] = { group: 99, binding: bindTick, name: i2 };
        groupMap[99] = groupMap[99] || {};
        groupMap[99][bindTick] = i2;
        bindTick++;
      }
      for (const i2 in resources) {
        const name2 = i2;
        let value2 = resources[i2];
        if (!value2.source && !value2._resourceType) {
          value2 = new UniformGroup(value2);
        }
        const data = nameHash[name2];
        if (data) {
          if (!groups[data.group]) {
            groups[data.group] = new BindGroup();
            this._ownedBindGroups.push(groups[data.group]);
          }
          groups[data.group].setResource(value2, data.binding);
        }
      }
    }
    this.groups = groups;
    this._uniformBindMap = groupMap;
    this.resources = this._buildResourceAccessor(groups, nameHash);
  }
  /**
   * Sometimes a resource group will be provided later (for example global uniforms)
   * In such cases, this method can be used to let the shader know about the group.
   * @param name - the name of the resource group
   * @param groupIndex - the index of the group (should match the webGPU shader group location)
   * @param bindIndex - the index of the bind point (should match the webGPU shader bind point)
   */
  addResource(name2, groupIndex, bindIndex) {
    var _a, _b;
    (_a = this._uniformBindMap)[groupIndex] || (_a[groupIndex] = {});
    (_b = this._uniformBindMap[groupIndex])[bindIndex] || (_b[bindIndex] = name2);
    if (!this.groups[groupIndex]) {
      this.groups[groupIndex] = new BindGroup();
      this._ownedBindGroups.push(this.groups[groupIndex]);
    }
  }
  _buildResourceAccessor(groups, nameHash) {
    const uniformsOut = {};
    for (const i2 in nameHash) {
      const data = nameHash[i2];
      Object.defineProperty(uniformsOut, data.name, {
        get() {
          return groups[data.group].getResource(data.binding);
        },
        set(value2) {
          groups[data.group].setResource(value2, data.binding);
        }
      });
    }
    return uniformsOut;
  }
  /**
   * Use to destroy the shader when its not longer needed.
   * It will destroy the resources and remove listeners.
   * @param destroyPrograms - if the programs should be destroyed as well.
   * Make sure its not being used by other shaders!
   */
  destroy(destroyPrograms = false) {
    var _a, _b;
    if (this._destroyed)
      return;
    this._destroyed = true;
    this.emit("destroy", this);
    if (destroyPrograms) {
      (_a = this.gpuProgram) == null ? void 0 : _a.destroy();
      (_b = this.glProgram) == null ? void 0 : _b.destroy();
    }
    this.gpuProgram = null;
    this.glProgram = null;
    this.removeAllListeners();
    this._uniformBindMap = null;
    this._ownedBindGroups.forEach((bindGroup) => {
      bindGroup.destroy();
    });
    this._ownedBindGroups = null;
    this.resources = null;
    this.groups = null;
  }
  static from(options) {
    const { gpu, gl, ...rest } = options;
    let gpuProgram;
    let glProgram;
    if (gpu) {
      gpuProgram = GpuProgram.from(gpu);
    }
    if (gl) {
      glProgram = GlProgram.from(gl);
    }
    return new Shader({
      gpuProgram,
      glProgram,
      ...rest
    });
  }
}
const blendModeIds = {
  normal: 0,
  add: 1,
  multiply: 2,
  screen: 3,
  overlay: 4,
  erase: 5,
  "normal-npm": 6,
  "add-npm": 7,
  "screen-npm": 8,
  min: 9,
  max: 10
};
const BLEND = 0;
const OFFSET = 1;
const CULLING = 2;
const DEPTH_TEST = 3;
const WINDING = 4;
const DEPTH_MASK = 5;
const _State = class _State2 {
  constructor() {
    this.data = 0;
    this.blendMode = "normal";
    this.polygonOffset = 0;
    this.blend = true;
    this.depthMask = true;
  }
  /**
   * Activates blending of the computed fragment color values.
   * @default true
   */
  get blend() {
    return !!(this.data & 1 << BLEND);
  }
  set blend(value2) {
    if (!!(this.data & 1 << BLEND) !== value2) {
      this.data ^= 1 << BLEND;
    }
  }
  /**
   * Activates adding an offset to depth values of polygon's fragments
   * @default false
   */
  get offsets() {
    return !!(this.data & 1 << OFFSET);
  }
  set offsets(value2) {
    if (!!(this.data & 1 << OFFSET) !== value2) {
      this.data ^= 1 << OFFSET;
    }
  }
  /** The culling settings for this state none - No culling back - Back face culling front - Front face culling */
  set cullMode(value2) {
    if (value2 === "none") {
      this.culling = false;
      return;
    }
    this.culling = true;
    this.clockwiseFrontFace = value2 === "front";
  }
  get cullMode() {
    if (!this.culling) {
      return "none";
    }
    return this.clockwiseFrontFace ? "front" : "back";
  }
  /**
   * Activates culling of polygons.
   * @default false
   */
  get culling() {
    return !!(this.data & 1 << CULLING);
  }
  set culling(value2) {
    if (!!(this.data & 1 << CULLING) !== value2) {
      this.data ^= 1 << CULLING;
    }
  }
  /**
   * Activates depth comparisons and updates to the depth buffer.
   * @default false
   */
  get depthTest() {
    return !!(this.data & 1 << DEPTH_TEST);
  }
  set depthTest(value2) {
    if (!!(this.data & 1 << DEPTH_TEST) !== value2) {
      this.data ^= 1 << DEPTH_TEST;
    }
  }
  /**
   * Enables or disables writing to the depth buffer.
   * @default true
   */
  get depthMask() {
    return !!(this.data & 1 << DEPTH_MASK);
  }
  set depthMask(value2) {
    if (!!(this.data & 1 << DEPTH_MASK) !== value2) {
      this.data ^= 1 << DEPTH_MASK;
    }
  }
  /**
   * Specifies whether or not front or back-facing polygons can be culled.
   * @default false
   */
  get clockwiseFrontFace() {
    return !!(this.data & 1 << WINDING);
  }
  set clockwiseFrontFace(value2) {
    if (!!(this.data & 1 << WINDING) !== value2) {
      this.data ^= 1 << WINDING;
    }
  }
  /**
   * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.
   * Setting this mode to anything other than NO_BLEND will automatically switch blending on.
   * @default 'normal'
   */
  get blendMode() {
    return this._blendMode;
  }
  set blendMode(value2) {
    this.blend = value2 !== "none";
    this._blendMode = value2;
    this._blendModeId = blendModeIds[value2] || 0;
  }
  /**
   * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.
   * @default 0
   */
  get polygonOffset() {
    return this._polygonOffset;
  }
  set polygonOffset(value2) {
    this.offsets = !!value2;
    this._polygonOffset = value2;
  }
  toString() {
    return `[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;
  }
  /**
   * A quickly getting an instance of a State that is configured for 2d rendering.
   * @returns a new State with values set for 2d rendering
   */
  static for2d() {
    const state = new _State2();
    state.depthTest = false;
    state.blend = true;
    return state;
  }
};
_State.default2d = _State.for2d();
let State = _State;
const _Filter = class _Filter2 extends Shader {
  /**
   * @param options - The optional parameters of this filter.
   */
  constructor(options) {
    options = { ..._Filter2.defaultOptions, ...options };
    super(options);
    this.enabled = true;
    this._state = State.for2d();
    this.blendMode = options.blendMode;
    this.padding = options.padding;
    if (typeof options.antialias === "boolean") {
      this.antialias = options.antialias ? "on" : "off";
    } else {
      this.antialias = options.antialias;
    }
    this.resolution = options.resolution;
    this.blendRequired = options.blendRequired;
    this.clipToViewport = options.clipToViewport;
    this.addResource("uTexture", 0, 1);
    if (options.blendRequired) {
      this.addResource("uBackTexture", 0, 3);
    }
  }
  /**
   * Applies the filter
   * @param filterManager - The renderer to retrieve the filter from
   * @param input - The input render target.
   * @param output - The target to output to.
   * @param clearMode - Should the output be cleared before rendering to it
   */
  apply(filterManager, input, output, clearMode) {
    filterManager.applyFilter(this, input, output, clearMode);
  }
  /**
   * Get the blend mode of the filter.
   * @default "normal"
   */
  get blendMode() {
    return this._state.blendMode;
  }
  /** Sets the blend mode of the filter. */
  set blendMode(value2) {
    this._state.blendMode = value2;
  }
  /**
   * A short hand function to create a filter based of a vertex and fragment shader src.
   * @param options
   * @returns A shiny new PixiJS filter!
   */
  static from(options) {
    const { gpu, gl, ...rest } = options;
    let gpuProgram;
    let glProgram;
    if (gpu) {
      gpuProgram = GpuProgram.from(gpu);
    }
    if (gl) {
      glProgram = GlProgram.from(gl);
    }
    return new _Filter2({
      gpuProgram,
      glProgram,
      ...rest
    });
  }
};
_Filter.defaultOptions = {
  blendMode: "normal",
  resolution: 1,
  padding: 0,
  antialias: "off",
  blendRequired: false,
  clipToViewport: true
};
let Filter = _Filter;
const environments = [];
extensions.handleByNamedList(ExtensionType.Environment, environments);
async function loadEnvironmentExtensions(skip) {
  if (skip)
    return;
  for (let i2 = 0; i2 < environments.length; i2++) {
    const env = environments[i2];
    if (env.value.test()) {
      await env.value.load();
      return;
    }
  }
}
let unsafeEval;
function unsafeEvalSupported() {
  if (typeof unsafeEval === "boolean") {
    return unsafeEval;
  }
  try {
    const func = new Function("param1", "param2", "param3", "return param1[param2] === param3;");
    unsafeEval = func({ a: "b" }, "a", "b") === true;
  } catch (_e) {
    unsafeEval = false;
  }
  return unsafeEval;
}
function earcut$1(data, holeIndices, dim = 2) {
  const hasHoles = holeIndices && holeIndices.length;
  const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
  let outerNode = linkedList(data, 0, outerLen, dim, true);
  const triangles = [];
  if (!outerNode || outerNode.next === outerNode.prev) return triangles;
  let minX, minY, invSize;
  if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
  if (data.length > 80 * dim) {
    minX = data[0];
    minY = data[1];
    let maxX = minX;
    let maxY = minY;
    for (let i2 = dim; i2 < outerLen; i2 += dim) {
      const x2 = data[i2];
      const y2 = data[i2 + 1];
      if (x2 < minX) minX = x2;
      if (y2 < minY) minY = y2;
      if (x2 > maxX) maxX = x2;
      if (y2 > maxY) maxY = y2;
    }
    invSize = Math.max(maxX - minX, maxY - minY);
    invSize = invSize !== 0 ? 32767 / invSize : 0;
  }
  earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
  return triangles;
}
function linkedList(data, start, end, dim, clockwise) {
  let last;
  if (clockwise === signedArea(data, start, end, dim) > 0) {
    for (let i2 = start; i2 < end; i2 += dim) last = insertNode(i2 / dim | 0, data[i2], data[i2 + 1], last);
  } else {
    for (let i2 = end - dim; i2 >= start; i2 -= dim) last = insertNode(i2 / dim | 0, data[i2], data[i2 + 1], last);
  }
  if (last && equals(last, last.next)) {
    removeNode(last);
    last = last.next;
  }
  return last;
}
function filterPoints(start, end) {
  if (!start) return start;
  if (!end) end = start;
  let p2 = start, again;
  do {
    again = false;
    if (!p2.steiner && (equals(p2, p2.next) || area(p2.prev, p2, p2.next) === 0)) {
      removeNode(p2);
      p2 = end = p2.prev;
      if (p2 === p2.next) break;
      again = true;
    } else {
      p2 = p2.next;
    }
  } while (again || p2 !== end);
  return end;
}
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
  if (!ear) return;
  if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
  let stop = ear;
  while (ear.prev !== ear.next) {
    const prev = ear.prev;
    const next = ear.next;
    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      triangles.push(prev.i, ear.i, next.i);
      removeNode(ear);
      ear = next.next;
      stop = next.next;
      continue;
    }
    ear = next;
    if (ear === stop) {
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
      } else if (pass === 1) {
        ear = cureLocalIntersections(filterPoints(ear), triangles);
        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, invSize);
      }
      break;
    }
  }
}
function isEar(ear) {
  const a2 = ear.prev, b2 = ear, c2 = ear.next;
  if (area(a2, b2, c2) >= 0) return false;
  const ax = a2.x, bx = b2.x, cx = c2.x, ay = a2.y, by = b2.y, cy = c2.y;
  const x0 = Math.min(ax, bx, cx), y0 = Math.min(ay, by, cy), x1 = Math.max(ax, bx, cx), y1 = Math.max(ay, by, cy);
  let p2 = c2.next;
  while (p2 !== a2) {
    if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0) return false;
    p2 = p2.next;
  }
  return true;
}
function isEarHashed(ear, minX, minY, invSize) {
  const a2 = ear.prev, b2 = ear, c2 = ear.next;
  if (area(a2, b2, c2) >= 0) return false;
  const ax = a2.x, bx = b2.x, cx = c2.x, ay = a2.y, by = b2.y, cy = c2.y;
  const x0 = Math.min(ax, bx, cx), y0 = Math.min(ay, by, cy), x1 = Math.max(ax, bx, cx), y1 = Math.max(ay, by, cy);
  const minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
  let p2 = ear.prevZ, n2 = ear.nextZ;
  while (p2 && p2.z >= minZ && n2 && n2.z <= maxZ) {
    if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && p2 !== a2 && p2 !== c2 && pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0) return false;
    p2 = p2.prevZ;
    if (n2.x >= x0 && n2.x <= x1 && n2.y >= y0 && n2.y <= y1 && n2 !== a2 && n2 !== c2 && pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0) return false;
    n2 = n2.nextZ;
  }
  while (p2 && p2.z >= minZ) {
    if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && p2 !== a2 && p2 !== c2 && pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0) return false;
    p2 = p2.prevZ;
  }
  while (n2 && n2.z <= maxZ) {
    if (n2.x >= x0 && n2.x <= x1 && n2.y >= y0 && n2.y <= y1 && n2 !== a2 && n2 !== c2 && pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0) return false;
    n2 = n2.nextZ;
  }
  return true;
}
function cureLocalIntersections(start, triangles) {
  let p2 = start;
  do {
    const a2 = p2.prev, b2 = p2.next.next;
    if (!equals(a2, b2) && intersects(a2, p2, p2.next, b2) && locallyInside(a2, b2) && locallyInside(b2, a2)) {
      triangles.push(a2.i, p2.i, b2.i);
      removeNode(p2);
      removeNode(p2.next);
      p2 = start = b2;
    }
    p2 = p2.next;
  } while (p2 !== start);
  return filterPoints(p2);
}
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
  let a2 = start;
  do {
    let b2 = a2.next.next;
    while (b2 !== a2.prev) {
      if (a2.i !== b2.i && isValidDiagonal(a2, b2)) {
        let c2 = splitPolygon(a2, b2);
        a2 = filterPoints(a2, a2.next);
        c2 = filterPoints(c2, c2.next);
        earcutLinked(a2, triangles, dim, minX, minY, invSize, 0);
        earcutLinked(c2, triangles, dim, minX, minY, invSize, 0);
        return;
      }
      b2 = b2.next;
    }
    a2 = a2.next;
  } while (a2 !== start);
}
function eliminateHoles(data, holeIndices, outerNode, dim) {
  const queue = [];
  for (let i2 = 0, len = holeIndices.length; i2 < len; i2++) {
    const start = holeIndices[i2] * dim;
    const end = i2 < len - 1 ? holeIndices[i2 + 1] * dim : data.length;
    const list = linkedList(data, start, end, dim, false);
    if (list === list.next) list.steiner = true;
    queue.push(getLeftmost(list));
  }
  queue.sort(compareXYSlope);
  for (let i2 = 0; i2 < queue.length; i2++) {
    outerNode = eliminateHole(queue[i2], outerNode);
  }
  return outerNode;
}
function compareXYSlope(a2, b2) {
  let result = a2.x - b2.x;
  if (result === 0) {
    result = a2.y - b2.y;
    if (result === 0) {
      const aSlope = (a2.next.y - a2.y) / (a2.next.x - a2.x);
      const bSlope = (b2.next.y - b2.y) / (b2.next.x - b2.x);
      result = aSlope - bSlope;
    }
  }
  return result;
}
function eliminateHole(hole, outerNode) {
  const bridge = findHoleBridge(hole, outerNode);
  if (!bridge) {
    return outerNode;
  }
  const bridgeReverse = splitPolygon(bridge, hole);
  filterPoints(bridgeReverse, bridgeReverse.next);
  return filterPoints(bridge, bridge.next);
}
function findHoleBridge(hole, outerNode) {
  let p2 = outerNode;
  const hx = hole.x;
  const hy = hole.y;
  let qx = -Infinity;
  let m2;
  if (equals(hole, p2)) return p2;
  do {
    if (equals(hole, p2.next)) return p2.next;
    else if (hy <= p2.y && hy >= p2.next.y && p2.next.y !== p2.y) {
      const x2 = p2.x + (hy - p2.y) * (p2.next.x - p2.x) / (p2.next.y - p2.y);
      if (x2 <= hx && x2 > qx) {
        qx = x2;
        m2 = p2.x < p2.next.x ? p2 : p2.next;
        if (x2 === hx) return m2;
      }
    }
    p2 = p2.next;
  } while (p2 !== outerNode);
  if (!m2) return null;
  const stop = m2;
  const mx = m2.x;
  const my = m2.y;
  let tanMin = Infinity;
  p2 = m2;
  do {
    if (hx >= p2.x && p2.x >= mx && hx !== p2.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p2.x, p2.y)) {
      const tan = Math.abs(hy - p2.y) / (hx - p2.x);
      if (locallyInside(p2, hole) && (tan < tanMin || tan === tanMin && (p2.x > m2.x || p2.x === m2.x && sectorContainsSector(m2, p2)))) {
        m2 = p2;
        tanMin = tan;
      }
    }
    p2 = p2.next;
  } while (p2 !== stop);
  return m2;
}
function sectorContainsSector(m2, p2) {
  return area(m2.prev, m2, p2.prev) < 0 && area(p2.next, m2, m2.next) < 0;
}
function indexCurve(start, minX, minY, invSize) {
  let p2 = start;
  do {
    if (p2.z === 0) p2.z = zOrder(p2.x, p2.y, minX, minY, invSize);
    p2.prevZ = p2.prev;
    p2.nextZ = p2.next;
    p2 = p2.next;
  } while (p2 !== start);
  p2.prevZ.nextZ = null;
  p2.prevZ = null;
  sortLinked(p2);
}
function sortLinked(list) {
  let numMerges;
  let inSize = 1;
  do {
    let p2 = list;
    let e2;
    list = null;
    let tail = null;
    numMerges = 0;
    while (p2) {
      numMerges++;
      let q = p2;
      let pSize = 0;
      for (let i2 = 0; i2 < inSize; i2++) {
        pSize++;
        q = q.nextZ;
        if (!q) break;
      }
      let qSize = inSize;
      while (pSize > 0 || qSize > 0 && q) {
        if (pSize !== 0 && (qSize === 0 || !q || p2.z <= q.z)) {
          e2 = p2;
          p2 = p2.nextZ;
          pSize--;
        } else {
          e2 = q;
          q = q.nextZ;
          qSize--;
        }
        if (tail) tail.nextZ = e2;
        else list = e2;
        e2.prevZ = tail;
        tail = e2;
      }
      p2 = q;
    }
    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);
  return list;
}
function zOrder(x2, y2, minX, minY, invSize) {
  x2 = (x2 - minX) * invSize | 0;
  y2 = (y2 - minY) * invSize | 0;
  x2 = (x2 | x2 << 8) & 16711935;
  x2 = (x2 | x2 << 4) & 252645135;
  x2 = (x2 | x2 << 2) & 858993459;
  x2 = (x2 | x2 << 1) & 1431655765;
  y2 = (y2 | y2 << 8) & 16711935;
  y2 = (y2 | y2 << 4) & 252645135;
  y2 = (y2 | y2 << 2) & 858993459;
  y2 = (y2 | y2 << 1) & 1431655765;
  return x2 | y2 << 1;
}
function getLeftmost(start) {
  let p2 = start, leftmost = start;
  do {
    if (p2.x < leftmost.x || p2.x === leftmost.x && p2.y < leftmost.y) leftmost = p2;
    p2 = p2.next;
  } while (p2 !== start);
  return leftmost;
}
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
  return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
}
function pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, px, py) {
  return !(ax === px && ay === py) && pointInTriangle(ax, ay, bx, by, cx, cy, px, py);
}
function isValidDiagonal(a2, b2) {
  return a2.next.i !== b2.i && a2.prev.i !== b2.i && !intersectsPolygon(a2, b2) && // doesn't intersect other edges
  (locallyInside(a2, b2) && locallyInside(b2, a2) && middleInside(a2, b2) && // locally visible
  (area(a2.prev, a2, b2.prev) || area(a2, b2.prev, b2)) || // does not create opposite-facing sectors
  equals(a2, b2) && area(a2.prev, a2, a2.next) > 0 && area(b2.prev, b2, b2.next) > 0);
}
function area(p2, q, r2) {
  return (q.y - p2.y) * (r2.x - q.x) - (q.x - p2.x) * (r2.y - q.y);
}
function equals(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
}
function intersects(p1, q1, p2, q2) {
  const o1 = sign(area(p1, q1, p2));
  const o2 = sign(area(p1, q1, q2));
  const o3 = sign(area(p2, q2, p1));
  const o4 = sign(area(p2, q2, q1));
  if (o1 !== o2 && o3 !== o4) return true;
  if (o1 === 0 && onSegment(p1, p2, q1)) return true;
  if (o2 === 0 && onSegment(p1, q2, q1)) return true;
  if (o3 === 0 && onSegment(p2, p1, q2)) return true;
  if (o4 === 0 && onSegment(p2, q1, q2)) return true;
  return false;
}
function onSegment(p2, q, r2) {
  return q.x <= Math.max(p2.x, r2.x) && q.x >= Math.min(p2.x, r2.x) && q.y <= Math.max(p2.y, r2.y) && q.y >= Math.min(p2.y, r2.y);
}
function sign(num) {
  return num > 0 ? 1 : num < 0 ? -1 : 0;
}
function intersectsPolygon(a2, b2) {
  let p2 = a2;
  do {
    if (p2.i !== a2.i && p2.next.i !== a2.i && p2.i !== b2.i && p2.next.i !== b2.i && intersects(p2, p2.next, a2, b2)) return true;
    p2 = p2.next;
  } while (p2 !== a2);
  return false;
}
function locallyInside(a2, b2) {
  return area(a2.prev, a2, a2.next) < 0 ? area(a2, b2, a2.next) >= 0 && area(a2, a2.prev, b2) >= 0 : area(a2, b2, a2.prev) < 0 || area(a2, a2.next, b2) < 0;
}
function middleInside(a2, b2) {
  let p2 = a2;
  let inside = false;
  const px = (a2.x + b2.x) / 2;
  const py = (a2.y + b2.y) / 2;
  do {
    if (p2.y > py !== p2.next.y > py && p2.next.y !== p2.y && px < (p2.next.x - p2.x) * (py - p2.y) / (p2.next.y - p2.y) + p2.x)
      inside = !inside;
    p2 = p2.next;
  } while (p2 !== a2);
  return inside;
}
function splitPolygon(a2, b2) {
  const a22 = createNode(a2.i, a2.x, a2.y), b22 = createNode(b2.i, b2.x, b2.y), an = a2.next, bp = b2.prev;
  a2.next = b2;
  b2.prev = a2;
  a22.next = an;
  an.prev = a22;
  b22.next = a22;
  a22.prev = b22;
  bp.next = b22;
  b22.prev = bp;
  return b22;
}
function insertNode(i2, x2, y2, last) {
  const p2 = createNode(i2, x2, y2);
  if (!last) {
    p2.prev = p2;
    p2.next = p2;
  } else {
    p2.next = last.next;
    p2.prev = last;
    last.next.prev = p2;
    last.next = p2;
  }
  return p2;
}
function removeNode(p2) {
  p2.next.prev = p2.prev;
  p2.prev.next = p2.next;
  if (p2.prevZ) p2.prevZ.nextZ = p2.nextZ;
  if (p2.nextZ) p2.nextZ.prevZ = p2.prevZ;
}
function createNode(i2, x2, y2) {
  return {
    i: i2,
    // vertex index in coordinates array
    x: x2,
    y: y2,
    // vertex coordinates
    prev: null,
    // previous and next vertex nodes in a polygon ring
    next: null,
    z: 0,
    // z-order curve value
    prevZ: null,
    // previous and next nodes in z-order
    nextZ: null,
    steiner: false
    // indicates whether this is a steiner point
  };
}
function signedArea(data, start, end, dim) {
  let sum = 0;
  for (let i2 = start, j2 = end - dim; i2 < end; i2 += dim) {
    sum += (data[j2] - data[i2]) * (data[i2 + 1] + data[j2 + 1]);
    j2 = i2;
  }
  return sum;
}
const earcut = earcut$1.default || earcut$1;
var CLEAR = /* @__PURE__ */ ((CLEAR2) => {
  CLEAR2[CLEAR2["NONE"] = 0] = "NONE";
  CLEAR2[CLEAR2["COLOR"] = 16384] = "COLOR";
  CLEAR2[CLEAR2["STENCIL"] = 1024] = "STENCIL";
  CLEAR2[CLEAR2["DEPTH"] = 256] = "DEPTH";
  CLEAR2[CLEAR2["COLOR_DEPTH"] = 16640] = "COLOR_DEPTH";
  CLEAR2[CLEAR2["COLOR_STENCIL"] = 17408] = "COLOR_STENCIL";
  CLEAR2[CLEAR2["DEPTH_STENCIL"] = 1280] = "DEPTH_STENCIL";
  CLEAR2[CLEAR2["ALL"] = 17664] = "ALL";
  return CLEAR2;
})(CLEAR || {});
class SystemRunner {
  /**
   * @param name - The function name that will be executed on the listeners added to this Runner.
   */
  constructor(name2) {
    this.items = [];
    this._name = name2;
  }
  /* jsdoc/check-param-names */
  /**
   * Dispatch/Broadcast Runner to all listeners added to the queue.
   * @param {...any} params - (optional) parameters to pass to each listener
   */
  /* jsdoc/check-param-names */
  emit(a0, a1, a2, a3, a4, a5, a6, a7) {
    const { name: name2, items } = this;
    for (let i2 = 0, len = items.length; i2 < len; i2++) {
      items[i2][name2](a0, a1, a2, a3, a4, a5, a6, a7);
    }
    return this;
  }
  /**
   * Add a listener to the Runner
   *
   * Runners do not need to have scope or functions passed to them.
   * All that is required is to pass the listening object and ensure that it has contains a function that has the same name
   * as the name provided to the Runner when it was created.
   *
   * Eg A listener passed to this Runner will require a 'complete' function.
   *
   * ```ts
   * import { Runner } from 'pixi.js';
   *
   * const complete = new Runner('complete');
   * ```
   *
   * The scope used will be the object itself.
   * @param {any} item - The object that will be listening.
   */
  add(item) {
    if (item[this._name]) {
      this.remove(item);
      this.items.push(item);
    }
    return this;
  }
  /**
   * Remove a single listener from the dispatch queue.
   * @param {any} item - The listener that you would like to remove.
   */
  remove(item) {
    const index = this.items.indexOf(item);
    if (index !== -1) {
      this.items.splice(index, 1);
    }
    return this;
  }
  /**
   * Check to see if the listener is already in the Runner
   * @param {any} item - The listener that you would like to check.
   */
  contains(item) {
    return this.items.indexOf(item) !== -1;
  }
  /** Remove all listeners from the Runner */
  removeAll() {
    this.items.length = 0;
    return this;
  }
  /** Remove all references, don't use after this. */
  destroy() {
    this.removeAll();
    this.items = null;
    this._name = null;
  }
  /**
   * `true` if there are no this Runner contains no listeners
   * @readonly
   */
  get empty() {
    return this.items.length === 0;
  }
  /**
   * The name of the runner.
   * @readonly
   */
  get name() {
    return this._name;
  }
}
const defaultRunners = [
  "init",
  "destroy",
  "contextChange",
  "resolutionChange",
  "resetState",
  "renderEnd",
  "renderStart",
  "render",
  "update",
  "postrender",
  "prerender"
];
const _AbstractRenderer = class _AbstractRenderer2 extends EventEmitter {
  /**
   * Set up a system with a collection of SystemClasses and runners.
   * Systems are attached dynamically to this class when added.
   * @param config - the config for the system manager
   */
  constructor(config) {
    super();
    this.uid = uid("renderer");
    this.runners = /* @__PURE__ */ Object.create(null);
    this.renderPipes = /* @__PURE__ */ Object.create(null);
    this._initOptions = {};
    this._systemsHash = /* @__PURE__ */ Object.create(null);
    this.type = config.type;
    this.name = config.name;
    this.config = config;
    const combinedRunners = [...defaultRunners, ...this.config.runners ?? []];
    this._addRunners(...combinedRunners);
    this._unsafeEvalCheck();
  }
  /**
   * Initialize the renderer.
   * @param options - The options to use to create the renderer.
   */
  async init(options = {}) {
    const skip = options.skipExtensionImports === true ? true : options.manageImports === false;
    await loadEnvironmentExtensions(skip);
    this._addSystems(this.config.systems);
    this._addPipes(this.config.renderPipes, this.config.renderPipeAdaptors);
    for (const systemName in this._systemsHash) {
      const system = this._systemsHash[systemName];
      const defaultSystemOptions = system.constructor.defaultOptions;
      options = { ...defaultSystemOptions, ...options };
    }
    options = { ..._AbstractRenderer2.defaultOptions, ...options };
    this._roundPixels = options.roundPixels ? 1 : 0;
    for (let i2 = 0; i2 < this.runners.init.items.length; i2++) {
      await this.runners.init.items[i2].init(options);
    }
    this._initOptions = options;
  }
  render(args, deprecated) {
    let options = args;
    if (options instanceof Container) {
      options = { container: options };
      if (deprecated) {
        deprecation(v8_0_0, "passing a second argument is deprecated, please use render options instead");
        options.target = deprecated.renderTexture;
      }
    }
    options.target || (options.target = this.view.renderTarget);
    if (options.target === this.view.renderTarget) {
      this._lastObjectRendered = options.container;
      options.clearColor ?? (options.clearColor = this.background.colorRgba);
      options.clear ?? (options.clear = this.background.clearBeforeRender);
    }
    if (options.clearColor) {
      const isRGBAArray = Array.isArray(options.clearColor) && options.clearColor.length === 4;
      options.clearColor = isRGBAArray ? options.clearColor : Color.shared.setValue(options.clearColor).toArray();
    }
    if (!options.transform) {
      options.container.updateLocalTransform();
      options.transform = options.container.localTransform;
    }
    if (!options.container.visible) {
      return;
    }
    options.container.enableRenderGroup();
    this.runners.prerender.emit(options);
    this.runners.renderStart.emit(options);
    this.runners.render.emit(options);
    this.runners.renderEnd.emit(options);
    this.runners.postrender.emit(options);
  }
  /**
   * Resizes the WebGL view to the specified width and height.
   * @param desiredScreenWidth - The desired width of the screen.
   * @param desiredScreenHeight - The desired height of the screen.
   * @param resolution - The resolution / device pixel ratio of the renderer.
   */
  resize(desiredScreenWidth, desiredScreenHeight, resolution2) {
    const previousResolution = this.view.resolution;
    this.view.resize(desiredScreenWidth, desiredScreenHeight, resolution2);
    this.emit("resize", this.view.screen.width, this.view.screen.height, this.view.resolution);
    if (resolution2 !== void 0 && resolution2 !== previousResolution) {
      this.runners.resolutionChange.emit(resolution2);
    }
  }
  /**
   * Clears the render target.
   * @param options - The options to use when clearing the render target.
   * @param options.target - The render target to clear.
   * @param options.clearColor - The color to clear with.
   * @param options.clear - The clear mode to use.
   * @advanced
   */
  clear(options = {}) {
    const renderer = this;
    options.target || (options.target = renderer.renderTarget.renderTarget);
    options.clearColor || (options.clearColor = this.background.colorRgba);
    options.clear ?? (options.clear = CLEAR.ALL);
    const { clear, clearColor, target } = options;
    Color.shared.setValue(clearColor ?? this.background.colorRgba);
    renderer.renderTarget.clear(target, clear, Color.shared.toArray());
  }
  /** The resolution / device pixel ratio of the renderer. */
  get resolution() {
    return this.view.resolution;
  }
  set resolution(value2) {
    this.view.resolution = value2;
    this.runners.resolutionChange.emit(value2);
  }
  /**
   * Same as view.width, actual number of pixels in the canvas by horizontal.
   * @type {number}
   * @readonly
   * @default 800
   */
  get width() {
    return this.view.texture.frame.width;
  }
  /**
   * Same as view.height, actual number of pixels in the canvas by vertical.
   * @default 600
   */
  get height() {
    return this.view.texture.frame.height;
  }
  // NOTE: this was `view` in v7
  /**
   * The canvas element that everything is drawn to.
   * @type {environment.ICanvas}
   */
  get canvas() {
    return this.view.canvas;
  }
  /**
   * the last object rendered by the renderer. Useful for other plugins like interaction managers
   * @readonly
   */
  get lastObjectRendered() {
    return this._lastObjectRendered;
  }
  /**
   * Flag if we are rendering to the screen vs renderTexture
   * @readonly
   * @default true
   */
  get renderingToScreen() {
    const renderer = this;
    return renderer.renderTarget.renderingToScreen;
  }
  /**
   * Measurements of the screen. (0, 0, screenWidth, screenHeight).
   *
   * Its safe to use as filterArea or hitArea for the whole stage.
   */
  get screen() {
    return this.view.screen;
  }
  /**
   * Create a bunch of runners based of a collection of ids
   * @param runnerIds - the runner ids to add
   */
  _addRunners(...runnerIds) {
    runnerIds.forEach((runnerId) => {
      this.runners[runnerId] = new SystemRunner(runnerId);
    });
  }
  _addSystems(systems) {
    let i2;
    for (i2 in systems) {
      const val = systems[i2];
      this._addSystem(val.value, val.name);
    }
  }
  /**
   * Add a new system to the renderer.
   * @param ClassRef - Class reference
   * @param name - Property name for system, if not specified
   *        will use a static `name` property on the class itself. This
   *        name will be assigned as s property on the Renderer so make
   *        sure it doesn't collide with properties on Renderer.
   * @returns Return instance of renderer
   */
  _addSystem(ClassRef, name2) {
    const system = new ClassRef(this);
    if (this[name2]) {
      throw new Error(`Whoops! The name "${name2}" is already in use`);
    }
    this[name2] = system;
    this._systemsHash[name2] = system;
    for (const i2 in this.runners) {
      this.runners[i2].add(system);
    }
    return this;
  }
  _addPipes(pipes, pipeAdaptors) {
    const adaptors = pipeAdaptors.reduce((acc, adaptor) => {
      acc[adaptor.name] = adaptor.value;
      return acc;
    }, {});
    pipes.forEach((pipe) => {
      const PipeClass = pipe.value;
      const name2 = pipe.name;
      const Adaptor = adaptors[name2];
      this.renderPipes[name2] = new PipeClass(
        this,
        Adaptor ? new Adaptor() : null
      );
      this.runners.destroy.add(this.renderPipes[name2]);
    });
  }
  destroy(options = false) {
    this.runners.destroy.items.reverse();
    this.runners.destroy.emit(options);
    if (options === true || typeof options === "object" && options.releaseGlobalResources) {
      GlobalResourceRegistry.release();
    }
    Object.values(this.runners).forEach((runner) => {
      runner.destroy();
    });
    this._systemsHash = null;
    this.renderPipes = null;
  }
  /**
   * Generate a texture from a container.
   * @param options - options or container target to use when generating the texture
   * @returns a texture
   */
  generateTexture(options) {
    return this.textureGenerator.generateTexture(options);
  }
  /**
   * Whether the renderer will round coordinates to whole pixels when rendering.
   * Can be overridden on a per scene item basis.
   */
  get roundPixels() {
    return !!this._roundPixels;
  }
  /**
   * Overridable function by `pixi.js/unsafe-eval` to silence
   * throwing an error if platform doesn't support unsafe-evals.
   * @private
   * @ignore
   */
  _unsafeEvalCheck() {
    if (!unsafeEvalSupported()) {
      throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.");
    }
  }
  /**
   * Resets the rendering state of the renderer.
   * This is useful when you want to use the WebGL context directly and need to ensure PixiJS's internal state
   * stays synchronized. When modifying the WebGL context state externally, calling this method before the next Pixi
   * render will reset all internal caches and ensure it executes correctly.
   *
   * This is particularly useful when combining PixiJS with other rendering engines like Three.js:
   * ```js
   * // Reset Three.js state
   * threeRenderer.resetState();
   *
   * // Render a Three.js scene
   * threeRenderer.render(threeScene, threeCamera);
   *
   * // Reset PixiJS state since Three.js modified the WebGL context
   * pixiRenderer.resetState();
   *
   * // Now render Pixi content
   * pixiRenderer.render(pixiScene);
   * ```
   * @advanced
   */
  resetState() {
    this.runners.resetState.emit();
  }
};
_AbstractRenderer.defaultOptions = {
  /**
   * Default resolution / device pixel ratio of the renderer.
   * @default 1
   */
  resolution: 1,
  /**
   * Should the `failIfMajorPerformanceCaveat` flag be enabled as a context option used in the `isWebGLSupported`
   * function. If set to true, a WebGL renderer can fail to be created if the browser thinks there could be
   * performance issues when using WebGL.
   *
   * In PixiJS v6 this has changed from true to false by default, to allow WebGL to work in as many
   * scenarios as possible. However, some users may have a poor experience, for example, if a user has a gpu or
   * driver version blacklisted by the
   * browser.
   *
   * If your application requires high performance rendering, you may wish to set this to false.
   * We recommend one of two options if you decide to set this flag to false:
   *
   * 1: Use the Canvas renderer as a fallback in case high performance WebGL is
   *    not supported.
   *
   * 2: Call `isWebGLSupported` (which if found in the utils package) in your code before attempting to create a
   *    PixiJS renderer, and show an error message to the user if the function returns false, explaining that their
   *    device & browser combination does not support high performance WebGL.
   *    This is a much better strategy than trying to create a PixiJS renderer and finding it then fails.
   * @default false
   */
  failIfMajorPerformanceCaveat: false,
  /**
   * Should round pixels be forced when rendering?
   * @default false
   */
  roundPixels: false
};
let AbstractRenderer = _AbstractRenderer;
let _isWebGLSupported;
function isWebGLSupported(failIfMajorPerformanceCaveat) {
  if (_isWebGLSupported !== void 0)
    return _isWebGLSupported;
  _isWebGLSupported = (() => {
    var _a;
    const contextOptions = {
      stencil: true,
      failIfMajorPerformanceCaveat: failIfMajorPerformanceCaveat ?? AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat
    };
    try {
      if (!DOMAdapter.get().getWebGLRenderingContext()) {
        return false;
      }
      const canvas = DOMAdapter.get().createCanvas();
      let gl = canvas.getContext("webgl", contextOptions);
      const success = !!((_a = gl == null ? void 0 : gl.getContextAttributes()) == null ? void 0 : _a.stencil);
      if (gl) {
        const loseContext = gl.getExtension("WEBGL_lose_context");
        if (loseContext) {
          loseContext.loseContext();
        }
      }
      gl = null;
      return success;
    } catch (_e) {
      return false;
    }
  })();
  return _isWebGLSupported;
}
let _isWebGPUSupported;
async function isWebGPUSupported(options = {}) {
  if (_isWebGPUSupported !== void 0)
    return _isWebGPUSupported;
  _isWebGPUSupported = await (async () => {
    const gpu = DOMAdapter.get().getNavigator().gpu;
    if (!gpu) {
      return false;
    }
    try {
      const adapter = await gpu.requestAdapter(options);
      await adapter.requestDevice();
      return true;
    } catch (_e) {
      return false;
    }
  })();
  return _isWebGPUSupported;
}
const renderPriority = ["webgl", "webgpu", "canvas"];
async function autoDetectRenderer(options) {
  let preferredOrder = [];
  if (options.preference) {
    preferredOrder.push(options.preference);
    renderPriority.forEach((item) => {
      if (item !== options.preference) {
        preferredOrder.push(item);
      }
    });
  } else {
    preferredOrder = renderPriority.slice();
  }
  let RendererClass;
  let finalOptions = {};
  for (let i2 = 0; i2 < preferredOrder.length; i2++) {
    const rendererType = preferredOrder[i2];
    if (rendererType === "webgpu" && await isWebGPUSupported()) {
      const { WebGPURenderer } = await __vitePreload(async () => {
        const { WebGPURenderer: WebGPURenderer2 } = await import("./WebGPURenderer-CTBXFgSQ.js");
        return { WebGPURenderer: WebGPURenderer2 };
      }, true ? __vite__mapDeps([3,2,4]) : void 0);
      RendererClass = WebGPURenderer;
      finalOptions = { ...options, ...options.webgpu };
      break;
    } else if (rendererType === "webgl" && isWebGLSupported(
      options.failIfMajorPerformanceCaveat ?? AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat
    )) {
      const { WebGLRenderer } = await __vitePreload(async () => {
        const { WebGLRenderer: WebGLRenderer2 } = await import("./WebGLRenderer-0tiCfP3M.js");
        return { WebGLRenderer: WebGLRenderer2 };
      }, true ? __vite__mapDeps([5,2,4]) : void 0);
      RendererClass = WebGLRenderer;
      finalOptions = { ...options, ...options.webgl };
      break;
    } else if (rendererType === "canvas") {
      finalOptions = { ...options };
      throw new Error("CanvasRenderer is not yet implemented");
    }
  }
  delete finalOptions.webgpu;
  delete finalOptions.webgl;
  if (!RendererClass) {
    throw new Error("No available renderer for the current environment");
  }
  const renderer = new RendererClass();
  await renderer.init(finalOptions);
  return renderer;
}
const VERSION = "8.14.3";
class ApplicationInitHook {
  static init() {
    var _a;
    (_a = globalThis.__PIXI_APP_INIT__) == null ? void 0 : _a.call(globalThis, this, VERSION);
  }
  static destroy() {
  }
}
ApplicationInitHook.extension = ExtensionType.Application;
class RendererInitHook {
  constructor(renderer) {
    this._renderer = renderer;
  }
  init() {
    var _a;
    (_a = globalThis.__PIXI_RENDERER_INIT__) == null ? void 0 : _a.call(globalThis, this._renderer, VERSION);
  }
  destroy() {
    this._renderer = null;
  }
}
RendererInitHook.extension = {
  type: [
    ExtensionType.WebGLSystem,
    ExtensionType.WebGPUSystem
  ],
  name: "initHook",
  priority: -10
};
const _Application = class _Application2 {
  constructor(...args) {
    this.stage = new Container();
    if (args[0] !== void 0) {
      deprecation(v8_0_0, "Application constructor options are deprecated, please use Application.init() instead.");
    }
  }
  /**
   * Initializes the PixiJS application with the specified options.
   *
   * This method must be called after creating a new Application instance.
   * @param options - Configuration options for the application and renderer
   * @returns A promise that resolves when initialization is complete
   * @example
   * ```js
   * const app = new Application();
   *
   * // Initialize with custom options
   * await app.init({
   *     width: 800,
   *     height: 600,
   *     backgroundColor: 0x1099bb,
   *     preference: 'webgl', // or 'webgpu'
   * });
   * ```
   */
  async init(options) {
    options = { ...options };
    this.stage || (this.stage = new Container());
    this.renderer = await autoDetectRenderer(options);
    _Application2._plugins.forEach((plugin) => {
      plugin.init.call(this, options);
    });
  }
  /**
   * Renders the current stage to the screen.
   *
   * When using the default setup with {@link TickerPlugin} (enabled by default), you typically don't need to call
   * this method directly as rendering is handled automatically.
   *
   * Only use this method if you've disabled the {@link TickerPlugin} or need custom
   * render timing control.
   * @example
   * ```js
   * // Example 1: Default setup (TickerPlugin handles rendering)
   * const app = new Application();
   * await app.init();
   * // No need to call render() - TickerPlugin handles it
   *
   * // Example 2: Custom rendering loop (if TickerPlugin is disabled)
   * const app = new Application();
   * await app.init({ autoStart: false }); // Disable automatic rendering
   *
   * function animate() {
   *     app.render();
   *     requestAnimationFrame(animate);
   * }
   * animate();
   * ```
   */
  render() {
    this.renderer.render({ container: this.stage });
  }
  /**
   * Reference to the renderer's canvas element. This is the HTML element
   * that displays your application's graphics.
   * @readonly
   * @type {HTMLCanvasElement}
   * @example
   * ```js
   * // Create a new application
   * const app = new Application();
   * // Initialize the application
   * await app.init({...});
   * // Add canvas to the page
   * document.body.appendChild(app.canvas);
   *
   * // Access the canvas directly
   * console.log(app.canvas); // HTMLCanvasElement
   * ```
   */
  get canvas() {
    return this.renderer.canvas;
  }
  /**
   * Reference to the renderer's canvas element.
   * @type {HTMLCanvasElement}
   * @deprecated since 8.0.0
   * @see {@link Application#canvas}
   */
  get view() {
    deprecation(v8_0_0, "Application.view is deprecated, please use Application.canvas instead.");
    return this.renderer.canvas;
  }
  /**
   * Reference to the renderer's screen rectangle. This represents the visible area of your application.
   *
   * It's commonly used for:
   * - Setting filter areas for full-screen effects
   * - Defining hit areas for screen-wide interaction
   * - Determining the visible bounds of your application
   * @readonly
   * @example
   * ```js
   * // Use as filter area for a full-screen effect
   * const blurFilter = new BlurFilter();
   * sprite.filterArea = app.screen;
   *
   * // Use as hit area for screen-wide interaction
   * const screenSprite = new Sprite();
   * screenSprite.hitArea = app.screen;
   *
   * // Get screen dimensions
   * console.log(app.screen.width, app.screen.height);
   * ```
   * @see {@link Rectangle} For all available properties and methods
   */
  get screen() {
    return this.renderer.screen;
  }
  /**
   * Destroys the application and all of its resources.
   *
   * This method should be called when you want to completely
   * clean up the application and free all associated memory.
   * @param rendererDestroyOptions - Options for destroying the renderer:
   *  - `false` or `undefined`: Preserves the canvas element (default)
   *  - `true`: Removes the canvas element
   *  - `{ removeView: boolean }`: Object with removeView property to control canvas removal
   * @param options - Options for destroying the application:
   *  - `false` or `undefined`: Basic cleanup (default)
   *  - `true`: Complete cleanup including children
   *  - Detailed options object:
   *    - `children`: Remove children
   *    - `texture`: Destroy textures
   *    - `textureSource`: Destroy texture sources
   *    - `context`: Destroy WebGL context
   * @example
   * ```js
   * // Basic cleanup
   * app.destroy();
   *
   * // Remove canvas and do complete cleanup
   * app.destroy(true, true);
   *
   * // Remove canvas with explicit options
   * app.destroy({ removeView: true }, true);
   *
   * // Detailed cleanup with specific options
   * app.destroy(
   *     { removeView: true },
   *     {
   *         children: true,
   *         texture: true,
   *         textureSource: true,
   *         context: true
   *     }
   * );
   * ```
   * > [!WARNING] After calling destroy, the application instance should no longer be used.
   * > All properties will be null and further operations will throw errors.
   */
  destroy(rendererDestroyOptions = false, options = false) {
    const plugins = _Application2._plugins.slice(0);
    plugins.reverse();
    plugins.forEach((plugin) => {
      plugin.destroy.call(this);
    });
    this.stage.destroy(options);
    this.stage = null;
    this.renderer.destroy(rendererDestroyOptions);
    this.renderer = null;
  }
};
_Application._plugins = [];
let Application = _Application;
extensions.handleByList(ExtensionType.Application, Application._plugins);
extensions.add(ApplicationInitHook);
class AbstractBitmapFont extends EventEmitter {
  constructor() {
    super(...arguments);
    this.chars = /* @__PURE__ */ Object.create(null);
    this.lineHeight = 0;
    this.fontFamily = "";
    this.fontMetrics = { fontSize: 0, ascent: 0, descent: 0 };
    this.baseLineOffset = 0;
    this.distanceField = { type: "none", range: 0 };
    this.pages = [];
    this.applyFillAsTint = true;
    this.baseMeasurementFontSize = 100;
    this.baseRenderedFontSize = 100;
  }
  /**
   * The name of the font face.
   * @deprecated since 8.0.0 Use `fontFamily` instead.
   */
  get font() {
    deprecation(v8_0_0, "BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead.");
    return this.fontFamily;
  }
  /**
   * The map of base page textures (i.e., sheets of glyphs).
   * @deprecated since 8.0.0 Use `pages` instead.
   */
  get pageTextures() {
    deprecation(v8_0_0, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.");
    return this.pages;
  }
  /**
   * The size of the font face in pixels.
   * @deprecated since 8.0.0 Use `fontMetrics.fontSize` instead.
   */
  get size() {
    deprecation(v8_0_0, "BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead.");
    return this.fontMetrics.fontSize;
  }
  /**
   * The kind of distance field for this font or "none".
   * @deprecated since 8.0.0 Use `distanceField.type` instead.
   */
  get distanceFieldRange() {
    deprecation(v8_0_0, "BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead.");
    return this.distanceField.range;
  }
  /**
   * The range of the distance field in pixels.
   * @deprecated since 8.0.0 Use `distanceField.range` instead.
   */
  get distanceFieldType() {
    deprecation(v8_0_0, "BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead.");
    return this.distanceField.type;
  }
  destroy(destroyTextures = false) {
    var _a;
    this.emit("destroy", this);
    this.removeAllListeners();
    for (const i2 in this.chars) {
      (_a = this.chars[i2].texture) == null ? void 0 : _a.destroy();
    }
    this.chars = null;
    if (destroyTextures) {
      this.pages.forEach((page) => page.texture.destroy(true));
      this.pages = null;
    }
  }
}
/**
 * tiny-lru
 *
 * @copyright 2025 Jason Mulligan <jason.mulligan@avoidwork.com>
 * @license BSD-3-Clause
 * @version 11.4.5
 */
class LRU {
  /**
   * Creates a new LRU cache instance.
   * Note: Constructor does not validate parameters. Use lru() factory function for parameter validation.
   *
   * @constructor
   * @param {number} [max=0] - Maximum number of items to store. 0 means unlimited.
   * @param {number} [ttl=0] - Time to live in milliseconds. 0 means no expiration.
   * @param {boolean} [resetTtl=false] - Whether to reset TTL when accessing existing items via get().
   * @example
   * const cache = new LRU(1000, 60000, true); // 1000 items, 1 minute TTL, reset on access
   * @see {@link lru} For parameter validation
   * @since 1.0.0
   */
  constructor(max = 0, ttl = 0, resetTtl = false) {
    this.first = null;
    this.items = /* @__PURE__ */ Object.create(null);
    this.last = null;
    this.max = max;
    this.resetTtl = resetTtl;
    this.size = 0;
    this.ttl = ttl;
  }
  /**
   * Removes all items from the cache.
   *
   * @method clear
   * @memberof LRU
   * @returns {LRU} The LRU instance for method chaining.
   * @example
   * cache.clear();
   * console.log(cache.size); // 0
   * @since 1.0.0
   */
  clear() {
    this.first = null;
    this.items = /* @__PURE__ */ Object.create(null);
    this.last = null;
    this.size = 0;
    return this;
  }
  /**
   * Removes an item from the cache by key.
   *
   * @method delete
   * @memberof LRU
   * @param {string} key - The key of the item to delete.
   * @returns {LRU} The LRU instance for method chaining.
   * @example
   * cache.set('key1', 'value1');
   * cache.delete('key1');
   * console.log(cache.has('key1')); // false
   * @see {@link LRU#has}
   * @see {@link LRU#clear}
   * @since 1.0.0
   */
  delete(key2) {
    if (this.has(key2)) {
      const item = this.items[key2];
      delete this.items[key2];
      this.size--;
      if (item.prev !== null) {
        item.prev.next = item.next;
      }
      if (item.next !== null) {
        item.next.prev = item.prev;
      }
      if (this.first === item) {
        this.first = item.next;
      }
      if (this.last === item) {
        this.last = item.prev;
      }
    }
    return this;
  }
  /**
   * Returns an array of [key, value] pairs for the specified keys.
   * Order follows LRU order (least to most recently used).
   *
   * @method entries
   * @memberof LRU
   * @param {string[]} [keys=this.keys()] - Array of keys to get entries for. Defaults to all keys.
   * @returns {Array<Array<*>>} Array of [key, value] pairs in LRU order.
   * @example
   * cache.set('a', 1).set('b', 2);
   * console.log(cache.entries()); // [['a', 1], ['b', 2]]
   * console.log(cache.entries(['a'])); // [['a', 1]]
   * @see {@link LRU#keys}
   * @see {@link LRU#values}
   * @since 11.1.0
   */
  entries(keys = this.keys()) {
    return keys.map((key2) => [key2, this.get(key2)]);
  }
  /**
   * Removes the least recently used item from the cache.
   *
   * @method evict
   * @memberof LRU
   * @param {boolean} [bypass=false] - Whether to force eviction even when cache is empty.
   * @returns {LRU} The LRU instance for method chaining.
   * @example
   * cache.set('old', 'value').set('new', 'value');
   * cache.evict(); // Removes 'old' item
   * @see {@link LRU#setWithEvicted}
   * @since 1.0.0
   */
  evict(bypass = false) {
    if (bypass || this.size > 0) {
      const item = this.first;
      delete this.items[item.key];
      if (--this.size === 0) {
        this.first = null;
        this.last = null;
      } else {
        this.first = item.next;
        this.first.prev = null;
      }
    }
    return this;
  }
  /**
   * Returns the expiration timestamp for a given key.
   *
   * @method expiresAt
   * @memberof LRU
   * @param {string} key - The key to check expiration for.
   * @returns {number|undefined} The expiration timestamp in milliseconds, or undefined if key doesn't exist.
   * @example
   * const cache = new LRU(100, 5000); // 5 second TTL
   * cache.set('key1', 'value1');
   * console.log(cache.expiresAt('key1')); // timestamp 5 seconds from now
   * @see {@link LRU#get}
   * @see {@link LRU#has}
   * @since 1.0.0
   */
  expiresAt(key2) {
    let result;
    if (this.has(key2)) {
      result = this.items[key2].expiry;
    }
    return result;
  }
  /**
   * Retrieves a value from the cache by key. Updates the item's position to most recently used.
   *
   * @method get
   * @memberof LRU
   * @param {string} key - The key to retrieve.
   * @returns {*} The value associated with the key, or undefined if not found or expired.
   * @example
   * cache.set('key1', 'value1');
   * console.log(cache.get('key1')); // 'value1'
   * console.log(cache.get('nonexistent')); // undefined
   * @see {@link LRU#set}
   * @see {@link LRU#has}
   * @since 1.0.0
   */
  get(key2) {
    const item = this.items[key2];
    if (item !== void 0) {
      if (this.ttl > 0) {
        if (item.expiry <= Date.now()) {
          this.delete(key2);
          return void 0;
        }
      }
      this.moveToEnd(item);
      return item.value;
    }
    return void 0;
  }
  /**
   * Checks if a key exists in the cache.
   *
   * @method has
   * @memberof LRU
   * @param {string} key - The key to check for.
   * @returns {boolean} True if the key exists, false otherwise.
   * @example
   * cache.set('key1', 'value1');
   * console.log(cache.has('key1')); // true
   * console.log(cache.has('nonexistent')); // false
   * @see {@link LRU#get}
   * @see {@link LRU#delete}
   * @since 9.0.0
   */
  has(key2) {
    return key2 in this.items;
  }
  /**
   * Efficiently moves an item to the end of the LRU list (most recently used position).
   * This is an internal optimization method that avoids the overhead of the full set() operation
   * when only LRU position needs to be updated.
   *
   * @method moveToEnd
   * @memberof LRU
   * @param {Object} item - The cache item with prev/next pointers to reposition.
   * @private
   * @since 11.3.5
   */
  moveToEnd(item) {
    if (this.last === item) {
      return;
    }
    if (item.prev !== null) {
      item.prev.next = item.next;
    }
    if (item.next !== null) {
      item.next.prev = item.prev;
    }
    if (this.first === item) {
      this.first = item.next;
    }
    item.prev = this.last;
    item.next = null;
    if (this.last !== null) {
      this.last.next = item;
    }
    this.last = item;
    if (this.first === null) {
      this.first = item;
    }
  }
  /**
   * Returns an array of all keys in the cache, ordered from least to most recently used.
   *
   * @method keys
   * @memberof LRU
   * @returns {string[]} Array of keys in LRU order.
   * @example
   * cache.set('a', 1).set('b', 2);
   * cache.get('a'); // Move 'a' to most recent
   * console.log(cache.keys()); // ['b', 'a']
   * @see {@link LRU#values}
   * @see {@link LRU#entries}
   * @since 9.0.0
   */
  keys() {
    const result = [];
    let x2 = this.first;
    while (x2 !== null) {
      result.push(x2.key);
      x2 = x2.next;
    }
    return result;
  }
  /**
   * Sets a value in the cache and returns any evicted item.
   *
   * @method setWithEvicted
   * @memberof LRU
   * @param {string} key - The key to set.
   * @param {*} value - The value to store.
   * @param {boolean} [resetTtl=this.resetTtl] - Whether to reset the TTL for this operation.
   * @returns {Object|null} The evicted item (if any) with shape {key, value, expiry, prev, next}, or null.
   * @example
   * const cache = new LRU(2);
   * cache.set('a', 1).set('b', 2);
   * const evicted = cache.setWithEvicted('c', 3); // evicted = {key: 'a', value: 1, ...}
   * @see {@link LRU#set}
   * @see {@link LRU#evict}
   * @since 11.3.0
   */
  setWithEvicted(key2, value2, resetTtl = this.resetTtl) {
    let evicted = null;
    if (this.has(key2)) {
      this.set(key2, value2, true, resetTtl);
    } else {
      if (this.max > 0 && this.size === this.max) {
        evicted = { ...this.first };
        this.evict(true);
      }
      let item = this.items[key2] = {
        expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
        key: key2,
        prev: this.last,
        next: null,
        value: value2
      };
      if (++this.size === 1) {
        this.first = item;
      } else {
        this.last.next = item;
      }
      this.last = item;
    }
    return evicted;
  }
  /**
   * Sets a value in the cache. Updates the item's position to most recently used.
   *
   * @method set
   * @memberof LRU
   * @param {string} key - The key to set.
   * @param {*} value - The value to store.
   * @param {boolean} [bypass=false] - Internal parameter for setWithEvicted method.
   * @param {boolean} [resetTtl=this.resetTtl] - Whether to reset the TTL for this operation.
   * @returns {LRU} The LRU instance for method chaining.
   * @example
   * cache.set('key1', 'value1')
   *      .set('key2', 'value2')
   *      .set('key3', 'value3');
   * @see {@link LRU#get}
   * @see {@link LRU#setWithEvicted}
   * @since 1.0.0
   */
  set(key2, value2, bypass = false, resetTtl = this.resetTtl) {
    let item = this.items[key2];
    if (bypass || item !== void 0) {
      item.value = value2;
      if (bypass === false && resetTtl) {
        item.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;
      }
      this.moveToEnd(item);
    } else {
      if (this.max > 0 && this.size === this.max) {
        this.evict(true);
      }
      item = this.items[key2] = {
        expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
        key: key2,
        prev: this.last,
        next: null,
        value: value2
      };
      if (++this.size === 1) {
        this.first = item;
      } else {
        this.last.next = item;
      }
      this.last = item;
    }
    return this;
  }
  /**
   * Returns an array of all values in the cache for the specified keys.
   * Order follows LRU order (least to most recently used).
   *
   * @method values
   * @memberof LRU
   * @param {string[]} [keys=this.keys()] - Array of keys to get values for. Defaults to all keys.
   * @returns {Array<*>} Array of values corresponding to the keys in LRU order.
   * @example
   * cache.set('a', 1).set('b', 2);
   * console.log(cache.values()); // [1, 2]
   * console.log(cache.values(['a'])); // [1]
   * @see {@link LRU#keys}
   * @see {@link LRU#entries}
   * @since 11.1.0
   */
  values(keys = this.keys()) {
    return keys.map((key2) => this.get(key2));
  }
}
function lru(max = 1e3, ttl = 0, resetTtl = false) {
  if (isNaN(max) || max < 0) {
    throw new TypeError("Invalid max value");
  }
  if (isNaN(ttl) || ttl < 0) {
    throw new TypeError("Invalid ttl value");
  }
  if (typeof resetTtl !== "boolean") {
    throw new TypeError("Invalid resetTtl value");
  }
  return new LRU(max, ttl, resetTtl);
}
const genericFontFamilies = [
  "serif",
  "sans-serif",
  "monospace",
  "cursive",
  "fantasy",
  "system-ui"
];
function fontStringFromTextStyle(style) {
  const fontSizeString = typeof style.fontSize === "number" ? `${style.fontSize}px` : style.fontSize;
  let fontFamilies = style.fontFamily;
  if (!Array.isArray(style.fontFamily)) {
    fontFamilies = style.fontFamily.split(",");
  }
  for (let i2 = fontFamilies.length - 1; i2 >= 0; i2--) {
    let fontFamily = fontFamilies[i2].trim();
    if (!/([\"\'])[^\'\"]+\1/.test(fontFamily) && !genericFontFamilies.includes(fontFamily)) {
      fontFamily = `"${fontFamily}"`;
    }
    fontFamilies[i2] = fontFamily;
  }
  return `${style.fontStyle} ${style.fontVariant} ${style.fontWeight} ${fontSizeString} ${fontFamilies.join(",")}`;
}
const contextSettings = {
  // TextMetrics requires getImageData readback for measuring fonts.
  willReadFrequently: true
};
const _CanvasTextMetrics = class _CanvasTextMetrics2 {
  /**
   * Checking that we can use modern canvas 2D API.
   *
   * Note: This is an unstable API, Chrome < 94 use `textLetterSpacing`, later versions use `letterSpacing`.
   * @see TextMetrics.experimentalLetterSpacing
   * @see https://developer.mozilla.org/en-US/docs/Web/API/ICanvasRenderingContext2D/letterSpacing
   * @see https://developer.chrome.com/origintrials/#/view_trial/3585991203293757441
   */
  static get experimentalLetterSpacingSupported() {
    let result = _CanvasTextMetrics2._experimentalLetterSpacingSupported;
    if (result === void 0) {
      const proto = DOMAdapter.get().getCanvasRenderingContext2D().prototype;
      result = _CanvasTextMetrics2._experimentalLetterSpacingSupported = "letterSpacing" in proto || "textLetterSpacing" in proto;
    }
    return result;
  }
  /**
   * @param text - the text that was measured
   * @param style - the style that was measured
   * @param width - the measured width of the text
   * @param height - the measured height of the text
   * @param lines - an array of the lines of text broken by new lines and wrapping if specified in style
   * @param lineWidths - an array of the line widths for each line matched to `lines`
   * @param lineHeight - the measured line height for this style
   * @param maxLineWidth - the maximum line width for all measured lines
   * @param {FontMetrics} fontProperties - the font properties object from TextMetrics.measureFont
   */
  constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {
    this.text = text;
    this.style = style;
    this.width = width;
    this.height = height;
    this.lines = lines;
    this.lineWidths = lineWidths;
    this.lineHeight = lineHeight;
    this.maxLineWidth = maxLineWidth;
    this.fontProperties = fontProperties;
  }
  /**
   * Measures the supplied string of text and returns a Rectangle.
   * @param text - The text to measure.
   * @param style - The text style to use for measuring
   * @param canvas - optional specification of the canvas to use for measuring.
   * @param wordWrap
   * @returns Measured width and height of the text.
   */
  static measureText(text = " ", style, canvas = _CanvasTextMetrics2._canvas, wordWrap = style.wordWrap) {
    var _a;
    const textKey = `${text}-${style.styleKey}-wordWrap-${wordWrap}`;
    if (_CanvasTextMetrics2._measurementCache.has(textKey)) {
      return _CanvasTextMetrics2._measurementCache.get(textKey);
    }
    const font = fontStringFromTextStyle(style);
    const fontProperties = _CanvasTextMetrics2.measureFont(font);
    if (fontProperties.fontSize === 0) {
      fontProperties.fontSize = style.fontSize;
      fontProperties.ascent = style.fontSize;
    }
    const context2 = _CanvasTextMetrics2.__context;
    context2.font = font;
    const outputText = wordWrap ? _CanvasTextMetrics2._wordWrap(text, style, canvas) : text;
    const lines = outputText.split(/(?:\r\n|\r|\n)/);
    const lineWidths = new Array(lines.length);
    let maxLineWidth = 0;
    for (let i2 = 0; i2 < lines.length; i2++) {
      const lineWidth = _CanvasTextMetrics2._measureText(lines[i2], style.letterSpacing, context2);
      lineWidths[i2] = lineWidth;
      maxLineWidth = Math.max(maxLineWidth, lineWidth);
    }
    const strokeWidth = ((_a = style._stroke) == null ? void 0 : _a.width) || 0;
    let width = maxLineWidth + strokeWidth;
    if (style.dropShadow) {
      width += style.dropShadow.distance;
    }
    const lineHeight = style.lineHeight || fontProperties.fontSize;
    let height = Math.max(lineHeight, fontProperties.fontSize + strokeWidth) + (lines.length - 1) * (lineHeight + style.leading);
    if (style.dropShadow) {
      height += style.dropShadow.distance;
    }
    const measurements = new _CanvasTextMetrics2(
      text,
      style,
      width,
      height,
      lines,
      lineWidths,
      lineHeight + style.leading,
      maxLineWidth,
      fontProperties
    );
    _CanvasTextMetrics2._measurementCache.set(textKey, measurements);
    return measurements;
  }
  static _measureText(text, letterSpacing, context2) {
    let useExperimentalLetterSpacing = false;
    if (_CanvasTextMetrics2.experimentalLetterSpacingSupported) {
      if (_CanvasTextMetrics2.experimentalLetterSpacing) {
        context2.letterSpacing = `${letterSpacing}px`;
        context2.textLetterSpacing = `${letterSpacing}px`;
        useExperimentalLetterSpacing = true;
      } else {
        context2.letterSpacing = "0px";
        context2.textLetterSpacing = "0px";
      }
    }
    const metrics = context2.measureText(text);
    let metricWidth = metrics.width;
    const actualBoundingBoxLeft = -metrics.actualBoundingBoxLeft;
    const actualBoundingBoxRight = metrics.actualBoundingBoxRight;
    let boundsWidth = actualBoundingBoxRight - actualBoundingBoxLeft;
    if (metricWidth > 0) {
      if (useExperimentalLetterSpacing) {
        metricWidth -= letterSpacing;
        boundsWidth -= letterSpacing;
      } else {
        const val = (_CanvasTextMetrics2.graphemeSegmenter(text).length - 1) * letterSpacing;
        metricWidth += val;
        boundsWidth += val;
      }
    }
    return Math.max(metricWidth, boundsWidth);
  }
  /**
   * Applies newlines to a string to have it optimally fit into the horizontal
   * bounds set by the Text object's wordWrapWidth property.
   * @param text - String to apply word wrapping to
   * @param style - the style to use when wrapping
   * @param canvas - optional specification of the canvas to use for measuring.
   * @returns New string with new lines applied where required
   */
  static _wordWrap(text, style, canvas = _CanvasTextMetrics2._canvas) {
    const context2 = canvas.getContext("2d", contextSettings);
    let width = 0;
    let line = "";
    let lines = "";
    const cache = /* @__PURE__ */ Object.create(null);
    const { letterSpacing, whiteSpace } = style;
    const collapseSpaces = _CanvasTextMetrics2._collapseSpaces(whiteSpace);
    const collapseNewlines = _CanvasTextMetrics2._collapseNewlines(whiteSpace);
    let canPrependSpaces = !collapseSpaces;
    const wordWrapWidth = style.wordWrapWidth + letterSpacing;
    const tokens = _CanvasTextMetrics2._tokenize(text);
    for (let i2 = 0; i2 < tokens.length; i2++) {
      let token = tokens[i2];
      if (_CanvasTextMetrics2._isNewline(token)) {
        if (!collapseNewlines) {
          lines += _CanvasTextMetrics2._addLine(line);
          canPrependSpaces = !collapseSpaces;
          line = "";
          width = 0;
          continue;
        }
        token = " ";
      }
      if (collapseSpaces) {
        const currIsBreakingSpace = _CanvasTextMetrics2.isBreakingSpace(token);
        const lastIsBreakingSpace = _CanvasTextMetrics2.isBreakingSpace(line[line.length - 1]);
        if (currIsBreakingSpace && lastIsBreakingSpace) {
          continue;
        }
      }
      const tokenWidth = _CanvasTextMetrics2._getFromCache(token, letterSpacing, cache, context2);
      if (tokenWidth > wordWrapWidth) {
        if (line !== "") {
          lines += _CanvasTextMetrics2._addLine(line);
          line = "";
          width = 0;
        }
        if (_CanvasTextMetrics2.canBreakWords(token, style.breakWords)) {
          const characters = _CanvasTextMetrics2.wordWrapSplit(token);
          for (let j2 = 0; j2 < characters.length; j2++) {
            let char = characters[j2];
            let lastChar = char;
            let k2 = 1;
            while (characters[j2 + k2]) {
              const nextChar = characters[j2 + k2];
              if (!_CanvasTextMetrics2.canBreakChars(lastChar, nextChar, token, j2, style.breakWords)) {
                char += nextChar;
              } else {
                break;
              }
              lastChar = nextChar;
              k2++;
            }
            j2 += k2 - 1;
            const characterWidth = _CanvasTextMetrics2._getFromCache(char, letterSpacing, cache, context2);
            if (characterWidth + width > wordWrapWidth) {
              lines += _CanvasTextMetrics2._addLine(line);
              canPrependSpaces = false;
              line = "";
              width = 0;
            }
            line += char;
            width += characterWidth;
          }
        } else {
          if (line.length > 0) {
            lines += _CanvasTextMetrics2._addLine(line);
            line = "";
            width = 0;
          }
          const isLastToken = i2 === tokens.length - 1;
          lines += _CanvasTextMetrics2._addLine(token, !isLastToken);
          canPrependSpaces = false;
          line = "";
          width = 0;
        }
      } else {
        if (tokenWidth + width > wordWrapWidth) {
          canPrependSpaces = false;
          lines += _CanvasTextMetrics2._addLine(line);
          line = "";
          width = 0;
        }
        if (line.length > 0 || !_CanvasTextMetrics2.isBreakingSpace(token) || canPrependSpaces) {
          line += token;
          width += tokenWidth;
        }
      }
    }
    lines += _CanvasTextMetrics2._addLine(line, false);
    return lines;
  }
  /**
   * Convenience function for logging each line added during the wordWrap method.
   * @param line    - The line of text to add
   * @param newLine - Add new line character to end
   * @returns A formatted line
   */
  static _addLine(line, newLine = true) {
    line = _CanvasTextMetrics2._trimRight(line);
    line = newLine ? `${line}
` : line;
    return line;
  }
  /**
   * Gets & sets the widths of calculated characters in a cache object
   * @param key            - The key
   * @param letterSpacing  - The letter spacing
   * @param cache          - The cache
   * @param context        - The canvas context
   * @returns The from cache.
   */
  static _getFromCache(key2, letterSpacing, cache, context2) {
    let width = cache[key2];
    if (typeof width !== "number") {
      width = _CanvasTextMetrics2._measureText(key2, letterSpacing, context2) + letterSpacing;
      cache[key2] = width;
    }
    return width;
  }
  /**
   * Determines whether we should collapse breaking spaces.
   * @param whiteSpace - The TextStyle property whiteSpace
   * @returns Should collapse
   */
  static _collapseSpaces(whiteSpace) {
    return whiteSpace === "normal" || whiteSpace === "pre-line";
  }
  /**
   * Determines whether we should collapse newLine chars.
   * @param whiteSpace - The white space
   * @returns should collapse
   */
  static _collapseNewlines(whiteSpace) {
    return whiteSpace === "normal";
  }
  /**
   * Trims breaking whitespaces from string.
   * @param text - The text
   * @returns Trimmed string
   */
  static _trimRight(text) {
    if (typeof text !== "string") {
      return "";
    }
    for (let i2 = text.length - 1; i2 >= 0; i2--) {
      const char = text[i2];
      if (!_CanvasTextMetrics2.isBreakingSpace(char)) {
        break;
      }
      text = text.slice(0, -1);
    }
    return text;
  }
  /**
   * Determines if char is a newline.
   * @param char - The character
   * @returns True if newline, False otherwise.
   */
  static _isNewline(char) {
    if (typeof char !== "string") {
      return false;
    }
    return _CanvasTextMetrics2._newlines.includes(char.charCodeAt(0));
  }
  /**
   * Determines if char is a breaking whitespace.
   *
   * It allows one to determine whether char should be a breaking whitespace
   * For example certain characters in CJK langs or numbers.
   * It must return a boolean.
   * @param char - The character
   * @param [_nextChar] - The next character
   * @returns True if whitespace, False otherwise.
   */
  static isBreakingSpace(char, _nextChar) {
    if (typeof char !== "string") {
      return false;
    }
    return _CanvasTextMetrics2._breakingSpaces.includes(char.charCodeAt(0));
  }
  /**
   * Splits a string into words, breaking-spaces and newLine characters
   * @param text - The text
   * @returns A tokenized array
   */
  static _tokenize(text) {
    const tokens = [];
    let token = "";
    if (typeof text !== "string") {
      return tokens;
    }
    for (let i2 = 0; i2 < text.length; i2++) {
      const char = text[i2];
      const nextChar = text[i2 + 1];
      if (_CanvasTextMetrics2.isBreakingSpace(char, nextChar) || _CanvasTextMetrics2._isNewline(char)) {
        if (token !== "") {
          tokens.push(token);
          token = "";
        }
        if (char === "\r" && nextChar === "\n") {
          tokens.push("\r\n");
          i2++;
        } else {
          tokens.push(char);
        }
        continue;
      }
      token += char;
    }
    if (token !== "") {
      tokens.push(token);
    }
    return tokens;
  }
  /**
   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
   *
   * It allows one to customise which words should break
   * Examples are if the token is CJK or numbers.
   * It must return a boolean.
   * @param _token - The token
   * @param breakWords - The style attr break words
   * @returns Whether to break word or not
   */
  static canBreakWords(_token, breakWords) {
    return breakWords;
  }
  /**
   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
   *
   * It allows one to determine whether a pair of characters
   * should be broken by newlines
   * For example certain characters in CJK langs or numbers.
   * It must return a boolean.
   * @param _char - The character
   * @param _nextChar - The next character
   * @param _token - The token/word the characters are from
   * @param _index - The index in the token of the char
   * @param _breakWords - The style attr break words
   * @returns whether to break word or not
   */
  static canBreakChars(_char, _nextChar, _token, _index, _breakWords) {
    return true;
  }
  /**
   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
   *
   * It is called when a token (usually a word) has to be split into separate pieces
   * in order to determine the point to break a word.
   * It must return an array of characters.
   * @param token - The token to split
   * @returns The characters of the token
   * @see CanvasTextMetrics.graphemeSegmenter
   */
  static wordWrapSplit(token) {
    return _CanvasTextMetrics2.graphemeSegmenter(token);
  }
  /**
   * Calculates the ascent, descent and fontSize of a given font-style
   * @param font - String representing the style of the font
   * @returns Font properties object
   */
  static measureFont(font) {
    if (_CanvasTextMetrics2._fonts[font]) {
      return _CanvasTextMetrics2._fonts[font];
    }
    const context2 = _CanvasTextMetrics2._context;
    context2.font = font;
    const metrics = context2.measureText(_CanvasTextMetrics2.METRICS_STRING + _CanvasTextMetrics2.BASELINE_SYMBOL);
    const properties2 = {
      ascent: metrics.actualBoundingBoxAscent,
      descent: metrics.actualBoundingBoxDescent,
      fontSize: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent
    };
    _CanvasTextMetrics2._fonts[font] = properties2;
    return properties2;
  }
  /**
   * Clear font metrics in metrics cache.
   * @param {string} [font] - font name. If font name not set then clear cache for all fonts.
   */
  static clearMetrics(font = "") {
    if (font) {
      delete _CanvasTextMetrics2._fonts[font];
    } else {
      _CanvasTextMetrics2._fonts = {};
    }
  }
  /**
   * Cached canvas element for measuring text
   * TODO: this should be private, but isn't because of backward compat, will fix later.
   * @ignore
   */
  static get _canvas() {
    if (!_CanvasTextMetrics2.__canvas) {
      let canvas;
      try {
        const c2 = new OffscreenCanvas(0, 0);
        const context2 = c2.getContext("2d", contextSettings);
        if (context2 == null ? void 0 : context2.measureText) {
          _CanvasTextMetrics2.__canvas = c2;
          return c2;
        }
        canvas = DOMAdapter.get().createCanvas();
      } catch (_cx) {
        canvas = DOMAdapter.get().createCanvas();
      }
      canvas.width = canvas.height = 10;
      _CanvasTextMetrics2.__canvas = canvas;
    }
    return _CanvasTextMetrics2.__canvas;
  }
  /**
   * TODO: this should be private, but isn't because of backward compat, will fix later.
   * @ignore
   */
  static get _context() {
    if (!_CanvasTextMetrics2.__context) {
      _CanvasTextMetrics2.__context = _CanvasTextMetrics2._canvas.getContext("2d", contextSettings);
    }
    return _CanvasTextMetrics2.__context;
  }
};
_CanvasTextMetrics.METRICS_STRING = "|q";
_CanvasTextMetrics.BASELINE_SYMBOL = "M";
_CanvasTextMetrics.BASELINE_MULTIPLIER = 1.4;
_CanvasTextMetrics.HEIGHT_MULTIPLIER = 2;
_CanvasTextMetrics.graphemeSegmenter = (() => {
  if (typeof (Intl == null ? void 0 : Intl.Segmenter) === "function") {
    const segmenter = new Intl.Segmenter();
    return (s2) => {
      const segments = segmenter.segment(s2);
      const result = [];
      let i2 = 0;
      for (const segment of segments) {
        result[i2++] = segment.segment;
      }
      return result;
    };
  }
  return (s2) => [...s2];
})();
_CanvasTextMetrics.experimentalLetterSpacing = false;
_CanvasTextMetrics._fonts = {};
_CanvasTextMetrics._newlines = [
  10,
  // line feed
  13
  // carriage return
];
_CanvasTextMetrics._breakingSpaces = [
  9,
  // character tabulation
  32,
  // space
  8192,
  // en quad
  8193,
  // em quad
  8194,
  // en space
  8195,
  // em space
  8196,
  // three-per-em space
  8197,
  // four-per-em space
  8198,
  // six-per-em space
  8200,
  // punctuation space
  8201,
  // thin space
  8202,
  // hair space
  8287,
  // medium mathematical space
  12288
  // ideographic space
];
_CanvasTextMetrics._measurementCache = lru(1e3);
let CanvasTextMetrics = _CanvasTextMetrics;
const emptyColorStops = [{ offset: 0, color: "white" }, { offset: 1, color: "black" }];
const _FillGradient = class _FillGradient2 {
  constructor(...args) {
    this.uid = uid("fillGradient");
    this._tick = 0;
    this.type = "linear";
    this.colorStops = [];
    let options = ensureGradientOptions(args);
    const defaults = options.type === "radial" ? _FillGradient2.defaultRadialOptions : _FillGradient2.defaultLinearOptions;
    options = { ...defaults, ...definedProps(options) };
    this._textureSize = options.textureSize;
    this._wrapMode = options.wrapMode;
    if (options.type === "radial") {
      this.center = options.center;
      this.outerCenter = options.outerCenter ?? this.center;
      this.innerRadius = options.innerRadius;
      this.outerRadius = options.outerRadius;
      this.scale = options.scale;
      this.rotation = options.rotation;
    } else {
      this.start = options.start;
      this.end = options.end;
    }
    this.textureSpace = options.textureSpace;
    this.type = options.type;
    options.colorStops.forEach((stop) => {
      this.addColorStop(stop.offset, stop.color);
    });
  }
  /**
   * Adds a color stop to the gradient
   * @param offset - Position of the stop (0-1)
   * @param color - Color of the stop
   * @returns This gradient instance for chaining
   */
  addColorStop(offset, color) {
    this.colorStops.push({ offset, color: Color.shared.setValue(color).toHexa() });
    return this;
  }
  /**
   * Builds the internal texture and transform for the gradient.
   * Called automatically when the gradient is first used.
   * @internal
   */
  buildLinearGradient() {
    if (this.texture)
      return;
    let { x: x0, y: y0 } = this.start;
    let { x: x1, y: y1 } = this.end;
    let dx = x1 - x0;
    let dy = y1 - y0;
    const flip = dx < 0 || dy < 0;
    if (this._wrapMode === "clamp-to-edge") {
      if (dx < 0) {
        const temp = x0;
        x0 = x1;
        x1 = temp;
        dx *= -1;
      }
      if (dy < 0) {
        const temp = y0;
        y0 = y1;
        y1 = temp;
        dy *= -1;
      }
    }
    const colorStops = this.colorStops.length ? this.colorStops : emptyColorStops;
    const defaultSize = this._textureSize;
    const { canvas, context: context2 } = getCanvas(defaultSize, 1);
    const gradient = !flip ? context2.createLinearGradient(0, 0, this._textureSize, 0) : context2.createLinearGradient(this._textureSize, 0, 0, 0);
    addColorStops(gradient, colorStops);
    context2.fillStyle = gradient;
    context2.fillRect(0, 0, defaultSize, 1);
    this.texture = new Texture({
      source: new ImageSource({
        resource: canvas,
        addressMode: this._wrapMode
      })
    });
    const dist = Math.sqrt(dx * dx + dy * dy);
    const angle = Math.atan2(dy, dx);
    const m2 = new Matrix();
    m2.scale(dist / defaultSize, 1);
    m2.rotate(angle);
    m2.translate(x0, y0);
    if (this.textureSpace === "local") {
      m2.scale(defaultSize, defaultSize);
    }
    this.transform = m2;
  }
  /**
   * Builds the internal texture and transform for the gradient.
   * Called automatically when the gradient is first used.
   * @internal
   */
  buildGradient() {
    if (!this.texture)
      this._tick++;
    if (this.type === "linear") {
      this.buildLinearGradient();
    } else {
      this.buildRadialGradient();
    }
  }
  /**
   * Builds the internal texture and transform for the radial gradient.
   * Called automatically when the gradient is first used.
   * @internal
   */
  buildRadialGradient() {
    if (this.texture)
      return;
    const colorStops = this.colorStops.length ? this.colorStops : emptyColorStops;
    const defaultSize = this._textureSize;
    const { canvas, context: context2 } = getCanvas(defaultSize, defaultSize);
    const { x: x0, y: y0 } = this.center;
    const { x: x1, y: y1 } = this.outerCenter;
    const r0 = this.innerRadius;
    const r1 = this.outerRadius;
    const ox = x1 - r1;
    const oy = y1 - r1;
    const scale = defaultSize / (r1 * 2);
    const cx = (x0 - ox) * scale;
    const cy = (y0 - oy) * scale;
    const gradient = context2.createRadialGradient(
      cx,
      cy,
      r0 * scale,
      (x1 - ox) * scale,
      (y1 - oy) * scale,
      r1 * scale
    );
    addColorStops(gradient, colorStops);
    context2.fillStyle = colorStops[colorStops.length - 1].color;
    context2.fillRect(0, 0, defaultSize, defaultSize);
    context2.fillStyle = gradient;
    context2.translate(cx, cy);
    context2.rotate(this.rotation);
    context2.scale(1, this.scale);
    context2.translate(-cx, -cy);
    context2.fillRect(0, 0, defaultSize, defaultSize);
    this.texture = new Texture({
      source: new ImageSource({
        resource: canvas,
        addressMode: this._wrapMode
      })
    });
    const m2 = new Matrix();
    m2.scale(1 / scale, 1 / scale);
    m2.translate(ox, oy);
    if (this.textureSpace === "local") {
      m2.scale(defaultSize, defaultSize);
    }
    this.transform = m2;
  }
  /** Destroys the gradient, releasing resources. This will also destroy the internal texture. */
  destroy() {
    var _a;
    (_a = this.texture) == null ? void 0 : _a.destroy(true);
    this.texture = null;
    this.transform = null;
    this.colorStops = [];
    this.start = null;
    this.end = null;
    this.center = null;
    this.outerCenter = null;
  }
  /**
   * Returns a unique key for this gradient instance.
   * This key is used for caching and texture management.
   * @returns {string} Unique key for the gradient
   */
  get styleKey() {
    return `fill-gradient-${this.uid}-${this._tick}`;
  }
};
_FillGradient.defaultLinearOptions = {
  start: { x: 0, y: 0 },
  end: { x: 0, y: 1 },
  colorStops: [],
  textureSpace: "local",
  type: "linear",
  textureSize: 256,
  wrapMode: "clamp-to-edge"
};
_FillGradient.defaultRadialOptions = {
  center: { x: 0.5, y: 0.5 },
  innerRadius: 0,
  outerRadius: 0.5,
  colorStops: [],
  scale: 1,
  textureSpace: "local",
  type: "radial",
  textureSize: 256,
  wrapMode: "clamp-to-edge"
};
let FillGradient = _FillGradient;
function addColorStops(gradient, colorStops) {
  for (let i2 = 0; i2 < colorStops.length; i2++) {
    const stop = colorStops[i2];
    gradient.addColorStop(stop.offset, stop.color);
  }
}
function getCanvas(width, height) {
  const canvas = DOMAdapter.get().createCanvas(width, height);
  const context2 = canvas.getContext("2d");
  return { canvas, context: context2 };
}
function ensureGradientOptions(args) {
  let options = args[0] ?? {};
  if (typeof options === "number" || args[1]) {
    deprecation("8.5.2", `use options object instead`);
    options = {
      type: "linear",
      start: { x: args[0], y: args[1] },
      end: { x: args[2], y: args[3] },
      textureSpace: args[4],
      textureSize: args[5] ?? FillGradient.defaultLinearOptions.textureSize
    };
  }
  return options;
}
const repetitionMap = {
  repeat: {
    addressModeU: "repeat",
    addressModeV: "repeat"
  },
  "repeat-x": {
    addressModeU: "repeat",
    addressModeV: "clamp-to-edge"
  },
  "repeat-y": {
    addressModeU: "clamp-to-edge",
    addressModeV: "repeat"
  },
  "no-repeat": {
    addressModeU: "clamp-to-edge",
    addressModeV: "clamp-to-edge"
  }
};
class FillPattern {
  constructor(texture, repetition) {
    this.uid = uid("fillPattern");
    this._tick = 0;
    this.transform = new Matrix();
    this.texture = texture;
    this.transform.scale(
      1 / texture.frame.width,
      1 / texture.frame.height
    );
    if (repetition) {
      texture.source.style.addressModeU = repetitionMap[repetition].addressModeU;
      texture.source.style.addressModeV = repetitionMap[repetition].addressModeV;
    }
  }
  /**
   * Sets the transform for the pattern
   * @param transform - The transform matrix to apply to the pattern.
   * If not provided, the pattern will use the default transform.
   */
  setTransform(transform) {
    const texture = this.texture;
    this.transform.copyFrom(transform);
    this.transform.invert();
    this.transform.scale(
      1 / texture.frame.width,
      1 / texture.frame.height
    );
    this._tick++;
  }
  /** Internal texture used to render the gradient */
  get texture() {
    return this._texture;
  }
  set texture(value2) {
    if (this._texture === value2)
      return;
    this._texture = value2;
    this._tick++;
  }
  /**
   * Returns a unique key for this instance.
   * This key is used for caching.
   * @returns {string} Unique key for the instance
   */
  get styleKey() {
    return `fill-pattern-${this.uid}-${this._tick}`;
  }
  /** Destroys the fill pattern, releasing resources. This will also destroy the internal texture. */
  destroy() {
    this.texture.destroy(true);
    this.texture = null;
  }
}
var parseSvgPath;
var hasRequiredParseSvgPath;
function requireParseSvgPath() {
  if (hasRequiredParseSvgPath) return parseSvgPath;
  hasRequiredParseSvgPath = 1;
  parseSvgPath = parse2;
  var length = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 };
  var segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
  function parse2(path2) {
    var data = [];
    path2.replace(segment, function(_, command, args) {
      var type2 = command.toLowerCase();
      args = parseValues(args);
      if (type2 == "m" && args.length > 2) {
        data.push([command].concat(args.splice(0, 2)));
        type2 = "l";
        command = command == "m" ? "l" : "L";
      }
      while (true) {
        if (args.length == length[type2]) {
          args.unshift(command);
          return data.push(args);
        }
        if (args.length < length[type2]) throw new Error("malformed path data");
        data.push([command].concat(args.splice(0, length[type2])));
      }
    });
    return data;
  }
  var number = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
  function parseValues(args) {
    var numbers = args.match(number);
    return numbers ? numbers.map(Number) : [];
  }
  return parseSvgPath;
}
var parseSvgPathExports = requireParseSvgPath();
const parse = /* @__PURE__ */ getDefaultExportFromCjs(parseSvgPathExports);
function parseSVGPath(svgPath, path2) {
  const commands = parse(svgPath);
  const subpaths = [];
  let currentSubPath = null;
  let lastX = 0;
  let lastY = 0;
  for (let i2 = 0; i2 < commands.length; i2++) {
    const command = commands[i2];
    const type2 = command[0];
    const data = command;
    switch (type2) {
      case "M":
        lastX = data[1];
        lastY = data[2];
        path2.moveTo(lastX, lastY);
        break;
      case "m":
        lastX += data[1];
        lastY += data[2];
        path2.moveTo(lastX, lastY);
        break;
      case "H":
        lastX = data[1];
        path2.lineTo(lastX, lastY);
        break;
      case "h":
        lastX += data[1];
        path2.lineTo(lastX, lastY);
        break;
      case "V":
        lastY = data[1];
        path2.lineTo(lastX, lastY);
        break;
      case "v":
        lastY += data[1];
        path2.lineTo(lastX, lastY);
        break;
      case "L":
        lastX = data[1];
        lastY = data[2];
        path2.lineTo(lastX, lastY);
        break;
      case "l":
        lastX += data[1];
        lastY += data[2];
        path2.lineTo(lastX, lastY);
        break;
      case "C":
        lastX = data[5];
        lastY = data[6];
        path2.bezierCurveTo(
          data[1],
          data[2],
          // First control point
          data[3],
          data[4],
          // Second control point
          lastX,
          lastY
          // End point
        );
        break;
      case "c":
        path2.bezierCurveTo(
          lastX + data[1],
          lastY + data[2],
          // First control point
          lastX + data[3],
          lastY + data[4],
          // Second control point
          lastX + data[5],
          lastY + data[6]
          // End point
        );
        lastX += data[5];
        lastY += data[6];
        break;
      case "S":
        lastX = data[3];
        lastY = data[4];
        path2.bezierCurveToShort(
          data[1],
          data[2],
          // Control point
          lastX,
          lastY
          // End point
        );
        break;
      case "s":
        path2.bezierCurveToShort(
          lastX + data[1],
          lastY + data[2],
          // Control point
          lastX + data[3],
          lastY + data[4]
          // End point
        );
        lastX += data[3];
        lastY += data[4];
        break;
      case "Q":
        lastX = data[3];
        lastY = data[4];
        path2.quadraticCurveTo(
          data[1],
          data[2],
          // Control point
          lastX,
          lastY
          // End point
        );
        break;
      case "q":
        path2.quadraticCurveTo(
          lastX + data[1],
          lastY + data[2],
          // Control point
          lastX + data[3],
          lastY + data[4]
          // End point
        );
        lastX += data[3];
        lastY += data[4];
        break;
      case "T":
        lastX = data[1];
        lastY = data[2];
        path2.quadraticCurveToShort(
          lastX,
          lastY
          // End point
        );
        break;
      case "t":
        lastX += data[1];
        lastY += data[2];
        path2.quadraticCurveToShort(
          lastX,
          lastY
          // End point
        );
        break;
      case "A":
        lastX = data[6];
        lastY = data[7];
        path2.arcToSvg(
          data[1],
          // rx
          data[2],
          // ry
          data[3],
          // x-axis-rotation
          data[4],
          // large-arc-flag
          data[5],
          // sweep-flag
          lastX,
          lastY
          // End point
        );
        break;
      case "a":
        lastX += data[6];
        lastY += data[7];
        path2.arcToSvg(
          data[1],
          // rx
          data[2],
          // ry
          data[3],
          // x-axis-rotation
          data[4],
          // large-arc-flag
          data[5],
          // sweep-flag
          lastX,
          lastY
          // End point
        );
        break;
      case "Z":
      case "z":
        path2.closePath();
        if (subpaths.length > 0) {
          currentSubPath = subpaths.pop();
          if (currentSubPath) {
            lastX = currentSubPath.startX;
            lastY = currentSubPath.startY;
          } else {
            lastX = 0;
            lastY = 0;
          }
        }
        currentSubPath = null;
        break;
      default:
        warn(`Unknown SVG path command: ${type2}`);
    }
    if (type2 !== "Z" && type2 !== "z") {
      if (currentSubPath === null) {
        currentSubPath = { startX: lastX, startY: lastY };
        subpaths.push(currentSubPath);
      }
    }
  }
  return path2;
}
class Circle {
  /**
   * @param x - The X coordinate of the center of this circle
   * @param y - The Y coordinate of the center of this circle
   * @param radius - The radius of the circle
   */
  constructor(x2 = 0, y2 = 0, radius = 0) {
    this.type = "circle";
    this.x = x2;
    this.y = y2;
    this.radius = radius;
  }
  /**
   * Creates a clone of this Circle instance.
   * @example
   * ```ts
   * // Basic circle cloning
   * const original = new Circle(100, 100, 50);
   * const copy = original.clone();
   *
   * // Clone and modify
   * const modified = original.clone();
   * modified.radius = 75;
   *
   * // Verify independence
   * console.log(original.radius); // 50
   * console.log(modified.radius); // 75
   * ```
   * @returns A copy of the Circle
   * @see {@link Circle.copyFrom} For copying into existing circle
   * @see {@link Circle.copyTo} For copying to another circle
   */
  clone() {
    return new Circle(this.x, this.y, this.radius);
  }
  /**
   * Checks whether the x and y coordinates given are contained within this circle.
   *
   * Uses the distance formula to determine if a point is inside the circle's radius.
   *
   * Commonly used for hit testing in PixiJS events and graphics.
   * @example
   * ```ts
   * // Basic containment check
   * const circle = new Circle(100, 100, 50);
   * const isInside = circle.contains(120, 120);
   *
   * // Check mouse position
   * const circle = new Circle(0, 0, 100);
   * container.hitArea = circle;
   * container.on('pointermove', (e) => {
   *     // only called if pointer is within circle
   * });
   * ```
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coordinates are within this Circle
   * @see {@link Circle.strokeContains} For checking stroke intersection
   * @see {@link Circle.getBounds} For getting bounding box
   */
  contains(x2, y2) {
    if (this.radius <= 0)
      return false;
    const r2 = this.radius * this.radius;
    let dx = this.x - x2;
    let dy = this.y - y2;
    dx *= dx;
    dy *= dy;
    return dx + dy <= r2;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this circle including the stroke.
   * @example
   * ```ts
   * // Basic stroke check
   * const circle = new Circle(100, 100, 50);
   * const isOnStroke = circle.strokeContains(150, 100, 4); // 4px line width
   *
   * // Check with different alignments
   * const innerStroke = circle.strokeContains(150, 100, 4, 1);   // Inside
   * const centerStroke = circle.strokeContains(150, 100, 4, 0.5); // Centered
   * const outerStroke = circle.strokeContains(150, 100, 4, 0);   // Outside
   * ```
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @param width - The width of the line to check
   * @param alignment - The alignment of the stroke, 0.5 by default
   * @returns Whether the x/y coordinates are within this Circle's stroke
   * @see {@link Circle.contains} For checking fill containment
   * @see {@link Circle.getBounds} For getting stroke bounds
   */
  strokeContains(x2, y2, width, alignment = 0.5) {
    if (this.radius === 0)
      return false;
    const dx = this.x - x2;
    const dy = this.y - y2;
    const radius = this.radius;
    const outerWidth = (1 - alignment) * width;
    const distance2 = Math.sqrt(dx * dx + dy * dy);
    return distance2 <= radius + outerWidth && distance2 > radius - (width - outerWidth);
  }
  /**
   * Returns the framing rectangle of the circle as a Rectangle object.
   * @example
   * ```ts
   * // Basic bounds calculation
   * const circle = new Circle(100, 100, 50);
   * const bounds = circle.getBounds();
   * // bounds: x=50, y=50, width=100, height=100
   *
   * // Reuse existing rectangle
   * const rect = new Rectangle();
   * circle.getBounds(rect);
   * ```
   * @param out - Optional Rectangle object to store the result
   * @returns The framing rectangle
   * @see {@link Rectangle} For rectangle properties
   * @see {@link Circle.contains} For point containment
   */
  getBounds(out2) {
    out2 || (out2 = new Rectangle());
    out2.x = this.x - this.radius;
    out2.y = this.y - this.radius;
    out2.width = this.radius * 2;
    out2.height = this.radius * 2;
    return out2;
  }
  /**
   * Copies another circle to this one.
   * @example
   * ```ts
   * // Basic copying
   * const source = new Circle(100, 100, 50);
   * const target = new Circle();
   * target.copyFrom(source);
   * ```
   * @param circle - The circle to copy from
   * @returns Returns itself
   * @see {@link Circle.copyTo} For copying to another circle
   * @see {@link Circle.clone} For creating new circle copy
   */
  copyFrom(circle) {
    this.x = circle.x;
    this.y = circle.y;
    this.radius = circle.radius;
    return this;
  }
  /**
   * Copies this circle to another one.
   * @example
   * ```ts
   * // Basic copying
   * const source = new Circle(100, 100, 50);
   * const target = new Circle();
   * source.copyTo(target);
   * ```
   * @param circle - The circle to copy to
   * @returns Returns given parameter
   * @see {@link Circle.copyFrom} For copying from another circle
   * @see {@link Circle.clone} For creating new circle copy
   */
  copyTo(circle) {
    circle.copyFrom(this);
    return circle;
  }
  toString() {
    return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;
  }
}
class Ellipse {
  /**
   * @param x - The X coordinate of the center of this ellipse
   * @param y - The Y coordinate of the center of this ellipse
   * @param halfWidth - The half width of this ellipse
   * @param halfHeight - The half height of this ellipse
   */
  constructor(x2 = 0, y2 = 0, halfWidth = 0, halfHeight = 0) {
    this.type = "ellipse";
    this.x = x2;
    this.y = y2;
    this.halfWidth = halfWidth;
    this.halfHeight = halfHeight;
  }
  /**
   * Creates a clone of this Ellipse instance.
   * @example
   * ```ts
   * // Basic cloning
   * const original = new Ellipse(100, 100, 50, 25);
   * const copy = original.clone();
   *
   * // Clone and modify
   * const modified = original.clone();
   * modified.halfWidth *= 2;
   * modified.halfHeight *= 2;
   *
   * // Verify independence
   * console.log(original.halfWidth);  // 50
   * console.log(modified.halfWidth);  // 100
   * ```
   * @returns A copy of the ellipse
   * @see {@link Ellipse.copyFrom} For copying into existing ellipse
   * @see {@link Ellipse.copyTo} For copying to another ellipse
   */
  clone() {
    return new Ellipse(this.x, this.y, this.halfWidth, this.halfHeight);
  }
  /**
   * Checks whether the x and y coordinates given are contained within this ellipse.
   * Uses normalized coordinates and the ellipse equation to determine containment.
   * @example
   * ```ts
   * // Basic containment check
   * const ellipse = new Ellipse(100, 100, 50, 25);
   * const isInside = ellipse.contains(120, 110);
   * ```
   * @remarks
   * - Uses ellipse equation (x/a + y/b  1)
   * - Returns false if dimensions are 0 or negative
   * - Normalized to center (0,0) for calculation
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coords are within this ellipse
   * @see {@link Ellipse.strokeContains} For checking stroke intersection
   * @see {@link Ellipse.getBounds} For getting containing rectangle
   */
  contains(x2, y2) {
    if (this.halfWidth <= 0 || this.halfHeight <= 0) {
      return false;
    }
    let normx = (x2 - this.x) / this.halfWidth;
    let normy = (y2 - this.y) / this.halfHeight;
    normx *= normx;
    normy *= normy;
    return normx + normy <= 1;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this ellipse including stroke.
   * @example
   * ```ts
   * // Basic stroke check
   * const ellipse = new Ellipse(100, 100, 50, 25);
   * const isOnStroke = ellipse.strokeContains(150, 100, 4); // 4px line width
   *
   * // Check with different alignments
   * const innerStroke = ellipse.strokeContains(150, 100, 4, 1);   // Inside
   * const centerStroke = ellipse.strokeContains(150, 100, 4, 0.5); // Centered
   * const outerStroke = ellipse.strokeContains(150, 100, 4, 0);   // Outside
   * ```
   * @remarks
   * - Uses normalized ellipse equations
   * - Considers stroke alignment
   * - Returns false if dimensions are 0
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @param strokeWidth - The width of the line to check
   * @param alignment - The alignment of the stroke (1 = inner, 0.5 = centered, 0 = outer)
   * @returns Whether the x/y coords are within this ellipse's stroke
   * @see {@link Ellipse.contains} For checking fill containment
   * @see {@link Ellipse.getBounds} For getting stroke bounds
   */
  strokeContains(x2, y2, strokeWidth, alignment = 0.5) {
    const { halfWidth, halfHeight } = this;
    if (halfWidth <= 0 || halfHeight <= 0) {
      return false;
    }
    const strokeOuterWidth = strokeWidth * (1 - alignment);
    const strokeInnerWidth = strokeWidth - strokeOuterWidth;
    const innerHorizontal = halfWidth - strokeInnerWidth;
    const innerVertical = halfHeight - strokeInnerWidth;
    const outerHorizontal = halfWidth + strokeOuterWidth;
    const outerVertical = halfHeight + strokeOuterWidth;
    const normalizedX = x2 - this.x;
    const normalizedY = y2 - this.y;
    const innerEllipse = normalizedX * normalizedX / (innerHorizontal * innerHorizontal) + normalizedY * normalizedY / (innerVertical * innerVertical);
    const outerEllipse = normalizedX * normalizedX / (outerHorizontal * outerHorizontal) + normalizedY * normalizedY / (outerVertical * outerVertical);
    return innerEllipse > 1 && outerEllipse <= 1;
  }
  /**
   * Returns the framing rectangle of the ellipse as a Rectangle object.
   * @example
   * ```ts
   * // Basic bounds calculation
   * const ellipse = new Ellipse(100, 100, 50, 25);
   * const bounds = ellipse.getBounds();
   * // bounds: x=50, y=75, width=100, height=50
   *
   * // Reuse existing rectangle
   * const rect = new Rectangle();
   * ellipse.getBounds(rect);
   * ```
   * @remarks
   * - Creates Rectangle if none provided
   * - Top-left is (x-halfWidth, y-halfHeight)
   * - Width is halfWidth * 2
   * - Height is halfHeight * 2
   * @param out - Optional Rectangle object to store the result
   * @returns The framing rectangle
   * @see {@link Rectangle} For rectangle properties
   * @see {@link Ellipse.contains} For checking if a point is inside
   */
  getBounds(out2) {
    out2 || (out2 = new Rectangle());
    out2.x = this.x - this.halfWidth;
    out2.y = this.y - this.halfHeight;
    out2.width = this.halfWidth * 2;
    out2.height = this.halfHeight * 2;
    return out2;
  }
  /**
   * Copies another ellipse to this one.
   * @example
   * ```ts
   * // Basic copying
   * const source = new Ellipse(100, 100, 50, 25);
   * const target = new Ellipse();
   * target.copyFrom(source);
   * ```
   * @param ellipse - The ellipse to copy from
   * @returns Returns itself
   * @see {@link Ellipse.copyTo} For copying to another ellipse
   * @see {@link Ellipse.clone} For creating new ellipse copy
   */
  copyFrom(ellipse) {
    this.x = ellipse.x;
    this.y = ellipse.y;
    this.halfWidth = ellipse.halfWidth;
    this.halfHeight = ellipse.halfHeight;
    return this;
  }
  /**
   * Copies this ellipse to another one.
   * @example
   * ```ts
   * // Basic copying
   * const source = new Ellipse(100, 100, 50, 25);
   * const target = new Ellipse();
   * source.copyTo(target);
   * ```
   * @param ellipse - The ellipse to copy to
   * @returns Returns given parameter
   * @see {@link Ellipse.copyFrom} For copying from another ellipse
   * @see {@link Ellipse.clone} For creating new ellipse copy
   */
  copyTo(ellipse) {
    ellipse.copyFrom(this);
    return ellipse;
  }
  toString() {
    return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;
  }
}
function squaredDistanceToLineSegment(x2, y2, x1, y1, x22, y22) {
  const a2 = x2 - x1;
  const b2 = y2 - y1;
  const c2 = x22 - x1;
  const d2 = y22 - y1;
  const dot = a2 * c2 + b2 * d2;
  const lenSq = c2 * c2 + d2 * d2;
  let param = -1;
  if (lenSq !== 0) {
    param = dot / lenSq;
  }
  let xx;
  let yy;
  if (param < 0) {
    xx = x1;
    yy = y1;
  } else if (param > 1) {
    xx = x22;
    yy = y22;
  } else {
    xx = x1 + param * c2;
    yy = y1 + param * d2;
  }
  const dx = x2 - xx;
  const dy = y2 - yy;
  return dx * dx + dy * dy;
}
let tempRect$3;
let tempRect2;
class Polygon {
  /**
   * @param points - This can be an array of Points
   *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or
   *  the arguments passed can be all the points of the polygon e.g.
   *  `new Polygon(new Point(), new Point(), ...)`, or the arguments passed can be flat
   *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.
   */
  constructor(...points) {
    this.type = "polygon";
    let flat = Array.isArray(points[0]) ? points[0] : points;
    if (typeof flat[0] !== "number") {
      const p2 = [];
      for (let i2 = 0, il = flat.length; i2 < il; i2++) {
        p2.push(flat[i2].x, flat[i2].y);
      }
      flat = p2;
    }
    this.points = flat;
    this.closePath = true;
  }
  /**
   * Determines whether the polygon's points are arranged in a clockwise direction.
   * Uses the shoelace formula (surveyor's formula) to calculate the signed area.
   *
   * A positive area indicates clockwise winding, while negative indicates counter-clockwise.
   *
   * The formula sums up the cross products of adjacent vertices:
   * For each pair of adjacent points (x1,y1) and (x2,y2), we calculate (x1*y2 - x2*y1)
   * The final sum divided by 2 gives the signed area - positive for clockwise.
   * @example
   * ```ts
   * // Check polygon winding
   * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);
   * console.log(polygon.isClockwise()); // Check direction
   *
   * // Use in path construction
   * const hole = new Polygon([25, 25, 75, 25, 75, 75, 25, 75]);
   * if (hole.isClockwise() === shape.isClockwise()) {
   *     hole.points.reverse(); // Reverse for proper hole winding
   * }
   * ```
   * @returns `true` if the polygon's points are arranged clockwise, `false` if counter-clockwise
   */
  isClockwise() {
    let area2 = 0;
    const points = this.points;
    const length = points.length;
    for (let i2 = 0; i2 < length; i2 += 2) {
      const x1 = points[i2];
      const y1 = points[i2 + 1];
      const x2 = points[(i2 + 2) % length];
      const y2 = points[(i2 + 3) % length];
      area2 += (x2 - x1) * (y2 + y1);
    }
    return area2 < 0;
  }
  /**
   * Checks if this polygon completely contains another polygon.
   * Used for detecting holes in shapes, like when parsing SVG paths.
   * @example
   * ```ts
   * // Basic containment check
   * const outerSquare = new Polygon([0,0, 100,0, 100,100, 0,100]); // A square
   * const innerSquare = new Polygon([25,25, 75,25, 75,75, 25,75]); // A smaller square inside
   *
   * outerSquare.containsPolygon(innerSquare); // Returns true
   * innerSquare.containsPolygon(outerSquare); // Returns false
   * ```
   * @remarks
   * - Uses bounds check for quick rejection
   * - Tests all points for containment
   * @param polygon - The polygon to test for containment
   * @returns True if this polygon completely contains the other polygon
   * @see {@link Polygon.contains} For single point testing
   * @see {@link Polygon.getBounds} For bounds calculation
   */
  containsPolygon(polygon) {
    const thisBounds = this.getBounds(tempRect$3);
    const otherBounds = polygon.getBounds(tempRect2);
    if (!thisBounds.containsRect(otherBounds)) {
      return false;
    }
    const points = polygon.points;
    for (let i2 = 0; i2 < points.length; i2 += 2) {
      const x2 = points[i2];
      const y2 = points[i2 + 1];
      if (!this.contains(x2, y2)) {
        return false;
      }
    }
    return true;
  }
  /**
   * Creates a clone of this polygon.
   * @example
   * ```ts
   * // Basic cloning
   * const original = new Polygon([0, 0, 100, 0, 50, 100]);
   * const copy = original.clone();
   *
   * // Clone and modify
   * const modified = original.clone();
   * modified.points[0] = 10; // Modify first x coordinate
   * ```
   * @returns A copy of the polygon
   * @see {@link Polygon.copyFrom} For copying into existing polygon
   * @see {@link Polygon.copyTo} For copying to another polygon
   */
  clone() {
    const points = this.points.slice();
    const polygon = new Polygon(points);
    polygon.closePath = this.closePath;
    return polygon;
  }
  /**
   * Checks whether the x and y coordinates passed to this function are contained within this polygon.
   * Uses raycasting algorithm for point-in-polygon testing.
   * @example
   * ```ts
   * // Basic containment check
   * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);
   * const isInside = polygon.contains(25, 25); // true
   * ```
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coordinates are within this polygon
   * @see {@link Polygon.strokeContains} For checking stroke intersection
   * @see {@link Polygon.containsPolygon} For polygon-in-polygon testing
   */
  contains(x2, y2) {
    let inside = false;
    const length = this.points.length / 2;
    for (let i2 = 0, j2 = length - 1; i2 < length; j2 = i2++) {
      const xi = this.points[i2 * 2];
      const yi = this.points[i2 * 2 + 1];
      const xj = this.points[j2 * 2];
      const yj = this.points[j2 * 2 + 1];
      const intersect = yi > y2 !== yj > y2 && x2 < (xj - xi) * ((y2 - yi) / (yj - yi)) + xi;
      if (intersect) {
        inside = !inside;
      }
    }
    return inside;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this polygon including the stroke.
   * @example
   * ```ts
   * // Basic stroke check
   * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);
   * const isOnStroke = polygon.strokeContains(25, 25, 4); // 4px line width
   *
   * // Check with different alignments
   * const innerStroke = polygon.strokeContains(25, 25, 4, 1);   // Inside
   * const centerStroke = polygon.strokeContains(25, 25, 4, 0.5); // Centered
   * const outerStroke = polygon.strokeContains(25, 25, 4, 0);   // Outside
   * ```
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @param strokeWidth - The width of the line to check
   * @param alignment - The alignment of the stroke (1 = inner, 0.5 = centered, 0 = outer)
   * @returns Whether the x/y coordinates are within this polygon's stroke
   * @see {@link Polygon.contains} For checking fill containment
   * @see {@link Polygon.getBounds} For getting stroke bounds
   */
  strokeContains(x2, y2, strokeWidth, alignment = 0.5) {
    const strokeWidthSquared = strokeWidth * strokeWidth;
    const rightWidthSquared = strokeWidthSquared * (1 - alignment);
    const leftWidthSquared = strokeWidthSquared - rightWidthSquared;
    const { points } = this;
    const iterationLength = points.length - (this.closePath ? 0 : 2);
    for (let i2 = 0; i2 < iterationLength; i2 += 2) {
      const x1 = points[i2];
      const y1 = points[i2 + 1];
      const x22 = points[(i2 + 2) % points.length];
      const y22 = points[(i2 + 3) % points.length];
      const distanceSquared = squaredDistanceToLineSegment(x2, y2, x1, y1, x22, y22);
      const sign2 = Math.sign((x22 - x1) * (y2 - y1) - (y22 - y1) * (x2 - x1));
      if (distanceSquared <= (sign2 < 0 ? leftWidthSquared : rightWidthSquared)) {
        return true;
      }
    }
    return false;
  }
  /**
   * Returns the framing rectangle of the polygon as a Rectangle object.
   * @example
   * ```ts
   * // Basic bounds calculation
   * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);
   * const bounds = polygon.getBounds();
   * // bounds: x=0, y=0, width=100, height=100
   *
   * // Reuse existing rectangle
   * const rect = new Rectangle();
   * polygon.getBounds(rect);
   * ```
   * @param out - Optional rectangle to store the result
   * @returns The framing rectangle
   * @see {@link Rectangle} For rectangle properties
   * @see {@link Polygon.contains} For checking if a point is inside
   */
  getBounds(out2) {
    out2 || (out2 = new Rectangle());
    const points = this.points;
    let minX = Infinity;
    let maxX = -Infinity;
    let minY = Infinity;
    let maxY = -Infinity;
    for (let i2 = 0, n2 = points.length; i2 < n2; i2 += 2) {
      const x2 = points[i2];
      const y2 = points[i2 + 1];
      minX = x2 < minX ? x2 : minX;
      maxX = x2 > maxX ? x2 : maxX;
      minY = y2 < minY ? y2 : minY;
      maxY = y2 > maxY ? y2 : maxY;
    }
    out2.x = minX;
    out2.width = maxX - minX;
    out2.y = minY;
    out2.height = maxY - minY;
    return out2;
  }
  /**
   * Copies another polygon to this one.
   * @example
   * ```ts
   * // Basic copying
   * const source = new Polygon([0, 0, 100, 0, 50, 100]);
   * const target = new Polygon();
   * target.copyFrom(source);
   * ```
   * @param polygon - The polygon to copy from
   * @returns Returns itself
   * @see {@link Polygon.copyTo} For copying to another polygon
   * @see {@link Polygon.clone} For creating new polygon copy
   */
  copyFrom(polygon) {
    this.points = polygon.points.slice();
    this.closePath = polygon.closePath;
    return this;
  }
  /**
   * Copies this polygon to another one.
   * @example
   * ```ts
   * // Basic copying
   * const source = new Polygon([0, 0, 100, 0, 50, 100]);
   * const target = new Polygon();
   * source.copyTo(target);
   * ```
   * @param polygon - The polygon to copy to
   * @returns Returns given parameter
   * @see {@link Polygon.copyFrom} For copying from another polygon
   * @see {@link Polygon.clone} For creating new polygon copy
   */
  copyTo(polygon) {
    polygon.copyFrom(this);
    return polygon;
  }
  toString() {
    return `[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, "")}]`;
  }
  /**
   * Get the last X coordinate of the polygon.
   * @example
   * ```ts
   * // Basic coordinate access
   * const polygon = new Polygon([0, 0, 100, 200, 300, 400]);
   * console.log(polygon.lastX); // 300
   * ```
   * @readonly
   * @returns The x-coordinate of the last vertex
   * @see {@link Polygon.lastY} For last Y coordinate
   * @see {@link Polygon.points} For raw points array
   */
  get lastX() {
    return this.points[this.points.length - 2];
  }
  /**
   * Get the last Y coordinate of the polygon.
   * @example
   * ```ts
   * // Basic coordinate access
   * const polygon = new Polygon([0, 0, 100, 200, 300, 400]);
   * console.log(polygon.lastY); // 400
   * ```
   * @readonly
   * @returns The y-coordinate of the last vertex
   * @see {@link Polygon.lastX} For last X coordinate
   * @see {@link Polygon.points} For raw points array
   */
  get lastY() {
    return this.points[this.points.length - 1];
  }
  /**
   * Get the last X coordinate of the polygon.
   * @readonly
   * @deprecated since 8.11.0, use {@link Polygon.lastX} instead.
   */
  get x() {
    deprecation("8.11.0", "Polygon.lastX is deprecated, please use Polygon.lastX instead.");
    return this.points[this.points.length - 2];
  }
  /**
   * Get the last Y coordinate of the polygon.
   * @readonly
   * @deprecated since 8.11.0, use {@link Polygon.lastY} instead.
   */
  get y() {
    deprecation("8.11.0", "Polygon.y is deprecated, please use Polygon.lastY instead.");
    return this.points[this.points.length - 1];
  }
  /**
   * Get the first X coordinate of the polygon.
   * @example
   * ```ts
   * // Basic coordinate access
   * const polygon = new Polygon([0, 0, 100, 200, 300, 400]);
   * console.log(polygon.x); // 0
   * ```
   * @readonly
   * @returns The x-coordinate of the first vertex
   * @see {@link Polygon.startY} For first Y coordinate
   * @see {@link Polygon.points} For raw points array
   */
  get startX() {
    return this.points[0];
  }
  /**
   * Get the first Y coordinate of the polygon.
   * @example
   * ```ts
   * // Basic coordinate access
   * const polygon = new Polygon([0, 0, 100, 200, 300, 400]);
   * console.log(polygon.y); // 0
   * ```
   * @readonly
   * @returns The y-coordinate of the first vertex
   * @see {@link Polygon.startX} For first X coordinate
   * @see {@link Polygon.points} For raw points array
   */
  get startY() {
    return this.points[1];
  }
}
const isCornerWithinStroke = (pX, pY, cornerX, cornerY, radius, strokeWidthInner, strokeWidthOuter) => {
  const dx = pX - cornerX;
  const dy = pY - cornerY;
  const distance2 = Math.sqrt(dx * dx + dy * dy);
  return distance2 >= radius - strokeWidthInner && distance2 <= radius + strokeWidthOuter;
};
class RoundedRectangle {
  /**
   * @param x - The X coordinate of the upper-left corner of the rounded rectangle
   * @param y - The Y coordinate of the upper-left corner of the rounded rectangle
   * @param width - The overall width of this rounded rectangle
   * @param height - The overall height of this rounded rectangle
   * @param radius - Controls the radius of the rounded corners
   */
  constructor(x2 = 0, y2 = 0, width = 0, height = 0, radius = 20) {
    this.type = "roundedRectangle";
    this.x = x2;
    this.y = y2;
    this.width = width;
    this.height = height;
    this.radius = radius;
  }
  /**
   * Returns the framing rectangle of the rounded rectangle as a Rectangle object
   * @example
   * ```ts
   * // Basic bounds calculation
   * const rect = new RoundedRectangle(100, 100, 200, 150, 20);
   * const bounds = rect.getBounds();
   * // bounds: x=100, y=100, width=200, height=150
   *
   * // Reuse existing rectangle
   * const out = new Rectangle();
   * rect.getBounds(out);
   * ```
   * @remarks
   * - Rectangle matches outer dimensions
   * - Ignores corner radius
   * @param out - Optional rectangle to store the result
   * @returns The framing rectangle
   * @see {@link Rectangle} For rectangle properties
   * @see {@link RoundedRectangle.contains} For checking if a point is inside
   */
  getBounds(out2) {
    out2 || (out2 = new Rectangle());
    out2.x = this.x;
    out2.y = this.y;
    out2.width = this.width;
    out2.height = this.height;
    return out2;
  }
  /**
   * Creates a clone of this Rounded Rectangle.
   * @example
   * ```ts
   * // Basic cloning
   * const original = new RoundedRectangle(100, 100, 200, 150, 20);
   * const copy = original.clone();
   *
   * // Clone and modify
   * const modified = original.clone();
   * modified.radius = 30;
   * modified.width *= 2;
   *
   * // Verify independence
   * console.log(original.radius);  // 20
   * console.log(modified.radius);  // 30
   * ```
   * @returns A copy of the rounded rectangle
   * @see {@link RoundedRectangle.copyFrom} For copying into existing rectangle
   * @see {@link RoundedRectangle.copyTo} For copying to another rectangle
   */
  clone() {
    return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);
  }
  /**
   * Copies another rectangle to this one.
   * @example
   * ```ts
   * // Basic copying
   * const source = new RoundedRectangle(100, 100, 200, 150, 20);
   * const target = new RoundedRectangle();
   * target.copyFrom(source);
   *
   * // Chain with other operations
   * const rect = new RoundedRectangle()
   *     .copyFrom(source)
   *     .getBounds(rect);
   * ```
   * @param rectangle - The rectangle to copy from
   * @returns Returns itself
   * @see {@link RoundedRectangle.copyTo} For copying to another rectangle
   * @see {@link RoundedRectangle.clone} For creating new rectangle copy
   */
  copyFrom(rectangle) {
    this.x = rectangle.x;
    this.y = rectangle.y;
    this.width = rectangle.width;
    this.height = rectangle.height;
    return this;
  }
  /**
   * Copies this rectangle to another one.
   * @example
   * ```ts
   * // Basic copying
   * const source = new RoundedRectangle(100, 100, 200, 150, 20);
   * const target = new RoundedRectangle();
   * source.copyTo(target);
   *
   * // Chain with other operations
   * const result = source
   *     .copyTo(new RoundedRectangle())
   *     .getBounds();
   * ```
   * @param rectangle - The rectangle to copy to
   * @returns Returns given parameter
   * @see {@link RoundedRectangle.copyFrom} For copying from another rectangle
   * @see {@link RoundedRectangle.clone} For creating new rectangle copy
   */
  copyTo(rectangle) {
    rectangle.copyFrom(this);
    return rectangle;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this Rounded Rectangle
   * @example
   * ```ts
   * // Basic containment check
   * const rect = new RoundedRectangle(100, 100, 200, 150, 20);
   * const isInside = rect.contains(150, 125); // true
   * // Check corner radius
   * const corner = rect.contains(100, 100); // false if within corner curve
   * ```
   * @remarks
   * - Returns false if width/height is 0 or negative
   * - Handles rounded corners with radius check
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coordinates are within this Rounded Rectangle
   * @see {@link RoundedRectangle.strokeContains} For checking stroke intersection
   * @see {@link RoundedRectangle.getBounds} For getting containing rectangle
   */
  contains(x2, y2) {
    if (this.width <= 0 || this.height <= 0) {
      return false;
    }
    if (x2 >= this.x && x2 <= this.x + this.width) {
      if (y2 >= this.y && y2 <= this.y + this.height) {
        const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
        if (y2 >= this.y + radius && y2 <= this.y + this.height - radius || x2 >= this.x + radius && x2 <= this.x + this.width - radius) {
          return true;
        }
        let dx = x2 - (this.x + radius);
        let dy = y2 - (this.y + radius);
        const radius2 = radius * radius;
        if (dx * dx + dy * dy <= radius2) {
          return true;
        }
        dx = x2 - (this.x + this.width - radius);
        if (dx * dx + dy * dy <= radius2) {
          return true;
        }
        dy = y2 - (this.y + this.height - radius);
        if (dx * dx + dy * dy <= radius2) {
          return true;
        }
        dx = x2 - (this.x + radius);
        if (dx * dx + dy * dy <= radius2) {
          return true;
        }
      }
    }
    return false;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.
   * @example
   * ```ts
   * // Basic stroke check
   * const rect = new RoundedRectangle(100, 100, 200, 150, 20);
   * const isOnStroke = rect.strokeContains(150, 100, 4); // 4px line width
   *
   * // Check with different alignments
   * const innerStroke = rect.strokeContains(150, 100, 4, 1);   // Inside
   * const centerStroke = rect.strokeContains(150, 100, 4, 0.5); // Centered
   * const outerStroke = rect.strokeContains(150, 100, 4, 0);   // Outside
   * ```
   * @param pX - The X coordinate of the point to test
   * @param pY - The Y coordinate of the point to test
   * @param strokeWidth - The width of the line to check
   * @param alignment - The alignment of the stroke (1 = inner, 0.5 = centered, 0 = outer)
   * @returns Whether the x/y coordinates are within this rectangle's stroke
   * @see {@link RoundedRectangle.contains} For checking fill containment
   * @see {@link RoundedRectangle.getBounds} For getting stroke bounds
   */
  strokeContains(pX, pY, strokeWidth, alignment = 0.5) {
    const { x: x2, y: y2, width, height, radius } = this;
    const strokeWidthOuter = strokeWidth * (1 - alignment);
    const strokeWidthInner = strokeWidth - strokeWidthOuter;
    const innerX = x2 + radius;
    const innerY = y2 + radius;
    const innerWidth = width - radius * 2;
    const innerHeight = height - radius * 2;
    const rightBound = x2 + width;
    const bottomBound = y2 + height;
    if ((pX >= x2 - strokeWidthOuter && pX <= x2 + strokeWidthInner || pX >= rightBound - strokeWidthInner && pX <= rightBound + strokeWidthOuter) && pY >= innerY && pY <= innerY + innerHeight) {
      return true;
    }
    if ((pY >= y2 - strokeWidthOuter && pY <= y2 + strokeWidthInner || pY >= bottomBound - strokeWidthInner && pY <= bottomBound + strokeWidthOuter) && pX >= innerX && pX <= innerX + innerWidth) {
      return true;
    }
    return (
      // Top-left
      pX < innerX && pY < innerY && isCornerWithinStroke(
        pX,
        pY,
        innerX,
        innerY,
        radius,
        strokeWidthInner,
        strokeWidthOuter
      ) || pX > rightBound - radius && pY < innerY && isCornerWithinStroke(
        pX,
        pY,
        rightBound - radius,
        innerY,
        radius,
        strokeWidthInner,
        strokeWidthOuter
      ) || pX > rightBound - radius && pY > bottomBound - radius && isCornerWithinStroke(
        pX,
        pY,
        rightBound - radius,
        bottomBound - radius,
        radius,
        strokeWidthInner,
        strokeWidthOuter
      ) || pX < innerX && pY > bottomBound - radius && isCornerWithinStroke(
        pX,
        pY,
        innerX,
        bottomBound - radius,
        radius,
        strokeWidthInner,
        strokeWidthOuter
      )
    );
  }
  toString() {
    return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;
  }
}
const cachedGroups = {};
function getTextureBatchBindGroup(textures, size2, maxTextures) {
  let uid2 = 2166136261;
  for (let i2 = 0; i2 < size2; i2++) {
    uid2 ^= textures[i2].uid;
    uid2 = Math.imul(uid2, 16777619);
    uid2 >>>= 0;
  }
  return cachedGroups[uid2] || generateTextureBatchBindGroup(textures, size2, uid2, maxTextures);
}
function generateTextureBatchBindGroup(textures, size2, key2, maxTextures) {
  const bindGroupResources = {};
  let bindIndex = 0;
  for (let i2 = 0; i2 < maxTextures; i2++) {
    const texture = i2 < size2 ? textures[i2] : Texture.EMPTY.source;
    bindGroupResources[bindIndex++] = texture.source;
    bindGroupResources[bindIndex++] = texture.style;
  }
  const bindGroup = new BindGroup(bindGroupResources);
  cachedGroups[key2] = bindGroup;
  return bindGroup;
}
class ViewableBuffer {
  constructor(sizeOrBuffer) {
    if (typeof sizeOrBuffer === "number") {
      this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);
    } else if (sizeOrBuffer instanceof Uint8Array) {
      this.rawBinaryData = sizeOrBuffer.buffer;
    } else {
      this.rawBinaryData = sizeOrBuffer;
    }
    this.uint32View = new Uint32Array(this.rawBinaryData);
    this.float32View = new Float32Array(this.rawBinaryData);
    this.size = this.rawBinaryData.byteLength;
  }
  /** View on the raw binary data as a `Int8Array`. */
  get int8View() {
    if (!this._int8View) {
      this._int8View = new Int8Array(this.rawBinaryData);
    }
    return this._int8View;
  }
  /** View on the raw binary data as a `Uint8Array`. */
  get uint8View() {
    if (!this._uint8View) {
      this._uint8View = new Uint8Array(this.rawBinaryData);
    }
    return this._uint8View;
  }
  /**  View on the raw binary data as a `Int16Array`. */
  get int16View() {
    if (!this._int16View) {
      this._int16View = new Int16Array(this.rawBinaryData);
    }
    return this._int16View;
  }
  /** View on the raw binary data as a `Int32Array`. */
  get int32View() {
    if (!this._int32View) {
      this._int32View = new Int32Array(this.rawBinaryData);
    }
    return this._int32View;
  }
  /** View on the raw binary data as a `Float64Array`. */
  get float64View() {
    if (!this._float64Array) {
      this._float64Array = new Float64Array(this.rawBinaryData);
    }
    return this._float64Array;
  }
  /** View on the raw binary data as a `BigUint64Array`. */
  get bigUint64View() {
    if (!this._bigUint64Array) {
      this._bigUint64Array = new BigUint64Array(this.rawBinaryData);
    }
    return this._bigUint64Array;
  }
  /**
   * Returns the view of the given type.
   * @param type - One of `int8`, `uint8`, `int16`,
   *    `uint16`, `int32`, `uint32`, and `float32`.
   * @returns - typed array of given type
   */
  view(type2) {
    return this[`${type2}View`];
  }
  /** Destroys all buffer references. Do not use after calling this. */
  destroy() {
    this.rawBinaryData = null;
    this.uint32View = null;
    this.float32View = null;
    this.uint16View = null;
    this._int8View = null;
    this._uint8View = null;
    this._int16View = null;
    this._int32View = null;
    this._float64Array = null;
    this._bigUint64Array = null;
  }
  /**
   * Returns the size of the given type in bytes.
   * @param type - One of `int8`, `uint8`, `int16`,
   *   `uint16`, `int32`, `uint32`, and `float32`.
   * @returns - size of the type in bytes
   */
  static sizeOf(type2) {
    switch (type2) {
      case "int8":
      case "uint8":
        return 1;
      case "int16":
      case "uint16":
        return 2;
      case "int32":
      case "uint32":
      case "float32":
        return 4;
      default:
        throw new Error(`${type2} isn't a valid view type`);
    }
  }
}
function fastCopy(sourceBuffer, destinationBuffer) {
  const lengthDouble = sourceBuffer.byteLength / 8 | 0;
  const sourceFloat64View = new Float64Array(sourceBuffer, 0, lengthDouble);
  const destinationFloat64View = new Float64Array(destinationBuffer, 0, lengthDouble);
  destinationFloat64View.set(sourceFloat64View);
  const remainingBytes = sourceBuffer.byteLength - lengthDouble * 8;
  if (remainingBytes > 0) {
    const sourceUint8View = new Uint8Array(sourceBuffer, lengthDouble * 8, remainingBytes);
    const destinationUint8View = new Uint8Array(destinationBuffer, lengthDouble * 8, remainingBytes);
    destinationUint8View.set(sourceUint8View);
  }
}
const BLEND_TO_NPM = {
  normal: "normal-npm",
  add: "add-npm",
  screen: "screen-npm"
};
var STENCIL_MODES = /* @__PURE__ */ ((STENCIL_MODES2) => {
  STENCIL_MODES2[STENCIL_MODES2["DISABLED"] = 0] = "DISABLED";
  STENCIL_MODES2[STENCIL_MODES2["RENDERING_MASK_ADD"] = 1] = "RENDERING_MASK_ADD";
  STENCIL_MODES2[STENCIL_MODES2["MASK_ACTIVE"] = 2] = "MASK_ACTIVE";
  STENCIL_MODES2[STENCIL_MODES2["INVERSE_MASK_ACTIVE"] = 3] = "INVERSE_MASK_ACTIVE";
  STENCIL_MODES2[STENCIL_MODES2["RENDERING_MASK_REMOVE"] = 4] = "RENDERING_MASK_REMOVE";
  STENCIL_MODES2[STENCIL_MODES2["NONE"] = 5] = "NONE";
  return STENCIL_MODES2;
})(STENCIL_MODES || {});
function getAdjustedBlendModeBlend(blendMode, textureSource) {
  if (textureSource.alphaMode === "no-premultiply-alpha") {
    return BLEND_TO_NPM[blendMode] || blendMode;
  }
  return blendMode;
}
const fragTemplate$1 = [
  "precision mediump float;",
  "void main(void){",
  "float test = 0.1;",
  "%forloop%",
  "gl_FragColor = vec4(0.0);",
  "}"
].join("\n");
function generateIfTestSrc(maxIfs) {
  let src = "";
  for (let i2 = 0; i2 < maxIfs; ++i2) {
    if (i2 > 0) {
      src += "\nelse ";
    }
    if (i2 < maxIfs - 1) {
      src += `if(test == ${i2}.0){}`;
    }
  }
  return src;
}
function checkMaxIfStatementsInShader(maxIfs, gl) {
  if (maxIfs === 0) {
    throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
  }
  const shader = gl.createShader(gl.FRAGMENT_SHADER);
  try {
    while (true) {
      const fragmentSrc = fragTemplate$1.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));
      gl.shaderSource(shader, fragmentSrc);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        maxIfs = maxIfs / 2 | 0;
      } else {
        break;
      }
    }
  } finally {
    gl.deleteShader(shader);
  }
  return maxIfs;
}
let maxTexturesPerBatchCache = null;
function getMaxTexturesPerBatch() {
  var _a;
  if (maxTexturesPerBatchCache)
    return maxTexturesPerBatchCache;
  const gl = getTestContext();
  maxTexturesPerBatchCache = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
  maxTexturesPerBatchCache = checkMaxIfStatementsInShader(
    maxTexturesPerBatchCache,
    gl
  );
  (_a = gl.getExtension("WEBGL_lose_context")) == null ? void 0 : _a.loseContext();
  return maxTexturesPerBatchCache;
}
class BatchTextureArray {
  constructor() {
    this.ids = /* @__PURE__ */ Object.create(null);
    this.textures = [];
    this.count = 0;
  }
  /** Clear the textures and their locations. */
  clear() {
    for (let i2 = 0; i2 < this.count; i2++) {
      const t2 = this.textures[i2];
      this.textures[i2] = null;
      this.ids[t2.uid] = null;
    }
    this.count = 0;
  }
}
class Batch {
  constructor() {
    this.renderPipeId = "batch";
    this.action = "startBatch";
    this.start = 0;
    this.size = 0;
    this.textures = new BatchTextureArray();
    this.blendMode = "normal";
    this.topology = "triangle-strip";
    this.canBundle = true;
  }
  destroy() {
    this.textures = null;
    this.gpuBindGroup = null;
    this.bindGroup = null;
    this.batcher = null;
  }
}
const batchPool = [];
let batchPoolIndex = 0;
GlobalResourceRegistry.register({
  clear: () => {
    if (batchPool.length > 0) {
      for (const item of batchPool) {
        if (item)
          item.destroy();
      }
    }
    batchPool.length = 0;
    batchPoolIndex = 0;
  }
});
function getBatchFromPool() {
  return batchPoolIndex > 0 ? batchPool[--batchPoolIndex] : new Batch();
}
function returnBatchToPool(batch) {
  batchPool[batchPoolIndex++] = batch;
}
let BATCH_TICK = 0;
const _Batcher = class _Batcher2 {
  constructor(options) {
    this.uid = uid("batcher");
    this.dirty = true;
    this.batchIndex = 0;
    this.batches = [];
    this._elements = [];
    options = { ..._Batcher2.defaultOptions, ...options };
    if (!options.maxTextures) {
      deprecation("v8.8.0", "maxTextures is a required option for Batcher now, please pass it in the options");
      options.maxTextures = getMaxTexturesPerBatch();
    }
    const { maxTextures, attributesInitialSize, indicesInitialSize } = options;
    this.attributeBuffer = new ViewableBuffer(attributesInitialSize * 4);
    this.indexBuffer = new Uint16Array(indicesInitialSize);
    this.maxTextures = maxTextures;
  }
  begin() {
    this.elementSize = 0;
    this.elementStart = 0;
    this.indexSize = 0;
    this.attributeSize = 0;
    for (let i2 = 0; i2 < this.batchIndex; i2++) {
      returnBatchToPool(this.batches[i2]);
    }
    this.batchIndex = 0;
    this._batchIndexStart = 0;
    this._batchIndexSize = 0;
    this.dirty = true;
  }
  add(batchableObject) {
    this._elements[this.elementSize++] = batchableObject;
    batchableObject._indexStart = this.indexSize;
    batchableObject._attributeStart = this.attributeSize;
    batchableObject._batcher = this;
    this.indexSize += batchableObject.indexSize;
    this.attributeSize += batchableObject.attributeSize * this.vertexSize;
  }
  checkAndUpdateTexture(batchableObject, texture) {
    const textureId2 = batchableObject._batch.textures.ids[texture._source.uid];
    if (!textureId2 && textureId2 !== 0)
      return false;
    batchableObject._textureId = textureId2;
    batchableObject.texture = texture;
    return true;
  }
  updateElement(batchableObject) {
    this.dirty = true;
    const attributeBuffer = this.attributeBuffer;
    if (batchableObject.packAsQuad) {
      this.packQuadAttributes(
        batchableObject,
        attributeBuffer.float32View,
        attributeBuffer.uint32View,
        batchableObject._attributeStart,
        batchableObject._textureId
      );
    } else {
      this.packAttributes(
        batchableObject,
        attributeBuffer.float32View,
        attributeBuffer.uint32View,
        batchableObject._attributeStart,
        batchableObject._textureId
      );
    }
  }
  /**
   * breaks the batcher. This happens when a batch gets too big,
   * or we need to switch to a different type of rendering (a filter for example)
   * @param instructionSet
   */
  break(instructionSet) {
    const elements2 = this._elements;
    if (!elements2[this.elementStart])
      return;
    let batch = getBatchFromPool();
    let textureBatch = batch.textures;
    textureBatch.clear();
    const firstElement = elements2[this.elementStart];
    let blendMode = getAdjustedBlendModeBlend(firstElement.blendMode, firstElement.texture._source);
    let topology = firstElement.topology;
    if (this.attributeSize * 4 > this.attributeBuffer.size) {
      this._resizeAttributeBuffer(this.attributeSize * 4);
    }
    if (this.indexSize > this.indexBuffer.length) {
      this._resizeIndexBuffer(this.indexSize);
    }
    const f32 = this.attributeBuffer.float32View;
    const u32 = this.attributeBuffer.uint32View;
    const indexBuffer = this.indexBuffer;
    let size2 = this._batchIndexSize;
    let start = this._batchIndexStart;
    let action2 = "startBatch";
    const maxTextures = this.maxTextures;
    for (let i2 = this.elementStart; i2 < this.elementSize; ++i2) {
      const element = elements2[i2];
      elements2[i2] = null;
      const texture = element.texture;
      const source2 = texture._source;
      const adjustedBlendMode = getAdjustedBlendModeBlend(element.blendMode, source2);
      const breakRequired = blendMode !== adjustedBlendMode || topology !== element.topology;
      if (source2._batchTick === BATCH_TICK && !breakRequired) {
        element._textureId = source2._textureBindLocation;
        size2 += element.indexSize;
        if (element.packAsQuad) {
          this.packQuadAttributes(
            element,
            f32,
            u32,
            element._attributeStart,
            element._textureId
          );
          this.packQuadIndex(
            indexBuffer,
            element._indexStart,
            element._attributeStart / this.vertexSize
          );
        } else {
          this.packAttributes(
            element,
            f32,
            u32,
            element._attributeStart,
            element._textureId
          );
          this.packIndex(
            element,
            indexBuffer,
            element._indexStart,
            element._attributeStart / this.vertexSize
          );
        }
        element._batch = batch;
        continue;
      }
      source2._batchTick = BATCH_TICK;
      if (textureBatch.count >= maxTextures || breakRequired) {
        this._finishBatch(
          batch,
          start,
          size2 - start,
          textureBatch,
          blendMode,
          topology,
          instructionSet,
          action2
        );
        action2 = "renderBatch";
        start = size2;
        blendMode = adjustedBlendMode;
        topology = element.topology;
        batch = getBatchFromPool();
        textureBatch = batch.textures;
        textureBatch.clear();
        ++BATCH_TICK;
      }
      element._textureId = source2._textureBindLocation = textureBatch.count;
      textureBatch.ids[source2.uid] = textureBatch.count;
      textureBatch.textures[textureBatch.count++] = source2;
      element._batch = batch;
      size2 += element.indexSize;
      if (element.packAsQuad) {
        this.packQuadAttributes(
          element,
          f32,
          u32,
          element._attributeStart,
          element._textureId
        );
        this.packQuadIndex(
          indexBuffer,
          element._indexStart,
          element._attributeStart / this.vertexSize
        );
      } else {
        this.packAttributes(
          element,
          f32,
          u32,
          element._attributeStart,
          element._textureId
        );
        this.packIndex(
          element,
          indexBuffer,
          element._indexStart,
          element._attributeStart / this.vertexSize
        );
      }
    }
    if (textureBatch.count > 0) {
      this._finishBatch(
        batch,
        start,
        size2 - start,
        textureBatch,
        blendMode,
        topology,
        instructionSet,
        action2
      );
      start = size2;
      ++BATCH_TICK;
    }
    this.elementStart = this.elementSize;
    this._batchIndexStart = start;
    this._batchIndexSize = size2;
  }
  _finishBatch(batch, indexStart, indexSize, textureBatch, blendMode, topology, instructionSet, action2) {
    batch.gpuBindGroup = null;
    batch.bindGroup = null;
    batch.action = action2;
    batch.batcher = this;
    batch.textures = textureBatch;
    batch.blendMode = blendMode;
    batch.topology = topology;
    batch.start = indexStart;
    batch.size = indexSize;
    ++BATCH_TICK;
    this.batches[this.batchIndex++] = batch;
    instructionSet.add(batch);
  }
  finish(instructionSet) {
    this.break(instructionSet);
  }
  /**
   * Resizes the attribute buffer to the given size (1 = 1 float32)
   * @param size - the size in vertices to ensure (not bytes!)
   */
  ensureAttributeBuffer(size2) {
    if (size2 * 4 <= this.attributeBuffer.size)
      return;
    this._resizeAttributeBuffer(size2 * 4);
  }
  /**
   * Resizes the index buffer to the given size (1 = 1 float32)
   * @param size - the size in vertices to ensure (not bytes!)
   */
  ensureIndexBuffer(size2) {
    if (size2 <= this.indexBuffer.length)
      return;
    this._resizeIndexBuffer(size2);
  }
  _resizeAttributeBuffer(size2) {
    const newSize = Math.max(size2, this.attributeBuffer.size * 2);
    const newArrayBuffer = new ViewableBuffer(newSize);
    fastCopy(this.attributeBuffer.rawBinaryData, newArrayBuffer.rawBinaryData);
    this.attributeBuffer = newArrayBuffer;
  }
  _resizeIndexBuffer(size2) {
    const indexBuffer = this.indexBuffer;
    let newSize = Math.max(size2, indexBuffer.length * 1.5);
    newSize += newSize % 2;
    const newIndexBuffer = newSize > 65535 ? new Uint32Array(newSize) : new Uint16Array(newSize);
    if (newIndexBuffer.BYTES_PER_ELEMENT !== indexBuffer.BYTES_PER_ELEMENT) {
      for (let i2 = 0; i2 < indexBuffer.length; i2++) {
        newIndexBuffer[i2] = indexBuffer[i2];
      }
    } else {
      fastCopy(indexBuffer.buffer, newIndexBuffer.buffer);
    }
    this.indexBuffer = newIndexBuffer;
  }
  packQuadIndex(indexBuffer, index, indicesOffset) {
    indexBuffer[index] = indicesOffset + 0;
    indexBuffer[index + 1] = indicesOffset + 1;
    indexBuffer[index + 2] = indicesOffset + 2;
    indexBuffer[index + 3] = indicesOffset + 0;
    indexBuffer[index + 4] = indicesOffset + 2;
    indexBuffer[index + 5] = indicesOffset + 3;
  }
  packIndex(element, indexBuffer, index, indicesOffset) {
    const indices = element.indices;
    const size2 = element.indexSize;
    const indexOffset = element.indexOffset;
    const attributeOffset = element.attributeOffset;
    for (let i2 = 0; i2 < size2; i2++) {
      indexBuffer[index++] = indicesOffset + indices[i2 + indexOffset] - attributeOffset;
    }
  }
  /**
   * Destroys the batch and its resources.
   * @param options - destruction options
   * @param options.shader - whether to destroy the associated shader
   */
  destroy(options = {}) {
    var _a;
    if (this.batches === null)
      return;
    for (let i2 = 0; i2 < this.batches.length; i2++) {
      returnBatchToPool(this.batches[i2]);
    }
    this.batches = null;
    this.geometry.destroy(true);
    this.geometry = null;
    if (options.shader) {
      (_a = this.shader) == null ? void 0 : _a.destroy();
      this.shader = null;
    }
    for (let i2 = 0; i2 < this._elements.length; i2++) {
      if (this._elements[i2])
        this._elements[i2]._batch = null;
    }
    this._elements = null;
    this.indexBuffer = null;
    this.attributeBuffer.destroy();
    this.attributeBuffer = null;
  }
};
_Batcher.defaultOptions = {
  maxTextures: null,
  attributesInitialSize: 4,
  indicesInitialSize: 6
};
let Batcher = _Batcher;
var BufferUsage = /* @__PURE__ */ ((BufferUsage2) => {
  BufferUsage2[BufferUsage2["MAP_READ"] = 1] = "MAP_READ";
  BufferUsage2[BufferUsage2["MAP_WRITE"] = 2] = "MAP_WRITE";
  BufferUsage2[BufferUsage2["COPY_SRC"] = 4] = "COPY_SRC";
  BufferUsage2[BufferUsage2["COPY_DST"] = 8] = "COPY_DST";
  BufferUsage2[BufferUsage2["INDEX"] = 16] = "INDEX";
  BufferUsage2[BufferUsage2["VERTEX"] = 32] = "VERTEX";
  BufferUsage2[BufferUsage2["UNIFORM"] = 64] = "UNIFORM";
  BufferUsage2[BufferUsage2["STORAGE"] = 128] = "STORAGE";
  BufferUsage2[BufferUsage2["INDIRECT"] = 256] = "INDIRECT";
  BufferUsage2[BufferUsage2["QUERY_RESOLVE"] = 512] = "QUERY_RESOLVE";
  BufferUsage2[BufferUsage2["STATIC"] = 1024] = "STATIC";
  return BufferUsage2;
})(BufferUsage || {});
class Buffer2 extends EventEmitter {
  /**
   * Creates a new Buffer with the given options
   * @param options - the options for the buffer
   */
  constructor(options) {
    let { data, size: size2 } = options;
    const { usage: usage2, label: label2, shrinkToFit } = options;
    super();
    this.uid = uid("buffer");
    this._resourceType = "buffer";
    this._resourceId = uid("resource");
    this._touched = 0;
    this._updateID = 1;
    this._dataInt32 = null;
    this.shrinkToFit = true;
    this.destroyed = false;
    if (data instanceof Array) {
      data = new Float32Array(data);
    }
    this._data = data;
    size2 ?? (size2 = data == null ? void 0 : data.byteLength);
    const mappedAtCreation = !!data;
    this.descriptor = {
      size: size2,
      usage: usage2,
      mappedAtCreation,
      label: label2
    };
    this.shrinkToFit = shrinkToFit ?? true;
  }
  /** the data in the buffer */
  get data() {
    return this._data;
  }
  set data(value2) {
    this.setDataWithSize(value2, value2.length, true);
  }
  get dataInt32() {
    if (!this._dataInt32) {
      this._dataInt32 = new Int32Array(this.data.buffer);
    }
    return this._dataInt32;
  }
  /** whether the buffer is static or not */
  get static() {
    return !!(this.descriptor.usage & BufferUsage.STATIC);
  }
  set static(value2) {
    if (value2) {
      this.descriptor.usage |= BufferUsage.STATIC;
    } else {
      this.descriptor.usage &= ~BufferUsage.STATIC;
    }
  }
  /**
   * Sets the data in the buffer to the given value. This will immediately update the buffer on the GPU.
   * If you only want to update a subset of the buffer, you can pass in the size of the data.
   * @param value - the data to set
   * @param size - the size of the data in bytes
   * @param syncGPU - should the buffer be updated on the GPU immediately?
   */
  setDataWithSize(value2, size2, syncGPU) {
    this._updateID++;
    this._updateSize = size2 * value2.BYTES_PER_ELEMENT;
    if (this._data === value2) {
      if (syncGPU)
        this.emit("update", this);
      return;
    }
    const oldData = this._data;
    this._data = value2;
    this._dataInt32 = null;
    if (!oldData || oldData.length !== value2.length) {
      if (!this.shrinkToFit && oldData && value2.byteLength < oldData.byteLength) {
        if (syncGPU)
          this.emit("update", this);
      } else {
        this.descriptor.size = value2.byteLength;
        this._resourceId = uid("resource");
        this.emit("change", this);
      }
      return;
    }
    if (syncGPU)
      this.emit("update", this);
  }
  /**
   * updates the buffer on the GPU to reflect the data in the buffer.
   * By default it will update the entire buffer. If you only want to update a subset of the buffer,
   * you can pass in the size of the buffer to update.
   * @param sizeInBytes - the new size of the buffer in bytes
   */
  update(sizeInBytes) {
    this._updateSize = sizeInBytes ?? this._updateSize;
    this._updateID++;
    this.emit("update", this);
  }
  /** Destroys the buffer */
  destroy() {
    this.destroyed = true;
    this.emit("destroy", this);
    this.emit("change", this);
    this._data = null;
    this.descriptor = null;
    this.removeAllListeners();
  }
}
function ensureIsBuffer(buffer2, index) {
  if (!(buffer2 instanceof Buffer2)) {
    let usage2 = index ? BufferUsage.INDEX : BufferUsage.VERTEX;
    if (buffer2 instanceof Array) {
      if (index) {
        buffer2 = new Uint32Array(buffer2);
        usage2 = BufferUsage.INDEX | BufferUsage.COPY_DST;
      } else {
        buffer2 = new Float32Array(buffer2);
        usage2 = BufferUsage.VERTEX | BufferUsage.COPY_DST;
      }
    }
    buffer2 = new Buffer2({
      data: buffer2,
      label: index ? "index-mesh-buffer" : "vertex-mesh-buffer",
      usage: usage2
    });
  }
  return buffer2;
}
function getGeometryBounds(geometry, attributeId, bounds) {
  const attribute = geometry.getAttribute(attributeId);
  if (!attribute) {
    bounds.minX = 0;
    bounds.minY = 0;
    bounds.maxX = 0;
    bounds.maxY = 0;
    return bounds;
  }
  const data = attribute.buffer.data;
  let minX = Infinity;
  let minY = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;
  const byteSize = data.BYTES_PER_ELEMENT;
  const offset = (attribute.offset || 0) / byteSize;
  const stride = (attribute.stride || 2 * 4) / byteSize;
  for (let i2 = offset; i2 < data.length; i2 += stride) {
    const x2 = data[i2];
    const y2 = data[i2 + 1];
    if (x2 > maxX)
      maxX = x2;
    if (y2 > maxY)
      maxY = y2;
    if (x2 < minX)
      minX = x2;
    if (y2 < minY)
      minY = y2;
  }
  bounds.minX = minX;
  bounds.minY = minY;
  bounds.maxX = maxX;
  bounds.maxY = maxY;
  return bounds;
}
function ensureIsAttribute(attribute) {
  if (attribute instanceof Buffer2 || Array.isArray(attribute) || attribute.BYTES_PER_ELEMENT) {
    attribute = {
      buffer: attribute
    };
  }
  attribute.buffer = ensureIsBuffer(attribute.buffer, false);
  return attribute;
}
class Geometry extends EventEmitter {
  /**
   * Create a new instance of a geometry
   * @param options - The options for the geometry.
   */
  constructor(options = {}) {
    super();
    this.uid = uid("geometry");
    this._layoutKey = 0;
    this.instanceCount = 1;
    this._bounds = new Bounds();
    this._boundsDirty = true;
    const { attributes, indexBuffer, topology } = options;
    this.buffers = [];
    this.attributes = {};
    if (attributes) {
      for (const i2 in attributes) {
        this.addAttribute(i2, attributes[i2]);
      }
    }
    this.instanceCount = options.instanceCount ?? 1;
    if (indexBuffer) {
      this.addIndex(indexBuffer);
    }
    this.topology = topology || "triangle-list";
  }
  onBufferUpdate() {
    this._boundsDirty = true;
    this.emit("update", this);
  }
  /**
   * Returns the requested attribute.
   * @param id - The name of the attribute required
   * @returns - The attribute requested.
   */
  getAttribute(id2) {
    return this.attributes[id2];
  }
  /**
   * Returns the index buffer
   * @returns - The index buffer.
   */
  getIndex() {
    return this.indexBuffer;
  }
  /**
   * Returns the requested buffer.
   * @param id - The name of the buffer required.
   * @returns - The buffer requested.
   */
  getBuffer(id2) {
    return this.getAttribute(id2).buffer;
  }
  /**
   * Used to figure out how many vertices there are in this geometry
   * @returns the number of vertices in the geometry
   */
  getSize() {
    for (const i2 in this.attributes) {
      const attribute = this.attributes[i2];
      const buffer2 = attribute.buffer;
      return buffer2.data.length / (attribute.stride / 4 || attribute.size);
    }
    return 0;
  }
  /**
   * Adds an attribute to the geometry.
   * @param name - The name of the attribute to add.
   * @param attributeOption - The attribute option to add.
   */
  addAttribute(name2, attributeOption) {
    const attribute = ensureIsAttribute(attributeOption);
    const bufferIndex = this.buffers.indexOf(attribute.buffer);
    if (bufferIndex === -1) {
      this.buffers.push(attribute.buffer);
      attribute.buffer.on("update", this.onBufferUpdate, this);
      attribute.buffer.on("change", this.onBufferUpdate, this);
    }
    this.attributes[name2] = attribute;
  }
  /**
   * Adds an index buffer to the geometry.
   * @param indexBuffer - The index buffer to add. Can be a Buffer, TypedArray, or an array of numbers.
   */
  addIndex(indexBuffer) {
    this.indexBuffer = ensureIsBuffer(indexBuffer, true);
    this.buffers.push(this.indexBuffer);
  }
  /** Returns the bounds of the geometry. */
  get bounds() {
    if (!this._boundsDirty)
      return this._bounds;
    this._boundsDirty = false;
    return getGeometryBounds(this, "aPosition", this._bounds);
  }
  /**
   * destroys the geometry.
   * @param destroyBuffers - destroy the buffers associated with this geometry
   */
  destroy(destroyBuffers = false) {
    var _a;
    this.emit("destroy", this);
    this.removeAllListeners();
    if (destroyBuffers) {
      this.buffers.forEach((buffer2) => buffer2.destroy());
    }
    (_a = this.indexBuffer) == null ? void 0 : _a.destroy();
    this.attributes = null;
    this.buffers = null;
    this.indexBuffer = null;
    this._bounds = null;
  }
}
const placeHolderBufferData = new Float32Array(1);
const placeHolderIndexData = new Uint32Array(1);
class BatchGeometry extends Geometry {
  constructor() {
    const vertexSize = 6;
    const attributeBuffer = new Buffer2({
      data: placeHolderBufferData,
      label: "attribute-batch-buffer",
      usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,
      shrinkToFit: false
    });
    const indexBuffer = new Buffer2({
      data: placeHolderIndexData,
      label: "index-batch-buffer",
      usage: BufferUsage.INDEX | BufferUsage.COPY_DST,
      // | BufferUsage.STATIC,
      shrinkToFit: false
    });
    const stride = vertexSize * 4;
    super({
      attributes: {
        aPosition: {
          buffer: attributeBuffer,
          format: "float32x2",
          stride,
          offset: 0
        },
        aUV: {
          buffer: attributeBuffer,
          format: "float32x2",
          stride,
          offset: 2 * 4
        },
        aColor: {
          buffer: attributeBuffer,
          format: "unorm8x4",
          stride,
          offset: 4 * 4
        },
        aTextureIdAndRound: {
          buffer: attributeBuffer,
          format: "uint16x2",
          stride,
          offset: 5 * 4
        }
      },
      indexBuffer
    });
  }
}
function addBits(srcParts, parts, name2) {
  if (srcParts) {
    for (const i2 in srcParts) {
      const id2 = i2.toLocaleLowerCase();
      const part = parts[id2];
      if (part) {
        let sanitisedPart = srcParts[i2];
        if (i2 === "header") {
          sanitisedPart = sanitisedPart.replace(/@in\s+[^;]+;\s*/g, "").replace(/@out\s+[^;]+;\s*/g, "");
        }
        if (name2) {
          part.push(`//----${name2}----//`);
        }
        part.push(sanitisedPart);
      } else {
        warn(`${i2} placement hook does not exist in shader`);
      }
    }
  }
}
const findHooksRx = /\{\{(.*?)\}\}/g;
function compileHooks(programSrc) {
  var _a;
  const parts = {};
  const partMatches = ((_a = programSrc.match(findHooksRx)) == null ? void 0 : _a.map((hook) => hook.replace(/[{()}]/g, ""))) ?? [];
  partMatches.forEach((hook) => {
    parts[hook] = [];
  });
  return parts;
}
function extractInputs(fragmentSource, out2) {
  let match;
  const regex = /@in\s+([^;]+);/g;
  while ((match = regex.exec(fragmentSource)) !== null) {
    out2.push(match[1]);
  }
}
function compileInputs(fragments, template, sort = false) {
  const results = [];
  extractInputs(template, results);
  fragments.forEach((fragment) => {
    if (fragment.header) {
      extractInputs(fragment.header, results);
    }
  });
  const mainInput = results;
  if (sort) {
    mainInput.sort();
  }
  const finalString = mainInput.map((inValue, i2) => `       @location(${i2}) ${inValue},`).join("\n");
  let cleanedString = template.replace(/@in\s+[^;]+;\s*/g, "");
  cleanedString = cleanedString.replace("{{in}}", `
${finalString}
`);
  return cleanedString;
}
function extractOutputs(fragmentSource, out2) {
  let match;
  const regex = /@out\s+([^;]+);/g;
  while ((match = regex.exec(fragmentSource)) !== null) {
    out2.push(match[1]);
  }
}
function extractVariableName(value2) {
  const regex = /\b(\w+)\s*:/g;
  const match = regex.exec(value2);
  return match ? match[1] : "";
}
function stripVariable(value2) {
  const regex = /@.*?\s+/g;
  return value2.replace(regex, "");
}
function compileOutputs(fragments, template) {
  const results = [];
  extractOutputs(template, results);
  fragments.forEach((fragment) => {
    if (fragment.header) {
      extractOutputs(fragment.header, results);
    }
  });
  let index = 0;
  const mainStruct = results.sort().map((inValue) => {
    if (inValue.indexOf("builtin") > -1) {
      return inValue;
    }
    return `@location(${index++}) ${inValue}`;
  }).join(",\n");
  const mainStart = results.sort().map((inValue) => `       var ${stripVariable(inValue)};`).join("\n");
  const mainEnd = `return VSOutput(
            ${results.sort().map((inValue) => ` ${extractVariableName(inValue)}`).join(",\n")});`;
  let compiledCode = template.replace(/@out\s+[^;]+;\s*/g, "");
  compiledCode = compiledCode.replace("{{struct}}", `
${mainStruct}
`);
  compiledCode = compiledCode.replace("{{start}}", `
${mainStart}
`);
  compiledCode = compiledCode.replace("{{return}}", `
${mainEnd}
`);
  return compiledCode;
}
function injectBits(templateSrc, fragmentParts) {
  let out2 = templateSrc;
  for (const i2 in fragmentParts) {
    const parts = fragmentParts[i2];
    const toInject = parts.join("\n");
    if (toInject.length) {
      out2 = out2.replace(`{{${i2}}}`, `//-----${i2} START-----//
${parts.join("\n")}
//----${i2} FINISH----//`);
    } else {
      out2 = out2.replace(`{{${i2}}}`, "");
    }
  }
  return out2;
}
const cacheMap = /* @__PURE__ */ Object.create(null);
const bitCacheMap = /* @__PURE__ */ new Map();
let CACHE_UID = 0;
function compileHighShader({
  template,
  bits
}) {
  const cacheId = generateCacheId(template, bits);
  if (cacheMap[cacheId])
    return cacheMap[cacheId];
  const { vertex, fragment } = compileInputsAndOutputs(template, bits);
  cacheMap[cacheId] = compileBits(vertex, fragment, bits);
  return cacheMap[cacheId];
}
function compileHighShaderGl({
  template,
  bits
}) {
  const cacheId = generateCacheId(template, bits);
  if (cacheMap[cacheId])
    return cacheMap[cacheId];
  cacheMap[cacheId] = compileBits(template.vertex, template.fragment, bits);
  return cacheMap[cacheId];
}
function compileInputsAndOutputs(template, bits) {
  const vertexFragments = bits.map((shaderBit) => shaderBit.vertex).filter((v2) => !!v2);
  const fragmentFragments = bits.map((shaderBit) => shaderBit.fragment).filter((v2) => !!v2);
  let compiledVertex = compileInputs(vertexFragments, template.vertex, true);
  compiledVertex = compileOutputs(vertexFragments, compiledVertex);
  const compiledFragment = compileInputs(fragmentFragments, template.fragment, true);
  return {
    vertex: compiledVertex,
    fragment: compiledFragment
  };
}
function generateCacheId(template, bits) {
  return bits.map((highFragment) => {
    if (!bitCacheMap.has(highFragment)) {
      bitCacheMap.set(highFragment, CACHE_UID++);
    }
    return bitCacheMap.get(highFragment);
  }).sort((a2, b2) => a2 - b2).join("-") + template.vertex + template.fragment;
}
function compileBits(vertex, fragment, bits) {
  const vertexParts = compileHooks(vertex);
  const fragmentParts = compileHooks(fragment);
  bits.forEach((shaderBit) => {
    addBits(shaderBit.vertex, vertexParts, shaderBit.name);
    addBits(shaderBit.fragment, fragmentParts, shaderBit.name);
  });
  return {
    vertex: injectBits(vertex, vertexParts),
    fragment: injectBits(fragment, fragmentParts)
  };
}
const vertexGPUTemplate = (
  /* wgsl */
  `
    @in aPosition: vec2<f32>;
    @in aUV: vec2<f32>;

    @out @builtin(position) vPosition: vec4<f32>;
    @out vUV : vec2<f32>;
    @out vColor : vec4<f32>;

    {{header}}

    struct VSOutput {
        {{struct}}
    };

    @vertex
    fn main( {{in}} ) -> VSOutput {

        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;
        var modelMatrix = mat3x3<f32>(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        var position = aPosition;
        var uv = aUV;

        {{start}}

        vColor = vec4<f32>(1., 1., 1., 1.);

        {{main}}

        vUV = uv;

        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;

        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);

        vColor *= globalUniforms.uWorldColorAlpha;

        {{end}}

        {{return}}
    };
`
);
const fragmentGPUTemplate = (
  /* wgsl */
  `
    @in vUV : vec2<f32>;
    @in vColor : vec4<f32>;

    {{header}}

    @fragment
    fn main(
        {{in}}
      ) -> @location(0) vec4<f32> {

        {{start}}

        var outColor:vec4<f32>;

        {{main}}

        var finalColor:vec4<f32> = outColor * vColor;

        {{end}}

        return finalColor;
      };
`
);
const vertexGlTemplate = (
  /* glsl */
  `
    in vec2 aPosition;
    in vec2 aUV;

    out vec4 vColor;
    out vec2 vUV;

    {{header}}

    void main(void){

        mat3 worldTransformMatrix = uWorldTransformMatrix;
        mat3 modelMatrix = mat3(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        vec2 position = aPosition;
        vec2 uv = aUV;

        {{start}}

        vColor = vec4(1.);

        {{main}}

        vUV = uv;

        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;

        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);

        vColor *= uWorldColorAlpha;

        {{end}}
    }
`
);
const fragmentGlTemplate = (
  /* glsl */
  `

    in vec4 vColor;
    in vec2 vUV;

    out vec4 finalColor;

    {{header}}

    void main(void) {

        {{start}}

        vec4 outColor;

        {{main}}

        finalColor = outColor * vColor;

        {{end}}
    }
`
);
const globalUniformsBit = {
  name: "global-uniforms-bit",
  vertex: {
    header: (
      /* wgsl */
      `
        struct GlobalUniforms {
            uProjectionMatrix:mat3x3<f32>,
            uWorldTransformMatrix:mat3x3<f32>,
            uWorldColorAlpha: vec4<f32>,
            uResolution: vec2<f32>,
        }

        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;
        `
    )
  }
};
const globalUniformsBitGl = {
  name: "global-uniforms-bit",
  vertex: {
    header: (
      /* glsl */
      `
          uniform mat3 uProjectionMatrix;
          uniform mat3 uWorldTransformMatrix;
          uniform vec4 uWorldColorAlpha;
          uniform vec2 uResolution;
        `
    )
  }
};
function compileHighShaderGpuProgram({ bits, name: name2 }) {
  const source2 = compileHighShader({
    template: {
      fragment: fragmentGPUTemplate,
      vertex: vertexGPUTemplate
    },
    bits: [
      globalUniformsBit,
      ...bits
    ]
  });
  return GpuProgram.from({
    name: name2,
    vertex: {
      source: source2.vertex,
      entryPoint: "main"
    },
    fragment: {
      source: source2.fragment,
      entryPoint: "main"
    }
  });
}
function compileHighShaderGlProgram({ bits, name: name2 }) {
  return new GlProgram({
    name: name2,
    ...compileHighShaderGl({
      template: {
        vertex: vertexGlTemplate,
        fragment: fragmentGlTemplate
      },
      bits: [
        globalUniformsBitGl,
        ...bits
      ]
    })
  });
}
const colorBit = {
  name: "color-bit",
  vertex: {
    header: (
      /* wgsl */
      `
            @in aColor: vec4<f32>;
        `
    ),
    main: (
      /* wgsl */
      `
            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);
        `
    )
  }
};
const colorBitGl = {
  name: "color-bit",
  vertex: {
    header: (
      /* glsl */
      `
            in vec4 aColor;
        `
    ),
    main: (
      /* glsl */
      `
            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);
        `
    )
  }
};
const textureBatchBitGpuCache = {};
function generateBindingSrc(maxTextures) {
  const src = [];
  if (maxTextures === 1) {
    src.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;");
    src.push("@group(1) @binding(1) var textureSampler1: sampler;");
  } else {
    let bindingIndex = 0;
    for (let i2 = 0; i2 < maxTextures; i2++) {
      src.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i2 + 1}: texture_2d<f32>;`);
      src.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i2 + 1}: sampler;`);
    }
  }
  return src.join("\n");
}
function generateSampleSrc(maxTextures) {
  const src = [];
  if (maxTextures === 1) {
    src.push("outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);");
  } else {
    src.push("switch vTextureId {");
    for (let i2 = 0; i2 < maxTextures; i2++) {
      if (i2 === maxTextures - 1) {
        src.push(`  default:{`);
      } else {
        src.push(`  case ${i2}:{`);
      }
      src.push(`      outColor = textureSampleGrad(textureSource${i2 + 1}, textureSampler${i2 + 1}, vUV, uvDx, uvDy);`);
      src.push(`      break;}`);
    }
    src.push(`}`);
  }
  return src.join("\n");
}
function generateTextureBatchBit(maxTextures) {
  if (!textureBatchBitGpuCache[maxTextures]) {
    textureBatchBitGpuCache[maxTextures] = {
      name: "texture-batch-bit",
      vertex: {
        header: `
                @in aTextureIdAndRound: vec2<u32>;
                @out @interpolate(flat) vTextureId : u32;
            `,
        main: `
                vTextureId = aTextureIdAndRound.y;
            `,
        end: `
                if(aTextureIdAndRound.x == 1)
                {
                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
                }
            `
      },
      fragment: {
        header: `
                @in @interpolate(flat) vTextureId: u32;

                ${generateBindingSrc(maxTextures)}
            `,
        main: `
                var uvDx = dpdx(vUV);
                var uvDy = dpdy(vUV);

                ${generateSampleSrc(maxTextures)}
            `
      }
    };
  }
  return textureBatchBitGpuCache[maxTextures];
}
const textureBatchBitGlCache = {};
function generateSampleGlSrc(maxTextures) {
  const src = [];
  for (let i2 = 0; i2 < maxTextures; i2++) {
    if (i2 > 0) {
      src.push("else");
    }
    if (i2 < maxTextures - 1) {
      src.push(`if(vTextureId < ${i2}.5)`);
    }
    src.push("{");
    src.push(`	outColor = texture(uTextures[${i2}], vUV);`);
    src.push("}");
  }
  return src.join("\n");
}
function generateTextureBatchBitGl(maxTextures) {
  if (!textureBatchBitGlCache[maxTextures]) {
    textureBatchBitGlCache[maxTextures] = {
      name: "texture-batch-bit",
      vertex: {
        header: `
                in vec2 aTextureIdAndRound;
                out float vTextureId;

            `,
        main: `
                vTextureId = aTextureIdAndRound.y;
            `,
        end: `
                if(aTextureIdAndRound.x == 1.)
                {
                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
                }
            `
      },
      fragment: {
        header: `
                in float vTextureId;

                uniform sampler2D uTextures[${maxTextures}];

            `,
        main: `

                ${generateSampleGlSrc(maxTextures)}
            `
      }
    };
  }
  return textureBatchBitGlCache[maxTextures];
}
const roundPixelsBit = {
  name: "round-pixels-bit",
  vertex: {
    header: (
      /* wgsl */
      `
            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32>
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
    )
  }
};
const roundPixelsBitGl = {
  name: "round-pixels-bit",
  vertex: {
    header: (
      /* glsl */
      `
            vec2 roundPixels(vec2 position, vec2 targetSize)
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
    )
  }
};
const batchSamplersUniformGroupHash = {};
function getBatchSamplersUniformGroup(maxTextures) {
  let batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures];
  if (batchSamplersUniformGroup)
    return batchSamplersUniformGroup;
  const sampleValues = new Int32Array(maxTextures);
  for (let i2 = 0; i2 < maxTextures; i2++) {
    sampleValues[i2] = i2;
  }
  batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures] = new UniformGroup({
    uTextures: { value: sampleValues, type: `i32`, size: maxTextures }
  }, { isStatic: true });
  return batchSamplersUniformGroup;
}
class DefaultShader extends Shader {
  constructor(maxTextures) {
    const glProgram = compileHighShaderGlProgram({
      name: "batch",
      bits: [
        colorBitGl,
        generateTextureBatchBitGl(maxTextures),
        roundPixelsBitGl
      ]
    });
    const gpuProgram = compileHighShaderGpuProgram({
      name: "batch",
      bits: [
        colorBit,
        generateTextureBatchBit(maxTextures),
        roundPixelsBit
      ]
    });
    super({
      glProgram,
      gpuProgram,
      resources: {
        batchSamplers: getBatchSamplersUniformGroup(maxTextures)
      }
    });
    this.maxTextures = maxTextures;
  }
}
let defaultShader = null;
const _DefaultBatcher = class _DefaultBatcher2 extends Batcher {
  constructor(options) {
    super(options);
    this.geometry = new BatchGeometry();
    this.name = _DefaultBatcher2.extension.name;
    this.vertexSize = 6;
    defaultShader ?? (defaultShader = new DefaultShader(options.maxTextures));
    this.shader = defaultShader;
  }
  /**
   * Packs the attributes of a DefaultBatchableMeshElement into the provided views.
   * @param element - The DefaultBatchableMeshElement to pack.
   * @param float32View - The Float32Array view to pack into.
   * @param uint32View - The Uint32Array view to pack into.
   * @param index - The starting index in the views.
   * @param textureId - The texture ID to use.
   */
  packAttributes(element, float32View, uint32View, index, textureId2) {
    const textureIdAndRound = textureId2 << 16 | element.roundPixels & 65535;
    const wt = element.transform;
    const a2 = wt.a;
    const b2 = wt.b;
    const c2 = wt.c;
    const d2 = wt.d;
    const tx = wt.tx;
    const ty = wt.ty;
    const { positions, uvs } = element;
    const argb = element.color;
    const offset = element.attributeOffset;
    const end = offset + element.attributeSize;
    for (let i2 = offset; i2 < end; i2++) {
      const i22 = i2 * 2;
      const x2 = positions[i22];
      const y2 = positions[i22 + 1];
      float32View[index++] = a2 * x2 + c2 * y2 + tx;
      float32View[index++] = d2 * y2 + b2 * x2 + ty;
      float32View[index++] = uvs[i22];
      float32View[index++] = uvs[i22 + 1];
      uint32View[index++] = argb;
      uint32View[index++] = textureIdAndRound;
    }
  }
  /**
   * Packs the attributes of a DefaultBatchableQuadElement into the provided views.
   * @param element - The DefaultBatchableQuadElement to pack.
   * @param float32View - The Float32Array view to pack into.
   * @param uint32View - The Uint32Array view to pack into.
   * @param index - The starting index in the views.
   * @param textureId - The texture ID to use.
   */
  packQuadAttributes(element, float32View, uint32View, index, textureId2) {
    const texture = element.texture;
    const wt = element.transform;
    const a2 = wt.a;
    const b2 = wt.b;
    const c2 = wt.c;
    const d2 = wt.d;
    const tx = wt.tx;
    const ty = wt.ty;
    const bounds = element.bounds;
    const w0 = bounds.maxX;
    const w1 = bounds.minX;
    const h0 = bounds.maxY;
    const h1 = bounds.minY;
    const uvs = texture.uvs;
    const argb = element.color;
    const textureIdAndRound = textureId2 << 16 | element.roundPixels & 65535;
    float32View[index + 0] = a2 * w1 + c2 * h1 + tx;
    float32View[index + 1] = d2 * h1 + b2 * w1 + ty;
    float32View[index + 2] = uvs.x0;
    float32View[index + 3] = uvs.y0;
    uint32View[index + 4] = argb;
    uint32View[index + 5] = textureIdAndRound;
    float32View[index + 6] = a2 * w0 + c2 * h1 + tx;
    float32View[index + 7] = d2 * h1 + b2 * w0 + ty;
    float32View[index + 8] = uvs.x1;
    float32View[index + 9] = uvs.y1;
    uint32View[index + 10] = argb;
    uint32View[index + 11] = textureIdAndRound;
    float32View[index + 12] = a2 * w0 + c2 * h0 + tx;
    float32View[index + 13] = d2 * h0 + b2 * w0 + ty;
    float32View[index + 14] = uvs.x2;
    float32View[index + 15] = uvs.y2;
    uint32View[index + 16] = argb;
    uint32View[index + 17] = textureIdAndRound;
    float32View[index + 18] = a2 * w1 + c2 * h0 + tx;
    float32View[index + 19] = d2 * h0 + b2 * w1 + ty;
    float32View[index + 20] = uvs.x3;
    float32View[index + 21] = uvs.y3;
    uint32View[index + 22] = argb;
    uint32View[index + 23] = textureIdAndRound;
  }
  /**
   * Updates the maximum number of textures that can be used in the shader.
   * @param maxTextures - The maximum number of textures that can be used in the shader.
   * @internal
   */
  _updateMaxTextures(maxTextures) {
    if (this.shader.maxTextures === maxTextures)
      return;
    defaultShader = new DefaultShader(maxTextures);
    this.shader = defaultShader;
  }
  destroy() {
    this.shader = null;
    super.destroy();
  }
};
_DefaultBatcher.extension = {
  type: [
    ExtensionType.Batcher
  ],
  name: "default"
};
let DefaultBatcher = _DefaultBatcher;
function buildUvs(vertices, verticesStride, verticesOffset, uvs, uvsOffset, uvsStride, size2, matrix = null) {
  let index = 0;
  verticesOffset *= verticesStride;
  uvsOffset *= uvsStride;
  const a2 = matrix.a;
  const b2 = matrix.b;
  const c2 = matrix.c;
  const d2 = matrix.d;
  const tx = matrix.tx;
  const ty = matrix.ty;
  while (index < size2) {
    const x2 = vertices[verticesOffset];
    const y2 = vertices[verticesOffset + 1];
    uvs[uvsOffset] = a2 * x2 + c2 * y2 + tx;
    uvs[uvsOffset + 1] = b2 * x2 + d2 * y2 + ty;
    uvsOffset += uvsStride;
    verticesOffset += verticesStride;
    index++;
  }
}
function buildSimpleUvs(uvs, uvsOffset, uvsStride, size2) {
  let index = 0;
  uvsOffset *= uvsStride;
  while (index < size2) {
    uvs[uvsOffset] = 0;
    uvs[uvsOffset + 1] = 0;
    uvsOffset += uvsStride;
    index++;
  }
}
function transformVertices(vertices, m2, offset, stride, size2) {
  const a2 = m2.a;
  const b2 = m2.b;
  const c2 = m2.c;
  const d2 = m2.d;
  const tx = m2.tx;
  const ty = m2.ty;
  offset || (offset = 0);
  stride || (stride = 2);
  size2 || (size2 = vertices.length / stride - offset);
  let index = offset * stride;
  for (let i2 = 0; i2 < size2; i2++) {
    const x2 = vertices[index];
    const y2 = vertices[index + 1];
    vertices[index] = a2 * x2 + c2 * y2 + tx;
    vertices[index + 1] = b2 * x2 + d2 * y2 + ty;
    index += stride;
  }
}
const identityMatrix = new Matrix();
class BatchableGraphics {
  constructor() {
    this.packAsQuad = false;
    this.batcherName = "default";
    this.topology = "triangle-list";
    this.applyTransform = true;
    this.roundPixels = 0;
    this._batcher = null;
    this._batch = null;
  }
  get uvs() {
    return this.geometryData.uvs;
  }
  get positions() {
    return this.geometryData.vertices;
  }
  get indices() {
    return this.geometryData.indices;
  }
  get blendMode() {
    if (this.renderable && this.applyTransform) {
      return this.renderable.groupBlendMode;
    }
    return "normal";
  }
  get color() {
    const rgb = this.baseColor;
    const bgr = rgb >> 16 | rgb & 65280 | (rgb & 255) << 16;
    const renderable = this.renderable;
    if (renderable) {
      return multiplyHexColors(bgr, renderable.groupColor) + (this.alpha * renderable.groupAlpha * 255 << 24);
    }
    return bgr + (this.alpha * 255 << 24);
  }
  get transform() {
    var _a;
    return ((_a = this.renderable) == null ? void 0 : _a.groupTransform) || identityMatrix;
  }
  copyTo(gpuBuffer) {
    gpuBuffer.indexOffset = this.indexOffset;
    gpuBuffer.indexSize = this.indexSize;
    gpuBuffer.attributeOffset = this.attributeOffset;
    gpuBuffer.attributeSize = this.attributeSize;
    gpuBuffer.baseColor = this.baseColor;
    gpuBuffer.alpha = this.alpha;
    gpuBuffer.texture = this.texture;
    gpuBuffer.geometryData = this.geometryData;
    gpuBuffer.topology = this.topology;
  }
  reset() {
    this.applyTransform = true;
    this.renderable = null;
    this.topology = "triangle-list";
  }
  destroy() {
    this.renderable = null;
    this.texture = null;
    this.geometryData = null;
    this._batcher = null;
    this._batch = null;
  }
}
const buildCircle = {
  extension: {
    type: ExtensionType.ShapeBuilder,
    name: "circle"
  },
  build(shape, points) {
    let x2;
    let y2;
    let dx;
    let dy;
    let rx;
    let ry;
    if (shape.type === "circle") {
      const circle = shape;
      rx = ry = circle.radius;
      if (rx <= 0) {
        return false;
      }
      x2 = circle.x;
      y2 = circle.y;
      dx = dy = 0;
    } else if (shape.type === "ellipse") {
      const ellipse = shape;
      rx = ellipse.halfWidth;
      ry = ellipse.halfHeight;
      if (rx <= 0 || ry <= 0) {
        return false;
      }
      x2 = ellipse.x;
      y2 = ellipse.y;
      dx = dy = 0;
    } else {
      const roundedRect = shape;
      const halfWidth = roundedRect.width / 2;
      const halfHeight = roundedRect.height / 2;
      x2 = roundedRect.x + halfWidth;
      y2 = roundedRect.y + halfHeight;
      rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));
      dx = halfWidth - rx;
      dy = halfHeight - ry;
    }
    if (dx < 0 || dy < 0) {
      return false;
    }
    const n2 = Math.ceil(2.3 * Math.sqrt(rx + ry));
    const m2 = n2 * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);
    if (m2 === 0) {
      return false;
    }
    if (n2 === 0) {
      points[0] = points[6] = x2 + dx;
      points[1] = points[3] = y2 + dy;
      points[2] = points[4] = x2 - dx;
      points[5] = points[7] = y2 - dy;
      return true;
    }
    let j1 = 0;
    let j2 = n2 * 4 + (dx ? 2 : 0) + 2;
    let j3 = j2;
    let j4 = m2;
    let x0 = dx + rx;
    let y0 = dy;
    let x1 = x2 + x0;
    let x22 = x2 - x0;
    let y1 = y2 + y0;
    points[j1++] = x1;
    points[j1++] = y1;
    points[--j2] = y1;
    points[--j2] = x22;
    if (dy) {
      const y222 = y2 - y0;
      points[j3++] = x22;
      points[j3++] = y222;
      points[--j4] = y222;
      points[--j4] = x1;
    }
    for (let i2 = 1; i2 < n2; i2++) {
      const a2 = Math.PI / 2 * (i2 / n2);
      const x02 = dx + Math.cos(a2) * rx;
      const y02 = dy + Math.sin(a2) * ry;
      const x12 = x2 + x02;
      const x222 = x2 - x02;
      const y12 = y2 + y02;
      const y222 = y2 - y02;
      points[j1++] = x12;
      points[j1++] = y12;
      points[--j2] = y12;
      points[--j2] = x222;
      points[j3++] = x222;
      points[j3++] = y222;
      points[--j4] = y222;
      points[--j4] = x12;
    }
    x0 = dx;
    y0 = dy + ry;
    x1 = x2 + x0;
    x22 = x2 - x0;
    y1 = y2 + y0;
    const y22 = y2 - y0;
    points[j1++] = x1;
    points[j1++] = y1;
    points[--j4] = y22;
    points[--j4] = x1;
    if (dx) {
      points[j1++] = x22;
      points[j1++] = y1;
      points[--j4] = y22;
      points[--j4] = x22;
    }
    return true;
  },
  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
    if (points.length === 0) {
      return;
    }
    let centerX = 0;
    let centerY = 0;
    for (let i2 = 0; i2 < points.length; i2 += 2) {
      centerX += points[i2];
      centerY += points[i2 + 1];
    }
    centerX /= points.length / 2;
    centerY /= points.length / 2;
    let count2 = verticesOffset;
    vertices[count2 * verticesStride] = centerX;
    vertices[count2 * verticesStride + 1] = centerY;
    const centerIndex = count2++;
    for (let i2 = 0; i2 < points.length; i2 += 2) {
      vertices[count2 * verticesStride] = points[i2];
      vertices[count2 * verticesStride + 1] = points[i2 + 1];
      if (i2 > 0) {
        indices[indicesOffset++] = count2;
        indices[indicesOffset++] = centerIndex;
        indices[indicesOffset++] = count2 - 1;
      }
      count2++;
    }
    indices[indicesOffset++] = centerIndex + 1;
    indices[indicesOffset++] = centerIndex;
    indices[indicesOffset++] = count2 - 1;
  }
};
const buildEllipse = { ...buildCircle, extension: { ...buildCircle.extension, name: "ellipse" } };
const buildRoundedRectangle = { ...buildCircle, extension: { ...buildCircle.extension, name: "roundedRectangle" } };
const closePointEps = 1e-4;
const curveEps = 1e-4;
function getOrientationOfPoints(points) {
  const m2 = points.length;
  if (m2 < 6) {
    return 1;
  }
  let area2 = 0;
  for (let i2 = 0, x1 = points[m2 - 2], y1 = points[m2 - 1]; i2 < m2; i2 += 2) {
    const x2 = points[i2];
    const y2 = points[i2 + 1];
    area2 += (x2 - x1) * (y2 + y1);
    x1 = x2;
    y1 = y2;
  }
  if (area2 < 0) {
    return -1;
  }
  return 1;
}
function square(x2, y2, nx, ny, innerWeight, outerWeight, clockwise, verts) {
  const ix = x2 - nx * innerWeight;
  const iy = y2 - ny * innerWeight;
  const ox = x2 + nx * outerWeight;
  const oy = y2 + ny * outerWeight;
  let exx;
  let eyy;
  if (clockwise) {
    exx = ny;
    eyy = -nx;
  } else {
    exx = -ny;
    eyy = nx;
  }
  const eix = ix + exx;
  const eiy = iy + eyy;
  const eox = ox + exx;
  const eoy = oy + eyy;
  verts.push(eix, eiy);
  verts.push(eox, eoy);
  return 2;
}
function round(cx, cy, sx, sy, ex, ey, verts, clockwise) {
  const cx2p0x = sx - cx;
  const cy2p0y = sy - cy;
  let angle0 = Math.atan2(cx2p0x, cy2p0y);
  let angle1 = Math.atan2(ex - cx, ey - cy);
  if (clockwise && angle0 < angle1) {
    angle0 += Math.PI * 2;
  } else if (!clockwise && angle0 > angle1) {
    angle1 += Math.PI * 2;
  }
  let startAngle = angle0;
  const angleDiff = angle1 - angle0;
  const absAngleDiff = Math.abs(angleDiff);
  const radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);
  const segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;
  const angleInc = angleDiff / segCount;
  startAngle += angleInc;
  if (clockwise) {
    verts.push(cx, cy);
    verts.push(sx, sy);
    for (let i2 = 1, angle = startAngle; i2 < segCount; i2++, angle += angleInc) {
      verts.push(cx, cy);
      verts.push(
        cx + Math.sin(angle) * radius,
        cy + Math.cos(angle) * radius
      );
    }
    verts.push(cx, cy);
    verts.push(ex, ey);
  } else {
    verts.push(sx, sy);
    verts.push(cx, cy);
    for (let i2 = 1, angle = startAngle; i2 < segCount; i2++, angle += angleInc) {
      verts.push(
        cx + Math.sin(angle) * radius,
        cy + Math.cos(angle) * radius
      );
      verts.push(cx, cy);
    }
    verts.push(ex, ey);
    verts.push(cx, cy);
  }
  return segCount * 2;
}
function buildLine(points, lineStyle, flipAlignment, closed, vertices, indices) {
  const eps = closePointEps;
  if (points.length === 0) {
    return;
  }
  const style = lineStyle;
  let alignment = style.alignment;
  if (lineStyle.alignment !== 0.5) {
    let orientation = getOrientationOfPoints(points);
    alignment = (alignment - 0.5) * orientation + 0.5;
  }
  const firstPoint = new Point(points[0], points[1]);
  const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);
  const closedShape = closed;
  const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps;
  if (closedShape) {
    points = points.slice();
    if (closedPath) {
      points.pop();
      points.pop();
      lastPoint.set(points[points.length - 2], points[points.length - 1]);
    }
    const midPointX = (firstPoint.x + lastPoint.x) * 0.5;
    const midPointY = (lastPoint.y + firstPoint.y) * 0.5;
    points.unshift(midPointX, midPointY);
    points.push(midPointX, midPointY);
  }
  const verts = vertices;
  const length = points.length / 2;
  let indexCount = points.length;
  const indexStart = verts.length / 2;
  const width = style.width / 2;
  const widthSquared = width * width;
  const miterLimitSquared = style.miterLimit * style.miterLimit;
  let x0 = points[0];
  let y0 = points[1];
  let x1 = points[2];
  let y1 = points[3];
  let x2 = 0;
  let y2 = 0;
  let perpX = -(y0 - y1);
  let perpY = x0 - x1;
  let perp1x = 0;
  let perp1y = 0;
  let dist = Math.sqrt(perpX * perpX + perpY * perpY);
  perpX /= dist;
  perpY /= dist;
  perpX *= width;
  perpY *= width;
  const ratio = alignment;
  const innerWeight = (1 - ratio) * 2;
  const outerWeight = ratio * 2;
  if (!closedShape) {
    if (style.cap === "round") {
      indexCount += round(
        x0 - perpX * (innerWeight - outerWeight) * 0.5,
        y0 - perpY * (innerWeight - outerWeight) * 0.5,
        x0 - perpX * innerWeight,
        y0 - perpY * innerWeight,
        x0 + perpX * outerWeight,
        y0 + perpY * outerWeight,
        verts,
        true
      ) + 2;
    } else if (style.cap === "square") {
      indexCount += square(x0, y0, perpX, perpY, innerWeight, outerWeight, true, verts);
    }
  }
  verts.push(
    x0 - perpX * innerWeight,
    y0 - perpY * innerWeight
  );
  verts.push(
    x0 + perpX * outerWeight,
    y0 + perpY * outerWeight
  );
  for (let i2 = 1; i2 < length - 1; ++i2) {
    x0 = points[(i2 - 1) * 2];
    y0 = points[(i2 - 1) * 2 + 1];
    x1 = points[i2 * 2];
    y1 = points[i2 * 2 + 1];
    x2 = points[(i2 + 1) * 2];
    y2 = points[(i2 + 1) * 2 + 1];
    perpX = -(y0 - y1);
    perpY = x0 - x1;
    dist = Math.sqrt(perpX * perpX + perpY * perpY);
    perpX /= dist;
    perpY /= dist;
    perpX *= width;
    perpY *= width;
    perp1x = -(y1 - y2);
    perp1y = x1 - x2;
    dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);
    perp1x /= dist;
    perp1y /= dist;
    perp1x *= width;
    perp1y *= width;
    const dx0 = x1 - x0;
    const dy0 = y0 - y1;
    const dx1 = x1 - x2;
    const dy1 = y2 - y1;
    const dot = dx0 * dx1 + dy0 * dy1;
    const cross = dy0 * dx1 - dy1 * dx0;
    const clockwise = cross < 0;
    if (Math.abs(cross) < 1e-3 * Math.abs(dot)) {
      verts.push(
        x1 - perpX * innerWeight,
        y1 - perpY * innerWeight
      );
      verts.push(
        x1 + perpX * outerWeight,
        y1 + perpY * outerWeight
      );
      if (dot >= 0) {
        if (style.join === "round") {
          indexCount += round(
            x1,
            y1,
            x1 - perpX * innerWeight,
            y1 - perpY * innerWeight,
            x1 - perp1x * innerWeight,
            y1 - perp1y * innerWeight,
            verts,
            false
          ) + 4;
        } else {
          indexCount += 2;
        }
        verts.push(
          x1 - perp1x * outerWeight,
          y1 - perp1y * outerWeight
        );
        verts.push(
          x1 + perp1x * innerWeight,
          y1 + perp1y * innerWeight
        );
      }
      continue;
    }
    const c1 = (-perpX + x0) * (-perpY + y1) - (-perpX + x1) * (-perpY + y0);
    const c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);
    const px = (dx0 * c2 - dx1 * c1) / cross;
    const py = (dy1 * c1 - dy0 * c2) / cross;
    const pDist = (px - x1) * (px - x1) + (py - y1) * (py - y1);
    const imx = x1 + (px - x1) * innerWeight;
    const imy = y1 + (py - y1) * innerWeight;
    const omx = x1 - (px - x1) * outerWeight;
    const omy = y1 - (py - y1) * outerWeight;
    const smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);
    const insideWeight = clockwise ? innerWeight : outerWeight;
    const smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;
    const insideMiterOk = pDist <= smallerInsideDiagonalSq;
    if (insideMiterOk) {
      if (style.join === "bevel" || pDist / widthSquared > miterLimitSquared) {
        if (clockwise) {
          verts.push(imx, imy);
          verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
          verts.push(imx, imy);
          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
        } else {
          verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
          verts.push(omx, omy);
          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
          verts.push(omx, omy);
        }
        indexCount += 2;
      } else if (style.join === "round") {
        if (clockwise) {
          verts.push(imx, imy);
          verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
          indexCount += round(
            x1,
            y1,
            x1 + perpX * outerWeight,
            y1 + perpY * outerWeight,
            x1 + perp1x * outerWeight,
            y1 + perp1y * outerWeight,
            verts,
            true
          ) + 4;
          verts.push(imx, imy);
          verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
        } else {
          verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
          verts.push(omx, omy);
          indexCount += round(
            x1,
            y1,
            x1 - perpX * innerWeight,
            y1 - perpY * innerWeight,
            x1 - perp1x * innerWeight,
            y1 - perp1y * innerWeight,
            verts,
            false
          ) + 4;
          verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
          verts.push(omx, omy);
        }
      } else {
        verts.push(imx, imy);
        verts.push(omx, omy);
      }
    } else {
      verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
      verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
      if (style.join === "round") {
        if (clockwise) {
          indexCount += round(
            x1,
            y1,
            x1 + perpX * outerWeight,
            y1 + perpY * outerWeight,
            x1 + perp1x * outerWeight,
            y1 + perp1y * outerWeight,
            verts,
            true
          ) + 2;
        } else {
          indexCount += round(
            x1,
            y1,
            x1 - perpX * innerWeight,
            y1 - perpY * innerWeight,
            x1 - perp1x * innerWeight,
            y1 - perp1y * innerWeight,
            verts,
            false
          ) + 2;
        }
      } else if (style.join === "miter" && pDist / widthSquared <= miterLimitSquared) {
        if (clockwise) {
          verts.push(omx, omy);
          verts.push(omx, omy);
        } else {
          verts.push(imx, imy);
          verts.push(imx, imy);
        }
        indexCount += 2;
      }
      verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);
      verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);
      indexCount += 2;
    }
  }
  x0 = points[(length - 2) * 2];
  y0 = points[(length - 2) * 2 + 1];
  x1 = points[(length - 1) * 2];
  y1 = points[(length - 1) * 2 + 1];
  perpX = -(y0 - y1);
  perpY = x0 - x1;
  dist = Math.sqrt(perpX * perpX + perpY * perpY);
  perpX /= dist;
  perpY /= dist;
  perpX *= width;
  perpY *= width;
  verts.push(x1 - perpX * innerWeight, y1 - perpY * innerWeight);
  verts.push(x1 + perpX * outerWeight, y1 + perpY * outerWeight);
  if (!closedShape) {
    if (style.cap === "round") {
      indexCount += round(
        x1 - perpX * (innerWeight - outerWeight) * 0.5,
        y1 - perpY * (innerWeight - outerWeight) * 0.5,
        x1 - perpX * innerWeight,
        y1 - perpY * innerWeight,
        x1 + perpX * outerWeight,
        y1 + perpY * outerWeight,
        verts,
        false
      ) + 2;
    } else if (style.cap === "square") {
      indexCount += square(x1, y1, perpX, perpY, innerWeight, outerWeight, false, verts);
    }
  }
  const eps2 = curveEps * curveEps;
  for (let i2 = indexStart; i2 < indexCount + indexStart - 2; ++i2) {
    x0 = verts[i2 * 2];
    y0 = verts[i2 * 2 + 1];
    x1 = verts[(i2 + 1) * 2];
    y1 = verts[(i2 + 1) * 2 + 1];
    x2 = verts[(i2 + 2) * 2];
    y2 = verts[(i2 + 2) * 2 + 1];
    if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) {
      continue;
    }
    indices.push(i2, i2 + 1, i2 + 2);
  }
}
function buildPixelLine(points, closed, vertices, indices) {
  const eps = closePointEps;
  if (points.length === 0) {
    return;
  }
  const fx = points[0];
  const fy = points[1];
  const lx = points[points.length - 2];
  const ly = points[points.length - 1];
  const closePath = closed || Math.abs(fx - lx) < eps && Math.abs(fy - ly) < eps;
  const verts = vertices;
  const length = points.length / 2;
  const indexStart = verts.length / 2;
  for (let i2 = 0; i2 < length; i2++) {
    verts.push(points[i2 * 2]);
    verts.push(points[i2 * 2 + 1]);
  }
  for (let i2 = 0; i2 < length - 1; i2++) {
    indices.push(indexStart + i2, indexStart + i2 + 1);
  }
  if (closePath) {
    indices.push(indexStart + length - 1, indexStart);
  }
}
function triangulateWithHoles(points, holes, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
  const triangles = earcut(points, holes, 2);
  if (!triangles) {
    return;
  }
  for (let i2 = 0; i2 < triangles.length; i2 += 3) {
    indices[indicesOffset++] = triangles[i2] + verticesOffset;
    indices[indicesOffset++] = triangles[i2 + 1] + verticesOffset;
    indices[indicesOffset++] = triangles[i2 + 2] + verticesOffset;
  }
  let index = verticesOffset * verticesStride;
  for (let i2 = 0; i2 < points.length; i2 += 2) {
    vertices[index] = points[i2];
    vertices[index + 1] = points[i2 + 1];
    index += verticesStride;
  }
}
const emptyArray = [];
const buildPolygon = {
  extension: {
    type: ExtensionType.ShapeBuilder,
    name: "polygon"
  },
  build(shape, points) {
    for (let i2 = 0; i2 < shape.points.length; i2++) {
      points[i2] = shape.points[i2];
    }
    return true;
  },
  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
    triangulateWithHoles(points, emptyArray, vertices, verticesStride, verticesOffset, indices, indicesOffset);
  }
};
const buildRectangle = {
  extension: {
    type: ExtensionType.ShapeBuilder,
    name: "rectangle"
  },
  build(shape, points) {
    const rectData = shape;
    const x2 = rectData.x;
    const y2 = rectData.y;
    const width = rectData.width;
    const height = rectData.height;
    if (!(width > 0 && height > 0)) {
      return false;
    }
    points[0] = x2;
    points[1] = y2;
    points[2] = x2 + width;
    points[3] = y2;
    points[4] = x2 + width;
    points[5] = y2 + height;
    points[6] = x2;
    points[7] = y2 + height;
    return true;
  },
  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
    let count2 = 0;
    verticesOffset *= verticesStride;
    vertices[verticesOffset + count2] = points[0];
    vertices[verticesOffset + count2 + 1] = points[1];
    count2 += verticesStride;
    vertices[verticesOffset + count2] = points[2];
    vertices[verticesOffset + count2 + 1] = points[3];
    count2 += verticesStride;
    vertices[verticesOffset + count2] = points[6];
    vertices[verticesOffset + count2 + 1] = points[7];
    count2 += verticesStride;
    vertices[verticesOffset + count2] = points[4];
    vertices[verticesOffset + count2 + 1] = points[5];
    count2 += verticesStride;
    const verticesIndex = verticesOffset / verticesStride;
    indices[indicesOffset++] = verticesIndex;
    indices[indicesOffset++] = verticesIndex + 1;
    indices[indicesOffset++] = verticesIndex + 2;
    indices[indicesOffset++] = verticesIndex + 1;
    indices[indicesOffset++] = verticesIndex + 3;
    indices[indicesOffset++] = verticesIndex + 2;
  }
};
const buildTriangle = {
  extension: {
    type: ExtensionType.ShapeBuilder,
    name: "triangle"
  },
  build(shape, points) {
    points[0] = shape.x;
    points[1] = shape.y;
    points[2] = shape.x2;
    points[3] = shape.y2;
    points[4] = shape.x3;
    points[5] = shape.y3;
    return true;
  },
  triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
    let count2 = 0;
    verticesOffset *= verticesStride;
    vertices[verticesOffset + count2] = points[0];
    vertices[verticesOffset + count2 + 1] = points[1];
    count2 += verticesStride;
    vertices[verticesOffset + count2] = points[2];
    vertices[verticesOffset + count2 + 1] = points[3];
    count2 += verticesStride;
    vertices[verticesOffset + count2] = points[4];
    vertices[verticesOffset + count2 + 1] = points[5];
    const verticesIndex = verticesOffset / verticesStride;
    indices[indicesOffset++] = verticesIndex;
    indices[indicesOffset++] = verticesIndex + 1;
    indices[indicesOffset++] = verticesIndex + 2;
  }
};
const tempTextureMatrix$1 = new Matrix();
const tempRect$2 = new Rectangle();
function generateTextureMatrix(out2, style, shape, matrix) {
  const textureMatrix = style.matrix ? out2.copyFrom(style.matrix).invert() : out2.identity();
  if (style.textureSpace === "local") {
    const bounds = shape.getBounds(tempRect$2);
    if (style.width) {
      bounds.pad(style.width);
    }
    const { x: tx, y: ty } = bounds;
    const sx = 1 / bounds.width;
    const sy = 1 / bounds.height;
    const mTx = -tx * sx;
    const mTy = -ty * sy;
    const a1 = textureMatrix.a;
    const b1 = textureMatrix.b;
    const c1 = textureMatrix.c;
    const d1 = textureMatrix.d;
    textureMatrix.a *= sx;
    textureMatrix.b *= sx;
    textureMatrix.c *= sy;
    textureMatrix.d *= sy;
    textureMatrix.tx = mTx * a1 + mTy * c1 + textureMatrix.tx;
    textureMatrix.ty = mTx * b1 + mTy * d1 + textureMatrix.ty;
  } else {
    textureMatrix.translate(style.texture.frame.x, style.texture.frame.y);
    textureMatrix.scale(1 / style.texture.source.width, 1 / style.texture.source.height);
  }
  const sourceStyle = style.texture.source.style;
  if (!(style.fill instanceof FillGradient) && sourceStyle.addressMode === "clamp-to-edge") {
    sourceStyle.addressMode = "repeat";
    sourceStyle.update();
  }
  if (matrix) {
    textureMatrix.append(tempTextureMatrix$1.copyFrom(matrix).invert());
  }
  return textureMatrix;
}
const shapeBuilders = {};
extensions.handleByMap(ExtensionType.ShapeBuilder, shapeBuilders);
extensions.add(buildRectangle, buildPolygon, buildTriangle, buildCircle, buildEllipse, buildRoundedRectangle);
const tempRect$1 = new Rectangle();
const tempTextureMatrix = new Matrix();
function buildContextBatches(context2, gpuContext) {
  const { geometryData, batches } = gpuContext;
  batches.length = 0;
  geometryData.indices.length = 0;
  geometryData.vertices.length = 0;
  geometryData.uvs.length = 0;
  for (let i2 = 0; i2 < context2.instructions.length; i2++) {
    const instruction = context2.instructions[i2];
    if (instruction.action === "texture") {
      addTextureToGeometryData(instruction.data, batches, geometryData);
    } else if (instruction.action === "fill" || instruction.action === "stroke") {
      const isStroke = instruction.action === "stroke";
      const shapePath = instruction.data.path.shapePath;
      const style = instruction.data.style;
      const hole = instruction.data.hole;
      if (isStroke && hole) {
        addShapePathToGeometryData(hole.shapePath, style, true, batches, geometryData);
      }
      if (hole) {
        shapePath.shapePrimitives[shapePath.shapePrimitives.length - 1].holes = hole.shapePath.shapePrimitives;
      }
      addShapePathToGeometryData(shapePath, style, isStroke, batches, geometryData);
    }
  }
}
function addTextureToGeometryData(data, batches, geometryData) {
  const points = [];
  const build = shapeBuilders.rectangle;
  const rect = tempRect$1;
  rect.x = data.dx;
  rect.y = data.dy;
  rect.width = data.dw;
  rect.height = data.dh;
  const matrix = data.transform;
  if (!build.build(rect, points)) {
    return;
  }
  const { vertices, uvs, indices } = geometryData;
  const indexOffset = indices.length;
  const vertOffset = vertices.length / 2;
  if (matrix) {
    transformVertices(points, matrix);
  }
  build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);
  const texture = data.image;
  const textureUvs = texture.uvs;
  uvs.push(
    textureUvs.x0,
    textureUvs.y0,
    textureUvs.x1,
    textureUvs.y1,
    textureUvs.x3,
    textureUvs.y3,
    textureUvs.x2,
    textureUvs.y2
  );
  const graphicsBatch = BigPool.get(BatchableGraphics);
  graphicsBatch.indexOffset = indexOffset;
  graphicsBatch.indexSize = indices.length - indexOffset;
  graphicsBatch.attributeOffset = vertOffset;
  graphicsBatch.attributeSize = vertices.length / 2 - vertOffset;
  graphicsBatch.baseColor = data.style;
  graphicsBatch.alpha = data.alpha;
  graphicsBatch.texture = texture;
  graphicsBatch.geometryData = geometryData;
  batches.push(graphicsBatch);
}
function addShapePathToGeometryData(shapePath, style, isStroke, batches, geometryData) {
  const { vertices, uvs, indices } = geometryData;
  shapePath.shapePrimitives.forEach(({ shape, transform: matrix, holes }) => {
    const points = [];
    const build = shapeBuilders[shape.type];
    if (!build.build(shape, points)) {
      return;
    }
    const indexOffset = indices.length;
    const vertOffset = vertices.length / 2;
    let topology = "triangle-list";
    if (matrix) {
      transformVertices(points, matrix);
    }
    if (!isStroke) {
      if (holes) {
        const holeIndices = [];
        const otherPoints = points.slice();
        const holeArrays = getHoleArrays(holes);
        holeArrays.forEach((holePoints) => {
          holeIndices.push(otherPoints.length / 2);
          otherPoints.push(...holePoints);
        });
        triangulateWithHoles(otherPoints, holeIndices, vertices, 2, vertOffset, indices, indexOffset);
      } else {
        build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);
      }
    } else {
      const close = shape.closePath ?? true;
      const lineStyle = style;
      if (!lineStyle.pixelLine) {
        buildLine(points, lineStyle, false, close, vertices, indices);
      } else {
        buildPixelLine(points, close, vertices, indices);
        topology = "line-list";
      }
    }
    const uvsOffset = uvs.length / 2;
    const texture = style.texture;
    if (texture !== Texture.WHITE) {
      const textureMatrix = generateTextureMatrix(tempTextureMatrix, style, shape, matrix);
      buildUvs(vertices, 2, vertOffset, uvs, uvsOffset, 2, vertices.length / 2 - vertOffset, textureMatrix);
    } else {
      buildSimpleUvs(uvs, uvsOffset, 2, vertices.length / 2 - vertOffset);
    }
    const graphicsBatch = BigPool.get(BatchableGraphics);
    graphicsBatch.indexOffset = indexOffset;
    graphicsBatch.indexSize = indices.length - indexOffset;
    graphicsBatch.attributeOffset = vertOffset;
    graphicsBatch.attributeSize = vertices.length / 2 - vertOffset;
    graphicsBatch.baseColor = style.color;
    graphicsBatch.alpha = style.alpha;
    graphicsBatch.texture = texture;
    graphicsBatch.geometryData = geometryData;
    graphicsBatch.topology = topology;
    batches.push(graphicsBatch);
  });
}
function getHoleArrays(holePrimitives) {
  const holeArrays = [];
  for (let k2 = 0; k2 < holePrimitives.length; k2++) {
    const holePrimitive = holePrimitives[k2].shape;
    const holePoints = [];
    const holeBuilder = shapeBuilders[holePrimitive.type];
    if (holeBuilder.build(holePrimitive, holePoints)) {
      holeArrays.push(holePoints);
    }
  }
  return holeArrays;
}
class GpuGraphicsContext {
  constructor() {
    this.batches = [];
    this.geometryData = {
      vertices: [],
      uvs: [],
      indices: []
    };
  }
}
class GraphicsContextRenderData {
  constructor() {
    this.instructions = new InstructionSet();
  }
  init(options) {
    const maxTextures = options.maxTextures;
    this.batcher ? this.batcher._updateMaxTextures(maxTextures) : this.batcher = new DefaultBatcher({ maxTextures });
    this.instructions.reset();
  }
  /**
   * @deprecated since version 8.0.0
   * Use `batcher.geometry` instead.
   * @see {Batcher#geometry}
   */
  get geometry() {
    deprecation(v8_3_4, "GraphicsContextRenderData#geometry is deprecated, please use batcher.geometry instead.");
    return this.batcher.geometry;
  }
  destroy() {
    this.batcher.destroy();
    this.instructions.destroy();
    this.batcher = null;
    this.instructions = null;
  }
}
const _GraphicsContextSystem = class _GraphicsContextSystem2 {
  constructor(renderer) {
    this._gpuContextHash = {};
    this._graphicsDataContextHash = /* @__PURE__ */ Object.create(null);
    this._renderer = renderer;
    renderer.renderableGC.addManagedHash(this, "_gpuContextHash");
    renderer.renderableGC.addManagedHash(this, "_graphicsDataContextHash");
  }
  /**
   * Runner init called, update the default options
   * @ignore
   */
  init(options) {
    _GraphicsContextSystem2.defaultOptions.bezierSmoothness = (options == null ? void 0 : options.bezierSmoothness) ?? _GraphicsContextSystem2.defaultOptions.bezierSmoothness;
  }
  /**
   * Returns the render data for a given GraphicsContext.
   * @param context - The GraphicsContext to get the render data for.
   * @internal
   */
  getContextRenderData(context2) {
    return this._graphicsDataContextHash[context2.uid] || this._initContextRenderData(context2);
  }
  /**
   * Updates the GPU context for a given GraphicsContext.
   * If the context is dirty, it will rebuild the batches and geometry data.
   * @param context - The GraphicsContext to update.
   * @returns The updated GpuGraphicsContext.
   * @internal
   */
  updateGpuContext(context2) {
    let gpuContext = this._gpuContextHash[context2.uid] || this._initContext(context2);
    if (context2.dirty) {
      if (gpuContext) {
        this._cleanGraphicsContextData(context2);
      } else {
        gpuContext = this._initContext(context2);
      }
      buildContextBatches(context2, gpuContext);
      const batchMode = context2.batchMode;
      if (context2.customShader || batchMode === "no-batch") {
        gpuContext.isBatchable = false;
      } else if (batchMode === "auto") {
        gpuContext.isBatchable = gpuContext.geometryData.vertices.length < 400;
      } else {
        gpuContext.isBatchable = true;
      }
      context2.dirty = false;
    }
    return gpuContext;
  }
  /**
   * Returns the GpuGraphicsContext for a given GraphicsContext.
   * If it does not exist, it will initialize a new one.
   * @param context - The GraphicsContext to get the GpuGraphicsContext for.
   * @returns The GpuGraphicsContext for the given GraphicsContext.
   * @internal
   */
  getGpuContext(context2) {
    return this._gpuContextHash[context2.uid] || this._initContext(context2);
  }
  _initContextRenderData(context2) {
    const graphicsData = BigPool.get(GraphicsContextRenderData, {
      maxTextures: this._renderer.limits.maxBatchableTextures
    });
    const { batches, geometryData } = this._gpuContextHash[context2.uid];
    const vertexSize = geometryData.vertices.length;
    const indexSize = geometryData.indices.length;
    for (let i2 = 0; i2 < batches.length; i2++) {
      batches[i2].applyTransform = false;
    }
    const batcher = graphicsData.batcher;
    batcher.ensureAttributeBuffer(vertexSize);
    batcher.ensureIndexBuffer(indexSize);
    batcher.begin();
    for (let i2 = 0; i2 < batches.length; i2++) {
      const batch = batches[i2];
      batcher.add(batch);
    }
    batcher.finish(graphicsData.instructions);
    const geometry = batcher.geometry;
    geometry.indexBuffer.setDataWithSize(batcher.indexBuffer, batcher.indexSize, true);
    geometry.buffers[0].setDataWithSize(batcher.attributeBuffer.float32View, batcher.attributeSize, true);
    const drawBatches = batcher.batches;
    for (let i2 = 0; i2 < drawBatches.length; i2++) {
      const batch = drawBatches[i2];
      batch.bindGroup = getTextureBatchBindGroup(
        batch.textures.textures,
        batch.textures.count,
        this._renderer.limits.maxBatchableTextures
      );
    }
    this._graphicsDataContextHash[context2.uid] = graphicsData;
    return graphicsData;
  }
  _initContext(context2) {
    const gpuContext = new GpuGraphicsContext();
    gpuContext.context = context2;
    this._gpuContextHash[context2.uid] = gpuContext;
    context2.on("destroy", this.onGraphicsContextDestroy, this);
    return this._gpuContextHash[context2.uid];
  }
  onGraphicsContextDestroy(context2) {
    this._cleanGraphicsContextData(context2);
    context2.off("destroy", this.onGraphicsContextDestroy, this);
    this._gpuContextHash[context2.uid] = null;
  }
  _cleanGraphicsContextData(context2) {
    const gpuContext = this._gpuContextHash[context2.uid];
    if (!gpuContext.isBatchable) {
      if (this._graphicsDataContextHash[context2.uid]) {
        BigPool.return(this.getContextRenderData(context2));
        this._graphicsDataContextHash[context2.uid] = null;
      }
    }
    if (gpuContext.batches) {
      gpuContext.batches.forEach((batch) => {
        BigPool.return(batch);
      });
    }
  }
  destroy() {
    for (const i2 in this._gpuContextHash) {
      if (this._gpuContextHash[i2]) {
        this.onGraphicsContextDestroy(this._gpuContextHash[i2].context);
      }
    }
    this._gpuContextHash = {};
    this._graphicsDataContextHash = {};
    this._renderer = null;
  }
};
_GraphicsContextSystem.extension = {
  type: [
    ExtensionType.WebGLSystem,
    ExtensionType.WebGPUSystem,
    ExtensionType.CanvasSystem
  ],
  name: "graphicsContext"
};
_GraphicsContextSystem.defaultOptions = {
  /**
   * A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother)
   * @default 0.5
   */
  bezierSmoothness: 0.5
};
let GraphicsContextSystem = _GraphicsContextSystem;
const RECURSION_LIMIT$1 = 8;
const FLT_EPSILON$1 = 11920929e-14;
const PATH_DISTANCE_EPSILON$1 = 1;
function buildAdaptiveBezier(points, sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, smoothness) {
  const scale = 1;
  const smoothing = Math.min(
    0.99,
    // a value of 1.0 actually inverts smoothing, so we cap it at 0.99
    Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness)
  );
  let distanceTolerance = (PATH_DISTANCE_EPSILON$1 - smoothing) / scale;
  distanceTolerance *= distanceTolerance;
  begin$1(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance);
  return points;
}
function begin$1(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance) {
  recursive$1(sX, sY, cp1x, cp1y, cp2x, cp2y, eX, eY, points, distanceTolerance, 0);
  points.push(eX, eY);
}
function recursive$1(x1, y1, x2, y2, x3, y3, x4, y4, points, distanceTolerance, level2) {
  if (level2 > RECURSION_LIMIT$1) {
    return;
  }
  const x12 = (x1 + x2) / 2;
  const y12 = (y1 + y2) / 2;
  const x23 = (x2 + x3) / 2;
  const y23 = (y2 + y3) / 2;
  const x34 = (x3 + x4) / 2;
  const y34 = (y3 + y4) / 2;
  const x123 = (x12 + x23) / 2;
  const y123 = (y12 + y23) / 2;
  const x234 = (x23 + x34) / 2;
  const y234 = (y23 + y34) / 2;
  const x1234 = (x123 + x234) / 2;
  const y1234 = (y123 + y234) / 2;
  if (level2 > 0) {
    let dx = x4 - x1;
    let dy = y4 - y1;
    const d2 = Math.abs((x2 - x4) * dy - (y2 - y4) * dx);
    const d3 = Math.abs((x3 - x4) * dy - (y3 - y4) * dx);
    if (d2 > FLT_EPSILON$1 && d3 > FLT_EPSILON$1) {
      if ((d2 + d3) * (d2 + d3) <= distanceTolerance * (dx * dx + dy * dy)) {
        {
          points.push(x1234, y1234);
          return;
        }
      }
    } else if (d2 > FLT_EPSILON$1) {
      if (d2 * d2 <= distanceTolerance * (dx * dx + dy * dy)) {
        {
          points.push(x1234, y1234);
          return;
        }
      }
    } else if (d3 > FLT_EPSILON$1) {
      if (d3 * d3 <= distanceTolerance * (dx * dx + dy * dy)) {
        {
          points.push(x1234, y1234);
          return;
        }
      }
    } else {
      dx = x1234 - (x1 + x4) / 2;
      dy = y1234 - (y1 + y4) / 2;
      if (dx * dx + dy * dy <= distanceTolerance) {
        points.push(x1234, y1234);
        return;
      }
    }
  }
  recursive$1(x1, y1, x12, y12, x123, y123, x1234, y1234, points, distanceTolerance, level2 + 1);
  recursive$1(x1234, y1234, x234, y234, x34, y34, x4, y4, points, distanceTolerance, level2 + 1);
}
const RECURSION_LIMIT = 8;
const FLT_EPSILON = 11920929e-14;
const PATH_DISTANCE_EPSILON = 1;
function buildAdaptiveQuadratic(points, sX, sY, cp1x, cp1y, eX, eY, smoothness) {
  const scale = 1;
  const smoothing = Math.min(
    0.99,
    // a value of 1.0 actually inverts smoothing, so we cap it at 0.99
    Math.max(0, smoothness ?? GraphicsContextSystem.defaultOptions.bezierSmoothness)
  );
  let distanceTolerance = (PATH_DISTANCE_EPSILON - smoothing) / scale;
  distanceTolerance *= distanceTolerance;
  begin(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance);
  return points;
}
function begin(sX, sY, cp1x, cp1y, eX, eY, points, distanceTolerance) {
  recursive(points, sX, sY, cp1x, cp1y, eX, eY, distanceTolerance, 0);
  points.push(eX, eY);
}
function recursive(points, x1, y1, x2, y2, x3, y3, distanceTolerance, level2) {
  if (level2 > RECURSION_LIMIT) {
    return;
  }
  const x12 = (x1 + x2) / 2;
  const y12 = (y1 + y2) / 2;
  const x23 = (x2 + x3) / 2;
  const y23 = (y2 + y3) / 2;
  const x123 = (x12 + x23) / 2;
  const y123 = (y12 + y23) / 2;
  let dx = x3 - x1;
  let dy = y3 - y1;
  const d2 = Math.abs((x2 - x3) * dy - (y2 - y3) * dx);
  if (d2 > FLT_EPSILON) {
    if (d2 * d2 <= distanceTolerance * (dx * dx + dy * dy)) {
      {
        points.push(x123, y123);
        return;
      }
    }
  } else {
    dx = x123 - (x1 + x3) / 2;
    dy = y123 - (y1 + y3) / 2;
    if (dx * dx + dy * dy <= distanceTolerance) {
      points.push(x123, y123);
      return;
    }
  }
  recursive(points, x1, y1, x12, y12, x123, y123, distanceTolerance, level2 + 1);
  recursive(points, x123, y123, x23, y23, x3, y3, distanceTolerance, level2 + 1);
}
function buildArc(points, x2, y2, radius, start, end, clockwise, steps) {
  let dist = Math.abs(start - end);
  if (!clockwise && start > end) {
    dist = 2 * Math.PI - dist;
  } else if (clockwise && end > start) {
    dist = 2 * Math.PI - dist;
  }
  steps || (steps = Math.max(6, Math.floor(6 * Math.pow(radius, 1 / 3) * (dist / Math.PI))));
  steps = Math.max(steps, 3);
  let f2 = dist / steps;
  let t2 = start;
  f2 *= clockwise ? -1 : 1;
  for (let i2 = 0; i2 < steps + 1; i2++) {
    const cs = Math.cos(t2);
    const sn = Math.sin(t2);
    const nx = x2 + cs * radius;
    const ny = y2 + sn * radius;
    points.push(nx, ny);
    t2 += f2;
  }
}
function buildArcTo(points, x1, y1, x2, y2, radius) {
  const fromX = points[points.length - 2];
  const fromY = points[points.length - 1];
  const a1 = fromY - y1;
  const b1 = fromX - x1;
  const a2 = y2 - y1;
  const b2 = x2 - x1;
  const mm = Math.abs(a1 * b2 - b1 * a2);
  if (mm < 1e-8 || radius === 0) {
    if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {
      points.push(x1, y1);
    }
    return;
  }
  const dd = a1 * a1 + b1 * b1;
  const cc = a2 * a2 + b2 * b2;
  const tt = a1 * a2 + b1 * b2;
  const k1 = radius * Math.sqrt(dd) / mm;
  const k2 = radius * Math.sqrt(cc) / mm;
  const j1 = k1 * tt / dd;
  const j2 = k2 * tt / cc;
  const cx = k1 * b2 + k2 * b1;
  const cy = k1 * a2 + k2 * a1;
  const px = b1 * (k2 + j1);
  const py = a1 * (k2 + j1);
  const qx = b2 * (k1 + j2);
  const qy = a2 * (k1 + j2);
  const startAngle = Math.atan2(py - cy, px - cx);
  const endAngle = Math.atan2(qy - cy, qx - cx);
  buildArc(
    points,
    cx + x1,
    cy + y1,
    radius,
    startAngle,
    endAngle,
    b1 * a2 > b2 * a1
  );
}
const TAU = Math.PI * 2;
const out = {
  centerX: 0,
  centerY: 0,
  ang1: 0,
  ang2: 0
};
const mapToEllipse = ({ x: x2, y: y2 }, rx, ry, cosPhi, sinPhi, centerX, centerY, out2) => {
  x2 *= rx;
  y2 *= ry;
  const xp = cosPhi * x2 - sinPhi * y2;
  const yp = sinPhi * x2 + cosPhi * y2;
  out2.x = xp + centerX;
  out2.y = yp + centerY;
  return out2;
};
function approxUnitArc(ang1, ang2) {
  const a1 = ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);
  const a2 = ang2 === 1.5707963267948966 ? 0.551915024494 : a1;
  const x1 = Math.cos(ang1);
  const y1 = Math.sin(ang1);
  const x2 = Math.cos(ang1 + ang2);
  const y2 = Math.sin(ang1 + ang2);
  return [
    {
      x: x1 - y1 * a2,
      y: y1 + x1 * a2
    },
    {
      x: x2 + y2 * a2,
      y: y2 - x2 * a2
    },
    {
      x: x2,
      y: y2
    }
  ];
}
const vectorAngle = (ux2, uy2, vx2, vy2) => {
  const sign2 = ux2 * vy2 - uy2 * vx2 < 0 ? -1 : 1;
  let dot = ux2 * vx2 + uy2 * vy2;
  if (dot > 1) {
    dot = 1;
  }
  if (dot < -1) {
    dot = -1;
  }
  return sign2 * Math.acos(dot);
};
const getArcCenter = (px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinPhi, cosPhi, pxp, pyp, out2) => {
  const rxSq = Math.pow(rx, 2);
  const rySq = Math.pow(ry, 2);
  const pxpSq = Math.pow(pxp, 2);
  const pypSq = Math.pow(pyp, 2);
  let radicant = rxSq * rySq - rxSq * pypSq - rySq * pxpSq;
  if (radicant < 0) {
    radicant = 0;
  }
  radicant /= rxSq * pypSq + rySq * pxpSq;
  radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);
  const centerXp = radicant * rx / ry * pyp;
  const centerYp = radicant * -ry / rx * pxp;
  const centerX = cosPhi * centerXp - sinPhi * centerYp + (px + cx) / 2;
  const centerY = sinPhi * centerXp + cosPhi * centerYp + (py + cy) / 2;
  const vx1 = (pxp - centerXp) / rx;
  const vy1 = (pyp - centerYp) / ry;
  const vx2 = (-pxp - centerXp) / rx;
  const vy2 = (-pyp - centerYp) / ry;
  const ang1 = vectorAngle(1, 0, vx1, vy1);
  let ang2 = vectorAngle(vx1, vy1, vx2, vy2);
  if (sweepFlag === 0 && ang2 > 0) {
    ang2 -= TAU;
  }
  if (sweepFlag === 1 && ang2 < 0) {
    ang2 += TAU;
  }
  out2.centerX = centerX;
  out2.centerY = centerY;
  out2.ang1 = ang1;
  out2.ang2 = ang2;
};
function buildArcToSvg(points, px, py, cx, cy, rx, ry, xAxisRotation = 0, largeArcFlag = 0, sweepFlag = 0) {
  if (rx === 0 || ry === 0) {
    return;
  }
  const sinPhi = Math.sin(xAxisRotation * TAU / 360);
  const cosPhi = Math.cos(xAxisRotation * TAU / 360);
  const pxp = cosPhi * (px - cx) / 2 + sinPhi * (py - cy) / 2;
  const pyp = -sinPhi * (px - cx) / 2 + cosPhi * (py - cy) / 2;
  if (pxp === 0 && pyp === 0) {
    return;
  }
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  const lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);
  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }
  getArcCenter(
    px,
    py,
    cx,
    cy,
    rx,
    ry,
    largeArcFlag,
    sweepFlag,
    sinPhi,
    cosPhi,
    pxp,
    pyp,
    out
  );
  let { ang1, ang2 } = out;
  const { centerX, centerY } = out;
  let ratio = Math.abs(ang2) / (TAU / 4);
  if (Math.abs(1 - ratio) < 1e-7) {
    ratio = 1;
  }
  const segments = Math.max(Math.ceil(ratio), 1);
  ang2 /= segments;
  let lastX = points[points.length - 2];
  let lastY = points[points.length - 1];
  const outCurvePoint = { x: 0, y: 0 };
  for (let i2 = 0; i2 < segments; i2++) {
    const curve = approxUnitArc(ang1, ang2);
    const { x: x1, y: y1 } = mapToEllipse(curve[0], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);
    const { x: x2, y: y2 } = mapToEllipse(curve[1], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);
    const { x: x3, y: y3 } = mapToEllipse(curve[2], rx, ry, cosPhi, sinPhi, centerX, centerY, outCurvePoint);
    buildAdaptiveBezier(
      points,
      lastX,
      lastY,
      x1,
      y1,
      x2,
      y2,
      x3,
      y3
    );
    lastX = x3;
    lastY = y3;
    ang1 += ang2;
  }
}
function roundedShapeArc(g2, points, radius) {
  const vecFrom = (p2, pp) => {
    const x2 = pp.x - p2.x;
    const y2 = pp.y - p2.y;
    const len = Math.sqrt(x2 * x2 + y2 * y2);
    const nx = x2 / len;
    const ny = y2 / len;
    return { len, nx, ny };
  };
  const sharpCorner = (i2, p2) => {
    if (i2 === 0) {
      g2.moveTo(p2.x, p2.y);
    } else {
      g2.lineTo(p2.x, p2.y);
    }
  };
  let p1 = points[points.length - 1];
  for (let i2 = 0; i2 < points.length; i2++) {
    const p2 = points[i2 % points.length];
    const pRadius = p2.radius ?? radius;
    if (pRadius <= 0) {
      sharpCorner(i2, p2);
      p1 = p2;
      continue;
    }
    const p3 = points[(i2 + 1) % points.length];
    const v1 = vecFrom(p2, p1);
    const v2 = vecFrom(p2, p3);
    if (v1.len < 1e-4 || v2.len < 1e-4) {
      sharpCorner(i2, p2);
      p1 = p2;
      continue;
    }
    let angle = Math.asin(v1.nx * v2.ny - v1.ny * v2.nx);
    let radDirection = 1;
    let drawDirection = false;
    if (v1.nx * v2.nx - v1.ny * -v2.ny < 0) {
      if (angle < 0) {
        angle = Math.PI + angle;
      } else {
        angle = Math.PI - angle;
        radDirection = -1;
        drawDirection = true;
      }
    } else if (angle > 0) {
      radDirection = -1;
      drawDirection = true;
    }
    const halfAngle = angle / 2;
    let cRadius;
    let lenOut = Math.abs(
      Math.cos(halfAngle) * pRadius / Math.sin(halfAngle)
    );
    if (lenOut > Math.min(v1.len / 2, v2.len / 2)) {
      lenOut = Math.min(v1.len / 2, v2.len / 2);
      cRadius = Math.abs(lenOut * Math.sin(halfAngle) / Math.cos(halfAngle));
    } else {
      cRadius = pRadius;
    }
    const cX = p2.x + v2.nx * lenOut + -v2.ny * cRadius * radDirection;
    const cY = p2.y + v2.ny * lenOut + v2.nx * cRadius * radDirection;
    const startAngle = Math.atan2(v1.ny, v1.nx) + Math.PI / 2 * radDirection;
    const endAngle = Math.atan2(v2.ny, v2.nx) - Math.PI / 2 * radDirection;
    if (i2 === 0) {
      g2.moveTo(
        cX + Math.cos(startAngle) * cRadius,
        cY + Math.sin(startAngle) * cRadius
      );
    }
    g2.arc(cX, cY, cRadius, startAngle, endAngle, drawDirection);
    p1 = p2;
  }
}
function roundedShapeQuadraticCurve(g2, points, radius, smoothness) {
  const distance2 = (p1, p2) => Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
  const pointLerp = (p1, p2, t2) => ({
    x: p1.x + (p2.x - p1.x) * t2,
    y: p1.y + (p2.y - p1.y) * t2
  });
  const numPoints = points.length;
  for (let i2 = 0; i2 < numPoints; i2++) {
    const thisPoint = points[(i2 + 1) % numPoints];
    const pRadius = thisPoint.radius ?? radius;
    if (pRadius <= 0) {
      if (i2 === 0) {
        g2.moveTo(thisPoint.x, thisPoint.y);
      } else {
        g2.lineTo(thisPoint.x, thisPoint.y);
      }
      continue;
    }
    const lastPoint = points[i2];
    const nextPoint = points[(i2 + 2) % numPoints];
    const lastEdgeLength = distance2(lastPoint, thisPoint);
    let start;
    if (lastEdgeLength < 1e-4) {
      start = thisPoint;
    } else {
      const lastOffsetDistance = Math.min(lastEdgeLength / 2, pRadius);
      start = pointLerp(
        thisPoint,
        lastPoint,
        lastOffsetDistance / lastEdgeLength
      );
    }
    const nextEdgeLength = distance2(nextPoint, thisPoint);
    let end;
    if (nextEdgeLength < 1e-4) {
      end = thisPoint;
    } else {
      const nextOffsetDistance = Math.min(nextEdgeLength / 2, pRadius);
      end = pointLerp(
        thisPoint,
        nextPoint,
        nextOffsetDistance / nextEdgeLength
      );
    }
    if (i2 === 0) {
      g2.moveTo(start.x, start.y);
    } else {
      g2.lineTo(start.x, start.y);
    }
    g2.quadraticCurveTo(thisPoint.x, thisPoint.y, end.x, end.y, smoothness);
  }
}
const tempRectangle = new Rectangle();
class ShapePath {
  constructor(graphicsPath2D) {
    this.shapePrimitives = [];
    this._currentPoly = null;
    this._bounds = new Bounds();
    this._graphicsPath2D = graphicsPath2D;
    this.signed = graphicsPath2D.checkForHoles;
  }
  /**
   * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.
   * @param x - The x-coordinate for the starting point.
   * @param y - The y-coordinate for the starting point.
   * @returns The instance of the current object for chaining.
   */
  moveTo(x2, y2) {
    this.startPoly(x2, y2);
    return this;
  }
  /**
   * Connects the current point to a new point with a straight line. This method updates the current path.
   * @param x - The x-coordinate of the new point to connect to.
   * @param y - The y-coordinate of the new point to connect to.
   * @returns The instance of the current object for chaining.
   */
  lineTo(x2, y2) {
    this._ensurePoly();
    const points = this._currentPoly.points;
    const fromX = points[points.length - 2];
    const fromY = points[points.length - 1];
    if (fromX !== x2 || fromY !== y2) {
      points.push(x2, y2);
    }
    return this;
  }
  /**
   * Adds an arc to the path. The arc is centered at (x, y)
   *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.
   * @param x - The x-coordinate of the arc's center.
   * @param y - The y-coordinate of the arc's center.
   * @param radius - The radius of the arc.
   * @param startAngle - The starting angle of the arc, in radians.
   * @param endAngle - The ending angle of the arc, in radians.
   * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.
   * @returns The instance of the current object for chaining.
   */
  arc(x2, y2, radius, startAngle, endAngle, counterclockwise) {
    this._ensurePoly(false);
    const points = this._currentPoly.points;
    buildArc(points, x2, y2, radius, startAngle, endAngle, counterclockwise);
    return this;
  }
  /**
   * Adds an arc to the path with the arc tangent to the line joining two specified points.
   * The arc radius is specified by `radius`.
   * @param x1 - The x-coordinate of the first point.
   * @param y1 - The y-coordinate of the first point.
   * @param x2 - The x-coordinate of the second point.
   * @param y2 - The y-coordinate of the second point.
   * @param radius - The radius of the arc.
   * @returns The instance of the current object for chaining.
   */
  arcTo(x1, y1, x2, y2, radius) {
    this._ensurePoly();
    const points = this._currentPoly.points;
    buildArcTo(points, x1, y1, x2, y2, radius);
    return this;
  }
  /**
   * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.
   * @param rx - The x-radius of the ellipse.
   * @param ry - The y-radius of the ellipse.
   * @param xAxisRotation - The rotation of the ellipse's x-axis relative
   * to the x-axis of the coordinate system, in degrees.
   * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.
   * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.
   * @param x - The x-coordinate of the arc's end point.
   * @param y - The y-coordinate of the arc's end point.
   * @returns The instance of the current object for chaining.
   */
  arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x2, y2) {
    const points = this._currentPoly.points;
    buildArcToSvg(
      points,
      this._currentPoly.lastX,
      this._currentPoly.lastY,
      x2,
      y2,
      rx,
      ry,
      xAxisRotation,
      largeArcFlag,
      sweepFlag
    );
    return this;
  }
  /**
   * Adds a cubic Bezier curve to the path.
   * It requires three points: the first two are control points and the third one is the end point.
   * The starting point is the last point in the current path.
   * @param cp1x - The x-coordinate of the first control point.
   * @param cp1y - The y-coordinate of the first control point.
   * @param cp2x - The x-coordinate of the second control point.
   * @param cp2y - The y-coordinate of the second control point.
   * @param x - The x-coordinate of the end point.
   * @param y - The y-coordinate of the end point.
   * @param smoothness - Optional parameter to adjust the smoothness of the curve.
   * @returns The instance of the current object for chaining.
   */
  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x2, y2, smoothness) {
    this._ensurePoly();
    const currentPoly = this._currentPoly;
    buildAdaptiveBezier(
      this._currentPoly.points,
      currentPoly.lastX,
      currentPoly.lastY,
      cp1x,
      cp1y,
      cp2x,
      cp2y,
      x2,
      y2,
      smoothness
    );
    return this;
  }
  /**
   * Adds a quadratic curve to the path. It requires two points: the control point and the end point.
   * The starting point is the last point in the current path.
   * @param cp1x - The x-coordinate of the control point.
   * @param cp1y - The y-coordinate of the control point.
   * @param x - The x-coordinate of the end point.
   * @param y - The y-coordinate of the end point.
   * @param smoothing - Optional parameter to adjust the smoothness of the curve.
   * @returns The instance of the current object for chaining.
   */
  quadraticCurveTo(cp1x, cp1y, x2, y2, smoothing) {
    this._ensurePoly();
    const currentPoly = this._currentPoly;
    buildAdaptiveQuadratic(
      this._currentPoly.points,
      currentPoly.lastX,
      currentPoly.lastY,
      cp1x,
      cp1y,
      x2,
      y2,
      smoothing
    );
    return this;
  }
  /**
   * Closes the current path by drawing a straight line back to the start.
   * If the shape is already closed or there are no points in the path, this method does nothing.
   * @returns The instance of the current object for chaining.
   */
  closePath() {
    this.endPoly(true);
    return this;
  }
  /**
   * Adds another path to the current path. This method allows for the combination of multiple paths into one.
   * @param path - The `GraphicsPath` object representing the path to add.
   * @param transform - An optional `Matrix` object to apply a transformation to the path before adding it.
   * @returns The instance of the current object for chaining.
   */
  addPath(path2, transform) {
    this.endPoly();
    if (transform && !transform.isIdentity()) {
      path2 = path2.clone(true);
      path2.transform(transform);
    }
    const shapePrimitives = this.shapePrimitives;
    const start = shapePrimitives.length;
    for (let i2 = 0; i2 < path2.instructions.length; i2++) {
      const instruction = path2.instructions[i2];
      this[instruction.action](...instruction.data);
    }
    if (path2.checkForHoles && shapePrimitives.length - start > 1) {
      let mainShape = null;
      for (let i2 = start; i2 < shapePrimitives.length; i2++) {
        const shapePrimitive = shapePrimitives[i2];
        if (shapePrimitive.shape.type === "polygon") {
          const polygon = shapePrimitive.shape;
          const mainPolygon = mainShape == null ? void 0 : mainShape.shape;
          if (mainPolygon && mainPolygon.containsPolygon(polygon)) {
            mainShape.holes || (mainShape.holes = []);
            mainShape.holes.push(shapePrimitive);
            shapePrimitives.copyWithin(i2, i2 + 1);
            shapePrimitives.length--;
            i2--;
          } else {
            mainShape = shapePrimitive;
          }
        }
      }
    }
    return this;
  }
  /**
   * Finalizes the drawing of the current path. Optionally, it can close the path.
   * @param closePath - A boolean indicating whether to close the path after finishing. False by default.
   */
  finish(closePath = false) {
    this.endPoly(closePath);
  }
  /**
   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.
   * @param x - The x-coordinate of the top-left corner of the rectangle.
   * @param y - The y-coordinate of the top-left corner of the rectangle.
   * @param w - The width of the rectangle.
   * @param h - The height of the rectangle.
   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.
   * @returns The instance of the current object for chaining.
   */
  rect(x2, y2, w2, h2, transform) {
    this.drawShape(new Rectangle(x2, y2, w2, h2), transform);
    return this;
  }
  /**
   * Draws a circle shape. This method adds a new circle path to the current drawing.
   * @param x - The x-coordinate of the center of the circle.
   * @param y - The y-coordinate of the center of the circle.
   * @param radius - The radius of the circle.
   * @param transform - An optional `Matrix` object to apply a transformation to the circle.
   * @returns The instance of the current object for chaining.
   */
  circle(x2, y2, radius, transform) {
    this.drawShape(new Circle(x2, y2, radius), transform);
    return this;
  }
  /**
   * Draws a polygon shape. This method allows for the creation of complex polygons by specifying a sequence of points.
   * @param points - An array of numbers, or or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]
   * representing the x and y coordinates of the polygon's vertices, in sequence.
   * @param close - A boolean indicating whether to close the polygon path. True by default.
   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.
   * @returns The instance of the current object for chaining.
   */
  poly(points, close, transform) {
    const polygon = new Polygon(points);
    polygon.closePath = close;
    this.drawShape(polygon, transform);
    return this;
  }
  /**
   * Draws a regular polygon with a specified number of sides. All sides and angles are equal.
   * @param x - The x-coordinate of the center of the polygon.
   * @param y - The y-coordinate of the center of the polygon.
   * @param radius - The radius of the circumscribed circle of the polygon.
   * @param sides - The number of sides of the polygon. Must be 3 or more.
   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.
   * @returns The instance of the current object for chaining.
   */
  regularPoly(x2, y2, radius, sides, rotation = 0, transform) {
    sides = Math.max(sides | 0, 3);
    const startAngle = -1 * Math.PI / 2 + rotation;
    const delta = Math.PI * 2 / sides;
    const polygon = [];
    for (let i2 = 0; i2 < sides; i2++) {
      const angle = startAngle - i2 * delta;
      polygon.push(
        x2 + radius * Math.cos(angle),
        y2 + radius * Math.sin(angle)
      );
    }
    this.poly(polygon, true, transform);
    return this;
  }
  /**
   * Draws a polygon with rounded corners.
   * Similar to `regularPoly` but with the ability to round the corners of the polygon.
   * @param x - The x-coordinate of the center of the polygon.
   * @param y - The y-coordinate of the center of the polygon.
   * @param radius - The radius of the circumscribed circle of the polygon.
   * @param sides - The number of sides of the polygon. Must be 3 or more.
   * @param corner - The radius of the rounding of the corners.
   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
   * @param smoothness - Optional parameter to adjust the smoothness of the rounding.
   * @returns The instance of the current object for chaining.
   */
  roundPoly(x2, y2, radius, sides, corner, rotation = 0, smoothness) {
    sides = Math.max(sides | 0, 3);
    if (corner <= 0) {
      return this.regularPoly(x2, y2, radius, sides, rotation);
    }
    const sideLength = radius * Math.sin(Math.PI / sides) - 1e-3;
    corner = Math.min(corner, sideLength);
    const startAngle = -1 * Math.PI / 2 + rotation;
    const delta = Math.PI * 2 / sides;
    const internalAngle = (sides - 2) * Math.PI / sides / 2;
    for (let i2 = 0; i2 < sides; i2++) {
      const angle = i2 * delta + startAngle;
      const x0 = x2 + radius * Math.cos(angle);
      const y0 = y2 + radius * Math.sin(angle);
      const a1 = angle + Math.PI + internalAngle;
      const a2 = angle - Math.PI - internalAngle;
      const x1 = x0 + corner * Math.cos(a1);
      const y1 = y0 + corner * Math.sin(a1);
      const x3 = x0 + corner * Math.cos(a2);
      const y3 = y0 + corner * Math.sin(a2);
      if (i2 === 0) {
        this.moveTo(x1, y1);
      } else {
        this.lineTo(x1, y1);
      }
      this.quadraticCurveTo(x0, y0, x3, y3, smoothness);
    }
    return this.closePath();
  }
  /**
   * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.
   * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.
   * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.
   * A minimum of 3 points is required.
   * @param radius - The default radius for the corners.
   * This radius is applied to all corners unless overridden in `points`.
   * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve
   *  method instead of an arc method. Defaults to false.
   * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.
   * Higher values make the curve smoother.
   * @returns The instance of the current object for chaining.
   */
  roundShape(points, radius, useQuadratic = false, smoothness) {
    if (points.length < 3) {
      return this;
    }
    if (useQuadratic) {
      roundedShapeQuadraticCurve(this, points, radius, smoothness);
    } else {
      roundedShapeArc(this, points, radius);
    }
    return this.closePath();
  }
  /**
   * Draw Rectangle with fillet corners. This is much like rounded rectangle
   * however it support negative numbers as well for the corner radius.
   * @param x - Upper left corner of rect
   * @param y - Upper right corner of rect
   * @param width - Width of rect
   * @param height - Height of rect
   * @param fillet - accept negative or positive values
   */
  filletRect(x2, y2, width, height, fillet) {
    if (fillet === 0) {
      return this.rect(x2, y2, width, height);
    }
    const maxFillet = Math.min(width, height) / 2;
    const inset = Math.min(maxFillet, Math.max(-maxFillet, fillet));
    const right = x2 + width;
    const bottom = y2 + height;
    const dir = inset < 0 ? -inset : 0;
    const size2 = Math.abs(inset);
    return this.moveTo(x2, y2 + size2).arcTo(x2 + dir, y2 + dir, x2 + size2, y2, size2).lineTo(right - size2, y2).arcTo(right - dir, y2 + dir, right, y2 + size2, size2).lineTo(right, bottom - size2).arcTo(right - dir, bottom - dir, x2 + width - size2, bottom, size2).lineTo(x2 + size2, bottom).arcTo(x2 + dir, bottom - dir, x2, bottom - size2, size2).closePath();
  }
  /**
   * Draw Rectangle with chamfer corners. These are angled corners.
   * @param x - Upper left corner of rect
   * @param y - Upper right corner of rect
   * @param width - Width of rect
   * @param height - Height of rect
   * @param chamfer - non-zero real number, size of corner cutout
   * @param transform
   */
  chamferRect(x2, y2, width, height, chamfer, transform) {
    if (chamfer <= 0) {
      return this.rect(x2, y2, width, height);
    }
    const inset = Math.min(chamfer, Math.min(width, height) / 2);
    const right = x2 + width;
    const bottom = y2 + height;
    const points = [
      x2 + inset,
      y2,
      right - inset,
      y2,
      right,
      y2 + inset,
      right,
      bottom - inset,
      right - inset,
      bottom,
      x2 + inset,
      bottom,
      x2,
      bottom - inset,
      x2,
      y2 + inset
    ];
    for (let i2 = points.length - 1; i2 >= 2; i2 -= 2) {
      if (points[i2] === points[i2 - 2] && points[i2 - 1] === points[i2 - 3]) {
        points.splice(i2 - 1, 2);
      }
    }
    return this.poly(points, true, transform);
  }
  /**
   * Draws an ellipse at the specified location and with the given x and y radii.
   * An optional transformation can be applied, allowing for rotation, scaling, and translation.
   * @param x - The x-coordinate of the center of the ellipse.
   * @param y - The y-coordinate of the center of the ellipse.
   * @param radiusX - The horizontal radius of the ellipse.
   * @param radiusY - The vertical radius of the ellipse.
   * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.
   * @returns The instance of the current object for chaining.
   */
  ellipse(x2, y2, radiusX, radiusY, transform) {
    this.drawShape(new Ellipse(x2, y2, radiusX, radiusY), transform);
    return this;
  }
  /**
   * Draws a rectangle with rounded corners.
   * The corner radius can be specified to determine how rounded the corners should be.
   * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.
   * @param x - The x-coordinate of the top-left corner of the rectangle.
   * @param y - The y-coordinate of the top-left corner of the rectangle.
   * @param w - The width of the rectangle.
   * @param h - The height of the rectangle.
   * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.
   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.
   * @returns The instance of the current object for chaining.
   */
  roundRect(x2, y2, w2, h2, radius, transform) {
    this.drawShape(new RoundedRectangle(x2, y2, w2, h2, radius), transform);
    return this;
  }
  /**
   * Draws a given shape on the canvas.
   * This is a generic method that can draw any type of shape specified by the `ShapePrimitive` parameter.
   * An optional transformation matrix can be applied to the shape, allowing for complex transformations.
   * @param shape - The shape to draw, defined as a `ShapePrimitive` object.
   * @param matrix - An optional `Matrix` for transforming the shape. This can include rotations,
   * scaling, and translations.
   * @returns The instance of the current object for chaining.
   */
  drawShape(shape, matrix) {
    this.endPoly();
    this.shapePrimitives.push({ shape, transform: matrix });
    return this;
  }
  /**
   * Starts a new polygon path from the specified starting point.
   * This method initializes a new polygon or ends the current one if it exists.
   * @param x - The x-coordinate of the starting point of the new polygon.
   * @param y - The y-coordinate of the starting point of the new polygon.
   * @returns The instance of the current object for chaining.
   */
  startPoly(x2, y2) {
    let currentPoly = this._currentPoly;
    if (currentPoly) {
      this.endPoly();
    }
    currentPoly = new Polygon();
    currentPoly.points.push(x2, y2);
    this._currentPoly = currentPoly;
    return this;
  }
  /**
   * Ends the current polygon path. If `closePath` is set to true,
   * the path is closed by connecting the last point to the first one.
   * This method finalizes the current polygon and prepares it for drawing or adding to the shape primitives.
   * @param closePath - A boolean indicating whether to close the polygon by connecting the last point
   *  back to the starting point. False by default.
   * @returns The instance of the current object for chaining.
   */
  endPoly(closePath = false) {
    const shape = this._currentPoly;
    if (shape && shape.points.length > 2) {
      shape.closePath = closePath;
      this.shapePrimitives.push({ shape });
    }
    this._currentPoly = null;
    return this;
  }
  _ensurePoly(start = true) {
    if (this._currentPoly)
      return;
    this._currentPoly = new Polygon();
    if (start) {
      const lastShape = this.shapePrimitives[this.shapePrimitives.length - 1];
      if (lastShape) {
        let lx = lastShape.shape.x;
        let ly = lastShape.shape.y;
        if (lastShape.transform && !lastShape.transform.isIdentity()) {
          const t2 = lastShape.transform;
          const tempX = lx;
          lx = t2.a * lx + t2.c * ly + t2.tx;
          ly = t2.b * tempX + t2.d * ly + t2.ty;
        }
        this._currentPoly.points.push(lx, ly);
      } else {
        this._currentPoly.points.push(0, 0);
      }
    }
  }
  /** Builds the path. */
  buildPath() {
    const path2 = this._graphicsPath2D;
    this.shapePrimitives.length = 0;
    this._currentPoly = null;
    for (let i2 = 0; i2 < path2.instructions.length; i2++) {
      const instruction = path2.instructions[i2];
      this[instruction.action](...instruction.data);
    }
    this.finish();
  }
  /** Gets the bounds of the path. */
  get bounds() {
    const bounds = this._bounds;
    bounds.clear();
    const shapePrimitives = this.shapePrimitives;
    for (let i2 = 0; i2 < shapePrimitives.length; i2++) {
      const shapePrimitive = shapePrimitives[i2];
      const boundsRect = shapePrimitive.shape.getBounds(tempRectangle);
      if (shapePrimitive.transform) {
        bounds.addRect(boundsRect, shapePrimitive.transform);
      } else {
        bounds.addRect(boundsRect);
      }
    }
    return bounds;
  }
}
class GraphicsPath {
  /**
   * Creates a `GraphicsPath` instance optionally from an SVG path string or an array of `PathInstruction`.
   * @param instructions - An SVG path string or an array of `PathInstruction` objects.
   * @param signed
   */
  constructor(instructions, signed = false) {
    this.instructions = [];
    this.uid = uid("graphicsPath");
    this._dirty = true;
    this.checkForHoles = signed;
    if (typeof instructions === "string") {
      parseSVGPath(instructions, this);
    } else {
      this.instructions = (instructions == null ? void 0 : instructions.slice()) ?? [];
    }
  }
  /**
   * Provides access to the internal shape path, ensuring it is up-to-date with the current instructions.
   * @returns The `ShapePath` instance associated with this `GraphicsPath`.
   */
  get shapePath() {
    if (!this._shapePath) {
      this._shapePath = new ShapePath(this);
    }
    if (this._dirty) {
      this._dirty = false;
      this._shapePath.buildPath();
    }
    return this._shapePath;
  }
  /**
   * Adds another `GraphicsPath` to this path, optionally applying a transformation.
   * @param path - The `GraphicsPath` to add.
   * @param transform - An optional transformation to apply to the added path.
   * @returns The instance of the current object for chaining.
   */
  addPath(path2, transform) {
    path2 = path2.clone();
    this.instructions.push({ action: "addPath", data: [path2, transform] });
    this._dirty = true;
    return this;
  }
  arc(...args) {
    this.instructions.push({ action: "arc", data: args });
    this._dirty = true;
    return this;
  }
  arcTo(...args) {
    this.instructions.push({ action: "arcTo", data: args });
    this._dirty = true;
    return this;
  }
  arcToSvg(...args) {
    this.instructions.push({ action: "arcToSvg", data: args });
    this._dirty = true;
    return this;
  }
  bezierCurveTo(...args) {
    this.instructions.push({ action: "bezierCurveTo", data: args });
    this._dirty = true;
    return this;
  }
  /**
   * Adds a cubic Bezier curve to the path.
   * It requires two points: the second control point and the end point. The first control point is assumed to be
   * The starting point is the last point in the current path.
   * @param cp2x - The x-coordinate of the second control point.
   * @param cp2y - The y-coordinate of the second control point.
   * @param x - The x-coordinate of the end point.
   * @param y - The y-coordinate of the end point.
   * @param smoothness - Optional parameter to adjust the smoothness of the curve.
   * @returns The instance of the current object for chaining.
   */
  bezierCurveToShort(cp2x, cp2y, x2, y2, smoothness) {
    const last = this.instructions[this.instructions.length - 1];
    const lastPoint = this.getLastPoint(Point.shared);
    let cp1x = 0;
    let cp1y = 0;
    if (!last || last.action !== "bezierCurveTo") {
      cp1x = lastPoint.x;
      cp1y = lastPoint.y;
    } else {
      cp1x = last.data[2];
      cp1y = last.data[3];
      const currentX = lastPoint.x;
      const currentY = lastPoint.y;
      cp1x = currentX + (currentX - cp1x);
      cp1y = currentY + (currentY - cp1y);
    }
    this.instructions.push({ action: "bezierCurveTo", data: [cp1x, cp1y, cp2x, cp2y, x2, y2, smoothness] });
    this._dirty = true;
    return this;
  }
  /**
   * Closes the current path by drawing a straight line back to the start.
   * If the shape is already closed or there are no points in the path, this method does nothing.
   * @returns The instance of the current object for chaining.
   */
  closePath() {
    this.instructions.push({ action: "closePath", data: [] });
    this._dirty = true;
    return this;
  }
  ellipse(...args) {
    this.instructions.push({ action: "ellipse", data: args });
    this._dirty = true;
    return this;
  }
  lineTo(...args) {
    this.instructions.push({ action: "lineTo", data: args });
    this._dirty = true;
    return this;
  }
  moveTo(...args) {
    this.instructions.push({ action: "moveTo", data: args });
    return this;
  }
  quadraticCurveTo(...args) {
    this.instructions.push({ action: "quadraticCurveTo", data: args });
    this._dirty = true;
    return this;
  }
  /**
   * Adds a quadratic curve to the path. It uses the previous point as the control point.
   * @param x - The x-coordinate of the end point.
   * @param y - The y-coordinate of the end point.
   * @param smoothness - Optional parameter to adjust the smoothness of the curve.
   * @returns The instance of the current object for chaining.
   */
  quadraticCurveToShort(x2, y2, smoothness) {
    const last = this.instructions[this.instructions.length - 1];
    const lastPoint = this.getLastPoint(Point.shared);
    let cpx1 = 0;
    let cpy1 = 0;
    if (!last || last.action !== "quadraticCurveTo") {
      cpx1 = lastPoint.x;
      cpy1 = lastPoint.y;
    } else {
      cpx1 = last.data[0];
      cpy1 = last.data[1];
      const currentX = lastPoint.x;
      const currentY = lastPoint.y;
      cpx1 = currentX + (currentX - cpx1);
      cpy1 = currentY + (currentY - cpy1);
    }
    this.instructions.push({ action: "quadraticCurveTo", data: [cpx1, cpy1, x2, y2, smoothness] });
    this._dirty = true;
    return this;
  }
  /**
   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.
   * @param x - The x-coordinate of the top-left corner of the rectangle.
   * @param y - The y-coordinate of the top-left corner of the rectangle.
   * @param w - The width of the rectangle.
   * @param h - The height of the rectangle.
   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.
   * @returns The instance of the current object for chaining.
   */
  rect(x2, y2, w2, h2, transform) {
    this.instructions.push({ action: "rect", data: [x2, y2, w2, h2, transform] });
    this._dirty = true;
    return this;
  }
  /**
   * Draws a circle shape. This method adds a new circle path to the current drawing.
   * @param x - The x-coordinate of the center of the circle.
   * @param y - The y-coordinate of the center of the circle.
   * @param radius - The radius of the circle.
   * @param transform - An optional `Matrix` object to apply a transformation to the circle.
   * @returns The instance of the current object for chaining.
   */
  circle(x2, y2, radius, transform) {
    this.instructions.push({ action: "circle", data: [x2, y2, radius, transform] });
    this._dirty = true;
    return this;
  }
  roundRect(...args) {
    this.instructions.push({ action: "roundRect", data: args });
    this._dirty = true;
    return this;
  }
  poly(...args) {
    this.instructions.push({ action: "poly", data: args });
    this._dirty = true;
    return this;
  }
  regularPoly(...args) {
    this.instructions.push({ action: "regularPoly", data: args });
    this._dirty = true;
    return this;
  }
  roundPoly(...args) {
    this.instructions.push({ action: "roundPoly", data: args });
    this._dirty = true;
    return this;
  }
  roundShape(...args) {
    this.instructions.push({ action: "roundShape", data: args });
    this._dirty = true;
    return this;
  }
  filletRect(...args) {
    this.instructions.push({ action: "filletRect", data: args });
    this._dirty = true;
    return this;
  }
  chamferRect(...args) {
    this.instructions.push({ action: "chamferRect", data: args });
    this._dirty = true;
    return this;
  }
  /**
   * Draws a star shape centered at a specified location. This method allows for the creation
   *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.
   * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.
   * An optional transformation can be applied to scale, rotate, or translate the star as needed.
   * @param x - The x-coordinate of the center of the star.
   * @param y - The y-coordinate of the center of the star.
   * @param points - The number of points of the star.
   * @param radius - The outer radius of the star (distance from the center to the outer points).
   * @param innerRadius - Optional. The inner radius of the star
   * (distance from the center to the inner points between the outer points).
   * If not provided, defaults to half of the `radius`.
   * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.
   * Defaults to 0, meaning one point is directly upward.
   * @param transform - An optional `Matrix` object to apply a transformation to the star.
   * This can include rotations, scaling, and translations.
   * @returns The instance of the current object for chaining further drawing commands.
   */
  // eslint-disable-next-line max-len
  star(x2, y2, points, radius, innerRadius, rotation, transform) {
    innerRadius || (innerRadius = radius / 2);
    const startAngle = -1 * Math.PI / 2 + rotation;
    const len = points * 2;
    const delta = Math.PI * 2 / len;
    const polygon = [];
    for (let i2 = 0; i2 < len; i2++) {
      const r2 = i2 % 2 ? innerRadius : radius;
      const angle = i2 * delta + startAngle;
      polygon.push(
        x2 + r2 * Math.cos(angle),
        y2 + r2 * Math.sin(angle)
      );
    }
    this.poly(polygon, true, transform);
    return this;
  }
  /**
   * Creates a copy of the current `GraphicsPath` instance. This method supports both shallow and deep cloning.
   * A shallow clone copies the reference of the instructions array, while a deep clone creates a new array and
   * copies each instruction individually, ensuring that modifications to the instructions of the cloned `GraphicsPath`
   * do not affect the original `GraphicsPath` and vice versa.
   * @param deep - A boolean flag indicating whether the clone should be deep.
   * @returns A new `GraphicsPath` instance that is a clone of the current instance.
   */
  clone(deep = false) {
    const newGraphicsPath2D = new GraphicsPath();
    newGraphicsPath2D.checkForHoles = this.checkForHoles;
    if (!deep) {
      newGraphicsPath2D.instructions = this.instructions.slice();
    } else {
      for (let i2 = 0; i2 < this.instructions.length; i2++) {
        const instruction = this.instructions[i2];
        newGraphicsPath2D.instructions.push({ action: instruction.action, data: instruction.data.slice() });
      }
    }
    return newGraphicsPath2D;
  }
  clear() {
    this.instructions.length = 0;
    this._dirty = true;
    return this;
  }
  /**
   * Applies a transformation matrix to all drawing instructions within the `GraphicsPath`.
   * This method enables the modification of the path's geometry according to the provided
   * transformation matrix, which can include translations, rotations, scaling, and skewing.
   *
   * Each drawing instruction in the path is updated to reflect the transformation,
   * ensuring the visual representation of the path is consistent with the applied matrix.
   *
   * Note: The transformation is applied directly to the coordinates and control points of the drawing instructions,
   * not to the path as a whole. This means the transformation's effects are baked into the individual instructions,
   * allowing for fine-grained control over the path's appearance.
   * @param matrix - A `Matrix` object representing the transformation to apply.
   * @returns The instance of the current object for chaining further operations.
   */
  transform(matrix) {
    if (matrix.isIdentity())
      return this;
    const a2 = matrix.a;
    const b2 = matrix.b;
    const c2 = matrix.c;
    const d2 = matrix.d;
    const tx = matrix.tx;
    const ty = matrix.ty;
    let x2 = 0;
    let y2 = 0;
    let cpx1 = 0;
    let cpy1 = 0;
    let cpx2 = 0;
    let cpy2 = 0;
    let rx = 0;
    let ry = 0;
    for (let i2 = 0; i2 < this.instructions.length; i2++) {
      const instruction = this.instructions[i2];
      const data = instruction.data;
      switch (instruction.action) {
        case "moveTo":
        case "lineTo":
          x2 = data[0];
          y2 = data[1];
          data[0] = a2 * x2 + c2 * y2 + tx;
          data[1] = b2 * x2 + d2 * y2 + ty;
          break;
        case "bezierCurveTo":
          cpx1 = data[0];
          cpy1 = data[1];
          cpx2 = data[2];
          cpy2 = data[3];
          x2 = data[4];
          y2 = data[5];
          data[0] = a2 * cpx1 + c2 * cpy1 + tx;
          data[1] = b2 * cpx1 + d2 * cpy1 + ty;
          data[2] = a2 * cpx2 + c2 * cpy2 + tx;
          data[3] = b2 * cpx2 + d2 * cpy2 + ty;
          data[4] = a2 * x2 + c2 * y2 + tx;
          data[5] = b2 * x2 + d2 * y2 + ty;
          break;
        case "quadraticCurveTo":
          cpx1 = data[0];
          cpy1 = data[1];
          x2 = data[2];
          y2 = data[3];
          data[0] = a2 * cpx1 + c2 * cpy1 + tx;
          data[1] = b2 * cpx1 + d2 * cpy1 + ty;
          data[2] = a2 * x2 + c2 * y2 + tx;
          data[3] = b2 * x2 + d2 * y2 + ty;
          break;
        case "arcToSvg":
          x2 = data[5];
          y2 = data[6];
          rx = data[0];
          ry = data[1];
          data[0] = a2 * rx + c2 * ry;
          data[1] = b2 * rx + d2 * ry;
          data[5] = a2 * x2 + c2 * y2 + tx;
          data[6] = b2 * x2 + d2 * y2 + ty;
          break;
        case "circle":
          data[4] = adjustTransform(data[3], matrix);
          break;
        case "rect":
          data[4] = adjustTransform(data[4], matrix);
          break;
        case "ellipse":
          data[8] = adjustTransform(data[8], matrix);
          break;
        case "roundRect":
          data[5] = adjustTransform(data[5], matrix);
          break;
        case "addPath":
          data[0].transform(matrix);
          break;
        case "poly":
          data[2] = adjustTransform(data[2], matrix);
          break;
        default:
          warn("unknown transform action", instruction.action);
          break;
      }
    }
    this._dirty = true;
    return this;
  }
  get bounds() {
    return this.shapePath.bounds;
  }
  /**
   * Retrieves the last point from the current drawing instructions in the `GraphicsPath`.
   * This method is useful for operations that depend on the path's current endpoint,
   * such as connecting subsequent shapes or paths. It supports various drawing instructions,
   * ensuring the last point's position is accurately determined regardless of the path's complexity.
   *
   * If the last instruction is a `closePath`, the method iterates backward through the instructions
   *  until it finds an actionable instruction that defines a point (e.g., `moveTo`, `lineTo`,
   * `quadraticCurveTo`, etc.). For compound paths added via `addPath`, it recursively retrieves
   * the last point from the nested path.
   * @param out - A `Point` object where the last point's coordinates will be stored.
   * This object is modified directly to contain the result.
   * @returns The `Point` object containing the last point's coordinates.
   */
  getLastPoint(out2) {
    let index = this.instructions.length - 1;
    let lastInstruction = this.instructions[index];
    if (!lastInstruction) {
      out2.x = 0;
      out2.y = 0;
      return out2;
    }
    while (lastInstruction.action === "closePath") {
      index--;
      if (index < 0) {
        out2.x = 0;
        out2.y = 0;
        return out2;
      }
      lastInstruction = this.instructions[index];
    }
    switch (lastInstruction.action) {
      case "moveTo":
      case "lineTo":
        out2.x = lastInstruction.data[0];
        out2.y = lastInstruction.data[1];
        break;
      case "quadraticCurveTo":
        out2.x = lastInstruction.data[2];
        out2.y = lastInstruction.data[3];
        break;
      case "bezierCurveTo":
        out2.x = lastInstruction.data[4];
        out2.y = lastInstruction.data[5];
        break;
      case "arc":
      case "arcToSvg":
        out2.x = lastInstruction.data[5];
        out2.y = lastInstruction.data[6];
        break;
      case "addPath":
        lastInstruction.data[0].getLastPoint(out2);
        break;
    }
    return out2;
  }
}
function adjustTransform(currentMatrix, transform) {
  if (currentMatrix) {
    return currentMatrix.prepend(transform);
  }
  return transform.clone();
}
function parseSVGFloatAttribute(svg, id2, defaultValue) {
  const value2 = svg.getAttribute(id2);
  return value2 ? Number(value2) : defaultValue;
}
function parseSVGDefinitions(svg, session) {
  const definitions = svg.querySelectorAll("defs");
  for (let i2 = 0; i2 < definitions.length; i2++) {
    const definition = definitions[i2];
    for (let j2 = 0; j2 < definition.children.length; j2++) {
      const child = definition.children[j2];
      switch (child.nodeName.toLowerCase()) {
        case "lineargradient":
          session.defs[child.id] = parseLinearGradient(child);
          break;
        case "radialgradient":
          session.defs[child.id] = parseRadialGradient();
          break;
      }
    }
  }
}
function parseLinearGradient(child) {
  const x0 = parseSVGFloatAttribute(child, "x1", 0);
  const y0 = parseSVGFloatAttribute(child, "y1", 0);
  const x1 = parseSVGFloatAttribute(child, "x2", 1);
  const y1 = parseSVGFloatAttribute(child, "y2", 0);
  const gradientUnit = child.getAttribute("gradientUnits") || "objectBoundingBox";
  const gradient = new FillGradient(
    x0,
    y0,
    x1,
    y1,
    gradientUnit === "objectBoundingBox" ? "local" : "global"
  );
  for (let k2 = 0; k2 < child.children.length; k2++) {
    const stop = child.children[k2];
    const offset = parseSVGFloatAttribute(stop, "offset", 0);
    const color = Color.shared.setValue(stop.getAttribute("stop-color")).toNumber();
    gradient.addColorStop(offset, color);
  }
  return gradient;
}
function parseRadialGradient(_child) {
  warn("[SVG Parser] Radial gradients are not yet supported");
  return new FillGradient(0, 0, 1, 0);
}
function extractSvgUrlId(url) {
  const match = url.match(/url\s*\(\s*['"]?\s*#([^'"\s)]+)\s*['"]?\s*\)/i);
  return match ? match[1] : "";
}
const styleAttributes = {
  // Fill properties
  fill: { type: "paint", default: 0 },
  // Fill color/gradient
  "fill-opacity": { type: "number", default: 1 },
  // Fill transparency
  // Stroke properties
  stroke: { type: "paint", default: 0 },
  // Stroke color/gradient
  "stroke-width": { type: "number", default: 1 },
  // Width of stroke
  "stroke-opacity": { type: "number", default: 1 },
  // Stroke transparency
  "stroke-linecap": { type: "string", default: "butt" },
  // End cap style: butt, round, square
  "stroke-linejoin": { type: "string", default: "miter" },
  // Join style: miter, round, bevel
  "stroke-miterlimit": { type: "number", default: 10 },
  // Limit on miter join sharpness
  "stroke-dasharray": { type: "string", default: "none" },
  // Dash pattern
  "stroke-dashoffset": { type: "number", default: 0 },
  // Offset for dash pattern
  // Global properties
  opacity: { type: "number", default: 1 }
  // Overall opacity
};
function parseSVGStyle(svg, session) {
  const style = svg.getAttribute("style");
  const strokeStyle = {};
  const fillStyle = {};
  const result = {
    strokeStyle,
    fillStyle,
    useFill: false,
    useStroke: false
  };
  for (const key2 in styleAttributes) {
    const attribute = svg.getAttribute(key2);
    if (attribute) {
      parseAttribute(session, result, key2, attribute.trim());
    }
  }
  if (style) {
    const styleParts = style.split(";");
    for (let i2 = 0; i2 < styleParts.length; i2++) {
      const stylePart = styleParts[i2].trim();
      const [key2, value2] = stylePart.split(":");
      if (styleAttributes[key2]) {
        parseAttribute(session, result, key2, value2.trim());
      }
    }
  }
  return {
    strokeStyle: result.useStroke ? strokeStyle : null,
    fillStyle: result.useFill ? fillStyle : null,
    useFill: result.useFill,
    useStroke: result.useStroke
  };
}
function parseAttribute(session, result, id2, value2) {
  switch (id2) {
    case "stroke":
      if (value2 !== "none") {
        if (value2.startsWith("url(")) {
          const id22 = extractSvgUrlId(value2);
          result.strokeStyle.fill = session.defs[id22];
        } else {
          result.strokeStyle.color = Color.shared.setValue(value2).toNumber();
        }
        result.useStroke = true;
      }
      break;
    case "stroke-width":
      result.strokeStyle.width = Number(value2);
      break;
    case "fill":
      if (value2 !== "none") {
        if (value2.startsWith("url(")) {
          const id22 = extractSvgUrlId(value2);
          result.fillStyle.fill = session.defs[id22];
        } else {
          result.fillStyle.color = Color.shared.setValue(value2).toNumber();
        }
        result.useFill = true;
      }
      break;
    case "fill-opacity":
      result.fillStyle.alpha = Number(value2);
      break;
    case "stroke-opacity":
      result.strokeStyle.alpha = Number(value2);
      break;
    case "opacity":
      result.fillStyle.alpha = Number(value2);
      result.strokeStyle.alpha = Number(value2);
      break;
  }
}
function checkForNestedPattern(subpathsWithArea) {
  if (subpathsWithArea.length <= 2) {
    return true;
  }
  const areas = subpathsWithArea.map((s2) => s2.area).sort((a2, b2) => b2 - a2);
  const [largestArea, secondArea] = areas;
  const smallestArea = areas[areas.length - 1];
  const largestToSecondRatio = largestArea / secondArea;
  const secondToSmallestRatio = secondArea / smallestArea;
  if (largestToSecondRatio > 3 && secondToSmallestRatio < 2) {
    return false;
  }
  return true;
}
function extractSubpaths(pathData) {
  const parts = pathData.split(/(?=[Mm])/);
  const subpaths = parts.filter((part) => part.trim().length > 0);
  return subpaths;
}
function calculatePathArea(pathData) {
  const coords = pathData.match(/[-+]?[0-9]*\.?[0-9]+/g);
  if (!coords || coords.length < 4)
    return 0;
  const numbers = coords.map(Number);
  const xs = [];
  const ys = [];
  for (let i2 = 0; i2 < numbers.length; i2 += 2) {
    if (i2 + 1 < numbers.length) {
      xs.push(numbers[i2]);
      ys.push(numbers[i2 + 1]);
    }
  }
  if (xs.length === 0 || ys.length === 0)
    return 0;
  const minX = Math.min(...xs);
  const maxX = Math.max(...xs);
  const minY = Math.min(...ys);
  const maxY = Math.max(...ys);
  const area2 = (maxX - minX) * (maxY - minY);
  return area2;
}
function appendSVGPath(pathData, graphicsPath) {
  const tempPath = new GraphicsPath(pathData, false);
  for (const instruction of tempPath.instructions) {
    graphicsPath.instructions.push(instruction);
  }
}
function SVGParser(svg, graphicsContext) {
  if (typeof svg === "string") {
    const div = document.createElement("div");
    div.innerHTML = svg.trim();
    svg = div.querySelector("svg");
  }
  const session = {
    context: graphicsContext,
    defs: {},
    path: new GraphicsPath()
  };
  parseSVGDefinitions(svg, session);
  const children = svg.children;
  const { fillStyle, strokeStyle } = parseSVGStyle(svg, session);
  for (let i2 = 0; i2 < children.length; i2++) {
    const child = children[i2];
    if (child.nodeName.toLowerCase() === "defs")
      continue;
    renderChildren(child, session, fillStyle, strokeStyle);
  }
  return graphicsContext;
}
function renderChildren(svg, session, fillStyle, strokeStyle) {
  const children = svg.children;
  const { fillStyle: f1, strokeStyle: s1 } = parseSVGStyle(svg, session);
  if (f1 && fillStyle) {
    fillStyle = { ...fillStyle, ...f1 };
  } else if (f1) {
    fillStyle = f1;
  }
  if (s1 && strokeStyle) {
    strokeStyle = { ...strokeStyle, ...s1 };
  } else if (s1) {
    strokeStyle = s1;
  }
  const noStyle = !fillStyle && !strokeStyle;
  if (noStyle) {
    fillStyle = { color: 0 };
  }
  let x2;
  let y2;
  let x1;
  let y1;
  let x22;
  let y22;
  let cx;
  let cy;
  let r2;
  let rx;
  let ry;
  let points;
  let pointsString;
  let d2;
  let graphicsPath;
  let width;
  let height;
  switch (svg.nodeName.toLowerCase()) {
    case "path": {
      d2 = svg.getAttribute("d");
      const fillRule = svg.getAttribute("fill-rule");
      const subpaths = extractSubpaths(d2);
      const hasExplicitEvenodd = fillRule === "evenodd";
      const hasMultipleSubpaths = subpaths.length > 1;
      const shouldProcessHoles = hasExplicitEvenodd && hasMultipleSubpaths;
      if (shouldProcessHoles) {
        const subpathsWithArea = subpaths.map((subpath) => ({
          path: subpath,
          area: calculatePathArea(subpath)
        }));
        subpathsWithArea.sort((a2, b2) => b2.area - a2.area);
        const useMultipleHolesApproach = subpaths.length > 3 || !checkForNestedPattern(subpathsWithArea);
        if (useMultipleHolesApproach) {
          for (let i2 = 0; i2 < subpathsWithArea.length; i2++) {
            const subpath = subpathsWithArea[i2];
            const isMainShape = i2 === 0;
            session.context.beginPath();
            const newPath = new GraphicsPath(void 0, true);
            appendSVGPath(subpath.path, newPath);
            session.context.path(newPath);
            if (isMainShape) {
              if (fillStyle)
                session.context.fill(fillStyle);
              if (strokeStyle)
                session.context.stroke(strokeStyle);
            } else {
              session.context.cut();
            }
          }
        } else {
          for (let i2 = 0; i2 < subpathsWithArea.length; i2++) {
            const subpath = subpathsWithArea[i2];
            const isHole = i2 % 2 === 1;
            session.context.beginPath();
            const newPath = new GraphicsPath(void 0, true);
            appendSVGPath(subpath.path, newPath);
            session.context.path(newPath);
            if (isHole) {
              session.context.cut();
            } else {
              if (fillStyle)
                session.context.fill(fillStyle);
              if (strokeStyle)
                session.context.stroke(strokeStyle);
            }
          }
        }
      } else {
        const useEvenoddForGraphicsPath = fillRule ? fillRule === "evenodd" : true;
        graphicsPath = new GraphicsPath(d2, useEvenoddForGraphicsPath);
        session.context.path(graphicsPath);
        if (fillStyle)
          session.context.fill(fillStyle);
        if (strokeStyle)
          session.context.stroke(strokeStyle);
      }
      break;
    }
    case "circle":
      cx = parseSVGFloatAttribute(svg, "cx", 0);
      cy = parseSVGFloatAttribute(svg, "cy", 0);
      r2 = parseSVGFloatAttribute(svg, "r", 0);
      session.context.ellipse(cx, cy, r2, r2);
      if (fillStyle)
        session.context.fill(fillStyle);
      if (strokeStyle)
        session.context.stroke(strokeStyle);
      break;
    case "rect":
      x2 = parseSVGFloatAttribute(svg, "x", 0);
      y2 = parseSVGFloatAttribute(svg, "y", 0);
      width = parseSVGFloatAttribute(svg, "width", 0);
      height = parseSVGFloatAttribute(svg, "height", 0);
      rx = parseSVGFloatAttribute(svg, "rx", 0);
      ry = parseSVGFloatAttribute(svg, "ry", 0);
      if (rx || ry) {
        session.context.roundRect(x2, y2, width, height, rx || ry);
      } else {
        session.context.rect(x2, y2, width, height);
      }
      if (fillStyle)
        session.context.fill(fillStyle);
      if (strokeStyle)
        session.context.stroke(strokeStyle);
      break;
    case "ellipse":
      cx = parseSVGFloatAttribute(svg, "cx", 0);
      cy = parseSVGFloatAttribute(svg, "cy", 0);
      rx = parseSVGFloatAttribute(svg, "rx", 0);
      ry = parseSVGFloatAttribute(svg, "ry", 0);
      session.context.beginPath();
      session.context.ellipse(cx, cy, rx, ry);
      if (fillStyle)
        session.context.fill(fillStyle);
      if (strokeStyle)
        session.context.stroke(strokeStyle);
      break;
    case "line":
      x1 = parseSVGFloatAttribute(svg, "x1", 0);
      y1 = parseSVGFloatAttribute(svg, "y1", 0);
      x22 = parseSVGFloatAttribute(svg, "x2", 0);
      y22 = parseSVGFloatAttribute(svg, "y2", 0);
      session.context.beginPath();
      session.context.moveTo(x1, y1);
      session.context.lineTo(x22, y22);
      if (strokeStyle)
        session.context.stroke(strokeStyle);
      break;
    case "polygon":
      pointsString = svg.getAttribute("points");
      points = pointsString.match(/\d+/g).map((n2) => parseInt(n2, 10));
      session.context.poly(points, true);
      if (fillStyle)
        session.context.fill(fillStyle);
      if (strokeStyle)
        session.context.stroke(strokeStyle);
      break;
    case "polyline":
      pointsString = svg.getAttribute("points");
      points = pointsString.match(/\d+/g).map((n2) => parseInt(n2, 10));
      session.context.poly(points, false);
      if (strokeStyle)
        session.context.stroke(strokeStyle);
      break;
    case "g":
    case "svg":
      break;
    default: {
      warn(`[SVG parser] <${svg.nodeName}> elements unsupported`);
      break;
    }
  }
  if (noStyle) {
    fillStyle = null;
  }
  for (let i2 = 0; i2 < children.length; i2++) {
    renderChildren(children[i2], session, fillStyle, strokeStyle);
  }
}
function isColorLike(value2) {
  return Color.isColorLike(value2);
}
function isFillPattern(value2) {
  return value2 instanceof FillPattern;
}
function isFillGradient(value2) {
  return value2 instanceof FillGradient;
}
function isTexture(value2) {
  return value2 instanceof Texture;
}
function handleColorLike(fill, value2, defaultStyle) {
  const temp = Color.shared.setValue(value2 ?? 0);
  fill.color = temp.toNumber();
  fill.alpha = temp.alpha === 1 ? defaultStyle.alpha : temp.alpha;
  fill.texture = Texture.WHITE;
  return { ...defaultStyle, ...fill };
}
function handleTexture(fill, value2, defaultStyle) {
  fill.texture = value2;
  return { ...defaultStyle, ...fill };
}
function handleFillPattern(fill, value2, defaultStyle) {
  fill.fill = value2;
  fill.color = 16777215;
  fill.texture = value2.texture;
  fill.matrix = value2.transform;
  return { ...defaultStyle, ...fill };
}
function handleFillGradient(fill, value2, defaultStyle) {
  value2.buildGradient();
  fill.fill = value2;
  fill.color = 16777215;
  fill.texture = value2.texture;
  fill.matrix = value2.transform;
  fill.textureSpace = value2.textureSpace;
  return { ...defaultStyle, ...fill };
}
function handleFillObject(value2, defaultStyle) {
  const style = { ...defaultStyle, ...value2 };
  const color = Color.shared.setValue(style.color);
  style.alpha *= color.alpha;
  style.color = color.toNumber();
  return style;
}
function toFillStyle(value2, defaultStyle) {
  if (value2 === void 0 || value2 === null) {
    return null;
  }
  const fill = {};
  const objectStyle = value2;
  if (isColorLike(value2)) {
    return handleColorLike(fill, value2, defaultStyle);
  } else if (isTexture(value2)) {
    return handleTexture(fill, value2, defaultStyle);
  } else if (isFillPattern(value2)) {
    return handleFillPattern(fill, value2, defaultStyle);
  } else if (isFillGradient(value2)) {
    return handleFillGradient(fill, value2, defaultStyle);
  } else if (objectStyle.fill && isFillPattern(objectStyle.fill)) {
    return handleFillPattern(objectStyle, objectStyle.fill, defaultStyle);
  } else if (objectStyle.fill && isFillGradient(objectStyle.fill)) {
    return handleFillGradient(objectStyle, objectStyle.fill, defaultStyle);
  }
  return handleFillObject(objectStyle, defaultStyle);
}
function toStrokeStyle(value2, defaultStyle) {
  const { width, alignment, miterLimit, cap, join, pixelLine, ...rest } = defaultStyle;
  const fill = toFillStyle(value2, rest);
  if (!fill) {
    return null;
  }
  return {
    width,
    alignment,
    miterLimit,
    cap,
    join,
    pixelLine,
    ...fill
  };
}
const tmpPoint = new Point();
const tempMatrix = new Matrix();
const _GraphicsContext = class _GraphicsContext2 extends EventEmitter {
  constructor() {
    super(...arguments);
    this.uid = uid("graphicsContext");
    this.dirty = true;
    this.batchMode = "auto";
    this.instructions = [];
    this._activePath = new GraphicsPath();
    this._transform = new Matrix();
    this._fillStyle = { ..._GraphicsContext2.defaultFillStyle };
    this._strokeStyle = { ..._GraphicsContext2.defaultStrokeStyle };
    this._stateStack = [];
    this._tick = 0;
    this._bounds = new Bounds();
    this._boundsDirty = true;
  }
  /**
   * Creates a new GraphicsContext object that is a clone of this instance, copying all properties,
   * including the current drawing state, transformations, styles, and instructions.
   * @returns A new GraphicsContext instance with the same properties and state as this one.
   */
  clone() {
    const clone = new _GraphicsContext2();
    clone.batchMode = this.batchMode;
    clone.instructions = this.instructions.slice();
    clone._activePath = this._activePath.clone();
    clone._transform = this._transform.clone();
    clone._fillStyle = { ...this._fillStyle };
    clone._strokeStyle = { ...this._strokeStyle };
    clone._stateStack = this._stateStack.slice();
    clone._bounds = this._bounds.clone();
    clone._boundsDirty = true;
    return clone;
  }
  /**
   * The current fill style of the graphics context. This can be a color, gradient, pattern, or a more complex style defined by a FillStyle object.
   */
  get fillStyle() {
    return this._fillStyle;
  }
  set fillStyle(value2) {
    this._fillStyle = toFillStyle(value2, _GraphicsContext2.defaultFillStyle);
  }
  /**
   * The current stroke style of the graphics context. Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.
   */
  get strokeStyle() {
    return this._strokeStyle;
  }
  set strokeStyle(value2) {
    this._strokeStyle = toStrokeStyle(value2, _GraphicsContext2.defaultStrokeStyle);
  }
  /**
   * Sets the current fill style of the graphics context. The fill style can be a color, gradient,
   * pattern, or a more complex style defined by a FillStyle object.
   * @param style - The fill style to apply. This can be a simple color, a gradient or pattern object,
   *                or a FillStyle or ConvertedFillStyle object.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  setFillStyle(style) {
    this._fillStyle = toFillStyle(style, _GraphicsContext2.defaultFillStyle);
    return this;
  }
  /**
   * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can
   * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.
   * @param style - The stroke style to apply. Can be defined as a color, a gradient or pattern,
   *                or a StrokeStyle or ConvertedStrokeStyle object.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  setStrokeStyle(style) {
    this._strokeStyle = toFillStyle(style, _GraphicsContext2.defaultStrokeStyle);
    return this;
  }
  texture(texture, tint, dx, dy, dw, dh) {
    this.instructions.push({
      action: "texture",
      data: {
        image: texture,
        dx: dx || 0,
        dy: dy || 0,
        dw: dw || texture.frame.width,
        dh: dh || texture.frame.height,
        transform: this._transform.clone(),
        alpha: this._fillStyle.alpha,
        style: tint ? Color.shared.setValue(tint).toNumber() : 16777215
      }
    });
    this.onUpdate();
    return this;
  }
  /**
   * Resets the current path. Any previous path and its commands are discarded and a new path is
   * started. This is typically called before beginning a new shape or series of drawing commands.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  beginPath() {
    this._activePath = new GraphicsPath();
    return this;
  }
  fill(style, alpha) {
    let path2;
    const lastInstruction = this.instructions[this.instructions.length - 1];
    if (this._tick === 0 && (lastInstruction == null ? void 0 : lastInstruction.action) === "stroke") {
      path2 = lastInstruction.data.path;
    } else {
      path2 = this._activePath.clone();
    }
    if (!path2)
      return this;
    if (style != null) {
      if (alpha !== void 0 && typeof style === "number") {
        deprecation(v8_0_0, "GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead");
        style = { color: style, alpha };
      }
      this._fillStyle = toFillStyle(style, _GraphicsContext2.defaultFillStyle);
    }
    this.instructions.push({
      action: "fill",
      // TODO copy fill style!
      data: { style: this.fillStyle, path: path2 }
    });
    this.onUpdate();
    this._initNextPathLocation();
    this._tick = 0;
    return this;
  }
  _initNextPathLocation() {
    const { x: x2, y: y2 } = this._activePath.getLastPoint(Point.shared);
    this._activePath.clear();
    this._activePath.moveTo(x2, y2);
  }
  /**
   * Strokes the current path with the current stroke style. This method can take an optional
   * FillInput parameter to define the stroke's appearance, including its color, width, and other properties.
   * @param style - (Optional) The stroke style to apply. Can be defined as a simple color or a more complex style object. If omitted, uses the current stroke style.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  stroke(style) {
    let path2;
    const lastInstruction = this.instructions[this.instructions.length - 1];
    if (this._tick === 0 && (lastInstruction == null ? void 0 : lastInstruction.action) === "fill") {
      path2 = lastInstruction.data.path;
    } else {
      path2 = this._activePath.clone();
    }
    if (!path2)
      return this;
    if (style != null) {
      this._strokeStyle = toStrokeStyle(style, _GraphicsContext2.defaultStrokeStyle);
    }
    this.instructions.push({
      action: "stroke",
      // TODO copy fill style!
      data: { style: this.strokeStyle, path: path2 }
    });
    this.onUpdate();
    this._initNextPathLocation();
    this._tick = 0;
    return this;
  }
  /**
   * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by
   * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will
   * fail to cut correctly!
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  cut() {
    for (let i2 = 0; i2 < 2; i2++) {
      const lastInstruction = this.instructions[this.instructions.length - 1 - i2];
      const holePath = this._activePath.clone();
      if (lastInstruction) {
        if (lastInstruction.action === "stroke" || lastInstruction.action === "fill") {
          if (lastInstruction.data.hole) {
            lastInstruction.data.hole.addPath(holePath);
          } else {
            lastInstruction.data.hole = holePath;
            break;
          }
        }
      }
    }
    this._initNextPathLocation();
    return this;
  }
  /**
   * Adds an arc to the current path, which is centered at (x, y) with the specified radius,
   * starting and ending angles, and direction.
   * @param x - The x-coordinate of the arc's center.
   * @param y - The y-coordinate of the arc's center.
   * @param radius - The arc's radius.
   * @param startAngle - The starting angle, in radians.
   * @param endAngle - The ending angle, in radians.
   * @param counterclockwise - (Optional) Specifies whether the arc is drawn counterclockwise (true) or clockwise (false). Defaults to false.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  arc(x2, y2, radius, startAngle, endAngle, counterclockwise) {
    this._tick++;
    const t2 = this._transform;
    this._activePath.arc(
      t2.a * x2 + t2.c * y2 + t2.tx,
      t2.b * x2 + t2.d * y2 + t2.ty,
      radius,
      startAngle,
      endAngle,
      counterclockwise
    );
    return this;
  }
  /**
   * Adds an arc to the current path with the given control points and radius, connected to the previous point
   * by a straight line if necessary.
   * @param x1 - The x-coordinate of the first control point.
   * @param y1 - The y-coordinate of the first control point.
   * @param x2 - The x-coordinate of the second control point.
   * @param y2 - The y-coordinate of the second control point.
   * @param radius - The arc's radius.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  arcTo(x1, y1, x2, y2, radius) {
    this._tick++;
    const t2 = this._transform;
    this._activePath.arcTo(
      t2.a * x1 + t2.c * y1 + t2.tx,
      t2.b * x1 + t2.d * y1 + t2.ty,
      t2.a * x2 + t2.c * y2 + t2.tx,
      t2.b * x2 + t2.d * y2 + t2.ty,
      radius
    );
    return this;
  }
  /**
   * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.
   * @param rx - The x-radius of the ellipse.
   * @param ry - The y-radius of the ellipse.
   * @param xAxisRotation - The rotation of the ellipse's x-axis relative
   * to the x-axis of the coordinate system, in degrees.
   * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.
   * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.
   * @param x - The x-coordinate of the arc's end point.
   * @param y - The y-coordinate of the arc's end point.
   * @returns The instance of the current object for chaining.
   */
  arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x2, y2) {
    this._tick++;
    const t2 = this._transform;
    this._activePath.arcToSvg(
      rx,
      ry,
      xAxisRotation,
      // should we rotate this with transform??
      largeArcFlag,
      sweepFlag,
      t2.a * x2 + t2.c * y2 + t2.tx,
      t2.b * x2 + t2.d * y2 + t2.ty
    );
    return this;
  }
  /**
   * Adds a cubic Bezier curve to the path.
   * It requires three points: the first two are control points and the third one is the end point.
   * The starting point is the last point in the current path.
   * @param cp1x - The x-coordinate of the first control point.
   * @param cp1y - The y-coordinate of the first control point.
   * @param cp2x - The x-coordinate of the second control point.
   * @param cp2y - The y-coordinate of the second control point.
   * @param x - The x-coordinate of the end point.
   * @param y - The y-coordinate of the end point.
   * @param smoothness - Optional parameter to adjust the smoothness of the curve.
   * @returns The instance of the current object for chaining.
   */
  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x2, y2, smoothness) {
    this._tick++;
    const t2 = this._transform;
    this._activePath.bezierCurveTo(
      t2.a * cp1x + t2.c * cp1y + t2.tx,
      t2.b * cp1x + t2.d * cp1y + t2.ty,
      t2.a * cp2x + t2.c * cp2y + t2.tx,
      t2.b * cp2x + t2.d * cp2y + t2.ty,
      t2.a * x2 + t2.c * y2 + t2.tx,
      t2.b * x2 + t2.d * y2 + t2.ty,
      smoothness
    );
    return this;
  }
  /**
   * Closes the current path by drawing a straight line back to the start.
   * If the shape is already closed or there are no points in the path, this method does nothing.
   * @returns The instance of the current object for chaining.
   */
  closePath() {
    var _a;
    this._tick++;
    (_a = this._activePath) == null ? void 0 : _a.closePath();
    return this;
  }
  /**
   * Draws an ellipse at the specified location and with the given x and y radii.
   * An optional transformation can be applied, allowing for rotation, scaling, and translation.
   * @param x - The x-coordinate of the center of the ellipse.
   * @param y - The y-coordinate of the center of the ellipse.
   * @param radiusX - The horizontal radius of the ellipse.
   * @param radiusY - The vertical radius of the ellipse.
   * @returns The instance of the current object for chaining.
   */
  ellipse(x2, y2, radiusX, radiusY) {
    this._tick++;
    this._activePath.ellipse(x2, y2, radiusX, radiusY, this._transform.clone());
    return this;
  }
  /**
   * Draws a circle shape. This method adds a new circle path to the current drawing.
   * @param x - The x-coordinate of the center of the circle.
   * @param y - The y-coordinate of the center of the circle.
   * @param radius - The radius of the circle.
   * @returns The instance of the current object for chaining.
   */
  circle(x2, y2, radius) {
    this._tick++;
    this._activePath.circle(x2, y2, radius, this._transform.clone());
    return this;
  }
  /**
   * Adds another `GraphicsPath` to this path, optionally applying a transformation.
   * @param path - The `GraphicsPath` to add.
   * @returns The instance of the current object for chaining.
   */
  path(path2) {
    this._tick++;
    this._activePath.addPath(path2, this._transform.clone());
    return this;
  }
  /**
   * Connects the current point to a new point with a straight line. This method updates the current path.
   * @param x - The x-coordinate of the new point to connect to.
   * @param y - The y-coordinate of the new point to connect to.
   * @returns The instance of the current object for chaining.
   */
  lineTo(x2, y2) {
    this._tick++;
    const t2 = this._transform;
    this._activePath.lineTo(
      t2.a * x2 + t2.c * y2 + t2.tx,
      t2.b * x2 + t2.d * y2 + t2.ty
    );
    return this;
  }
  /**
   * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.
   * @param x - The x-coordinate for the starting point.
   * @param y - The y-coordinate for the starting point.
   * @returns The instance of the current object for chaining.
   */
  moveTo(x2, y2) {
    this._tick++;
    const t2 = this._transform;
    const instructions = this._activePath.instructions;
    const transformedX = t2.a * x2 + t2.c * y2 + t2.tx;
    const transformedY = t2.b * x2 + t2.d * y2 + t2.ty;
    if (instructions.length === 1 && instructions[0].action === "moveTo") {
      instructions[0].data[0] = transformedX;
      instructions[0].data[1] = transformedY;
      return this;
    }
    this._activePath.moveTo(
      transformedX,
      transformedY
    );
    return this;
  }
  /**
   * Adds a quadratic curve to the path. It requires two points: the control point and the end point.
   * The starting point is the last point in the current path.
   * @param cpx - The x-coordinate of the control point.
   * @param cpy - The y-coordinate of the control point.
   * @param x - The x-coordinate of the end point.
   * @param y - The y-coordinate of the end point.
   * @param smoothness - Optional parameter to adjust the smoothness of the curve.
   * @returns The instance of the current object for chaining.
   */
  quadraticCurveTo(cpx, cpy, x2, y2, smoothness) {
    this._tick++;
    const t2 = this._transform;
    this._activePath.quadraticCurveTo(
      t2.a * cpx + t2.c * cpy + t2.tx,
      t2.b * cpx + t2.d * cpy + t2.ty,
      t2.a * x2 + t2.c * y2 + t2.tx,
      t2.b * x2 + t2.d * y2 + t2.ty,
      smoothness
    );
    return this;
  }
  /**
   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.
   * @param x - The x-coordinate of the top-left corner of the rectangle.
   * @param y - The y-coordinate of the top-left corner of the rectangle.
   * @param w - The width of the rectangle.
   * @param h - The height of the rectangle.
   * @returns The instance of the current object for chaining.
   */
  rect(x2, y2, w2, h2) {
    this._tick++;
    this._activePath.rect(x2, y2, w2, h2, this._transform.clone());
    return this;
  }
  /**
   * Draws a rectangle with rounded corners.
   * The corner radius can be specified to determine how rounded the corners should be.
   * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.
   * @param x - The x-coordinate of the top-left corner of the rectangle.
   * @param y - The y-coordinate of the top-left corner of the rectangle.
   * @param w - The width of the rectangle.
   * @param h - The height of the rectangle.
   * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.
   * @returns The instance of the current object for chaining.
   */
  roundRect(x2, y2, w2, h2, radius) {
    this._tick++;
    this._activePath.roundRect(x2, y2, w2, h2, radius, this._transform.clone());
    return this;
  }
  /**
   * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,
   * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,
   * rotated, or translated as needed.
   * @param points - An array of numbers, or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]
   * representing the x and y coordinates, of the polygon's vertices, in sequence.
   * @param close - A boolean indicating whether to close the polygon path. True by default.
   */
  poly(points, close) {
    this._tick++;
    this._activePath.poly(points, close, this._transform.clone());
    return this;
  }
  /**
   * Draws a regular polygon with a specified number of sides. All sides and angles are equal.
   * @param x - The x-coordinate of the center of the polygon.
   * @param y - The y-coordinate of the center of the polygon.
   * @param radius - The radius of the circumscribed circle of the polygon.
   * @param sides - The number of sides of the polygon. Must be 3 or more.
   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.
   * @returns The instance of the current object for chaining.
   */
  regularPoly(x2, y2, radius, sides, rotation = 0, transform) {
    this._tick++;
    this._activePath.regularPoly(x2, y2, radius, sides, rotation, transform);
    return this;
  }
  /**
   * Draws a polygon with rounded corners.
   * Similar to `regularPoly` but with the ability to round the corners of the polygon.
   * @param x - The x-coordinate of the center of the polygon.
   * @param y - The y-coordinate of the center of the polygon.
   * @param radius - The radius of the circumscribed circle of the polygon.
   * @param sides - The number of sides of the polygon. Must be 3 or more.
   * @param corner - The radius of the rounding of the corners.
   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
   * @returns The instance of the current object for chaining.
   */
  roundPoly(x2, y2, radius, sides, corner, rotation) {
    this._tick++;
    this._activePath.roundPoly(x2, y2, radius, sides, corner, rotation);
    return this;
  }
  /**
   * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.
   * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.
   * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.
   * A minimum of 3 points is required.
   * @param radius - The default radius for the corners.
   * This radius is applied to all corners unless overridden in `points`.
   * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve
   *  method instead of an arc method. Defaults to false.
   * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.
   * Higher values make the curve smoother.
   * @returns The instance of the current object for chaining.
   */
  roundShape(points, radius, useQuadratic, smoothness) {
    this._tick++;
    this._activePath.roundShape(points, radius, useQuadratic, smoothness);
    return this;
  }
  /**
   * Draw Rectangle with fillet corners. This is much like rounded rectangle
   * however it support negative numbers as well for the corner radius.
   * @param x - Upper left corner of rect
   * @param y - Upper right corner of rect
   * @param width - Width of rect
   * @param height - Height of rect
   * @param fillet - accept negative or positive values
   */
  filletRect(x2, y2, width, height, fillet) {
    this._tick++;
    this._activePath.filletRect(x2, y2, width, height, fillet);
    return this;
  }
  /**
   * Draw Rectangle with chamfer corners. These are angled corners.
   * @param x - Upper left corner of rect
   * @param y - Upper right corner of rect
   * @param width - Width of rect
   * @param height - Height of rect
   * @param chamfer - non-zero real number, size of corner cutout
   * @param transform
   */
  chamferRect(x2, y2, width, height, chamfer, transform) {
    this._tick++;
    this._activePath.chamferRect(x2, y2, width, height, chamfer, transform);
    return this;
  }
  /**
   * Draws a star shape centered at a specified location. This method allows for the creation
   *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.
   * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.
   * An optional transformation can be applied to scale, rotate, or translate the star as needed.
   * @param x - The x-coordinate of the center of the star.
   * @param y - The y-coordinate of the center of the star.
   * @param points - The number of points of the star.
   * @param radius - The outer radius of the star (distance from the center to the outer points).
   * @param innerRadius - Optional. The inner radius of the star
   * (distance from the center to the inner points between the outer points).
   * If not provided, defaults to half of the `radius`.
   * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.
   * Defaults to 0, meaning one point is directly upward.
   * @returns The instance of the current object for chaining further drawing commands.
   */
  star(x2, y2, points, radius, innerRadius = 0, rotation = 0) {
    this._tick++;
    this._activePath.star(x2, y2, points, radius, innerRadius, rotation, this._transform.clone());
    return this;
  }
  /**
   * Parses and renders an SVG string into the graphics context. This allows for complex shapes and paths
   * defined in SVG format to be drawn within the graphics context.
   * @param svg - The SVG string to be parsed and rendered.
   */
  svg(svg) {
    this._tick++;
    SVGParser(svg, this);
    return this;
  }
  /**
   * Restores the most recently saved graphics state by popping the top of the graphics state stack.
   * This includes transformations, fill styles, and stroke styles.
   */
  restore() {
    const state = this._stateStack.pop();
    if (state) {
      this._transform = state.transform;
      this._fillStyle = state.fillStyle;
      this._strokeStyle = state.strokeStyle;
    }
    return this;
  }
  /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */
  save() {
    this._stateStack.push({
      transform: this._transform.clone(),
      fillStyle: { ...this._fillStyle },
      strokeStyle: { ...this._strokeStyle }
    });
    return this;
  }
  /**
   * Returns the current transformation matrix of the graphics context.
   * @returns The current transformation matrix.
   */
  getTransform() {
    return this._transform;
  }
  /**
   * Resets the current transformation matrix to the identity matrix, effectively removing any transformations (rotation, scaling, translation) previously applied.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  resetTransform() {
    this._transform.identity();
    return this;
  }
  /**
   * Applies a rotation transformation to the graphics context around the current origin.
   * @param angle - The angle of rotation in radians.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  rotate(angle) {
    this._transform.rotate(angle);
    return this;
  }
  /**
   * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally and by y vertically.
   * @param x - The scale factor in the horizontal direction.
   * @param y - (Optional) The scale factor in the vertical direction. If not specified, the x value is used for both directions.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  scale(x2, y2 = x2) {
    this._transform.scale(x2, y2);
    return this;
  }
  setTransform(a2, b2, c2, d2, dx, dy) {
    if (a2 instanceof Matrix) {
      this._transform.set(a2.a, a2.b, a2.c, a2.d, a2.tx, a2.ty);
      return this;
    }
    this._transform.set(a2, b2, c2, d2, dx, dy);
    return this;
  }
  transform(a2, b2, c2, d2, dx, dy) {
    if (a2 instanceof Matrix) {
      this._transform.append(a2);
      return this;
    }
    tempMatrix.set(a2, b2, c2, d2, dx, dy);
    this._transform.append(tempMatrix);
    return this;
  }
  /**
   * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.
   * @param x - The amount to translate in the horizontal direction.
   * @param y - (Optional) The amount to translate in the vertical direction. If not specified, the x value is used for both directions.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  translate(x2, y2 = x2) {
    this._transform.translate(x2, y2);
    return this;
  }
  /**
   * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,
   * and optionally resetting transformations to the identity matrix.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  clear() {
    this._activePath.clear();
    this.instructions.length = 0;
    this.resetTransform();
    this.onUpdate();
    return this;
  }
  onUpdate() {
    this._boundsDirty = true;
    if (this.dirty)
      return;
    this.emit("update", this, 16);
    this.dirty = true;
  }
  /** The bounds of the graphic shape. */
  get bounds() {
    if (!this._boundsDirty)
      return this._bounds;
    this._boundsDirty = false;
    const bounds = this._bounds;
    bounds.clear();
    for (let i2 = 0; i2 < this.instructions.length; i2++) {
      const instruction = this.instructions[i2];
      const action2 = instruction.action;
      if (action2 === "fill") {
        const data = instruction.data;
        bounds.addBounds(data.path.bounds);
      } else if (action2 === "texture") {
        const data = instruction.data;
        bounds.addFrame(data.dx, data.dy, data.dx + data.dw, data.dy + data.dh, data.transform);
      }
      if (action2 === "stroke") {
        const data = instruction.data;
        const alignment = data.style.alignment;
        const outerPadding = data.style.width * (1 - alignment);
        const _bounds = data.path.bounds;
        bounds.addFrame(
          _bounds.minX - outerPadding,
          _bounds.minY - outerPadding,
          _bounds.maxX + outerPadding,
          _bounds.maxY + outerPadding
        );
      }
    }
    return bounds;
  }
  /**
   * Check to see if a point is contained within this geometry.
   * @param point - Point to check if it's contained.
   * @returns {boolean} `true` if the point is contained within geometry.
   */
  containsPoint(point) {
    var _a;
    if (!this.bounds.containsPoint(point.x, point.y))
      return false;
    const instructions = this.instructions;
    let hasHit = false;
    for (let k2 = 0; k2 < instructions.length; k2++) {
      const instruction = instructions[k2];
      const data = instruction.data;
      const path2 = data.path;
      if (!instruction.action || !path2)
        continue;
      const style = data.style;
      const shapes = path2.shapePath.shapePrimitives;
      for (let i2 = 0; i2 < shapes.length; i2++) {
        const shape = shapes[i2].shape;
        if (!style || !shape)
          continue;
        const transform = shapes[i2].transform;
        const transformedPoint = transform ? transform.applyInverse(point, tmpPoint) : point;
        if (instruction.action === "fill") {
          hasHit = shape.contains(transformedPoint.x, transformedPoint.y);
        } else {
          const strokeStyle = style;
          hasHit = shape.strokeContains(transformedPoint.x, transformedPoint.y, strokeStyle.width, strokeStyle.alignment);
        }
        const holes = data.hole;
        if (holes) {
          const holeShapes = (_a = holes.shapePath) == null ? void 0 : _a.shapePrimitives;
          if (holeShapes) {
            for (let j2 = 0; j2 < holeShapes.length; j2++) {
              if (holeShapes[j2].shape.contains(transformedPoint.x, transformedPoint.y)) {
                hasHit = false;
              }
            }
          }
        }
        if (hasHit) {
          return true;
        }
      }
    }
    return hasHit;
  }
  /**
   * Destroys the GraphicsData object.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @example
   * context.destroy();
   * context.destroy(true);
   * context.destroy({ texture: true, textureSource: true });
   */
  destroy(options = false) {
    this._stateStack.length = 0;
    this._transform = null;
    this.emit("destroy", this);
    this.removeAllListeners();
    const destroyTexture = typeof options === "boolean" ? options : options == null ? void 0 : options.texture;
    if (destroyTexture) {
      const destroyTextureSource = typeof options === "boolean" ? options : options == null ? void 0 : options.textureSource;
      if (this._fillStyle.texture) {
        this._fillStyle.fill && "uid" in this._fillStyle.fill ? this._fillStyle.fill.destroy() : this._fillStyle.texture.destroy(destroyTextureSource);
      }
      if (this._strokeStyle.texture) {
        this._strokeStyle.fill && "uid" in this._strokeStyle.fill ? this._strokeStyle.fill.destroy() : this._strokeStyle.texture.destroy(destroyTextureSource);
      }
    }
    this._fillStyle = null;
    this._strokeStyle = null;
    this.instructions = null;
    this._activePath = null;
    this._bounds = null;
    this._stateStack = null;
    this.customShader = null;
    this._transform = null;
  }
};
_GraphicsContext.defaultFillStyle = {
  /** The color to use for the fill. */
  color: 16777215,
  /** The alpha value to use for the fill. */
  alpha: 1,
  /** The texture to use for the fill. */
  texture: Texture.WHITE,
  /** The matrix to apply. */
  matrix: null,
  /** The fill pattern to use. */
  fill: null,
  /** Whether coordinates are 'global' or 'local' */
  textureSpace: "local"
};
_GraphicsContext.defaultStrokeStyle = {
  /** The width of the stroke. */
  width: 1,
  /** The color to use for the stroke. */
  color: 16777215,
  /** The alpha value to use for the stroke. */
  alpha: 1,
  /** The alignment of the stroke. */
  alignment: 0.5,
  /** The miter limit to use. */
  miterLimit: 10,
  /** The line cap style to use. */
  cap: "butt",
  /** The line join style to use. */
  join: "miter",
  /** The texture to use for the fill. */
  texture: Texture.WHITE,
  /** The matrix to apply. */
  matrix: null,
  /** The fill pattern to use. */
  fill: null,
  /** Whether coordinates are 'global' or 'local' */
  textureSpace: "local",
  /** If the stroke is a pixel line. */
  pixelLine: false
};
let GraphicsContext = _GraphicsContext;
const _TextStyle = class _TextStyle2 extends EventEmitter {
  constructor(style = {}) {
    super();
    this.uid = uid("textStyle");
    this._tick = 0;
    convertV7Tov8Style(style);
    const fullStyle = { ..._TextStyle2.defaultTextStyle, ...style };
    for (const key2 in fullStyle) {
      const thisKey = key2;
      this[thisKey] = fullStyle[key2];
    }
    this.update();
    this._tick = 0;
  }
  /**
   * Alignment for multiline text, does not affect single line text.
   * @type {'left'|'center'|'right'|'justify'}
   */
  get align() {
    return this._align;
  }
  set align(value2) {
    if (this._align === value2)
      return;
    this._align = value2;
    this.update();
  }
  /** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */
  get breakWords() {
    return this._breakWords;
  }
  set breakWords(value2) {
    if (this._breakWords === value2)
      return;
    this._breakWords = value2;
    this.update();
  }
  /** Set a drop shadow for the text. */
  get dropShadow() {
    return this._dropShadow;
  }
  set dropShadow(value2) {
    if (this._dropShadow === value2)
      return;
    if (value2 !== null && typeof value2 === "object") {
      this._dropShadow = this._createProxy({ ..._TextStyle2.defaultDropShadow, ...value2 });
    } else {
      this._dropShadow = value2 ? this._createProxy({ ..._TextStyle2.defaultDropShadow }) : null;
    }
    this.update();
  }
  /** The font family, can be a single font name, or a list of names where the first is the preferred font. */
  get fontFamily() {
    return this._fontFamily;
  }
  set fontFamily(value2) {
    if (this._fontFamily === value2)
      return;
    this._fontFamily = value2;
    this.update();
  }
  /** The font size (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em') */
  get fontSize() {
    return this._fontSize;
  }
  set fontSize(value2) {
    if (this._fontSize === value2)
      return;
    if (typeof value2 === "string") {
      this._fontSize = parseInt(value2, 10);
    } else {
      this._fontSize = value2;
    }
    this.update();
  }
  /**
   * The font style.
   * @type {'normal'|'italic'|'oblique'}
   */
  get fontStyle() {
    return this._fontStyle;
  }
  set fontStyle(value2) {
    if (this._fontStyle === value2)
      return;
    this._fontStyle = value2.toLowerCase();
    this.update();
  }
  /**
   * The font variant.
   * @type {'normal'|'small-caps'}
   */
  get fontVariant() {
    return this._fontVariant;
  }
  set fontVariant(value2) {
    if (this._fontVariant === value2)
      return;
    this._fontVariant = value2;
    this.update();
  }
  /**
   * The font weight.
   * @type {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}
   */
  get fontWeight() {
    return this._fontWeight;
  }
  set fontWeight(value2) {
    if (this._fontWeight === value2)
      return;
    this._fontWeight = value2;
    this.update();
  }
  /** The space between lines. */
  get leading() {
    return this._leading;
  }
  set leading(value2) {
    if (this._leading === value2)
      return;
    this._leading = value2;
    this.update();
  }
  /** The amount of spacing between letters, default is 0. */
  get letterSpacing() {
    return this._letterSpacing;
  }
  set letterSpacing(value2) {
    if (this._letterSpacing === value2)
      return;
    this._letterSpacing = value2;
    this.update();
  }
  /** The line height, a number that represents the vertical space that a letter uses. */
  get lineHeight() {
    return this._lineHeight;
  }
  set lineHeight(value2) {
    if (this._lineHeight === value2)
      return;
    this._lineHeight = value2;
    this.update();
  }
  /**
   * Occasionally some fonts are cropped. Adding some padding will prevent this from happening
   * by adding padding to all sides of the text.
   * > [!NOTE] This will NOT affect the positioning or bounds of the text.
   */
  get padding() {
    return this._padding;
  }
  set padding(value2) {
    if (this._padding === value2)
      return;
    this._padding = value2;
    this.update();
  }
  /**
   * An optional filter or array of filters to apply to the text, allowing for advanced visual effects.
   * These filters will be applied to the text as it is created, resulting in faster rendering for static text
   * compared to applying the filter directly to the text object (which would be applied at run time).
   * @default null
   */
  get filters() {
    return this._filters;
  }
  set filters(value2) {
    if (this._filters === value2)
      return;
    this._filters = Object.freeze(value2);
    this.update();
  }
  /**
   * Trim transparent borders from the text texture.
   * > [!IMPORTANT] PERFORMANCE WARNING:
   * > This is a costly operation as it requires scanning pixel alpha values.
   * > Avoid using `trim: true` for dynamic text, as it could significantly impact performance.
   */
  get trim() {
    return this._trim;
  }
  set trim(value2) {
    if (this._trim === value2)
      return;
    this._trim = value2;
    this.update();
  }
  /**
   * The baseline of the text that is rendered.
   * @type {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}
   */
  get textBaseline() {
    return this._textBaseline;
  }
  set textBaseline(value2) {
    if (this._textBaseline === value2)
      return;
    this._textBaseline = value2;
    this.update();
  }
  /**
   * How newlines and spaces should be handled.
   * Default is 'pre' (preserve, preserve).
   *
   *  value       | New lines     |   Spaces
   *  ---         | ---           |   ---
   * 'normal'     | Collapse      |   Collapse
   * 'pre'        | Preserve      |   Preserve
   * 'pre-line'   | Preserve      |   Collapse
   * @type {'normal'|'pre'|'pre-line'}
   */
  get whiteSpace() {
    return this._whiteSpace;
  }
  set whiteSpace(value2) {
    if (this._whiteSpace === value2)
      return;
    this._whiteSpace = value2;
    this.update();
  }
  /** Indicates if word wrap should be used. */
  get wordWrap() {
    return this._wordWrap;
  }
  set wordWrap(value2) {
    if (this._wordWrap === value2)
      return;
    this._wordWrap = value2;
    this.update();
  }
  /** The width at which text will wrap, it needs wordWrap to be set to true. */
  get wordWrapWidth() {
    return this._wordWrapWidth;
  }
  set wordWrapWidth(value2) {
    if (this._wordWrapWidth === value2)
      return;
    this._wordWrapWidth = value2;
    this.update();
  }
  /**
   * The fill style that will be used to color the text.
   * This can be:
   * - A color string like 'red', '#00FF00', or 'rgba(255,0,0,0.5)'
   * - A hex number like 0xff0000 for red
   * - A FillStyle object with properties like { color: 0xff0000, alpha: 0.5 }
   * - A FillGradient for gradient fills
   * - A FillPattern for pattern/texture fills
   *
   * When using a FillGradient, vertical gradients (angle of 90 degrees) are applied per line of text,
   * while gradients at any other angle are spread across the entire text body as a whole.
   * @example
   * // Vertical gradient applied per line
   * const verticalGradient = new FillGradient(0, 0, 0, 1)
   *     .addColorStop(0, 0xff0000)
   *     .addColorStop(1, 0x0000ff);
   *
   * const text = new Text({
   *     text: 'Line 1\nLine 2',
   *     style: { fill: verticalGradient }
   * });
   *
   * To manage the gradient in a global scope, set the textureSpace property of the FillGradient to 'global'.
   * @type {string|number|FillStyle|FillGradient|FillPattern}
   */
  get fill() {
    return this._originalFill;
  }
  set fill(value2) {
    if (value2 === this._originalFill)
      return;
    this._originalFill = value2;
    if (this._isFillStyle(value2)) {
      this._originalFill = this._createProxy({ ...GraphicsContext.defaultFillStyle, ...value2 }, () => {
        this._fill = toFillStyle(
          { ...this._originalFill },
          GraphicsContext.defaultFillStyle
        );
      });
    }
    this._fill = toFillStyle(
      value2 === 0 ? "black" : value2,
      GraphicsContext.defaultFillStyle
    );
    this.update();
  }
  /** A fillstyle that will be used on the text stroke, e.g., 'blue', '#FCFF00'. */
  get stroke() {
    return this._originalStroke;
  }
  set stroke(value2) {
    if (value2 === this._originalStroke)
      return;
    this._originalStroke = value2;
    if (this._isFillStyle(value2)) {
      this._originalStroke = this._createProxy({ ...GraphicsContext.defaultStrokeStyle, ...value2 }, () => {
        this._stroke = toStrokeStyle(
          { ...this._originalStroke },
          GraphicsContext.defaultStrokeStyle
        );
      });
    }
    this._stroke = toStrokeStyle(value2, GraphicsContext.defaultStrokeStyle);
    this.update();
  }
  update() {
    this._tick++;
    this.emit("update", this);
  }
  /** Resets all properties to the default values */
  reset() {
    const defaultStyle = _TextStyle2.defaultTextStyle;
    for (const key2 in defaultStyle) {
      this[key2] = defaultStyle[key2];
    }
  }
  /**
   * Returns a unique key for this instance.
   * This key is used for caching.
   * @returns {string} Unique key for the instance
   */
  get styleKey() {
    return `${this.uid}-${this._tick}`;
  }
  /**
   * Creates a new TextStyle object with the same values as this one.
   * @returns New cloned TextStyle object
   */
  clone() {
    return new _TextStyle2({
      align: this.align,
      breakWords: this.breakWords,
      dropShadow: this._dropShadow ? { ...this._dropShadow } : null,
      fill: this._fill,
      fontFamily: this.fontFamily,
      fontSize: this.fontSize,
      fontStyle: this.fontStyle,
      fontVariant: this.fontVariant,
      fontWeight: this.fontWeight,
      leading: this.leading,
      letterSpacing: this.letterSpacing,
      lineHeight: this.lineHeight,
      padding: this.padding,
      stroke: this._stroke,
      textBaseline: this.textBaseline,
      whiteSpace: this.whiteSpace,
      wordWrap: this.wordWrap,
      wordWrapWidth: this.wordWrapWidth,
      filters: this._filters ? [...this._filters] : void 0
    });
  }
  /**
   * Returns the final padding for the text style, taking into account any filters applied.
   * Used internally for correct measurements
   * @internal
   * @returns {number} The final padding for the text style.
   */
  _getFinalPadding() {
    let filterPadding = 0;
    if (this._filters) {
      for (let i2 = 0; i2 < this._filters.length; i2++) {
        filterPadding += this._filters[i2].padding;
      }
    }
    return Math.max(this._padding, filterPadding);
  }
  /**
   * Destroys this text style.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @example
   * // Destroy the text style and its textures
   * textStyle.destroy({ texture: true, textureSource: true });
   * textStyle.destroy(true);
   */
  destroy(options = false) {
    var _a, _b, _c, _d;
    this.removeAllListeners();
    const destroyTexture = typeof options === "boolean" ? options : options == null ? void 0 : options.texture;
    if (destroyTexture) {
      const destroyTextureSource = typeof options === "boolean" ? options : options == null ? void 0 : options.textureSource;
      if ((_a = this._fill) == null ? void 0 : _a.texture) {
        this._fill.texture.destroy(destroyTextureSource);
      }
      if ((_b = this._originalFill) == null ? void 0 : _b.texture) {
        this._originalFill.texture.destroy(destroyTextureSource);
      }
      if ((_c = this._stroke) == null ? void 0 : _c.texture) {
        this._stroke.texture.destroy(destroyTextureSource);
      }
      if ((_d = this._originalStroke) == null ? void 0 : _d.texture) {
        this._originalStroke.texture.destroy(destroyTextureSource);
      }
    }
    this._fill = null;
    this._stroke = null;
    this.dropShadow = null;
    this._originalStroke = null;
    this._originalFill = null;
  }
  _createProxy(value2, cb) {
    return new Proxy(value2, {
      set: (target, property, newValue) => {
        if (target[property] === newValue)
          return true;
        target[property] = newValue;
        cb == null ? void 0 : cb(property, newValue);
        this.update();
        return true;
      }
    });
  }
  _isFillStyle(value2) {
    return (value2 ?? null) !== null && !(Color.isColorLike(value2) || value2 instanceof FillGradient || value2 instanceof FillPattern);
  }
};
_TextStyle.defaultDropShadow = {
  alpha: 1,
  angle: Math.PI / 6,
  blur: 0,
  color: "black",
  distance: 5
};
_TextStyle.defaultTextStyle = {
  align: "left",
  breakWords: false,
  dropShadow: null,
  fill: "black",
  fontFamily: "Arial",
  fontSize: 26,
  fontStyle: "normal",
  fontVariant: "normal",
  fontWeight: "normal",
  leading: 0,
  letterSpacing: 0,
  lineHeight: 0,
  padding: 0,
  stroke: null,
  textBaseline: "alphabetic",
  trim: false,
  whiteSpace: "pre",
  wordWrap: false,
  wordWrapWidth: 100
};
let TextStyle = _TextStyle;
function convertV7Tov8Style(style) {
  const oldStyle = style;
  if (typeof oldStyle.dropShadow === "boolean" && oldStyle.dropShadow) {
    const defaults = TextStyle.defaultDropShadow;
    style.dropShadow = {
      alpha: oldStyle.dropShadowAlpha ?? defaults.alpha,
      angle: oldStyle.dropShadowAngle ?? defaults.angle,
      blur: oldStyle.dropShadowBlur ?? defaults.blur,
      color: oldStyle.dropShadowColor ?? defaults.color,
      distance: oldStyle.dropShadowDistance ?? defaults.distance
    };
  }
  if (oldStyle.strokeThickness !== void 0) {
    deprecation(v8_0_0, "strokeThickness is now a part of stroke");
    const color = oldStyle.stroke;
    let obj = {};
    if (Color.isColorLike(color)) {
      obj.color = color;
    } else if (color instanceof FillGradient || color instanceof FillPattern) {
      obj.fill = color;
    } else if (Object.hasOwnProperty.call(color, "color") || Object.hasOwnProperty.call(color, "fill")) {
      obj = color;
    } else {
      throw new Error("Invalid stroke value.");
    }
    style.stroke = {
      ...obj,
      width: oldStyle.strokeThickness
    };
  }
  if (Array.isArray(oldStyle.fillGradientStops)) {
    deprecation(v8_0_0, "gradient fill is now a fill pattern: `new FillGradient(...)`");
    if (!Array.isArray(oldStyle.fill) || oldStyle.fill.length === 0) {
      throw new Error("Invalid fill value. Expected an array of colors for gradient fill.");
    }
    if (oldStyle.fill.length !== oldStyle.fillGradientStops.length) {
      warn("The number of fill colors must match the number of fill gradient stops.");
    }
    const gradientFill = new FillGradient({
      start: { x: 0, y: 0 },
      end: { x: 0, y: 1 },
      textureSpace: "local"
    });
    const fillGradientStops = oldStyle.fillGradientStops.slice();
    const fills = oldStyle.fill.map((color) => Color.shared.setValue(color).toNumber());
    fillGradientStops.forEach((stop, index) => {
      gradientFill.addColorStop(stop, fills[index]);
    });
    style.fill = {
      fill: gradientFill
    };
  }
}
class CanvasPoolClass {
  constructor(canvasOptions) {
    this._canvasPool = /* @__PURE__ */ Object.create(null);
    this.canvasOptions = canvasOptions || {};
    this.enableFullScreen = false;
  }
  /**
   * Creates texture with params that were specified in pool constructor.
   * @param pixelWidth - Width of texture in pixels.
   * @param pixelHeight - Height of texture in pixels.
   */
  _createCanvasAndContext(pixelWidth, pixelHeight) {
    const canvas = DOMAdapter.get().createCanvas();
    canvas.width = pixelWidth;
    canvas.height = pixelHeight;
    const context2 = canvas.getContext("2d");
    return { canvas, context: context2 };
  }
  /**
   * Gets a Power-of-Two render texture or fullScreen texture
   * @param minWidth - The minimum width of the render texture.
   * @param minHeight - The minimum height of the render texture.
   * @param resolution - The resolution of the render texture.
   * @returns The new render texture.
   */
  getOptimalCanvasAndContext(minWidth, minHeight, resolution2 = 1) {
    minWidth = Math.ceil(minWidth * resolution2 - 1e-6);
    minHeight = Math.ceil(minHeight * resolution2 - 1e-6);
    minWidth = nextPow2(minWidth);
    minHeight = nextPow2(minHeight);
    const key2 = (minWidth << 17) + (minHeight << 1);
    if (!this._canvasPool[key2]) {
      this._canvasPool[key2] = [];
    }
    let canvasAndContext = this._canvasPool[key2].pop();
    if (!canvasAndContext) {
      canvasAndContext = this._createCanvasAndContext(minWidth, minHeight);
    }
    return canvasAndContext;
  }
  /**
   * Place a render texture back into the pool.
   * @param canvasAndContext
   */
  returnCanvasAndContext(canvasAndContext) {
    const canvas = canvasAndContext.canvas;
    const { width, height } = canvas;
    const key2 = (width << 17) + (height << 1);
    canvasAndContext.context.resetTransform();
    canvasAndContext.context.clearRect(0, 0, width, height);
    this._canvasPool[key2].push(canvasAndContext);
  }
  clear() {
    this._canvasPool = {};
  }
}
const CanvasPool = new CanvasPoolClass();
GlobalResourceRegistry.register(CanvasPool);
const PRECISION = 1e5;
function getCanvasFillStyle(fillStyle, context2, textMetrics, padding = 0) {
  if (fillStyle.texture === Texture.WHITE && !fillStyle.fill) {
    return Color.shared.setValue(fillStyle.color).setAlpha(fillStyle.alpha ?? 1).toHexa();
  } else if (!fillStyle.fill) {
    const pattern = context2.createPattern(fillStyle.texture.source.resource, "repeat");
    const tempMatrix2 = fillStyle.matrix.copyTo(Matrix.shared);
    tempMatrix2.scale(fillStyle.texture.frame.width, fillStyle.texture.frame.height);
    pattern.setTransform(tempMatrix2);
    return pattern;
  } else if (fillStyle.fill instanceof FillPattern) {
    const fillPattern = fillStyle.fill;
    const pattern = context2.createPattern(fillPattern.texture.source.resource, "repeat");
    const tempMatrix2 = fillPattern.transform.copyTo(Matrix.shared);
    tempMatrix2.scale(
      fillPattern.texture.frame.width,
      fillPattern.texture.frame.height
    );
    pattern.setTransform(tempMatrix2);
    return pattern;
  } else if (fillStyle.fill instanceof FillGradient) {
    const fillGradient = fillStyle.fill;
    const isLinear = fillGradient.type === "linear";
    const isLocal = fillGradient.textureSpace === "local";
    let width = 1;
    let height = 1;
    if (isLocal && textMetrics) {
      width = textMetrics.width + padding;
      height = textMetrics.height + padding;
    }
    let gradient;
    let isNearlyVertical = false;
    if (isLinear) {
      const { start, end } = fillGradient;
      gradient = context2.createLinearGradient(
        start.x * width,
        start.y * height,
        end.x * width,
        end.y * height
      );
      isNearlyVertical = Math.abs(end.x - start.x) < Math.abs((end.y - start.y) * 0.1);
    } else {
      const { center, innerRadius, outerCenter, outerRadius } = fillGradient;
      gradient = context2.createRadialGradient(
        center.x * width,
        center.y * height,
        innerRadius * width,
        outerCenter.x * width,
        outerCenter.y * height,
        outerRadius * width
      );
    }
    if (isNearlyVertical && isLocal && textMetrics) {
      const ratio = textMetrics.lineHeight / height;
      for (let i2 = 0; i2 < textMetrics.lines.length; i2++) {
        const start = (i2 * textMetrics.lineHeight + padding / 2) / height;
        fillGradient.colorStops.forEach((stop) => {
          const globalStop = start + stop.offset * ratio;
          gradient.addColorStop(
            // fix to 5 decimal places to avoid floating point precision issues
            Math.floor(globalStop * PRECISION) / PRECISION,
            Color.shared.setValue(stop.color).toHex()
          );
        });
      }
    } else {
      fillGradient.colorStops.forEach((stop) => {
        gradient.addColorStop(stop.offset, Color.shared.setValue(stop.color).toHex());
      });
    }
    return gradient;
  }
  warn("FillStyle not recognised", fillStyle);
  return "red";
}
const _DynamicBitmapFont = class _DynamicBitmapFont2 extends AbstractBitmapFont {
  /**
   * @param options - The options for the dynamic bitmap font.
   */
  constructor(options) {
    super();
    this.resolution = 1;
    this.pages = [];
    this._padding = 0;
    this._measureCache = /* @__PURE__ */ Object.create(null);
    this._currentChars = [];
    this._currentX = 0;
    this._currentY = 0;
    this._currentMaxCharHeight = 0;
    this._currentPageIndex = -1;
    this._skipKerning = false;
    const dynamicOptions = { ..._DynamicBitmapFont2.defaultOptions, ...options };
    this._textureSize = dynamicOptions.textureSize;
    this._mipmap = dynamicOptions.mipmap;
    const style = dynamicOptions.style.clone();
    if (dynamicOptions.overrideFill) {
      style._fill.color = 16777215;
      style._fill.alpha = 1;
      style._fill.texture = Texture.WHITE;
      style._fill.fill = null;
    }
    this.applyFillAsTint = dynamicOptions.overrideFill;
    const requestedFontSize = style.fontSize;
    style.fontSize = this.baseMeasurementFontSize;
    const font = fontStringFromTextStyle(style);
    if (dynamicOptions.overrideSize) {
      if (style._stroke) {
        style._stroke.width *= this.baseRenderedFontSize / requestedFontSize;
      }
    } else {
      style.fontSize = this.baseRenderedFontSize = requestedFontSize;
    }
    this._style = style;
    this._skipKerning = dynamicOptions.skipKerning ?? false;
    this.resolution = dynamicOptions.resolution ?? 1;
    this._padding = dynamicOptions.padding ?? 4;
    if (dynamicOptions.textureStyle) {
      this._textureStyle = dynamicOptions.textureStyle instanceof TextureStyle ? dynamicOptions.textureStyle : new TextureStyle(dynamicOptions.textureStyle);
    }
    this.fontMetrics = CanvasTextMetrics.measureFont(font);
    this.lineHeight = style.lineHeight || this.fontMetrics.fontSize || style.fontSize;
  }
  ensureCharacters(chars) {
    var _a, _b;
    const charList = CanvasTextMetrics.graphemeSegmenter(chars).filter((char) => !this._currentChars.includes(char)).filter((char, index, self2) => self2.indexOf(char) === index);
    if (!charList.length)
      return;
    this._currentChars = [...this._currentChars, ...charList];
    let pageData;
    if (this._currentPageIndex === -1) {
      pageData = this._nextPage();
    } else {
      pageData = this.pages[this._currentPageIndex];
    }
    let { canvas, context: context2 } = pageData.canvasAndContext;
    let textureSource = pageData.texture.source;
    const style = this._style;
    let currentX = this._currentX;
    let currentY = this._currentY;
    let currentMaxCharHeight = this._currentMaxCharHeight;
    const fontScale = this.baseRenderedFontSize / this.baseMeasurementFontSize;
    const padding = this._padding * fontScale;
    let skipTexture = false;
    const maxTextureWidth = canvas.width / this.resolution;
    const maxTextureHeight = canvas.height / this.resolution;
    for (let i2 = 0; i2 < charList.length; i2++) {
      const char = charList[i2];
      const metrics = CanvasTextMetrics.measureText(char, style, canvas, false);
      metrics.lineHeight = metrics.height;
      const width = metrics.width * fontScale;
      const textureGlyphWidth = Math.ceil((style.fontStyle === "italic" ? 2 : 1) * width);
      const height = metrics.height * fontScale;
      const paddedWidth = textureGlyphWidth + padding * 2;
      const paddedHeight = height + padding * 2;
      skipTexture = false;
      if (char !== "\n" && char !== "\r" && char !== "	" && char !== " ") {
        skipTexture = true;
        currentMaxCharHeight = Math.ceil(Math.max(paddedHeight, currentMaxCharHeight));
      }
      if (currentX + paddedWidth > maxTextureWidth) {
        currentY += currentMaxCharHeight;
        currentMaxCharHeight = paddedHeight;
        currentX = 0;
        if (currentY + currentMaxCharHeight > maxTextureHeight) {
          textureSource.update();
          const pageData2 = this._nextPage();
          canvas = pageData2.canvasAndContext.canvas;
          context2 = pageData2.canvasAndContext.context;
          textureSource = pageData2.texture.source;
          currentX = 0;
          currentY = 0;
          currentMaxCharHeight = 0;
        }
      }
      const xAdvance = width / fontScale - (((_a = style.dropShadow) == null ? void 0 : _a.distance) ?? 0) - (((_b = style._stroke) == null ? void 0 : _b.width) ?? 0);
      this.chars[char] = {
        id: char.codePointAt(0),
        xOffset: -this._padding,
        yOffset: -this._padding,
        xAdvance,
        kerning: {}
      };
      if (skipTexture) {
        this._drawGlyph(
          context2,
          metrics,
          currentX + padding,
          currentY + padding,
          fontScale,
          style
        );
        const px = textureSource.width * fontScale;
        const py = textureSource.height * fontScale;
        const frame = new Rectangle(
          currentX / px * textureSource.width,
          currentY / py * textureSource.height,
          paddedWidth / px * textureSource.width,
          paddedHeight / py * textureSource.height
        );
        this.chars[char].texture = new Texture({
          source: textureSource,
          frame
        });
        currentX += Math.ceil(paddedWidth);
      }
    }
    textureSource.update();
    this._currentX = currentX;
    this._currentY = currentY;
    this._currentMaxCharHeight = currentMaxCharHeight;
    this._skipKerning && this._applyKerning(charList, context2);
  }
  /**
   * @deprecated since 8.0.0
   * The map of base page textures (i.e., sheets of glyphs).
   */
  get pageTextures() {
    deprecation(v8_0_0, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.");
    return this.pages;
  }
  _applyKerning(newChars, context2) {
    const measureCache = this._measureCache;
    for (let i2 = 0; i2 < newChars.length; i2++) {
      const first = newChars[i2];
      for (let j2 = 0; j2 < this._currentChars.length; j2++) {
        const second = this._currentChars[j2];
        let c1 = measureCache[first];
        if (!c1)
          c1 = measureCache[first] = context2.measureText(first).width;
        let c2 = measureCache[second];
        if (!c2)
          c2 = measureCache[second] = context2.measureText(second).width;
        let total = context2.measureText(first + second).width;
        let amount = total - (c1 + c2);
        if (amount) {
          this.chars[first].kerning[second] = amount;
        }
        total = context2.measureText(first + second).width;
        amount = total - (c1 + c2);
        if (amount) {
          this.chars[second].kerning[first] = amount;
        }
      }
    }
  }
  _nextPage() {
    this._currentPageIndex++;
    const textureResolution = this.resolution;
    const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(
      this._textureSize,
      this._textureSize,
      textureResolution
    );
    this._setupContext(canvasAndContext.context, this._style, textureResolution);
    const resolution2 = textureResolution * (this.baseRenderedFontSize / this.baseMeasurementFontSize);
    const texture = new Texture({
      source: new ImageSource({
        resource: canvasAndContext.canvas,
        resolution: resolution2,
        alphaMode: "premultiply-alpha-on-upload",
        autoGenerateMipmaps: this._mipmap
      })
    });
    if (this._textureStyle) {
      texture.source.style = this._textureStyle;
    }
    const pageData = {
      canvasAndContext,
      texture
    };
    this.pages[this._currentPageIndex] = pageData;
    return pageData;
  }
  // canvas style!
  _setupContext(context2, style, resolution2) {
    style.fontSize = this.baseRenderedFontSize;
    context2.scale(resolution2, resolution2);
    context2.font = fontStringFromTextStyle(style);
    style.fontSize = this.baseMeasurementFontSize;
    context2.textBaseline = style.textBaseline;
    const stroke = style._stroke;
    const strokeThickness = (stroke == null ? void 0 : stroke.width) ?? 0;
    if (stroke) {
      context2.lineWidth = strokeThickness;
      context2.lineJoin = stroke.join;
      context2.miterLimit = stroke.miterLimit;
      context2.strokeStyle = getCanvasFillStyle(stroke, context2);
    }
    if (style._fill) {
      context2.fillStyle = getCanvasFillStyle(style._fill, context2);
    }
    if (style.dropShadow) {
      const shadowOptions = style.dropShadow;
      const rgb = Color.shared.setValue(shadowOptions.color).toArray();
      const dropShadowBlur = shadowOptions.blur * resolution2;
      const dropShadowDistance = shadowOptions.distance * resolution2;
      context2.shadowColor = `rgba(${rgb[0] * 255},${rgb[1] * 255},${rgb[2] * 255},${shadowOptions.alpha})`;
      context2.shadowBlur = dropShadowBlur;
      context2.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;
      context2.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance;
    } else {
      context2.shadowColor = "black";
      context2.shadowBlur = 0;
      context2.shadowOffsetX = 0;
      context2.shadowOffsetY = 0;
    }
  }
  _drawGlyph(context2, metrics, x2, y2, fontScale, style) {
    const char = metrics.text;
    const fontProperties = metrics.fontProperties;
    const stroke = style._stroke;
    const strokeThickness = ((stroke == null ? void 0 : stroke.width) ?? 0) * fontScale;
    const tx = x2 + strokeThickness / 2;
    const ty = y2 - strokeThickness / 2;
    const descent = fontProperties.descent * fontScale;
    const lineHeight = metrics.lineHeight * fontScale;
    let removeShadow = false;
    if (style.stroke && strokeThickness) {
      removeShadow = true;
      context2.strokeText(char, tx, ty + lineHeight - descent);
    }
    const { shadowBlur, shadowOffsetX, shadowOffsetY } = context2;
    if (style._fill) {
      if (removeShadow) {
        context2.shadowBlur = 0;
        context2.shadowOffsetX = 0;
        context2.shadowOffsetY = 0;
      }
      context2.fillText(char, tx, ty + lineHeight - descent);
    }
    if (removeShadow) {
      context2.shadowBlur = shadowBlur;
      context2.shadowOffsetX = shadowOffsetX;
      context2.shadowOffsetY = shadowOffsetY;
    }
  }
  destroy() {
    super.destroy();
    for (let i2 = 0; i2 < this.pages.length; i2++) {
      const { canvasAndContext, texture } = this.pages[i2];
      CanvasPool.returnCanvasAndContext(canvasAndContext);
      texture.destroy(true);
    }
    this.pages = null;
  }
};
_DynamicBitmapFont.defaultOptions = {
  textureSize: 512,
  style: new TextStyle(),
  mipmap: true
};
let DynamicBitmapFont = _DynamicBitmapFont;
function getBitmapTextLayout(chars, style, font, trimEnd) {
  const layoutData = {
    width: 0,
    height: 0,
    offsetY: 0,
    scale: style.fontSize / font.baseMeasurementFontSize,
    lines: [{
      width: 0,
      charPositions: [],
      spaceWidth: 0,
      spacesIndex: [],
      chars: []
    }]
  };
  layoutData.offsetY = font.baseLineOffset;
  let currentLine = layoutData.lines[0];
  let previousChar = null;
  let firstWord = true;
  const currentWord = {
    width: 0,
    start: 0,
    index: 0,
    // use index to not modify the array as we use it a lot!
    positions: [],
    chars: []
  };
  const scale = font.baseMeasurementFontSize / style.fontSize;
  const adjustedLetterSpacing = style.letterSpacing * scale;
  const adjustedWordWrapWidth = style.wordWrapWidth * scale;
  const adjustedLineHeight = style.lineHeight ? style.lineHeight * scale : font.lineHeight;
  const breakWords = style.wordWrap && style.breakWords;
  const nextWord = (word) => {
    const start = currentLine.width;
    for (let j2 = 0; j2 < currentWord.index; j2++) {
      const position = word.positions[j2];
      currentLine.chars.push(word.chars[j2]);
      currentLine.charPositions.push(position + start);
    }
    currentLine.width += word.width;
    firstWord = false;
    currentWord.width = 0;
    currentWord.index = 0;
    currentWord.chars.length = 0;
  };
  const nextLine = () => {
    let index = currentLine.chars.length - 1;
    if (trimEnd) {
      let lastChar = currentLine.chars[index];
      while (lastChar === " ") {
        currentLine.width -= font.chars[lastChar].xAdvance;
        lastChar = currentLine.chars[--index];
      }
    }
    layoutData.width = Math.max(layoutData.width, currentLine.width);
    currentLine = {
      width: 0,
      charPositions: [],
      chars: [],
      spaceWidth: 0,
      spacesIndex: []
    };
    firstWord = true;
    layoutData.lines.push(currentLine);
    layoutData.height += adjustedLineHeight;
  };
  const checkIsOverflow = (lineWidth) => lineWidth - adjustedLetterSpacing > adjustedWordWrapWidth;
  for (let i2 = 0; i2 < chars.length + 1; i2++) {
    let char;
    const isEnd = i2 === chars.length;
    if (!isEnd) {
      char = chars[i2];
    }
    const charData = font.chars[char] || font.chars[" "];
    const isSpace = /(?:\s)/.test(char);
    const isWordBreak = isSpace || char === "\r" || char === "\n" || isEnd;
    if (isWordBreak) {
      const addWordToNextLine = !firstWord && style.wordWrap && checkIsOverflow(currentLine.width + currentWord.width);
      if (addWordToNextLine) {
        nextLine();
        nextWord(currentWord);
        if (!isEnd) {
          currentLine.charPositions.push(0);
        }
      } else {
        currentWord.start = currentLine.width;
        nextWord(currentWord);
        if (!isEnd) {
          currentLine.charPositions.push(0);
        }
      }
      if (char === "\r" || char === "\n") {
        nextLine();
      } else if (!isEnd) {
        const spaceWidth = charData.xAdvance + (charData.kerning[previousChar] || 0) + adjustedLetterSpacing;
        currentLine.width += spaceWidth;
        currentLine.spaceWidth = spaceWidth;
        currentLine.spacesIndex.push(currentLine.charPositions.length);
        currentLine.chars.push(char);
      }
    } else {
      const kerning = charData.kerning[previousChar] || 0;
      const nextCharWidth = charData.xAdvance + kerning + adjustedLetterSpacing;
      const addWordToNextLine = breakWords && checkIsOverflow(currentLine.width + currentWord.width + nextCharWidth);
      if (addWordToNextLine) {
        nextWord(currentWord);
        nextLine();
      }
      currentWord.positions[currentWord.index++] = currentWord.width + kerning;
      currentWord.chars.push(char);
      currentWord.width += nextCharWidth;
    }
    previousChar = char;
  }
  nextLine();
  if (style.align === "center") {
    alignCenter(layoutData);
  } else if (style.align === "right") {
    alignRight(layoutData);
  } else if (style.align === "justify") {
    alignJustify(layoutData);
  }
  return layoutData;
}
function alignCenter(measurementData) {
  for (let i2 = 0; i2 < measurementData.lines.length; i2++) {
    const line = measurementData.lines[i2];
    const offset = measurementData.width / 2 - line.width / 2;
    for (let j2 = 0; j2 < line.charPositions.length; j2++) {
      line.charPositions[j2] += offset;
    }
  }
}
function alignRight(measurementData) {
  for (let i2 = 0; i2 < measurementData.lines.length; i2++) {
    const line = measurementData.lines[i2];
    const offset = measurementData.width - line.width;
    for (let j2 = 0; j2 < line.charPositions.length; j2++) {
      line.charPositions[j2] += offset;
    }
  }
}
function alignJustify(measurementData) {
  const width = measurementData.width;
  for (let i2 = 0; i2 < measurementData.lines.length; i2++) {
    const line = measurementData.lines[i2];
    let indy = 0;
    let spaceIndex = line.spacesIndex[indy++];
    let offset = 0;
    const totalSpaces = line.spacesIndex.length;
    const newSpaceWidth = (width - line.width) / totalSpaces;
    const spaceWidth = newSpaceWidth;
    for (let j2 = 0; j2 < line.charPositions.length; j2++) {
      if (j2 === spaceIndex) {
        spaceIndex = line.spacesIndex[indy++];
        offset += spaceWidth;
      }
      line.charPositions[j2] += offset;
    }
  }
}
function resolveCharacters(chars) {
  if (chars === "") {
    return [];
  }
  if (typeof chars === "string") {
    chars = [chars];
  }
  const result = [];
  for (let i2 = 0, j2 = chars.length; i2 < j2; i2++) {
    const item = chars[i2];
    if (Array.isArray(item)) {
      if (item.length !== 2) {
        throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);
      }
      if (item[0].length === 0 || item[1].length === 0) {
        throw new Error("[BitmapFont]: Invalid character delimiter.");
      }
      const startCode = item[0].charCodeAt(0);
      const endCode = item[1].charCodeAt(0);
      if (endCode < startCode) {
        throw new Error("[BitmapFont]: Invalid character range.");
      }
      for (let i22 = startCode, j22 = endCode; i22 <= j22; i22++) {
        result.push(String.fromCharCode(i22));
      }
    } else {
      result.push(...Array.from(item));
    }
  }
  if (result.length === 0) {
    throw new Error("[BitmapFont]: Empty set when resolving characters.");
  }
  return result;
}
let fontCount = 0;
class BitmapFontManagerClass {
  constructor() {
    this.ALPHA = [["a", "z"], ["A", "Z"], " "];
    this.NUMERIC = [["0", "9"]];
    this.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "];
    this.ASCII = [[" ", "~"]];
    this.defaultOptions = {
      chars: this.ALPHANUMERIC,
      resolution: 1,
      padding: 4,
      skipKerning: false,
      textureStyle: null
    };
    this.measureCache = lru(1e3);
  }
  /**
   * Get a font for the specified text and style.
   * @param text - The text to get the font for
   * @param style - The style to use
   */
  getFont(text, style) {
    var _a;
    let fontFamilyKey = `${style.fontFamily}-bitmap`;
    let overrideFill = true;
    if (style._fill.fill && !style._stroke) {
      fontFamilyKey += style._fill.fill.styleKey;
      overrideFill = false;
    } else if (style._stroke || style.dropShadow) {
      fontFamilyKey = `${style.styleKey}-bitmap`;
      overrideFill = false;
    }
    if (!Cache.has(fontFamilyKey)) {
      const styleCopy = Object.create(style);
      styleCopy.lineHeight = 0;
      const fnt = new DynamicBitmapFont({
        style: styleCopy,
        overrideFill,
        overrideSize: true,
        ...this.defaultOptions
      });
      fontCount++;
      if (fontCount > 50) {
        warn("BitmapText", `You have dynamically created ${fontCount} bitmap fonts, this can be inefficient. Try pre installing your font styles using \`BitmapFont.install({name:"style1", style})\``);
      }
      fnt.once("destroy", () => {
        fontCount--;
        Cache.remove(fontFamilyKey);
      });
      Cache.set(
        fontFamilyKey,
        fnt
      );
    }
    const dynamicFont = Cache.get(fontFamilyKey);
    (_a = dynamicFont.ensureCharacters) == null ? void 0 : _a.call(dynamicFont, text);
    return dynamicFont;
  }
  /**
   * Get the layout of a text for the specified style.
   * @param text - The text to get the layout for
   * @param style - The style to use
   * @param trimEnd - Whether to ignore whitespaces at the end of each line
   */
  getLayout(text, style, trimEnd = true) {
    const bitmapFont = this.getFont(text, style);
    const id2 = `${text}-${style.styleKey}-${trimEnd}`;
    if (this.measureCache.has(id2)) {
      return this.measureCache.get(id2);
    }
    const segments = CanvasTextMetrics.graphemeSegmenter(text);
    const layoutData = getBitmapTextLayout(segments, style, bitmapFont, trimEnd);
    this.measureCache.set(id2, layoutData);
    return layoutData;
  }
  /**
   * Measure the text using the specified style.
   * @param text - The text to measure
   * @param style - The style to use
   * @param trimEnd - Whether to ignore whitespaces at the end of each line
   */
  measureText(text, style, trimEnd = true) {
    return this.getLayout(text, style, trimEnd);
  }
  // eslint-disable-next-line max-len
  install(...args) {
    var _a, _b, _c, _d;
    let options = args[0];
    if (typeof options === "string") {
      options = {
        name: options,
        style: args[1],
        chars: (_a = args[2]) == null ? void 0 : _a.chars,
        resolution: (_b = args[2]) == null ? void 0 : _b.resolution,
        padding: (_c = args[2]) == null ? void 0 : _c.padding,
        skipKerning: (_d = args[2]) == null ? void 0 : _d.skipKerning
      };
      deprecation(v8_0_0, "BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})");
    }
    const name2 = options == null ? void 0 : options.name;
    if (!name2) {
      throw new Error("[BitmapFontManager] Property `name` is required.");
    }
    options = { ...this.defaultOptions, ...options };
    const textStyle = options.style;
    const style = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle);
    const overrideFill = options.dynamicFill ?? this._canUseTintForStyle(style);
    const font = new DynamicBitmapFont({
      style,
      overrideFill,
      skipKerning: options.skipKerning,
      padding: options.padding,
      resolution: options.resolution,
      overrideSize: false,
      textureStyle: options.textureStyle
    });
    const flatChars = resolveCharacters(options.chars);
    font.ensureCharacters(flatChars.join(""));
    Cache.set(`${name2}-bitmap`, font);
    font.once("destroy", () => Cache.remove(`${name2}-bitmap`));
    return font;
  }
  /**
   * Uninstalls a bitmap font from the cache.
   * @param {string} name - The name of the bitmap font to uninstall.
   */
  uninstall(name2) {
    const cacheKey = `${name2}-bitmap`;
    const font = Cache.get(cacheKey);
    if (font) {
      font.destroy();
    }
  }
  /**
   * Determines if a style can use tinting instead of baking colors into the bitmap.
   * Tinting is more efficient as it allows reusing the same bitmap with different colors.
   * @param style - The text style to evaluate
   * @returns true if the style can use tinting, false if colors must be baked in
   * @private
   */
  _canUseTintForStyle(style) {
    return !style._stroke && (!style.dropShadow || style.dropShadow.color === 0) && !style._fill.fill && style._fill.color === 16777215;
  }
}
const BitmapFontManager = new BitmapFontManagerClass();
class BitmapFont extends AbstractBitmapFont {
  constructor(options, url) {
    super();
    const { textures, data } = options;
    Object.keys(data.pages).forEach((key2) => {
      const pageData = data.pages[parseInt(key2, 10)];
      const texture = textures[pageData.id];
      this.pages.push({ texture });
    });
    Object.keys(data.chars).forEach((key2) => {
      const charData = data.chars[key2];
      const {
        frame: textureFrame,
        source: textureSource,
        rotate: textureRotate
      } = textures[charData.page];
      const frame = groupD8.transformRectCoords(
        charData,
        textureFrame,
        textureRotate,
        new Rectangle()
      );
      const texture = new Texture({
        frame,
        orig: new Rectangle(0, 0, charData.width, charData.height),
        source: textureSource,
        rotate: textureRotate
      });
      this.chars[key2] = {
        id: key2.codePointAt(0),
        xOffset: charData.xOffset,
        yOffset: charData.yOffset,
        xAdvance: charData.xAdvance,
        kerning: charData.kerning ?? {},
        texture
      };
    });
    this.baseRenderedFontSize = data.fontSize;
    this.baseMeasurementFontSize = data.fontSize;
    this.fontMetrics = {
      ascent: 0,
      descent: 0,
      fontSize: data.fontSize
    };
    this.baseLineOffset = data.baseLineOffset;
    this.lineHeight = data.lineHeight;
    this.fontFamily = data.fontFamily;
    this.distanceField = data.distanceField ?? {
      type: "none",
      range: 0
    };
    this.url = url;
  }
  /** Destroys the BitmapFont object. */
  destroy() {
    super.destroy();
    for (let i2 = 0; i2 < this.pages.length; i2++) {
      const { texture } = this.pages[i2];
      texture.destroy(true);
    }
    this.pages = null;
  }
  /**
   * Generates and installs a bitmap font with the specified options.
   * The font will be cached and available for use in BitmapText objects.
   * @param options - Setup options for font generation
   * @returns Installed font instance
   * @example
   * ```ts
   * // Install a basic font
   * BitmapFont.install({
   *     name: 'Title',
   *     style: {
   *         fontFamily: 'Arial',
   *         fontSize: 32,
   *         fill: '#ffffff'
   *     }
   * });
   *
   * // Install with advanced options
   * BitmapFont.install({
   *     name: 'Custom',
   *     style: {
   *         fontFamily: 'Arial',
   *         fontSize: 24,
   *         fill: '#00ff00',
   *         stroke: { color: '#000000', width: 2 }
   *     },
   *     chars: [['a', 'z'], ['A', 'Z'], ['0', '9']],
   *     resolution: 2,
   *     padding: 4,
   *     textureStyle: {
   *         scaleMode: 'nearest'
   *     }
   * });
   * ```
   */
  static install(options) {
    BitmapFontManager.install(options);
  }
  /**
   * Uninstalls a bitmap font from the cache.
   * This frees up memory and resources associated with the font.
   * @param name - The name of the bitmap font to uninstall
   * @example
   * ```ts
   * // Remove a font when it's no longer needed
   * BitmapFont.uninstall('MyCustomFont');
   *
   * // Clear multiple fonts
   * ['Title', 'Heading', 'Body'].forEach(BitmapFont.uninstall);
   * ```
   */
  static uninstall(name2) {
    BitmapFontManager.uninstall(name2);
  }
}
const bitmapFontTextParser = {
  test(data) {
    return typeof data === "string" && data.startsWith("info face=");
  },
  parse(txt) {
    const items = txt.match(/^[a-z]+\s+.+$/gm);
    const rawData = {
      info: [],
      common: [],
      page: [],
      char: [],
      chars: [],
      kerning: [],
      kernings: [],
      distanceField: []
    };
    for (const i2 in items) {
      const name2 = items[i2].match(/^[a-z]+/gm)[0];
      const attributeList = items[i2].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm);
      const itemData = {};
      for (const i22 in attributeList) {
        const split = attributeList[i22].split("=");
        const key2 = split[0];
        const strValue = split[1].replace(/"/gm, "");
        const floatValue = parseFloat(strValue);
        const value2 = isNaN(floatValue) ? strValue : floatValue;
        itemData[key2] = value2;
      }
      rawData[name2].push(itemData);
    }
    const font = {
      chars: {},
      pages: [],
      lineHeight: 0,
      fontSize: 0,
      fontFamily: "",
      distanceField: null,
      baseLineOffset: 0
    };
    const [info] = rawData.info;
    const [common2] = rawData.common;
    const [distanceField] = rawData.distanceField ?? [];
    if (distanceField) {
      font.distanceField = {
        range: parseInt(distanceField.distanceRange, 10),
        type: distanceField.fieldType
      };
    }
    font.fontSize = parseInt(info.size, 10);
    font.fontFamily = info.face;
    font.lineHeight = parseInt(common2.lineHeight, 10);
    const page = rawData.page;
    for (let i2 = 0; i2 < page.length; i2++) {
      font.pages.push({
        id: parseInt(page[i2].id, 10) || 0,
        file: page[i2].file
      });
    }
    const map = {};
    font.baseLineOffset = font.lineHeight - parseInt(common2.base, 10);
    const char = rawData.char;
    for (let i2 = 0; i2 < char.length; i2++) {
      const charNode = char[i2];
      const id2 = parseInt(charNode.id, 10);
      let letter = charNode.letter ?? charNode.char ?? String.fromCharCode(id2);
      if (letter === "space")
        letter = " ";
      map[id2] = letter;
      font.chars[letter] = {
        id: id2,
        // texture deets..
        page: parseInt(charNode.page, 10) || 0,
        x: parseInt(charNode.x, 10),
        y: parseInt(charNode.y, 10),
        width: parseInt(charNode.width, 10),
        height: parseInt(charNode.height, 10),
        xOffset: parseInt(charNode.xoffset, 10),
        yOffset: parseInt(charNode.yoffset, 10),
        xAdvance: parseInt(charNode.xadvance, 10),
        kerning: {}
      };
    }
    const kerning = rawData.kerning || [];
    for (let i2 = 0; i2 < kerning.length; i2++) {
      const first = parseInt(kerning[i2].first, 10);
      const second = parseInt(kerning[i2].second, 10);
      const amount = parseInt(kerning[i2].amount, 10);
      font.chars[map[second]].kerning[map[first]] = amount;
    }
    return font;
  }
};
const bitmapFontXMLParser = {
  test(data) {
    const xml = data;
    return typeof xml !== "string" && "getElementsByTagName" in xml && xml.getElementsByTagName("page").length && xml.getElementsByTagName("info")[0].getAttribute("face") !== null;
  },
  parse(xml) {
    const data = {
      chars: {},
      pages: [],
      lineHeight: 0,
      fontSize: 0,
      fontFamily: "",
      distanceField: null,
      baseLineOffset: 0
    };
    const info = xml.getElementsByTagName("info")[0];
    const common2 = xml.getElementsByTagName("common")[0];
    const distanceField = xml.getElementsByTagName("distanceField")[0];
    if (distanceField) {
      data.distanceField = {
        type: distanceField.getAttribute("fieldType"),
        range: parseInt(distanceField.getAttribute("distanceRange"), 10)
      };
    }
    const page = xml.getElementsByTagName("page");
    const char = xml.getElementsByTagName("char");
    const kerning = xml.getElementsByTagName("kerning");
    data.fontSize = parseInt(info.getAttribute("size"), 10);
    data.fontFamily = info.getAttribute("face");
    data.lineHeight = parseInt(common2.getAttribute("lineHeight"), 10);
    for (let i2 = 0; i2 < page.length; i2++) {
      data.pages.push({
        id: parseInt(page[i2].getAttribute("id"), 10) || 0,
        file: page[i2].getAttribute("file")
      });
    }
    const map = {};
    data.baseLineOffset = data.lineHeight - parseInt(common2.getAttribute("base"), 10);
    for (let i2 = 0; i2 < char.length; i2++) {
      const charNode = char[i2];
      const id2 = parseInt(charNode.getAttribute("id"), 10);
      let letter = charNode.getAttribute("letter") ?? charNode.getAttribute("char") ?? String.fromCharCode(id2);
      if (letter === "space")
        letter = " ";
      map[id2] = letter;
      data.chars[letter] = {
        id: id2,
        // texture deets..
        page: parseInt(charNode.getAttribute("page"), 10) || 0,
        x: parseInt(charNode.getAttribute("x"), 10),
        y: parseInt(charNode.getAttribute("y"), 10),
        width: parseInt(charNode.getAttribute("width"), 10),
        height: parseInt(charNode.getAttribute("height"), 10),
        // render deets..
        xOffset: parseInt(charNode.getAttribute("xoffset"), 10),
        yOffset: parseInt(charNode.getAttribute("yoffset"), 10),
        // + baseLineOffset,
        xAdvance: parseInt(charNode.getAttribute("xadvance"), 10),
        kerning: {}
      };
    }
    for (let i2 = 0; i2 < kerning.length; i2++) {
      const first = parseInt(kerning[i2].getAttribute("first"), 10);
      const second = parseInt(kerning[i2].getAttribute("second"), 10);
      const amount = parseInt(kerning[i2].getAttribute("amount"), 10);
      data.chars[map[second]].kerning[map[first]] = amount;
    }
    return data;
  }
};
const bitmapFontXMLStringParser = {
  test(data) {
    if (typeof data === "string" && data.match(/<font(\s|>)/)) {
      return bitmapFontXMLParser.test(DOMAdapter.get().parseXML(data));
    }
    return false;
  },
  parse(data) {
    return bitmapFontXMLParser.parse(DOMAdapter.get().parseXML(data));
  }
};
const validExtensions = [".xml", ".fnt"];
const bitmapFontCachePlugin = {
  extension: {
    type: ExtensionType.CacheParser,
    name: "cacheBitmapFont"
  },
  test: (asset) => asset instanceof BitmapFont,
  getCacheableAssets(keys, asset) {
    const out2 = {};
    keys.forEach((key2) => {
      out2[key2] = asset;
      out2[`${key2}-bitmap`] = asset;
    });
    out2[`${asset.fontFamily}-bitmap`] = asset;
    return out2;
  }
};
const loadBitmapFont = {
  extension: {
    type: ExtensionType.LoadParser,
    priority: LoaderParserPriority.Normal
  },
  /** used for deprecation purposes */
  name: "loadBitmapFont",
  id: "bitmap-font",
  test(url) {
    return validExtensions.includes(path.extname(url).toLowerCase());
  },
  async testParse(data) {
    return bitmapFontTextParser.test(data) || bitmapFontXMLStringParser.test(data);
  },
  async parse(asset, data, loader) {
    const bitmapFontData = bitmapFontTextParser.test(asset) ? bitmapFontTextParser.parse(asset) : bitmapFontXMLStringParser.parse(asset);
    const { src } = data;
    const { pages } = bitmapFontData;
    const textureUrls = [];
    const textureOptions = bitmapFontData.distanceField ? {
      scaleMode: "linear",
      alphaMode: "premultiply-alpha-on-upload",
      autoGenerateMipmaps: false,
      resolution: 1
    } : {};
    for (let i2 = 0; i2 < pages.length; ++i2) {
      const pageFile = pages[i2].file;
      let imagePath = path.join(path.dirname(src), pageFile);
      imagePath = copySearchParams(imagePath, src);
      textureUrls.push({
        src: imagePath,
        data: textureOptions
      });
    }
    const loadedTextures = await loader.load(textureUrls);
    const textures = textureUrls.map((url) => loadedTextures[url.src]);
    const bitmapFont = new BitmapFont({
      data: bitmapFontData,
      textures
    }, src);
    return bitmapFont;
  },
  async load(url, _options) {
    const response = await DOMAdapter.get().fetch(url);
    return await response.text();
  },
  async unload(bitmapFont, _resolvedAsset, loader) {
    await Promise.all(bitmapFont.pages.map((page) => loader.unload(page.texture.source._sourceOrigin)));
    bitmapFont.destroy();
  }
};
class BackgroundLoader {
  /**
   * @param loader
   * @param verbose - should the loader log to the console
   */
  constructor(loader, verbose = false) {
    this._loader = loader;
    this._assetList = [];
    this._isLoading = false;
    this._maxConcurrent = 1;
    this.verbose = verbose;
  }
  /**
   * Adds assets to the background loading queue. Assets are loaded one at a time to minimize
   * performance impact.
   * @param assetUrls - Array of resolved assets to load in the background
   * @example
   * ```ts
   * // Add assets to background load queue
   * backgroundLoader.add([
   *     { src: 'images/level1/bg.png' },
   *     { src: 'images/level1/characters.json' }
   * ]);
   *
   * // Assets will load sequentially in the background
   * // The loader automatically pauses when high-priority loads occur
   * // e.g. Assets.load() is called
   * ```
   * @remarks
   * - Assets are loaded one at a time to minimize performance impact
   * - Loading automatically pauses when Assets.load() is called
   * - No progress tracking is available for background loading
   * - Assets are cached as they complete loading
   * @internal
   */
  add(assetUrls) {
    assetUrls.forEach((a2) => {
      this._assetList.push(a2);
    });
    if (this.verbose) {
      console.log("[BackgroundLoader] assets: ", this._assetList);
    }
    if (this._isActive && !this._isLoading) {
      void this._next();
    }
  }
  /**
   * Loads the next set of assets. Will try to load as many assets as it can at the same time.
   *
   * The max assets it will try to load at one time will be 4.
   */
  async _next() {
    if (this._assetList.length && this._isActive) {
      this._isLoading = true;
      const toLoad = [];
      const toLoadAmount = Math.min(this._assetList.length, this._maxConcurrent);
      for (let i2 = 0; i2 < toLoadAmount; i2++) {
        toLoad.push(this._assetList.pop());
      }
      await this._loader.load(toLoad);
      this._isLoading = false;
      void this._next();
    }
  }
  /**
   * Controls the active state of the background loader. When active, the loader will
   * continue processing its queue. When inactive, loading is paused.
   * @returns Whether the background loader is currently active
   * @example
   * ```ts
   * // Pause background loading
   * backgroundLoader.active = false;
   *
   * // Resume background loading
   * backgroundLoader.active = true;
   *
   * // Check current state
   * console.log(backgroundLoader.active); // true/false
   *
   * // Common use case: Pause during intensive operations
   * backgroundLoader.active = false;  // Pause background loading
   * ... // Perform high-priority tasks
   * backgroundLoader.active = true;   // Resume background loading
   * ```
   * @remarks
   * - Setting to true resumes loading immediately
   * - Setting to false pauses after current asset completes
   * - Background loading is automatically paused during `Assets.load()`
   * - Assets already being loaded will complete even when set to false
   */
  get active() {
    return this._isActive;
  }
  set active(value2) {
    if (this._isActive === value2)
      return;
    this._isActive = value2;
    if (value2 && !this._isLoading) {
      void this._next();
    }
  }
}
const cacheTextureArray = {
  extension: {
    type: ExtensionType.CacheParser,
    name: "cacheTextureArray"
  },
  test: (asset) => Array.isArray(asset) && asset.every((t2) => t2 instanceof Texture),
  getCacheableAssets: (keys, asset) => {
    const out2 = {};
    keys.forEach((key2) => {
      asset.forEach((item, i2) => {
        out2[key2 + (i2 === 0 ? "" : i2 + 1)] = item;
      });
    });
    return out2;
  }
};
async function testImageFormat(imageData) {
  if ("Image" in globalThis) {
    return new Promise((resolve) => {
      const image = new Image();
      image.onload = () => {
        resolve(true);
      };
      image.onerror = () => {
        resolve(false);
      };
      image.src = imageData;
    });
  }
  if ("createImageBitmap" in globalThis && "fetch" in globalThis) {
    try {
      const blob = await (await fetch(imageData)).blob();
      await createImageBitmap(blob);
    } catch (_e) {
      return false;
    }
    return true;
  }
  return false;
}
const detectAvif = {
  extension: {
    type: ExtensionType.DetectionParser,
    priority: 1
  },
  test: async () => testImageFormat(
    // eslint-disable-next-line max-len
    "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A="
  ),
  add: async (formats) => [...formats, "avif"],
  remove: async (formats) => formats.filter((f2) => f2 !== "avif")
};
const imageFormats = ["png", "jpg", "jpeg"];
const detectDefaults = {
  extension: {
    type: ExtensionType.DetectionParser,
    priority: -1
  },
  test: () => Promise.resolve(true),
  add: async (formats) => [...formats, ...imageFormats],
  remove: async (formats) => formats.filter((f2) => !imageFormats.includes(f2))
};
const inWorker = "WorkerGlobalScope" in globalThis && globalThis instanceof globalThis.WorkerGlobalScope;
function testVideoFormat(mimeType) {
  if (inWorker) {
    return false;
  }
  const video = document.createElement("video");
  return video.canPlayType(mimeType) !== "";
}
const detectMp4 = {
  extension: {
    type: ExtensionType.DetectionParser,
    priority: 0
  },
  test: async () => testVideoFormat("video/mp4"),
  add: async (formats) => [...formats, "mp4", "m4v"],
  remove: async (formats) => formats.filter((f2) => f2 !== "mp4" && f2 !== "m4v")
};
const detectOgv = {
  extension: {
    type: ExtensionType.DetectionParser,
    priority: 0
  },
  test: async () => testVideoFormat("video/ogg"),
  add: async (formats) => [...formats, "ogv"],
  remove: async (formats) => formats.filter((f2) => f2 !== "ogv")
};
const detectWebm = {
  extension: {
    type: ExtensionType.DetectionParser,
    priority: 0
  },
  test: async () => testVideoFormat("video/webm"),
  add: async (formats) => [...formats, "webm"],
  remove: async (formats) => formats.filter((f2) => f2 !== "webm")
};
const detectWebp = {
  extension: {
    type: ExtensionType.DetectionParser,
    priority: 0
  },
  test: async () => testImageFormat(
    "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA="
  ),
  add: async (formats) => [...formats, "webp"],
  remove: async (formats) => formats.filter((f2) => f2 !== "webp")
};
const _Loader = class _Loader2 {
  constructor() {
    this.loadOptions = { ..._Loader2.defaultOptions };
    this._parsers = [];
    this._parsersValidated = false;
    this.parsers = new Proxy(this._parsers, {
      set: (target, key2, value2) => {
        this._parsersValidated = false;
        target[key2] = value2;
        return true;
      }
    });
    this.promiseCache = {};
  }
  /** function used for testing */
  reset() {
    this._parsersValidated = false;
    this.promiseCache = {};
  }
  /**
   * Used internally to generate a promise for the asset to be loaded.
   * @param url - The URL to be loaded
   * @param data - any custom additional information relevant to the asset being loaded
   * @returns - a promise that will resolve to an Asset for example a Texture of a JSON object
   */
  _getLoadPromiseAndParser(url, data) {
    const result = {
      promise: null,
      parser: null
    };
    result.promise = (async () => {
      var _a, _b;
      let asset = null;
      let parser = null;
      if (data.parser || data.loadParser) {
        parser = this._parserHash[data.parser || data.loadParser];
        if (data.loadParser) {
          warn(
            `[Assets] "loadParser" is deprecated, use "parser" instead for ${url}`
          );
        }
        if (!parser) {
          warn(
            `[Assets] specified load parser "${data.parser || data.loadParser}" not found while loading ${url}`
          );
        }
      }
      if (!parser) {
        for (let i2 = 0; i2 < this.parsers.length; i2++) {
          const parserX = this.parsers[i2];
          if (parserX.load && ((_a = parserX.test) == null ? void 0 : _a.call(parserX, url, data, this))) {
            parser = parserX;
            break;
          }
        }
        if (!parser) {
          warn(`[Assets] ${url} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`);
          return null;
        }
      }
      asset = await parser.load(url, data, this);
      result.parser = parser;
      for (let i2 = 0; i2 < this.parsers.length; i2++) {
        const parser2 = this.parsers[i2];
        if (parser2.parse) {
          if (parser2.parse && await ((_b = parser2.testParse) == null ? void 0 : _b.call(parser2, asset, data, this))) {
            asset = await parser2.parse(asset, data, this) || asset;
            result.parser = parser2;
          }
        }
      }
      return asset;
    })();
    return result;
  }
  async load(assetsToLoadIn, onProgressOrOptions) {
    if (!this._parsersValidated) {
      this._validateParsers();
    }
    const options = typeof onProgressOrOptions === "function" ? { ..._Loader2.defaultOptions, ...this.loadOptions, onProgress: onProgressOrOptions } : { ..._Loader2.defaultOptions, ...this.loadOptions, ...onProgressOrOptions || {} };
    const { onProgress, onError, strategy, retryCount, retryDelay } = options;
    let count2 = 0;
    const assets = {};
    const singleAsset = isSingleItem(assetsToLoadIn);
    const assetsToLoad = convertToList(assetsToLoadIn, (item) => ({
      alias: [item],
      src: item,
      data: {}
    }));
    const total = assetsToLoad.reduce((sum, asset) => sum + (asset.progressSize || 1), 0);
    const promises = assetsToLoad.map(async (asset) => {
      const url = path.toAbsolute(asset.src);
      if (assets[asset.src])
        return;
      await this._loadAssetWithRetry(url, asset, { onProgress, onError, strategy, retryCount, retryDelay }, assets);
      count2 += asset.progressSize || 1;
      if (onProgress)
        onProgress(count2 / total);
    });
    await Promise.all(promises);
    return singleAsset ? assets[assetsToLoad[0].src] : assets;
  }
  /**
   * Unloads one or more assets. Any unloaded assets will be destroyed, freeing up memory for your app.
   * The parser that created the asset, will be the one that unloads it.
   * @example
   * // Single asset:
   * const asset = await Loader.load('cool.png');
   *
   * await Loader.unload('cool.png');
   *
   * console.log(asset.destroyed); // true
   * @param assetsToUnloadIn - urls that you want to unload, or a single one!
   */
  async unload(assetsToUnloadIn) {
    const assetsToUnload = convertToList(assetsToUnloadIn, (item) => ({
      alias: [item],
      src: item
    }));
    const promises = assetsToUnload.map(async (asset) => {
      var _a, _b;
      const url = path.toAbsolute(asset.src);
      const loadPromise = this.promiseCache[url];
      if (loadPromise) {
        const loadedAsset = await loadPromise.promise;
        delete this.promiseCache[url];
        await ((_b = (_a = loadPromise.parser) == null ? void 0 : _a.unload) == null ? void 0 : _b.call(_a, loadedAsset, asset, this));
      }
    });
    await Promise.all(promises);
  }
  /** validates our parsers, right now it only checks for name conflicts but we can add more here as required! */
  _validateParsers() {
    this._parsersValidated = true;
    this._parserHash = this._parsers.filter((parser) => parser.name || parser.id).reduce((hash, parser) => {
      if (!parser.name && !parser.id) {
        warn(`[Assets] parser should have an id`);
      } else if (hash[parser.name] || hash[parser.id]) {
        warn(`[Assets] parser id conflict "${parser.id}"`);
      }
      hash[parser.name] = parser;
      if (parser.id)
        hash[parser.id] = parser;
      return hash;
    }, {});
  }
  async _loadAssetWithRetry(url, asset, options, assets) {
    let attempt = 0;
    const { onError, strategy, retryCount, retryDelay } = options;
    const wait = (ms) => new Promise((r2) => setTimeout(r2, ms));
    while (true) {
      try {
        if (!this.promiseCache[url]) {
          this.promiseCache[url] = this._getLoadPromiseAndParser(url, asset);
        }
        assets[asset.src] = await this.promiseCache[url].promise;
        return;
      } catch (e2) {
        delete this.promiseCache[url];
        delete assets[asset.src];
        attempt++;
        const isLast = strategy !== "retry" || attempt > retryCount;
        if (strategy === "retry" && !isLast) {
          if (onError)
            onError(e2, asset);
          await wait(retryDelay);
          continue;
        }
        if (strategy === "skip") {
          if (onError)
            onError(e2, asset);
          return;
        }
        if (onError)
          onError(e2, asset);
        throw new Error(`[Loader.load] Failed to load ${url}.
${e2}`);
      }
    }
  }
};
_Loader.defaultOptions = {
  onProgress: void 0,
  onError: void 0,
  strategy: "throw",
  retryCount: 3,
  retryDelay: 250
};
let Loader = _Loader;
function checkDataUrl(url, mimes) {
  if (Array.isArray(mimes)) {
    for (const mime of mimes) {
      if (url.startsWith(`data:${mime}`))
        return true;
    }
    return false;
  }
  return url.startsWith(`data:${mimes}`);
}
function checkExtension(url, extension) {
  const tempURL = url.split("?")[0];
  const ext = path.extname(tempURL).toLowerCase();
  if (Array.isArray(extension)) {
    return extension.includes(ext);
  }
  return ext === extension;
}
const validJSONExtension = ".json";
const validJSONMIME = "application/json";
const loadJson = {
  extension: {
    type: ExtensionType.LoadParser,
    priority: LoaderParserPriority.Low
  },
  /** used for deprecation purposes */
  name: "loadJson",
  id: "json",
  test(url) {
    return checkDataUrl(url, validJSONMIME) || checkExtension(url, validJSONExtension);
  },
  async load(url) {
    const response = await DOMAdapter.get().fetch(url);
    const json = await response.json();
    return json;
  }
};
const validTXTExtension = ".txt";
const validTXTMIME = "text/plain";
const loadTxt = {
  /** used for deprecation purposes */
  name: "loadTxt",
  id: "text",
  extension: {
    type: ExtensionType.LoadParser,
    priority: LoaderParserPriority.Low,
    name: "loadTxt"
  },
  test(url) {
    return checkDataUrl(url, validTXTMIME) || checkExtension(url, validTXTExtension);
  },
  async load(url) {
    const response = await DOMAdapter.get().fetch(url);
    const txt = await response.text();
    return txt;
  }
};
const validWeights = [
  "normal",
  "bold",
  "100",
  "200",
  "300",
  "400",
  "500",
  "600",
  "700",
  "800",
  "900"
];
const validFontExtensions = [".ttf", ".otf", ".woff", ".woff2"];
const validFontMIMEs = [
  "font/ttf",
  "font/otf",
  "font/woff",
  "font/woff2"
];
const CSS_IDENT_TOKEN_REGEX = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;
function getFontFamilyName(url) {
  const ext = path.extname(url);
  const name2 = path.basename(url, ext);
  const nameWithSpaces = name2.replace(/(-|_)/g, " ");
  const nameTokens = nameWithSpaces.toLowerCase().split(" ").map((word) => word.charAt(0).toUpperCase() + word.slice(1));
  let valid = nameTokens.length > 0;
  for (const token of nameTokens) {
    if (!token.match(CSS_IDENT_TOKEN_REGEX)) {
      valid = false;
      break;
    }
  }
  let fontFamilyName = nameTokens.join(" ");
  if (!valid) {
    fontFamilyName = `"${fontFamilyName.replace(/[\\"]/g, "\\$&")}"`;
  }
  return fontFamilyName;
}
const validURICharactersRegex = /^[0-9A-Za-z%:/?#\[\]@!\$&'()\*\+,;=\-._~]*$/;
function encodeURIWhenNeeded(uri) {
  if (validURICharactersRegex.test(uri)) {
    return uri;
  }
  return encodeURI(uri);
}
const loadWebFont = {
  extension: {
    type: ExtensionType.LoadParser,
    priority: LoaderParserPriority.Low
  },
  /** used for deprecation purposes */
  name: "loadWebFont",
  id: "web-font",
  test(url) {
    return checkDataUrl(url, validFontMIMEs) || checkExtension(url, validFontExtensions);
  },
  async load(url, options) {
    var _a, _b, _c;
    const fonts = DOMAdapter.get().getFontFaceSet();
    if (fonts) {
      const fontFaces = [];
      const name2 = ((_a = options.data) == null ? void 0 : _a.family) ?? getFontFamilyName(url);
      const weights = ((_c = (_b = options.data) == null ? void 0 : _b.weights) == null ? void 0 : _c.filter((weight2) => validWeights.includes(weight2))) ?? ["normal"];
      const data = options.data ?? {};
      for (let i2 = 0; i2 < weights.length; i2++) {
        const weight2 = weights[i2];
        const font = new FontFace(name2, `url(${encodeURIWhenNeeded(url)})`, {
          ...data,
          weight: weight2
        });
        await font.load();
        fonts.add(font);
        fontFaces.push(font);
      }
      if (Cache.has(`${name2}-and-url`)) {
        const cached = Cache.get(`${name2}-and-url`);
        cached.entries.push({ url, faces: fontFaces });
      } else {
        Cache.set(`${name2}-and-url`, {
          entries: [{ url, faces: fontFaces }]
        });
      }
      return fontFaces.length === 1 ? fontFaces[0] : fontFaces;
    }
    warn("[loadWebFont] FontFace API is not supported. Skipping loading font");
    return null;
  },
  unload(font) {
    const fonts = Array.isArray(font) ? font : [font];
    const fontFamily = fonts[0].family;
    const cached = Cache.get(`${fontFamily}-and-url`);
    const entry = cached.entries.find((f2) => f2.faces.some((t2) => fonts.indexOf(t2) !== -1));
    entry.faces = entry.faces.filter((f2) => fonts.indexOf(f2) === -1);
    if (entry.faces.length === 0) {
      cached.entries = cached.entries.filter((f2) => f2 !== entry);
    }
    fonts.forEach((t2) => {
      DOMAdapter.get().getFontFaceSet().delete(t2);
    });
    if (cached.entries.length === 0) {
      Cache.remove(`${fontFamily}-and-url`);
    }
  }
};
function getResolutionOfUrl(url, defaultValue = 1) {
  var _a;
  const resolution2 = (_a = Resolver.RETINA_PREFIX) == null ? void 0 : _a.exec(url);
  if (resolution2) {
    return parseFloat(resolution2[1]);
  }
  return defaultValue;
}
function createTexture(source2, loader, url) {
  source2.label = url;
  source2._sourceOrigin = url;
  const texture = new Texture({
    source: source2,
    label: url
  });
  const unload = () => {
    delete loader.promiseCache[url];
    if (Cache.has(url)) {
      Cache.remove(url);
    }
  };
  texture.source.once("destroy", () => {
    if (loader.promiseCache[url]) {
      warn("[Assets] A TextureSource managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the TextureSource.");
      unload();
    }
  });
  texture.once("destroy", () => {
    if (!source2.destroyed) {
      warn("[Assets] A Texture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the Texture.");
      unload();
    }
  });
  return texture;
}
const validSVGExtension = ".svg";
const validSVGMIME = "image/svg+xml";
const loadSvg = {
  extension: {
    type: ExtensionType.LoadParser,
    priority: LoaderParserPriority.Low,
    name: "loadSVG"
  },
  /** used for deprecation purposes */
  name: "loadSVG",
  id: "svg",
  config: {
    crossOrigin: "anonymous",
    parseAsGraphicsContext: false
  },
  test(url) {
    return checkDataUrl(url, validSVGMIME) || checkExtension(url, validSVGExtension);
  },
  async load(url, asset, loader) {
    var _a;
    if (((_a = asset.data) == null ? void 0 : _a.parseAsGraphicsContext) ?? this.config.parseAsGraphicsContext) {
      return loadAsGraphics(url);
    }
    return loadAsTexture(url, asset, loader, this.config.crossOrigin);
  },
  unload(asset) {
    asset.destroy(true);
  }
};
async function loadAsTexture(url, asset, loader, crossOrigin2) {
  var _a, _b, _c;
  const response = await DOMAdapter.get().fetch(url);
  const image = DOMAdapter.get().createImage();
  image.src = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(await response.text())}`;
  image.crossOrigin = crossOrigin2;
  await image.decode();
  const width = ((_a = asset.data) == null ? void 0 : _a.width) ?? image.width;
  const height = ((_b = asset.data) == null ? void 0 : _b.height) ?? image.height;
  const resolution2 = ((_c = asset.data) == null ? void 0 : _c.resolution) || getResolutionOfUrl(url);
  const canvasWidth = Math.ceil(width * resolution2);
  const canvasHeight = Math.ceil(height * resolution2);
  const canvas = DOMAdapter.get().createCanvas(canvasWidth, canvasHeight);
  const context2 = canvas.getContext("2d");
  context2.imageSmoothingEnabled = true;
  context2.imageSmoothingQuality = "high";
  context2.drawImage(image, 0, 0, width * resolution2, height * resolution2);
  const { parseAsGraphicsContext: _p, ...rest } = asset.data ?? {};
  const base = new ImageSource({
    resource: canvas,
    alphaMode: "premultiply-alpha-on-upload",
    resolution: resolution2,
    ...rest
  });
  return createTexture(base, loader, url);
}
async function loadAsGraphics(url) {
  const response = await DOMAdapter.get().fetch(url);
  const svgSource = await response.text();
  const context2 = new GraphicsContext();
  context2.svg(svgSource);
  return context2;
}
const WORKER_CODE$1 = `(function () {
    'use strict';

    const WHITE_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=";
    async function checkImageBitmap() {
      try {
        if (typeof createImageBitmap !== "function")
          return false;
        const response = await fetch(WHITE_PNG);
        const imageBlob = await response.blob();
        const imageBitmap = await createImageBitmap(imageBlob);
        return imageBitmap.width === 1 && imageBitmap.height === 1;
      } catch (_e) {
        return false;
      }
    }
    void checkImageBitmap().then((result) => {
      self.postMessage(result);
    });

})();
`;
let WORKER_URL$1 = null;
let WorkerInstance$1 = class WorkerInstance {
  constructor() {
    if (!WORKER_URL$1) {
      WORKER_URL$1 = URL.createObjectURL(new Blob([WORKER_CODE$1], { type: "application/javascript" }));
    }
    this.worker = new Worker(WORKER_URL$1);
  }
};
WorkerInstance$1.revokeObjectURL = function revokeObjectURL() {
  if (WORKER_URL$1) {
    URL.revokeObjectURL(WORKER_URL$1);
    WORKER_URL$1 = null;
  }
};
const WORKER_CODE = '(function () {\n    \'use strict\';\n\n    async function loadImageBitmap(url, alphaMode) {\n      const response = await fetch(url);\n      if (!response.ok) {\n        throw new Error(`[WorkerManager.loadImageBitmap] Failed to fetch ${url}: ${response.status} ${response.statusText}`);\n      }\n      const imageBlob = await response.blob();\n      return alphaMode === "premultiplied-alpha" ? createImageBitmap(imageBlob, { premultiplyAlpha: "none" }) : createImageBitmap(imageBlob);\n    }\n    self.onmessage = async (event) => {\n      try {\n        const imageBitmap = await loadImageBitmap(event.data.data[0], event.data.data[1]);\n        self.postMessage({\n          data: imageBitmap,\n          uuid: event.data.uuid,\n          id: event.data.id\n        }, [imageBitmap]);\n      } catch (e) {\n        self.postMessage({\n          error: e,\n          uuid: event.data.uuid,\n          id: event.data.id\n        });\n      }\n    };\n\n})();\n';
let WORKER_URL = null;
class WorkerInstance2 {
  constructor() {
    if (!WORKER_URL) {
      WORKER_URL = URL.createObjectURL(new Blob([WORKER_CODE], { type: "application/javascript" }));
    }
    this.worker = new Worker(WORKER_URL);
  }
}
WorkerInstance2.revokeObjectURL = function revokeObjectURL2() {
  if (WORKER_URL) {
    URL.revokeObjectURL(WORKER_URL);
    WORKER_URL = null;
  }
};
let UUID = 0;
let MAX_WORKERS;
class WorkerManagerClass {
  constructor() {
    this._initialized = false;
    this._createdWorkers = 0;
    this._workerPool = [];
    this._queue = [];
    this._resolveHash = {};
  }
  /**
   * Checks if ImageBitmap is supported in the current environment.
   *
   * This method uses a dedicated worker to test ImageBitmap support
   * and caches the result for subsequent calls.
   * @returns Promise that resolves to true if ImageBitmap is supported, false otherwise
   */
  isImageBitmapSupported() {
    if (this._isImageBitmapSupported !== void 0)
      return this._isImageBitmapSupported;
    this._isImageBitmapSupported = new Promise((resolve) => {
      const { worker } = new WorkerInstance$1();
      worker.addEventListener("message", (event) => {
        worker.terminate();
        WorkerInstance$1.revokeObjectURL();
        resolve(event.data);
      });
    });
    return this._isImageBitmapSupported;
  }
  /**
   * Loads an image as an ImageBitmap using a web worker.
   * @param src - The source URL or path of the image to load
   * @param asset - Optional resolved asset containing additional texture source options
   * @returns Promise that resolves to the loaded ImageBitmap
   * @example
   * ```typescript
   * const bitmap = await WorkerManager.loadImageBitmap('image.png');
   * const bitmapWithOptions = await WorkerManager.loadImageBitmap('image.png', asset);
   * ```
   */
  loadImageBitmap(src, asset) {
    var _a;
    return this._run("loadImageBitmap", [src, (_a = asset == null ? void 0 : asset.data) == null ? void 0 : _a.alphaMode]);
  }
  /**
   * Initializes the worker pool if not already initialized.
   * Currently a no-op but reserved for future initialization logic.
   */
  async _initWorkers() {
    if (this._initialized)
      return;
    this._initialized = true;
  }
  /**
   * Gets an available worker from the pool or creates a new one if needed.
   *
   * Workers are created up to the MAX_WORKERS limit (based on navigator.hardwareConcurrency).
   * Each worker is configured with a message handler for processing results.
   * @returns Available worker or undefined if pool is at capacity and no workers are free
   */
  _getWorker() {
    if (MAX_WORKERS === void 0) {
      MAX_WORKERS = navigator.hardwareConcurrency || 4;
    }
    let worker = this._workerPool.pop();
    if (!worker && this._createdWorkers < MAX_WORKERS) {
      this._createdWorkers++;
      worker = new WorkerInstance2().worker;
      worker.addEventListener("message", (event) => {
        this._complete(event.data);
        this._returnWorker(event.target);
        this._next();
      });
    }
    return worker;
  }
  /**
   * Returns a worker to the pool after completing a task.
   * @param worker - The worker to return to the pool
   */
  _returnWorker(worker) {
    this._workerPool.push(worker);
  }
  /**
   * Handles completion of a worker task by resolving or rejecting the corresponding promise.
   * @param data - Result data from the worker containing uuid, data, and optional error
   */
  _complete(data) {
    if (!this._resolveHash[data.uuid]) {
      return;
    }
    if (data.error !== void 0) {
      this._resolveHash[data.uuid].reject(data.error);
    } else {
      this._resolveHash[data.uuid].resolve(data.data);
    }
    delete this._resolveHash[data.uuid];
  }
  /**
   * Executes a task using the worker pool system.
   *
   * Queues the task and processes it when a worker becomes available.
   * @param id - Identifier for the type of task to run
   * @param args - Arguments to pass to the worker
   * @returns Promise that resolves with the worker's result
   */
  async _run(id2, args) {
    await this._initWorkers();
    const promise2 = new Promise((resolve, reject) => {
      this._queue.push({ id: id2, arguments: args, resolve, reject });
    });
    this._next();
    return promise2;
  }
  /**
   * Processes the next item in the queue if workers are available.
   *
   * This method is called after worker initialization and when workers
   * complete tasks to continue processing the queue.
   */
  _next() {
    if (!this._queue.length)
      return;
    const worker = this._getWorker();
    if (!worker) {
      return;
    }
    const toDo = this._queue.pop();
    const id2 = toDo.id;
    this._resolveHash[UUID] = { resolve: toDo.resolve, reject: toDo.reject };
    worker.postMessage({
      data: toDo.arguments,
      uuid: UUID++,
      id: id2
    });
  }
  /**
   * Resets the worker manager, terminating all workers and clearing the queue.
   *
   * This method:
   * - Terminates all active workers
   * - Rejects all pending promises with an error
   * - Clears all internal state
   * - Resets initialization flags
   *
   * This should be called when the worker manager is no longer needed
   * to prevent memory leaks and ensure proper cleanup.
   * @example
   * ```typescript
   * // Clean up when shutting down
   * WorkerManager.reset();
   * ```
   */
  reset() {
    this._workerPool.forEach((worker) => worker.terminate());
    this._workerPool.length = 0;
    Object.values(this._resolveHash).forEach(({ reject }) => {
      reject == null ? void 0 : reject(new Error("WorkerManager has been reset before completion"));
    });
    this._resolveHash = {};
    this._queue.length = 0;
    this._initialized = false;
    this._createdWorkers = 0;
  }
}
const WorkerManager = new WorkerManagerClass();
const validImageExtensions = [".jpeg", ".jpg", ".png", ".webp", ".avif"];
const validImageMIMEs = [
  "image/jpeg",
  "image/png",
  "image/webp",
  "image/avif"
];
async function loadImageBitmap(url, asset) {
  var _a;
  const response = await DOMAdapter.get().fetch(url);
  if (!response.ok) {
    throw new Error(`[loadImageBitmap] Failed to fetch ${url}: ${response.status} ${response.statusText}`);
  }
  const imageBlob = await response.blob();
  return ((_a = asset == null ? void 0 : asset.data) == null ? void 0 : _a.alphaMode) === "premultiplied-alpha" ? createImageBitmap(imageBlob, { premultiplyAlpha: "none" }) : createImageBitmap(imageBlob);
}
const loadTextures = {
  /** used for deprecation purposes */
  name: "loadTextures",
  id: "texture",
  extension: {
    type: ExtensionType.LoadParser,
    priority: LoaderParserPriority.High,
    name: "loadTextures"
  },
  config: {
    preferWorkers: true,
    preferCreateImageBitmap: true,
    crossOrigin: "anonymous"
  },
  test(url) {
    return checkDataUrl(url, validImageMIMEs) || checkExtension(url, validImageExtensions);
  },
  async load(url, asset, loader) {
    var _a;
    let src = null;
    if (globalThis.createImageBitmap && this.config.preferCreateImageBitmap) {
      if (this.config.preferWorkers && await WorkerManager.isImageBitmapSupported()) {
        src = await WorkerManager.loadImageBitmap(url, asset);
      } else {
        src = await loadImageBitmap(url, asset);
      }
    } else {
      src = await new Promise((resolve, reject) => {
        src = DOMAdapter.get().createImage();
        src.crossOrigin = this.config.crossOrigin;
        src.src = url;
        if (src.complete) {
          resolve(src);
        } else {
          src.onload = () => {
            resolve(src);
          };
          src.onerror = reject;
        }
      });
    }
    const base = new ImageSource({
      resource: src,
      alphaMode: "premultiply-alpha-on-upload",
      resolution: ((_a = asset.data) == null ? void 0 : _a.resolution) || getResolutionOfUrl(url),
      ...asset.data
    });
    return createTexture(base, loader, url);
  },
  unload(texture) {
    texture.destroy(true);
  }
};
const potentialVideoExtensions = [".mp4", ".m4v", ".webm", ".ogg", ".ogv", ".h264", ".avi", ".mov"];
let validVideoExtensions;
let validVideoMIMEs;
function crossOrigin(element, url, crossorigin) {
  if (crossorigin === void 0 && !url.startsWith("data:")) {
    element.crossOrigin = determineCrossOrigin(url);
  } else if (crossorigin !== false) {
    element.crossOrigin = typeof crossorigin === "string" ? crossorigin : "anonymous";
  }
}
function preloadVideo(element) {
  return new Promise((resolve, reject) => {
    element.addEventListener("canplaythrough", loaded);
    element.addEventListener("error", error);
    element.load();
    function loaded() {
      cleanup();
      resolve();
    }
    function error(err) {
      cleanup();
      reject(err);
    }
    function cleanup() {
      element.removeEventListener("canplaythrough", loaded);
      element.removeEventListener("error", error);
    }
  });
}
function determineCrossOrigin(url, loc = globalThis.location) {
  if (url.startsWith("data:")) {
    return "";
  }
  loc || (loc = globalThis.location);
  const parsedUrl = new URL(url, document.baseURI);
  if (parsedUrl.hostname !== loc.hostname || parsedUrl.port !== loc.port || parsedUrl.protocol !== loc.protocol) {
    return "anonymous";
  }
  return "";
}
function getBrowserSupportedVideoExtensions() {
  const supportedExtensions = [];
  const supportedMimes = [];
  for (const ext of potentialVideoExtensions) {
    const mimeType = VideoSource.MIME_TYPES[ext.substring(1)] || `video/${ext.substring(1)}`;
    if (testVideoFormat(mimeType)) {
      supportedExtensions.push(ext);
      if (!supportedMimes.includes(mimeType)) {
        supportedMimes.push(mimeType);
      }
    }
  }
  return {
    validVideoExtensions: supportedExtensions,
    validVideoMime: supportedMimes
  };
}
const loadVideoTextures = {
  /** used for deprecation purposes */
  name: "loadVideo",
  id: "video",
  extension: {
    type: ExtensionType.LoadParser,
    name: "loadVideo"
  },
  test(url) {
    if (!validVideoExtensions || !validVideoMIMEs) {
      const { validVideoExtensions: ve, validVideoMime: vm } = getBrowserSupportedVideoExtensions();
      validVideoExtensions = ve;
      validVideoMIMEs = vm;
    }
    const isValidDataUrl = checkDataUrl(url, validVideoMIMEs);
    const isValidExtension = checkExtension(url, validVideoExtensions);
    return isValidDataUrl || isValidExtension;
  },
  async load(url, asset, loader) {
    var _a, _b;
    const options = {
      ...VideoSource.defaultOptions,
      resolution: ((_a = asset.data) == null ? void 0 : _a.resolution) || getResolutionOfUrl(url),
      alphaMode: ((_b = asset.data) == null ? void 0 : _b.alphaMode) || await detectVideoAlphaMode(),
      ...asset.data
    };
    const videoElement = document.createElement("video");
    const attributeMap = {
      preload: options.autoLoad !== false ? "auto" : void 0,
      "webkit-playsinline": options.playsinline !== false ? "" : void 0,
      playsinline: options.playsinline !== false ? "" : void 0,
      muted: options.muted === true ? "" : void 0,
      loop: options.loop === true ? "" : void 0,
      autoplay: options.autoPlay !== false ? "" : void 0
    };
    Object.keys(attributeMap).forEach((key2) => {
      const value2 = attributeMap[key2];
      if (value2 !== void 0)
        videoElement.setAttribute(key2, value2);
    });
    if (options.muted === true) {
      videoElement.muted = true;
    }
    crossOrigin(videoElement, url, options.crossorigin);
    const sourceElement = document.createElement("source");
    let mime;
    if (options.mime) {
      mime = options.mime;
    } else if (url.startsWith("data:")) {
      mime = url.slice(5, url.indexOf(";"));
    } else if (!url.startsWith("blob:")) {
      const ext = url.split("?")[0].slice(url.lastIndexOf(".") + 1).toLowerCase();
      mime = VideoSource.MIME_TYPES[ext] || `video/${ext}`;
    }
    sourceElement.src = url;
    if (mime) {
      sourceElement.type = mime;
    }
    return new Promise((resolve) => {
      const onCanPlay = async () => {
        const base = new VideoSource({ ...options, resource: videoElement });
        videoElement.removeEventListener("canplay", onCanPlay);
        if (asset.data.preload) {
          await preloadVideo(videoElement);
        }
        resolve(createTexture(base, loader, url));
      };
      if (options.preload && !options.autoPlay) {
        videoElement.load();
      }
      videoElement.addEventListener("canplay", onCanPlay);
      videoElement.appendChild(sourceElement);
    });
  },
  unload(texture) {
    texture.destroy(true);
  }
};
const resolveTextureUrl = {
  extension: {
    type: ExtensionType.ResolveParser,
    name: "resolveTexture"
  },
  test: loadTextures.test,
  parse: (value2) => {
    var _a;
    return {
      resolution: parseFloat(((_a = Resolver.RETINA_PREFIX.exec(value2)) == null ? void 0 : _a[1]) ?? "1"),
      format: value2.split(".").pop(),
      src: value2
    };
  }
};
const resolveJsonUrl = {
  extension: {
    type: ExtensionType.ResolveParser,
    priority: -2,
    name: "resolveJson"
  },
  test: (value2) => Resolver.RETINA_PREFIX.test(value2) && value2.endsWith(".json"),
  parse: resolveTextureUrl.parse
};
class AssetsClass {
  constructor() {
    this._detections = [];
    this._initialized = false;
    this.resolver = new Resolver();
    this.loader = new Loader();
    this.cache = Cache;
    this._backgroundLoader = new BackgroundLoader(this.loader);
    this._backgroundLoader.active = true;
    this.reset();
  }
  /**
   * Initializes the Assets class with configuration options. While not required,
   * calling this before loading assets is recommended to set up default behaviors.
   * @param options - Configuration options for the Assets system
   * @example
   * ```ts
   * // Basic initialization (optional as Assets.load will call this automatically)
   * await Assets.init();
   *
   * // With CDN configuration
   * await Assets.init({
   *     basePath: 'https://my-cdn.com/assets/',
   *     defaultSearchParams: { version: '1.0.0' }
   * });
   *
   * // With manifest and preferences
   * await Assets.init({
   *     manifest: {
   *         bundles: [{
   *             name: 'game-screen',
   *             assets: [
   *                 {
   *                     alias: 'hero',
   *                     src: 'hero.{png,webp}',
   *                     data: { scaleMode: SCALE_MODES.NEAREST }
   *                 },
   *                 {
   *                     alias: 'map',
   *                     src: 'map.json'
   *                 }
   *             ]
   *         }]
   *     },
   *     // Optimize for device capabilities
   *     texturePreference: {
   *         resolution: window.devicePixelRatio,
   *         format: ['webp', 'png']
   *     },
   *     // Set global preferences
   *     preferences: {
   *         crossOrigin: 'anonymous',
   *     }
   * });
   *
   * // Load assets after initialization
   * const heroTexture = await Assets.load('hero');
   * ```
   * @remarks
   * - Can be called only once; subsequent calls will be ignored with a warning
   * - Format detection runs automatically unless `skipDetections` is true
   * - The manifest can be a URL to a JSON file or an inline object
   * @see {@link AssetInitOptions} For all available initialization options
   * @see {@link AssetsManifest} For manifest format details
   */
  async init(options = {}) {
    var _a, _b;
    if (this._initialized) {
      warn("[Assets]AssetManager already initialized, did you load before calling this Assets.init()?");
      return;
    }
    this._initialized = true;
    if (options.defaultSearchParams) {
      this.resolver.setDefaultSearchParams(options.defaultSearchParams);
    }
    if (options.basePath) {
      this.resolver.basePath = options.basePath;
    }
    if (options.bundleIdentifier) {
      this.resolver.setBundleIdentifier(options.bundleIdentifier);
    }
    if (options.manifest) {
      let manifest = options.manifest;
      if (typeof manifest === "string") {
        manifest = await this.load(manifest);
      }
      this.resolver.addManifest(manifest);
    }
    const resolutionPref = ((_a = options.texturePreference) == null ? void 0 : _a.resolution) ?? 1;
    const resolution2 = typeof resolutionPref === "number" ? [resolutionPref] : resolutionPref;
    const formats = await this._detectFormats({
      preferredFormats: (_b = options.texturePreference) == null ? void 0 : _b.format,
      skipDetections: options.skipDetections,
      detections: this._detections
    });
    this.resolver.prefer({
      params: {
        format: formats,
        resolution: resolution2
      }
    });
    if (options.preferences) {
      this.setPreferences(options.preferences);
    }
    if (options.loadOptions) {
      this.loader.loadOptions = {
        ...this.loader.loadOptions,
        ...options.loadOptions
      };
    }
  }
  /**
   * Registers assets with the Assets resolver. This method maps keys (aliases) to asset sources,
   * allowing you to load assets using friendly names instead of direct URLs.
   * @param assets - The unresolved assets to add to the resolver
   * @example
   * ```ts
   * // Basic usage - single asset
   * Assets.add({
   *     alias: 'myTexture',
   *     src: 'assets/texture.png'
   * });
   * const texture = await Assets.load('myTexture');
   *
   * // Multiple aliases for the same asset
   * Assets.add({
   *     alias: ['hero', 'player'],
   *     src: 'hero.png'
   * });
   * const hero1 = await Assets.load('hero');
   * const hero2 = await Assets.load('player'); // Same texture
   *
   * // Multiple format support
   * Assets.add({
   *     alias: 'character',
   *     src: 'character.{webp,png}' // Will choose best format
   * });
   * Assets.add({
   *     alias: 'character',
   *     src: ['character.webp', 'character.png'], // Explicitly specify formats
   * });
   *
   * // With texture options
   * Assets.add({
   *     alias: 'sprite',
   *     src: 'sprite.png',
   *     data: { scaleMode: 'nearest' }
   * });
   *
   * // Multiple assets at once
   * Assets.add([
   *     { alias: 'bg', src: 'background.png' },
   *     { alias: 'music', src: 'music.mp3' },
   *     { alias: 'spritesheet', src: 'sheet.json', data: { ignoreMultiPack: false } }
   * ]);
   * ```
   * @remarks
   * - Assets are resolved when loaded, not when added
   * - Multiple formats use the best available format for the browser
   * - Adding with same alias overwrites previous definition
   * - The `data` property is passed to the asset loader
   * @see {@link Resolver} For details on asset resolution
   * @see {@link LoaderParser} For asset-specific data options
   * @advanced
   */
  add(assets) {
    this.resolver.add(assets);
  }
  async load(urls, onProgress) {
    if (!this._initialized) {
      await this.init();
    }
    const singleAsset = isSingleItem(urls);
    const urlArray = convertToList(urls).map((url) => {
      if (typeof url !== "string") {
        const aliases = this.resolver.getAlias(url);
        if (aliases.some((alias) => !this.resolver.hasKey(alias))) {
          this.add(url);
        }
        return Array.isArray(aliases) ? aliases[0] : aliases;
      }
      if (!this.resolver.hasKey(url))
        this.add({ alias: url, src: url });
      return url;
    });
    const resolveResults = this.resolver.resolve(urlArray);
    const out2 = await this._mapLoadToResolve(resolveResults, onProgress);
    return singleAsset ? out2[urlArray[0]] : out2;
  }
  /**
   * Registers a bundle of assets that can be loaded as a group. Bundles are useful for organizing
   * assets into logical groups, such as game levels or UI screens.
   * @param bundleId - Unique identifier for the bundle
   * @param assets - Assets to include in the bundle
   * @example
   * ```ts
   * // Add a bundle using array format
   * Assets.addBundle('animals', [
   *     { alias: 'bunny', src: 'bunny.png' },
   *     { alias: 'chicken', src: 'chicken.png' },
   *     { alias: 'thumper', src: 'thumper.png' },
   * ]);
   *
   * // Add a bundle using object format
   * Assets.addBundle('animals', {
   *     bunny: 'bunny.png',
   *     chicken: 'chicken.png',
   *     thumper: 'thumper.png',
   * });
   *
   * // Add a bundle with advanced options
   * Assets.addBundle('ui', [
   *     {
   *         alias: 'button',
   *         src: 'button.{webp,png}',
   *         data: { scaleMode: 'nearest' }
   *     },
   *     {
   *         alias: ['logo', 'brand'],  // Multiple aliases
   *         src: 'logo.svg',
   *         data: { resolution: 2 }
   *     }
   * ]);
   *
   * // Load the bundle
   * await Assets.loadBundle('animals');
   *
   * // Use the loaded assets
   * const bunny = Sprite.from('bunny');
   * const chicken = Sprite.from('chicken');
   * ```
   * @remarks
   * - Bundle IDs must be unique
   * - Assets in bundles are not loaded until `loadBundle` is called
   * - Bundles can be background loaded using `backgroundLoadBundle`
   * - Assets in bundles can be loaded individually using their aliases
   * @see {@link Assets.loadBundle} For loading bundles
   * @see {@link Assets.backgroundLoadBundle} For background loading bundles
   * @see {@link Assets.unloadBundle} For unloading bundles
   * @see {@link AssetsManifest} For manifest format details
   */
  addBundle(bundleId, assets) {
    this.resolver.addBundle(bundleId, assets);
  }
  /**
   * Loads a bundle or multiple bundles of assets. Bundles are collections of related assets
   * that can be loaded together.
   * @param bundleIds - Single bundle ID or array of bundle IDs to load
   * @param onProgress - Optional callback for load progress (0.0 to 1.0)
   * @returns Promise that resolves with the loaded bundle assets
   * @example
   * ```ts
   * // Define bundles in your manifest
   * const manifest = {
   *     bundles: [
   *         {
   *             name: 'load-screen',
   *             assets: [
   *                 {
   *                     alias: 'background',
   *                     src: 'sunset.png',
   *                 },
   *                 {
   *                     alias: 'bar',
   *                     src: 'load-bar.{png,webp}', // use an array of individual assets
   *                 },
   *             ],
   *         },
   *         {
   *             name: 'game-screen',
   *             assets: [
   *                 {
   *                     alias: 'character',
   *                     src: 'robot.png',
   *                 },
   *                 {
   *                     alias: 'enemy',
   *                     src: 'bad-guy.png',
   *                 },
   *             ],
   *         },
   *     ]
   * };
   *
   * // Initialize with manifest
   * await Assets.init({ manifest });
   *
   * // Or add bundles programmatically
   * Assets.addBundle('load-screen', [...]);
   * Assets.loadBundle('load-screen');
   *
   * // Load a single bundle
   * await Assets.loadBundle('load-screen');
   * const bg = Sprite.from('background'); // Uses alias from bundle
   *
   * // Load multiple bundles
   * await Assets.loadBundle([
   *     'load-screen',
   *     'game-screen'
   * ]);
   *
   * // Load with progress tracking
   * await Assets.loadBundle('game-screen', (progress) => {
   *     console.log(`Loading: ${Math.round(progress * 100)}%`);
   * });
   * ```
   * @remarks
   * - Bundle assets are cached automatically
   * - Bundles can be pre-loaded using `backgroundLoadBundle`
   * - Assets in bundles can be accessed by their aliases
   * - Progress callback receives values from 0.0 to 1.0
   * @throws {Error} If the bundle ID doesn't exist in the manifest
   * @see {@link Assets.addBundle} For adding bundles programmatically
   * @see {@link Assets.backgroundLoadBundle} For background loading bundles
   * @see {@link Assets.unloadBundle} For unloading bundles
   * @see {@link AssetsManifest} For manifest format details
   */
  async loadBundle(bundleIds, onProgress) {
    if (!this._initialized) {
      await this.init();
    }
    let singleAsset = false;
    if (typeof bundleIds === "string") {
      singleAsset = true;
      bundleIds = [bundleIds];
    }
    const resolveResults = this.resolver.resolveBundle(bundleIds);
    const out2 = {};
    const keys = Object.keys(resolveResults);
    let total = 0;
    const counts = [];
    const _onProgress = () => {
      onProgress == null ? void 0 : onProgress(counts.reduce((a2, b2) => a2 + b2, 0) / total);
    };
    const promises = keys.map((bundleId, i2) => {
      const resolveResult = resolveResults[bundleId];
      const values = Object.values(resolveResult);
      const totalAssetsToLoad = [...new Set(values.flat())];
      const progressSize = totalAssetsToLoad.reduce((sum, asset) => sum + (asset.progressSize || 1), 0);
      counts.push(0);
      total += progressSize;
      return this._mapLoadToResolve(resolveResult, (e2) => {
        counts[i2] = e2 * progressSize;
        _onProgress();
      }).then((resolveResult2) => {
        out2[bundleId] = resolveResult2;
      });
    });
    await Promise.all(promises);
    return singleAsset ? out2[bundleIds[0]] : out2;
  }
  /**
   * Initiates background loading of assets. This allows assets to be loaded passively while other operations
   * continue, making them instantly available when needed later.
   *
   * Background loading is useful for:
   * - Preloading game levels while in a menu
   * - Loading non-critical assets during gameplay
   * - Reducing visible loading screens
   * @param urls - Single URL/alias or array of URLs/aliases to load in the background
   * @example
   * ```ts
   * // Basic background loading
   * Assets.backgroundLoad('images/level2-assets.png');
   *
   * // Background load multiple assets
   * Assets.backgroundLoad([
   *     'images/sprite1.png',
   *     'images/sprite2.png',
   *     'images/background.png'
   * ]);
   *
   * // Later, when you need the assets
   * const textures = await Assets.load([
   *     'images/sprite1.png',
   *     'images/sprite2.png'
   * ]); // Resolves immediately if background loading completed
   * ```
   * @remarks
   * - Background loading happens one asset at a time to avoid blocking the main thread
   * - Loading can be interrupted safely by calling `Assets.load()`
   * - Assets are cached as they complete loading
   * - No progress tracking is available for background loading
   */
  async backgroundLoad(urls) {
    if (!this._initialized) {
      await this.init();
    }
    if (typeof urls === "string") {
      urls = [urls];
    }
    const resolveResults = this.resolver.resolve(urls);
    this._backgroundLoader.add(Object.values(resolveResults));
  }
  /**
   * Initiates background loading of asset bundles. Similar to backgroundLoad but works with
   * predefined bundles of assets.
   *
   * Perfect for:
   * - Preloading level bundles during gameplay
   * - Loading UI assets during splash screens
   * - Preparing assets for upcoming game states
   * @param bundleIds - Single bundle ID or array of bundle IDs to load in the background
   * @example
   * ```ts
   * // Define bundles in your manifest
   * await Assets.init({
   *     manifest: {
   *         bundles: [
   *             {
   *               name: 'home',
   *               assets: [
   *                 {
   *                     alias: 'background',
   *                     src: 'images/home-bg.png',
   *                 },
   *                 {
   *                     alias: 'logo',
   *                     src: 'images/logo.png',
   *                 }
   *              ]
   *            },
   *            {
   *             name: 'level-1',
   *             assets: [
   *                 {
   *                     alias: 'background',
   *                     src: 'images/level1/bg.png',
   *                 },
   *                 {
   *                     alias: 'sprites',
   *                     src: 'images/level1/sprites.json'
   *                 }
   *             ]
   *         }]
   *     }
   * });
   *
   * // Load the home screen assets right away
   * await Assets.loadBundle('home');
   * showHomeScreen();
   *
   * // Start background loading while showing home screen
   * Assets.backgroundLoadBundle('level-1');
   *
   * // When player starts level, load completes faster
   * await Assets.loadBundle('level-1');
   * hideHomeScreen();
   * startLevel();
   * ```
   * @remarks
   * - Bundle assets are loaded one at a time
   * - Loading can be interrupted safely by calling `Assets.loadBundle()`
   * - Assets are cached as they complete loading
   * - Requires bundles to be registered via manifest or `addBundle`
   * @see {@link Assets.addBundle} For adding bundles programmatically
   * @see {@link Assets.loadBundle} For immediate bundle loading
   * @see {@link AssetsManifest} For manifest format details
   */
  async backgroundLoadBundle(bundleIds) {
    if (!this._initialized) {
      await this.init();
    }
    if (typeof bundleIds === "string") {
      bundleIds = [bundleIds];
    }
    const resolveResults = this.resolver.resolveBundle(bundleIds);
    Object.values(resolveResults).forEach((resolveResult) => {
      this._backgroundLoader.add(Object.values(resolveResult));
    });
  }
  /**
   * Only intended for development purposes.
   * This will wipe the resolver and caches.
   * You will need to reinitialize the Asset
   * @internal
   */
  reset() {
    this.resolver.reset();
    this.loader.reset();
    this.cache.reset();
    this._initialized = false;
  }
  get(keys) {
    if (typeof keys === "string") {
      return Cache.get(keys);
    }
    const assets = {};
    for (let i2 = 0; i2 < keys.length; i2++) {
      assets[i2] = Cache.get(keys[i2]);
    }
    return assets;
  }
  /**
   * helper function to map resolved assets back to loaded assets
   * @param resolveResults - the resolve results from the resolver
   * @param progressOrLoadOptions - the progress callback or load options
   */
  async _mapLoadToResolve(resolveResults, progressOrLoadOptions) {
    const resolveArray = [...new Set(Object.values(resolveResults))];
    this._backgroundLoader.active = false;
    const loadedAssets = await this.loader.load(resolveArray, progressOrLoadOptions);
    this._backgroundLoader.active = true;
    const out2 = {};
    resolveArray.forEach((resolveResult) => {
      const asset = loadedAssets[resolveResult.src];
      const keys = [resolveResult.src];
      if (resolveResult.alias) {
        keys.push(...resolveResult.alias);
      }
      keys.forEach((key2) => {
        out2[key2] = asset;
      });
      Cache.set(keys, asset);
    });
    return out2;
  }
  /**
   * Unloads assets and releases them from memory. This method ensures proper cleanup of
   * loaded assets when they're no longer needed.
   * @param urls - Single URL/alias or array of URLs/aliases to unload
   * @example
   * ```ts
   * // Unload a single asset
   * await Assets.unload('images/sprite.png');
   *
   * // Unload using an alias
   * await Assets.unload('hero'); // Unloads the asset registered with 'hero' alias
   *
   * // Unload multiple assets
   * await Assets.unload([
   *     'images/background.png',
   *     'images/character.png',
   *     'hero'
   * ]);
   *
   * // Unload and handle creation of new instances
   * await Assets.unload('hero');
   * const newHero = await Assets.load('hero'); // Will load fresh from source
   * ```
   * @remarks
   * > [!WARNING]
   * > Make sure assets aren't being used before unloading:
   * > - Remove sprites using the texture
   * > - Clear any references to the asset
   * > - Textures will be destroyed and can't be used after unloading
   * @throws {Error} If the asset is not found in cache
   */
  async unload(urls) {
    if (!this._initialized) {
      await this.init();
    }
    const urlArray = convertToList(urls).map((url) => typeof url !== "string" ? url.src : url);
    const resolveResults = this.resolver.resolve(urlArray);
    await this._unloadFromResolved(resolveResults);
  }
  /**
   * Unloads all assets in a bundle. Use this to free memory when a bundle's assets
   * are no longer needed, such as when switching game levels.
   * @param bundleIds - Single bundle ID or array of bundle IDs to unload
   * @example
   * ```ts
   * // Define and load a bundle
   * Assets.addBundle('level-1', {
   *     background: 'level1/bg.png',
   *     sprites: 'level1/sprites.json',
   *     music: 'level1/music.mp3'
   * });
   *
   * // Load the bundle
   * const level1 = await Assets.loadBundle('level-1');
   *
   * // Use the assets
   * const background = Sprite.from(level1.background);
   *
   * // When done with the level, unload everything
   * await Assets.unloadBundle('level-1');
   * // background sprite is now invalid!
   *
   * // Unload multiple bundles
   * await Assets.unloadBundle([
   *     'level-1',
   *     'level-2',
   *     'ui-elements'
   * ]);
   * ```
   * @remarks
   * > [!WARNING]
   * > - All assets in the bundle will be destroyed
   * > - Bundle needs to be reloaded to use assets again
   * > - Make sure no sprites or other objects are using the assets
   * @throws {Error} If the bundle is not found
   * @see {@link Assets.addBundle} For adding bundles
   * @see {@link Assets.loadBundle} For loading bundles
   */
  async unloadBundle(bundleIds) {
    if (!this._initialized) {
      await this.init();
    }
    bundleIds = convertToList(bundleIds);
    const resolveResults = this.resolver.resolveBundle(bundleIds);
    const promises = Object.keys(resolveResults).map((bundleId) => this._unloadFromResolved(resolveResults[bundleId]));
    await Promise.all(promises);
  }
  async _unloadFromResolved(resolveResult) {
    const resolveArray = Object.values(resolveResult);
    resolveArray.forEach((resolveResult2) => {
      Cache.remove(resolveResult2.src);
    });
    await this.loader.unload(resolveArray);
  }
  /**
   * Detects the supported formats for the browser, and returns an array of supported formats, respecting
   * the users preferred formats order.
   * @param options - the options to use when detecting formats
   * @param options.preferredFormats - the preferred formats to use
   * @param options.skipDetections - if we should skip the detections altogether
   * @param options.detections - the detections to use
   * @returns - the detected formats
   */
  async _detectFormats(options) {
    let formats = [];
    if (options.preferredFormats) {
      formats = Array.isArray(options.preferredFormats) ? options.preferredFormats : [options.preferredFormats];
    }
    for (const detection of options.detections) {
      if (options.skipDetections || await detection.test()) {
        formats = await detection.add(formats);
      } else if (!options.skipDetections) {
        formats = await detection.remove(formats);
      }
    }
    formats = formats.filter((format, index) => formats.indexOf(format) === index);
    return formats;
  }
  /**
   * All the detection parsers currently added to the Assets class.
   * @advanced
   */
  get detections() {
    return this._detections;
  }
  /**
   * Sets global preferences for asset loading behavior. This method configures how assets
   * are loaded and processed across all parsers.
   * @param preferences - Asset loading preferences
   * @example
   * ```ts
   * // Basic preferences
   * Assets.setPreferences({
   *     crossOrigin: 'anonymous',
   *     parseAsGraphicsContext: false
   * });
   * ```
   * @remarks
   * Preferences are applied to all compatible parsers and affect future asset loading.
   * Common preferences include:
   * - `crossOrigin`: CORS setting for loaded assets
   * - `preferWorkers`: Whether to use web workers for loading textures
   * - `preferCreateImageBitmap`: Use `createImageBitmap` for texture creation. Turning this off will use the `Image` constructor instead.
   * @see {@link AssetsPreferences} For all available preferences
   */
  setPreferences(preferences) {
    this.loader.parsers.forEach((parser) => {
      if (!parser.config)
        return;
      Object.keys(parser.config).filter((key2) => key2 in preferences).forEach((key2) => {
        parser.config[key2] = preferences[key2];
      });
    });
  }
}
const Assets = new AssetsClass();
extensions.handleByList(ExtensionType.LoadParser, Assets.loader.parsers).handleByList(ExtensionType.ResolveParser, Assets.resolver.parsers).handleByList(ExtensionType.CacheParser, Assets.cache.parsers).handleByList(ExtensionType.DetectionParser, Assets.detections);
extensions.add(
  cacheTextureArray,
  detectDefaults,
  detectAvif,
  detectWebp,
  detectMp4,
  detectOgv,
  detectWebm,
  loadJson,
  loadTxt,
  loadWebFont,
  loadSvg,
  loadTextures,
  loadVideoTextures,
  loadBitmapFont,
  bitmapFontCachePlugin,
  resolveTextureUrl,
  resolveJsonUrl
);
const assetKeyMap = {
  loader: ExtensionType.LoadParser,
  resolver: ExtensionType.ResolveParser,
  cache: ExtensionType.CacheParser,
  detection: ExtensionType.DetectionParser
};
extensions.handle(ExtensionType.Asset, (extension) => {
  const ref = extension.ref;
  Object.entries(assetKeyMap).filter(([key2]) => !!ref[key2]).forEach(([key2, type2]) => extensions.add(Object.assign(
    ref[key2],
    // Allow the function to optionally define it's own
    // ExtensionMetadata, the use cases here is priority for LoaderParsers
    { extension: ref[key2].extension ?? type2 }
  )));
}, (extension) => {
  const ref = extension.ref;
  Object.keys(assetKeyMap).filter((key2) => !!ref[key2]).forEach((key2) => extensions.remove(ref[key2]));
});
const GAUSSIAN_VALUES = {
  5: [0.153388, 0.221461, 0.250301],
  7: [0.071303, 0.131514, 0.189879, 0.214607],
  9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],
  11: [93e-4, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],
  13: [2406e-6, 9255e-6, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],
  15: [489e-6, 2403e-6, 9246e-6, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448]
};
const fragTemplate = [
  "in vec2 vBlurTexCoords[%size%];",
  "uniform sampler2D uTexture;",
  "out vec4 finalColor;",
  "void main(void)",
  "{",
  "    finalColor = vec4(0.0);",
  "    %blur%",
  "}"
].join("\n");
function generateBlurFragSource(kernelSize) {
  const kernel = GAUSSIAN_VALUES[kernelSize];
  const halfLength = kernel.length;
  let fragSource = fragTemplate;
  let blurLoop = "";
  const template = "finalColor += texture(uTexture, vBlurTexCoords[%index%]) * %value%;";
  let value2;
  for (let i2 = 0; i2 < kernelSize; i2++) {
    let blur = template.replace("%index%", i2.toString());
    value2 = i2;
    if (i2 >= halfLength) {
      value2 = kernelSize - i2 - 1;
    }
    blur = blur.replace("%value%", kernel[value2].toString());
    blurLoop += blur;
    blurLoop += "\n";
  }
  fragSource = fragSource.replace("%blur%", blurLoop);
  fragSource = fragSource.replace("%size%", kernelSize.toString());
  return fragSource;
}
const vertTemplate = `
    in vec2 aPosition;

    uniform float uStrength;

    out vec2 vBlurTexCoords[%size%];

    uniform vec4 uInputSize;
    uniform vec4 uOutputFrame;
    uniform vec4 uOutputTexture;

    vec4 filterVertexPosition( void )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;

    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

    vec2 filterTextureCoord( void )
    {
        return aPosition * (uOutputFrame.zw * uInputSize.zw);
    }

    void main(void)
    {
        gl_Position = filterVertexPosition();

        float pixelStrength = uInputSize.%dimension% * uStrength;

        vec2 textureCoord = filterTextureCoord();
        %blur%
    }`;
function generateBlurVertSource(kernelSize, x2) {
  const halfLength = Math.ceil(kernelSize / 2);
  let vertSource = vertTemplate;
  let blurLoop = "";
  let template;
  if (x2) {
    template = "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * pixelStrength, 0.0);";
  } else {
    template = "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * pixelStrength);";
  }
  for (let i2 = 0; i2 < kernelSize; i2++) {
    let blur = template.replace("%index%", i2.toString());
    blur = blur.replace("%sampleIndex%", `${i2 - (halfLength - 1)}.0`);
    blurLoop += blur;
    blurLoop += "\n";
  }
  vertSource = vertSource.replace("%blur%", blurLoop);
  vertSource = vertSource.replace("%size%", kernelSize.toString());
  vertSource = vertSource.replace("%dimension%", x2 ? "z" : "w");
  return vertSource;
}
function generateBlurGlProgram(horizontal, kernelSize) {
  const vertex = generateBlurVertSource(kernelSize, horizontal);
  const fragment = generateBlurFragSource(kernelSize);
  return GlProgram.from({
    vertex,
    fragment,
    name: `blur-${horizontal ? "horizontal" : "vertical"}-pass-filter`
  });
}
var source = "\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\nstruct BlurUniforms {\n  uStrength:f32,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler : sampler;\n\n@group(1) @binding(0) var<uniform> blurUniforms : BlurUniforms;\n\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    %blur-struct%\n  };\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \n}\n\nfn getSize() -> vec2<f32>\n{\n  return gfu.uGlobalFrame.zw;\n}\n\n\n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n\n  let filteredCord = filterTextureCoord(aPosition);\n\n  let pixelStrength = gfu.uInputSize.%dimension% * blurUniforms.uStrength;\n\n  return VSOutput(\n   filterVertexPosition(aPosition),\n    %blur-vertex-out%\n  );\n}\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  %blur-fragment-in%\n) -> @location(0) vec4<f32> {\n\n    var   finalColor = vec4(0.0);\n\n    %blur-sampling%\n\n    return finalColor;\n}";
function generateBlurProgram(horizontal, kernelSize) {
  const kernel = GAUSSIAN_VALUES[kernelSize];
  const halfLength = kernel.length;
  const blurStructSource = [];
  const blurOutSource = [];
  const blurSamplingSource = [];
  for (let i2 = 0; i2 < kernelSize; i2++) {
    blurStructSource[i2] = `@location(${i2}) offset${i2}: vec2<f32>,`;
    if (horizontal) {
      blurOutSource[i2] = `filteredCord + vec2(${i2 - halfLength + 1} * pixelStrength, 0.0),`;
    } else {
      blurOutSource[i2] = `filteredCord + vec2(0.0, ${i2 - halfLength + 1} * pixelStrength),`;
    }
    const kernelIndex = i2 < halfLength ? i2 : kernelSize - i2 - 1;
    const kernelValue = kernel[kernelIndex].toString();
    blurSamplingSource[i2] = `finalColor += textureSample(uTexture, uSampler, offset${i2}) * ${kernelValue};`;
  }
  const blurStruct = blurStructSource.join("\n");
  const blurOut = blurOutSource.join("\n");
  const blurSampling = blurSamplingSource.join("\n");
  const finalSource = source.replace("%blur-struct%", blurStruct).replace("%blur-vertex-out%", blurOut).replace("%blur-fragment-in%", blurStruct).replace("%blur-sampling%", blurSampling).replace("%dimension%", horizontal ? "z" : "w");
  return GpuProgram.from({
    vertex: {
      source: finalSource,
      entryPoint: "mainVertex"
    },
    fragment: {
      source: finalSource,
      entryPoint: "mainFragment"
    }
  });
}
const _BlurFilterPass = class _BlurFilterPass2 extends Filter {
  /**
   * @param options
   * @param options.horizontal - Do pass along the x-axis (`true`) or y-axis (`false`).
   * @param options.strength - The strength of the blur filter.
   * @param options.quality - The quality of the blur filter.
   * @param options.kernelSize - The kernelSize of the blur filter.Options: 5, 7, 9, 11, 13, 15.
   */
  constructor(options) {
    options = { ..._BlurFilterPass2.defaultOptions, ...options };
    const glProgram = generateBlurGlProgram(options.horizontal, options.kernelSize);
    const gpuProgram = generateBlurProgram(options.horizontal, options.kernelSize);
    super({
      glProgram,
      gpuProgram,
      resources: {
        blurUniforms: {
          uStrength: { value: 0, type: "f32" }
        }
      },
      ...options
    });
    this.horizontal = options.horizontal;
    this._quality = 0;
    this.quality = options.quality;
    this.blur = options.strength;
    this._uniforms = this.resources.blurUniforms.uniforms;
  }
  /**
   * Applies the filter.
   * @param filterManager - The manager.
   * @param input - The input target.
   * @param output - The output target.
   * @param clearMode - How to clear
   */
  apply(filterManager, input, output, clearMode) {
    this._uniforms.uStrength = this.strength / this.passes;
    if (this.passes === 1) {
      filterManager.applyFilter(this, input, output, clearMode);
    } else {
      const tempTexture = TexturePool.getSameSizeTexture(input);
      let flip = input;
      let flop = tempTexture;
      this._state.blend = false;
      const shouldClear = filterManager.renderer.type === RendererType.WEBGPU;
      for (let i2 = 0; i2 < this.passes - 1; i2++) {
        filterManager.applyFilter(this, flip, flop, i2 === 0 ? true : shouldClear);
        const temp = flop;
        flop = flip;
        flip = temp;
      }
      this._state.blend = true;
      filterManager.applyFilter(this, flip, output, clearMode);
      TexturePool.returnTexture(tempTexture);
    }
  }
  /**
   * Sets the strength of both the blur.
   * @default 16
   */
  get blur() {
    return this.strength;
  }
  set blur(value2) {
    this.padding = 1 + Math.abs(value2) * 2;
    this.strength = value2;
  }
  /**
   * Sets the quality of the blur by modifying the number of passes. More passes means higher
   * quality blurring but the lower the performance.
   * @default 4
   */
  get quality() {
    return this._quality;
  }
  set quality(value2) {
    this._quality = value2;
    this.passes = value2;
  }
};
_BlurFilterPass.defaultOptions = {
  /** The strength of the blur filter. */
  strength: 8,
  /** The quality of the blur filter. */
  quality: 4,
  /** The kernelSize of the blur filter.Options: 5, 7, 9, 11, 13, 15. */
  kernelSize: 5
};
let BlurFilterPass = _BlurFilterPass;
class BlurFilter extends Filter {
  constructor(...args) {
    let options = args[0] ?? {};
    if (typeof options === "number") {
      deprecation(v8_0_0, "BlurFilter constructor params are now options object. See params: { strength, quality, resolution, kernelSize }");
      options = { strength: options };
      if (args[1] !== void 0)
        options.quality = args[1];
      if (args[2] !== void 0)
        options.resolution = args[2] || "inherit";
      if (args[3] !== void 0)
        options.kernelSize = args[3];
    }
    options = { ...BlurFilterPass.defaultOptions, ...options };
    const { strength, strengthX, strengthY, quality, ...rest } = options;
    super({
      ...rest,
      compatibleRenderers: RendererType.BOTH,
      resources: {}
    });
    this._repeatEdgePixels = false;
    this.blurXFilter = new BlurFilterPass({ horizontal: true, ...options });
    this.blurYFilter = new BlurFilterPass({ horizontal: false, ...options });
    this.quality = quality;
    this.strengthX = strengthX ?? strength;
    this.strengthY = strengthY ?? strength;
    this.repeatEdgePixels = false;
  }
  /**
   * Applies the filter.
   * @param filterManager - The manager.
   * @param input - The input target.
   * @param output - The output target.
   * @param clearMode - How to clear
   * @advanced
   */
  apply(filterManager, input, output, clearMode) {
    const xStrength = Math.abs(this.blurXFilter.strength);
    const yStrength = Math.abs(this.blurYFilter.strength);
    if (xStrength && yStrength) {
      const tempTexture = TexturePool.getSameSizeTexture(input);
      this.blurXFilter.blendMode = "normal";
      this.blurXFilter.apply(filterManager, input, tempTexture, true);
      this.blurYFilter.blendMode = this.blendMode;
      this.blurYFilter.apply(filterManager, tempTexture, output, clearMode);
      TexturePool.returnTexture(tempTexture);
    } else if (yStrength) {
      this.blurYFilter.blendMode = this.blendMode;
      this.blurYFilter.apply(filterManager, input, output, clearMode);
    } else {
      this.blurXFilter.blendMode = this.blendMode;
      this.blurXFilter.apply(filterManager, input, output, clearMode);
    }
  }
  updatePadding() {
    if (this._repeatEdgePixels) {
      this.padding = 0;
    } else {
      this.padding = Math.max(Math.abs(this.blurXFilter.blur), Math.abs(this.blurYFilter.blur)) * 2;
    }
  }
  /**
   * Sets the strength of both the blurX and blurY properties simultaneously.
   * Controls the overall intensity of the Gaussian blur effect.
   * @example
   * ```ts
   * // Set equal blur strength for both axes
   * filter.strength = 8;
   *
   * // Will throw error if X and Y are different
   * filter.strengthX = 4;
   * filter.strengthY = 8;
   * filter.strength; // Error: BlurFilter's strengthX and strengthY are different
   * ```
   * @default 8
   * @throws {Error} If strengthX and strengthY are different values
   */
  get strength() {
    if (this.strengthX !== this.strengthY) {
      throw new Error("BlurFilter's strengthX and strengthY are different");
    }
    return this.strengthX;
  }
  set strength(value2) {
    this.blurXFilter.blur = this.blurYFilter.blur = value2;
    this.updatePadding();
  }
  /**
   * Sets the number of passes for blur. More passes means higher quality blurring.
   * Controls the precision and smoothness of the blur effect at the cost of performance.
   * @example
   * ```ts
   * // High quality blur (slower)
   * filter.quality = 8;
   *
   * // Low quality blur (faster)
   * filter.quality = 2;
   * ```
   * @default 4
   * @remarks Higher values produce better quality but impact performance
   */
  get quality() {
    return this.blurXFilter.quality;
  }
  set quality(value2) {
    this.blurXFilter.quality = this.blurYFilter.quality = value2;
  }
  /**
   * Sets the strength of horizontal blur.
   * Controls the blur intensity along the x-axis independently.
   * @example
   * ```ts
   * // Apply horizontal-only blur
   * filter.strengthX = 8;
   * filter.strengthY = 0;
   *
   * // Create motion blur effect
   * filter.strengthX = 16;
   * filter.strengthY = 2;
   * ```
   * @default 8
   */
  get strengthX() {
    return this.blurXFilter.blur;
  }
  set strengthX(value2) {
    this.blurXFilter.blur = value2;
    this.updatePadding();
  }
  /**
   * Sets the strength of the vertical blur.
   * Controls the blur intensity along the y-axis independently.
   * @example
   * ```ts
   * // Apply vertical-only blur
   * filter.strengthX = 0;
   * filter.strengthY = 8;
   *
   * // Create radial blur effect
   * filter.strengthX = 8;
   * filter.strengthY = 8;
   * ```
   * @default 8
   */
  get strengthY() {
    return this.blurYFilter.blur;
  }
  set strengthY(value2) {
    this.blurYFilter.blur = value2;
    this.updatePadding();
  }
  /**
   * Sets the strength of both the blurX and blurY properties simultaneously
   * @default 2
   * @deprecated since 8.3.0
   * @see BlurFilter.strength
   */
  get blur() {
    deprecation("8.3.0", "BlurFilter.blur is deprecated, please use BlurFilter.strength instead.");
    return this.strength;
  }
  set blur(value2) {
    deprecation("8.3.0", "BlurFilter.blur is deprecated, please use BlurFilter.strength instead.");
    this.strength = value2;
  }
  /**
   * Sets the strength of the blurX property
   * @default 2
   * @deprecated since 8.3.0
   * @see BlurFilter.strengthX
   */
  get blurX() {
    deprecation("8.3.0", "BlurFilter.blurX is deprecated, please use BlurFilter.strengthX instead.");
    return this.strengthX;
  }
  set blurX(value2) {
    deprecation("8.3.0", "BlurFilter.blurX is deprecated, please use BlurFilter.strengthX instead.");
    this.strengthX = value2;
  }
  /**
   * Sets the strength of the blurY property
   * @default 2
   * @deprecated since 8.3.0
   * @see BlurFilter.strengthY
   */
  get blurY() {
    deprecation("8.3.0", "BlurFilter.blurY is deprecated, please use BlurFilter.strengthY instead.");
    return this.strengthY;
  }
  set blurY(value2) {
    deprecation("8.3.0", "BlurFilter.blurY is deprecated, please use BlurFilter.strengthY instead.");
    this.strengthY = value2;
  }
  /**
   * If set to true the edge of the target will be clamped
   * @default false
   */
  get repeatEdgePixels() {
    return this._repeatEdgePixels;
  }
  set repeatEdgePixels(value2) {
    this._repeatEdgePixels = value2;
    this.updatePadding();
  }
}
BlurFilter.defaultOptions = {
  /** The strength of the blur filter. */
  strength: 8,
  /** The quality of the blur filter. */
  quality: 4,
  /** The kernelSize of the blur filter.Options: 5, 7, 9, 11, 13, 15. */
  kernelSize: 5
};
class Graphics extends ViewContainer {
  /**
   * Creates a new Graphics object.
   * @param options - Options for the Graphics.
   */
  constructor(options) {
    if (options instanceof GraphicsContext) {
      options = { context: options };
    }
    const { context: context2, roundPixels, ...rest } = options || {};
    super({
      label: "Graphics",
      ...rest
    });
    this.renderPipeId = "graphics";
    if (!context2) {
      this._context = this._ownedContext = new GraphicsContext();
    } else {
      this._context = context2;
    }
    this._context.on("update", this.onViewUpdate, this);
    this.didViewUpdate = true;
    this.allowChildren = false;
    this.roundPixels = roundPixels ?? false;
  }
  set context(context2) {
    if (context2 === this._context)
      return;
    this._context.off("update", this.onViewUpdate, this);
    this._context = context2;
    this._context.on("update", this.onViewUpdate, this);
    this.onViewUpdate();
  }
  /**
   * The underlying graphics context used for drawing operations.
   * Controls how shapes and paths are rendered.
   * @example
   * ```ts
   * // Create a shared context
   * const sharedContext = new GraphicsContext();
   *
   * // Create graphics objects sharing the same context
   * const graphics1 = new Graphics();
   * const graphics2 = new Graphics();
   *
   * // Assign shared context
   * graphics1.context = sharedContext;
   * graphics2.context = sharedContext;
   *
   * // Both graphics will show the same shapes
   * sharedContext
   *     .rect(0, 0, 100, 100)
   *     .fill({ color: 0xff0000 });
   * ```
   * @see {@link GraphicsContext} For drawing operations
   * @see {@link GraphicsOptions} For context configuration
   */
  get context() {
    return this._context;
  }
  /**
   * The local bounds of the graphics object.
   * Returns the boundaries after all graphical operations but before any transforms.
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Draw a shape
   * graphics
   *     .rect(0, 0, 100, 100)
   *     .fill({ color: 0xff0000 });
   *
   * // Get bounds information
   * const bounds = graphics.bounds;
   * console.log(bounds.width);  // 100
   * console.log(bounds.height); // 100
   * ```
   * @readonly
   * @see {@link Bounds} For bounds operations
   * @see {@link Container#getBounds} For transformed bounds
   */
  get bounds() {
    return this._context.bounds;
  }
  /**
   * Graphics objects do not need to update their bounds as the context handles this.
   * @private
   */
  updateBounds() {
  }
  /**
   * Checks if the object contains the given point.
   * Returns true if the point lies within the Graphics object's rendered area.
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Draw a shape
   * graphics
   *     .rect(0, 0, 100, 100)
   *     .fill({ color: 0xff0000 });
   *
   * // Check point intersection
   * if (graphics.containsPoint({ x: 50, y: 50 })) {
   *     console.log('Point is inside rectangle!');
   * }
   * ```
   * @param point - The point to check in local coordinates
   * @returns True if the point is inside the Graphics object
   * @see {@link Graphics#bounds} For bounding box checks
   * @see {@link PointData} For point data structure
   */
  containsPoint(point) {
    return this._context.containsPoint(point);
  }
  /**
   * Destroys this graphics renderable and optionally its context.
   * @param options - Options parameter. A boolean will act as if all options
   *
   * If the context was created by this graphics and `destroy(false)` or `destroy()` is called
   * then the context will still be destroyed.
   *
   * If you want to explicitly not destroy this context that this graphics created,
   * then you should pass destroy({ context: false })
   *
   * If the context was passed in as an argument to the constructor then it will not be destroyed
   * @example
   * ```ts
   * // Destroy the graphics and its context
   * graphics.destroy();
   * graphics.destroy(true);
   * graphics.destroy({ context: true, texture: true, textureSource: true });
   * ```
   */
  destroy(options) {
    if (this._ownedContext && !options) {
      this._ownedContext.destroy(options);
    } else if (options === true || (options == null ? void 0 : options.context) === true) {
      this._context.destroy(options);
    }
    this._ownedContext = null;
    this._context = null;
    super.destroy(options);
  }
  _callContextMethod(method, args) {
    this.context[method](...args);
    return this;
  }
  // --------------------------------------- GraphicsContext methods ---------------------------------------
  /**
   * Sets the current fill style of the graphics context.
   * The fill style can be a color, gradient, pattern, or a complex style object.
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Basic color fill
   * graphics
   *     .setFillStyle({ color: 0xff0000 }) // Red fill
   *     .rect(0, 0, 100, 100)
   *     .fill();
   *
   * // Gradient fill
   * const gradient = new FillGradient({
   *    end: { x: 1, y: 0 },
   *    colorStops: [
   *         { offset: 0, color: 0xff0000 }, // Red at start
   *         { offset: 0.5, color: 0x00ff00 }, // Green at middle
   *         { offset: 1, color: 0x0000ff }, // Blue at end
   *    ],
   * });
   *
   * graphics
   *     .setFillStyle(gradient)
   *     .circle(100, 100, 50)
   *     .fill();
   *
   * // Pattern fill
   * const pattern = new FillPattern(texture);
   * graphics
   *     .setFillStyle({
   *         fill: pattern,
   *         alpha: 0.5
   *     })
   *     .rect(0, 0, 200, 200)
   *     .fill();
   * ```
   * @param {FillInput} args - The fill style to apply
   * @returns The Graphics instance for chaining
   * @see {@link FillStyle} For fill style options
   * @see {@link FillGradient} For gradient fills
   * @see {@link FillPattern} For pattern fills
   */
  setFillStyle(...args) {
    return this._callContextMethod("setFillStyle", args);
  }
  /**
   * Sets the current stroke style of the graphics context.
   * Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations.
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Basic color stroke
   * graphics
   *     .setStrokeStyle({
   *         width: 2,
   *         color: 0x000000
   *     })
   *     .rect(0, 0, 100, 100)
   *     .stroke();
   *
   * // Complex stroke style
   * graphics
   *     .setStrokeStyle({
   *         width: 4,
   *         color: 0xff0000,
   *         alpha: 0.5,
   *         join: 'round',
   *         cap: 'round',
   *         alignment: 0.5
   *     })
   *     .circle(100, 100, 50)
   *     .stroke();
   *
   * // Gradient stroke
   * const gradient = new FillGradient({
   *    end: { x: 1, y: 0 },
   *    colorStops: [
   *         { offset: 0, color: 0xff0000 }, // Red at start
   *         { offset: 0.5, color: 0x00ff00 }, // Green at middle
   *         { offset: 1, color: 0x0000ff }, // Blue at end
   *    ],
   * });
   *
   * graphics
   *     .setStrokeStyle({
   *         width: 10,
   *         fill: gradient
   *     })
   *     .poly([0,0, 100,50, 0,100])
   *     .stroke();
   * ```
   * @param {StrokeInput} args - The stroke style to apply
   * @returns The Graphics instance for chaining
   * @see {@link StrokeStyle} For stroke style options
   * @see {@link FillGradient} For gradient strokes
   * @see {@link FillPattern} For pattern strokes
   */
  setStrokeStyle(...args) {
    return this._callContextMethod("setStrokeStyle", args);
  }
  fill(...args) {
    return this._callContextMethod("fill", args);
  }
  /**
   * Strokes the current path with the current stroke style or specified style.
   * Outlines the shape using the stroke settings.
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Stroke with direct color
   * graphics
   *     .circle(50, 50, 25)
   *     .stroke({
   *         width: 2,
   *         color: 0xff0000
   *     }); // 2px red stroke
   *
   * // Fill with texture
   * graphics
   *    .rect(0, 0, 100, 100)
   *    .stroke(myTexture); // Fill with texture
   *
   * // Stroke with gradient
   * const gradient = new FillGradient({
   *     end: { x: 1, y: 0 },
   *     colorStops: [
   *         { offset: 0, color: 0xff0000 },
   *         { offset: 0.5, color: 0x00ff00 },
   *         { offset: 1, color: 0x0000ff },
   *     ],
   * });
   *
   * graphics
   *     .rect(0, 0, 100, 100)
   *     .stroke({
   *         width: 4,
   *         fill: gradient,
   *         alignment: 0.5,
   *         join: 'round'
   *     });
   * ```
   * @param {StrokeStyle} args - Optional stroke style to apply. Can be:
   * - A stroke style object with width, color, etc.
   * - A gradient
   * - A pattern
   * If omitted, uses current stroke style.
   * @returns The Graphics instance for chaining
   * @see {@link StrokeStyle} For stroke style options
   * @see {@link FillGradient} For gradient strokes
   * @see {@link setStrokeStyle} For setting default stroke style
   */
  stroke(...args) {
    return this._callContextMethod("stroke", args);
  }
  texture(...args) {
    return this._callContextMethod("texture", args);
  }
  /**
   * Resets the current path. Any previous path and its commands are discarded and a new path is
   * started. This is typically called before beginning a new shape or series of drawing commands.
   * @example
   * ```ts
   * const graphics = new Graphics();
   * graphics
   *     .circle(150, 150, 50)
   *     .fill({ color: 0x00ff00 })
   *     .beginPath() // Starts a new path
   *     .circle(250, 150, 50)
   *     .fill({ color: 0x0000ff });
   * ```
   * @returns The Graphics instance for chaining
   * @see {@link Graphics#moveTo} For starting a new subpath
   * @see {@link Graphics#closePath} For closing the current path
   */
  beginPath() {
    return this._callContextMethod("beginPath", []);
  }
  /**
   * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by
   * subtracting a path from the previously drawn path.
   *
   * If a hole is not completely in a shape, it will fail to cut correctly.
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Draw outer circle
   * graphics
   *     .circle(100, 100, 50)
   *     .fill({ color: 0xff0000 });
   *     .circle(100, 100, 25) // Inner circle
   *     .cut() // Cuts out the inner circle from the outer circle
   * ```
   */
  cut() {
    return this._callContextMethod("cut", []);
  }
  arc(...args) {
    return this._callContextMethod("arc", args);
  }
  arcTo(...args) {
    return this._callContextMethod("arcTo", args);
  }
  arcToSvg(...args) {
    return this._callContextMethod("arcToSvg", args);
  }
  bezierCurveTo(...args) {
    return this._callContextMethod("bezierCurveTo", args);
  }
  /**
   * Closes the current path by drawing a straight line back to the start point.
   *
   * This is useful for completing shapes and ensuring they are properly closed for fills.
   * @example
   * ```ts
   * // Create a triangle with closed path
   * const graphics = new Graphics();
   * graphics
   *     .moveTo(50, 50)
   *     .lineTo(100, 100)
   *     .lineTo(0, 100)
   *     .closePath()
   * ```
   * @returns The Graphics instance for method chaining
   * @see {@link Graphics#beginPath} For starting a new path
   * @see {@link Graphics#fill} For filling closed paths
   * @see {@link Graphics#stroke} For stroking paths
   */
  closePath() {
    return this._callContextMethod("closePath", []);
  }
  ellipse(...args) {
    return this._callContextMethod("ellipse", args);
  }
  circle(...args) {
    return this._callContextMethod("circle", args);
  }
  path(...args) {
    return this._callContextMethod("path", args);
  }
  lineTo(...args) {
    return this._callContextMethod("lineTo", args);
  }
  moveTo(...args) {
    return this._callContextMethod("moveTo", args);
  }
  quadraticCurveTo(...args) {
    return this._callContextMethod("quadraticCurveTo", args);
  }
  rect(...args) {
    return this._callContextMethod("rect", args);
  }
  roundRect(...args) {
    return this._callContextMethod("roundRect", args);
  }
  poly(...args) {
    return this._callContextMethod("poly", args);
  }
  regularPoly(...args) {
    return this._callContextMethod("regularPoly", args);
  }
  roundPoly(...args) {
    return this._callContextMethod("roundPoly", args);
  }
  roundShape(...args) {
    return this._callContextMethod("roundShape", args);
  }
  filletRect(...args) {
    return this._callContextMethod("filletRect", args);
  }
  chamferRect(...args) {
    return this._callContextMethod("chamferRect", args);
  }
  star(...args) {
    return this._callContextMethod("star", args);
  }
  svg(...args) {
    return this._callContextMethod("svg", args);
  }
  restore(...args) {
    return this._callContextMethod("restore", args);
  }
  /**
   * Saves the current graphics state onto a stack. The state includes:
   * - Current transformation matrix
   * - Current fill style
   * - Current stroke style
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Save state before complex operations
   * graphics.save();
   *
   * // Create transformed and styled shape
   * graphics
   *     .translateTransform(100, 100)
   *     .rotateTransform(Math.PI / 4)
   *     .setFillStyle({
   *         color: 0xff0000,
   *         alpha: 0.5
   *     })
   *     .rect(-25, -25, 50, 50)
   *     .fill();
   *
   * // Restore to original state
   * graphics.restore();
   *
   * // Continue drawing with previous state
   * graphics
   *     .circle(50, 50, 25)
   *     .fill();
   * ```
   * @returns The Graphics instance for method chaining
   * @see {@link Graphics#restore} For restoring the saved state
   * @see {@link Graphics#setTransform} For setting transformations
   */
  save() {
    return this._callContextMethod("save", []);
  }
  /**
   * Returns the current transformation matrix of the graphics context.
   * This matrix represents all accumulated transformations including translate, scale, and rotate.
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Apply some transformations
   * graphics
   *     .translateTransform(100, 100)
   *     .rotateTransform(Math.PI / 4);
   *
   * // Get the current transform matrix
   * const matrix = graphics.getTransform();
   * console.log(matrix.tx, matrix.ty); // 100, 100
   *
   * // Use the matrix for other operations
   * graphics
   *     .setTransform(matrix)
   *     .circle(0, 0, 50)
   *     .fill({ color: 0xff0000 });
   * ```
   * @returns The current transformation matrix.
   * @see {@link Graphics#setTransform} For setting the transform matrix
   * @see {@link Matrix} For matrix operations
   */
  getTransform() {
    return this.context.getTransform();
  }
  /**
   * Resets the current transformation matrix to the identity matrix, effectively removing
   * any transformations (rotation, scaling, translation) previously applied.
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Apply transformations
   * graphics
   *     .translateTransform(100, 100)
   *     .scaleTransform(2, 2)
   *     .circle(0, 0, 25)
   *     .fill({ color: 0xff0000 });
   * // Reset transform to default state
   * graphics
   *     .resetTransform()
   *     .circle(50, 50, 25) // Will draw at actual coordinates
   *     .fill({ color: 0x00ff00 });
   * ```
   * @returns The Graphics instance for method chaining
   * @see {@link Graphics#getTransform} For getting the current transform
   * @see {@link Graphics#setTransform} For setting a specific transform
   * @see {@link Graphics#save} For saving the current transform state
   * @see {@link Graphics#restore} For restoring a previous transform state
   */
  resetTransform() {
    return this._callContextMethod("resetTransform", []);
  }
  rotateTransform(...args) {
    return this._callContextMethod("rotate", args);
  }
  scaleTransform(...args) {
    return this._callContextMethod("scale", args);
  }
  setTransform(...args) {
    return this._callContextMethod("setTransform", args);
  }
  transform(...args) {
    return this._callContextMethod("transform", args);
  }
  translateTransform(...args) {
    return this._callContextMethod("translate", args);
  }
  /**
   * Clears all drawing commands from the graphics context, effectively resetting it.
   * This includes clearing the current path, fill style, stroke style, and transformations.
   *
   * > [!NOTE] Graphics objects are not designed to be continuously cleared and redrawn.
   * > Instead, they are intended to be used for static or semi-static graphics that
   * > can be redrawn as needed. Frequent clearing and redrawing may lead to performance issues.
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Draw some shapes
   * graphics
   *     .circle(100, 100, 50)
   *     .fill({ color: 0xff0000 })
   *     .rect(200, 100, 100, 50)
   *     .fill({ color: 0x00ff00 });
   *
   * // Clear all graphics
   * graphics.clear();
   *
   * // Start fresh with new shapes
   * graphics
   *     .circle(150, 150, 30)
   *     .fill({ color: 0x0000ff });
   * ```
   * @returns The Graphics instance for method chaining
   * @see {@link Graphics#beginPath} For starting a new path without clearing styles
   * @see {@link Graphics#save} For saving the current state
   * @see {@link Graphics#restore} For restoring a previous state
   */
  clear() {
    return this._callContextMethod("clear", []);
  }
  /**
   * Gets or sets the current fill style for the graphics context. The fill style determines
   * how shapes are filled when using the fill() method.
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Basic color fill
   * graphics.fillStyle = {
   *     color: 0xff0000,  // Red
   *     alpha: 1
   * };
   *
   * // Using gradients
   * const gradient = new FillGradient({
   *     end: { x: 0, y: 1 }, // Vertical gradient
   *     stops: [
   *         { offset: 0, color: 0xff0000, alpha: 1 }, // Start color
   *         { offset: 1, color: 0x0000ff, alpha: 1 }  // End color
   *     ]
   * });
   *
   * graphics.fillStyle = {
   *     fill: gradient,
   *     alpha: 0.8
   * };
   *
   * // Using patterns
   * graphics.fillStyle = {
   *     texture: myTexture,
   *     alpha: 1,
   *     matrix: new Matrix()
   *         .scale(0.5, 0.5)
   *         .rotate(Math.PI / 4)
   * };
   * ```
   * @type {ConvertedFillStyle}
   * @see {@link FillStyle} For all available fill style options
   * @see {@link FillGradient} For creating gradient fills
   * @see {@link Graphics#fill} For applying the fill to paths
   */
  get fillStyle() {
    return this._context.fillStyle;
  }
  set fillStyle(value2) {
    this._context.fillStyle = value2;
  }
  /**
   * Gets or sets the current stroke style for the graphics context. The stroke style determines
   * how paths are outlined when using the stroke() method.
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Basic stroke style
   * graphics.strokeStyle = {
   *     width: 2,
   *     color: 0xff0000,
   *     alpha: 1
   * };
   *
   * // Using with gradients
   * const gradient = new FillGradient({
   *   end: { x: 0, y: 1 },
   *   stops: [
   *       { offset: 0, color: 0xff0000, alpha: 1 },
   *       { offset: 1, color: 0x0000ff, alpha: 1 }
   *   ]
   * });
   *
   * graphics.strokeStyle = {
   *     width: 4,
   *     fill: gradient,
   *     alignment: 0.5,
   *     join: 'round',
   *     cap: 'round'
   * };
   *
   * // Complex stroke settings
   * graphics.strokeStyle = {
   *     width: 6,
   *     color: 0x00ff00,
   *     alpha: 0.5,
   *     join: 'miter',
   *     miterLimit: 10,
   * };
   * ```
   * @see {@link StrokeStyle} For all available stroke style options
   * @see {@link Graphics#stroke} For applying the stroke to paths
   */
  get strokeStyle() {
    return this._context.strokeStyle;
  }
  set strokeStyle(value2) {
    this._context.strokeStyle = value2;
  }
  /**
   * Creates a new Graphics object that copies the current graphics content.
   * The clone can either share the same context (shallow clone) or have its own independent
   * context (deep clone).
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Create original graphics content
   * graphics
   *     .circle(100, 100, 50)
   *     .fill({ color: 0xff0000 });
   *
   * // Create a shallow clone (shared context)
   * const shallowClone = graphics.clone();
   *
   * // Changes to original affect the clone
   * graphics
   *     .circle(200, 100, 30)
   *     .fill({ color: 0x00ff00 });
   *
   * // Create a deep clone (independent context)
   * const deepClone = graphics.clone(true);
   *
   * // Modify deep clone independently
   * deepClone
   *     .translateTransform(100, 100)
   *     .circle(0, 0, 40)
   *     .fill({ color: 0x0000ff });
   * ```
   * @param deep - Whether to create a deep clone of the graphics object.
   *              If false (default), the context will be shared between objects.
   *              If true, creates an independent copy of the context.
   * @returns A new Graphics instance with either shared or copied context
   * @see {@link Graphics#context} For accessing the underlying graphics context
   * @see {@link GraphicsContext} For understanding the shared context behavior
   */
  clone(deep = false) {
    if (deep) {
      return new Graphics(this._context.clone());
    }
    this._ownedContext = null;
    const clone = new Graphics(this._context);
    return clone;
  }
  // -------- v7 deprecations ---------
  /**
   * @param width
   * @param color
   * @param alpha
   * @deprecated since 8.0.0 Use {@link Graphics#setStrokeStyle} instead
   */
  lineStyle(width, color, alpha) {
    deprecation(v8_0_0, "Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.");
    const strokeStyle = {};
    width && (strokeStyle.width = width);
    color && (strokeStyle.color = color);
    alpha && (strokeStyle.alpha = alpha);
    this.context.strokeStyle = strokeStyle;
    return this;
  }
  /**
   * @param color
   * @param alpha
   * @deprecated since 8.0.0 Use {@link Graphics#fill} instead
   */
  beginFill(color, alpha) {
    deprecation(v8_0_0, "Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");
    const fillStyle = {};
    if (color !== void 0)
      fillStyle.color = color;
    if (alpha !== void 0)
      fillStyle.alpha = alpha;
    this.context.fillStyle = fillStyle;
    return this;
  }
  /**
   * @deprecated since 8.0.0 Use {@link Graphics#fill} instead
   */
  endFill() {
    deprecation(v8_0_0, "Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");
    this.context.fill();
    const strokeStyle = this.context.strokeStyle;
    if (strokeStyle.width !== GraphicsContext.defaultStrokeStyle.width || strokeStyle.color !== GraphicsContext.defaultStrokeStyle.color || strokeStyle.alpha !== GraphicsContext.defaultStrokeStyle.alpha) {
      this.context.stroke();
    }
    return this;
  }
  /**
   * @param {...any} args
   * @deprecated since 8.0.0 Use {@link Graphics#circle} instead
   */
  drawCircle(...args) {
    deprecation(v8_0_0, "Graphics#drawCircle has been renamed to Graphics#circle");
    return this._callContextMethod("circle", args);
  }
  /**
   * @param {...any} args
   * @deprecated since 8.0.0 Use {@link Graphics#ellipse} instead
   */
  drawEllipse(...args) {
    deprecation(v8_0_0, "Graphics#drawEllipse has been renamed to Graphics#ellipse");
    return this._callContextMethod("ellipse", args);
  }
  /**
   * @param {...any} args
   * @deprecated since 8.0.0 Use {@link Graphics#poly} instead
   */
  drawPolygon(...args) {
    deprecation(v8_0_0, "Graphics#drawPolygon has been renamed to Graphics#poly");
    return this._callContextMethod("poly", args);
  }
  /**
   * @param {...any} args
   * @deprecated since 8.0.0 Use {@link Graphics#rect} instead
   */
  drawRect(...args) {
    deprecation(v8_0_0, "Graphics#drawRect has been renamed to Graphics#rect");
    return this._callContextMethod("rect", args);
  }
  /**
   * @param {...any} args
   * @deprecated since 8.0.0 Use {@link Graphics#roundRect} instead
   */
  drawRoundedRect(...args) {
    deprecation(v8_0_0, "Graphics#drawRoundedRect has been renamed to Graphics#roundRect");
    return this._callContextMethod("roundRect", args);
  }
  /**
   * @param {...any} args
   * @deprecated since 8.0.0 Use {@link Graphics#star} instead
   */
  drawStar(...args) {
    deprecation(v8_0_0, "Graphics#drawStar has been renamed to Graphics#star");
    return this._callContextMethod("star", args);
  }
}
class AnimatedSprite extends Sprite {
  constructor(...args) {
    let options = args[0];
    if (Array.isArray(args[0])) {
      options = {
        textures: args[0],
        autoUpdate: args[1]
      };
    }
    const {
      animationSpeed = 1,
      autoPlay = false,
      autoUpdate = true,
      loop = true,
      onComplete = null,
      onFrameChange = null,
      onLoop = null,
      textures,
      updateAnchor = false,
      ...rest
    } = options;
    const [firstFrame] = textures;
    super({
      ...rest,
      texture: firstFrame instanceof Texture ? firstFrame : firstFrame.texture
    });
    this._textures = null;
    this._durations = null;
    this._autoUpdate = autoUpdate;
    this._isConnectedToTicker = false;
    this.animationSpeed = animationSpeed;
    this.loop = loop;
    this.updateAnchor = updateAnchor;
    this.onComplete = onComplete;
    this.onFrameChange = onFrameChange;
    this.onLoop = onLoop;
    this._currentTime = 0;
    this._playing = false;
    this._previousFrame = null;
    this.textures = textures;
    if (autoPlay) {
      this.play();
    }
  }
  /**
   * Stops the animation playback and freezes the current frame.
   * Does not reset the current frame or animation progress.
   * @example
   * ```ts
   * // Create an animated sprite
   * const sprite = new AnimatedSprite({
   *     textures: [
   *         Texture.from('walk1.png'),
   *         Texture.from('walk2.png'),
   *         Texture.from('walk3.png')
   *     ],
   *     autoPlay: true
   * });
   *
   * // Stop at current frame
   * sprite.stop();
   *
   * // Stop at specific frame
   * sprite.gotoAndStop(1); // Stops at second frame
   *
   * // Stop and reset
   * sprite.stop();
   * sprite.currentFrame = 0;
   *
   * // Stop with completion check
   * if (sprite.playing) {
   *     sprite.stop();
   *     sprite.onComplete?.();
   * }
   * ```
   * @see {@link AnimatedSprite#play} For starting playback
   * @see {@link AnimatedSprite#gotoAndStop} For stopping at a specific frame
   * @see {@link AnimatedSprite#playing} For checking play state
   */
  stop() {
    if (!this._playing) {
      return;
    }
    this._playing = false;
    if (this._autoUpdate && this._isConnectedToTicker) {
      Ticker.shared.remove(this.update, this);
      this._isConnectedToTicker = false;
    }
  }
  /**
   * Starts or resumes the animation playback.
   * If the animation was previously stopped, it will continue from where it left off.
   * @example
   * ```ts
   * // Basic playback
   * const sprite = new AnimatedSprite({
   *     textures: [
   *         Texture.from('walk1.png'),
   *         Texture.from('walk2.png'),
   *     ],
   *     autoPlay: false
   * });
   * sprite.play();
   *
   * // Play after stopping
   * sprite.stop();
   * sprite.currentFrame = 0; // Reset to start
   * sprite.play(); // Play from beginning
   *
   * // Play with auto-update disabled
   * sprite.autoUpdate = false;
   * sprite.play();
   * app.ticker.add(() => {
   *     sprite.update(app.ticker); // Manual updates
   * });
   * ```
   * @see {@link AnimatedSprite#stop} For stopping playback
   * @see {@link AnimatedSprite#gotoAndPlay} For playing from a specific frame
   * @see {@link AnimatedSprite#playing} For checking play state
   */
  play() {
    if (this._playing) {
      return;
    }
    this._playing = true;
    if (this._autoUpdate && !this._isConnectedToTicker) {
      Ticker.shared.add(this.update, this, UPDATE_PRIORITY.HIGH);
      this._isConnectedToTicker = true;
    }
  }
  /**
   * Stops the AnimatedSprite and sets it to a specific frame.
   * @example
   * ```ts
   * // Create an animated sprite
   * const sprite = new AnimatedSprite({
   *     textures: [
   *         Texture.from('walk1.png'),
   *         Texture.from('walk2.png'),
   *         Texture.from('walk3.png'),
   *     ]
   * });
   *
   * // Go to specific frames
   * sprite.gotoAndStop(0);  // First frame
   * sprite.gotoAndStop(2);  // Third frame
   *
   * // Jump to last frame
   * sprite.gotoAndStop(sprite.totalFrames - 1);
   * ```
   * @param frameNumber - Frame index to stop at (0-based)
   * @throws {Error} If frameNumber is out of bounds
   * @see {@link AnimatedSprite#gotoAndPlay} For going to a frame and playing
   * @see {@link AnimatedSprite#currentFrame} For getting/setting current frame
   * @see {@link AnimatedSprite#totalFrames} For total number of frames
   */
  gotoAndStop(frameNumber) {
    this.stop();
    this.currentFrame = frameNumber;
  }
  /**
   * Goes to a specific frame and begins playing the AnimatedSprite from that point.
   * Combines frame navigation and playback start in one operation.
   * @example
   * ```ts
   * // Start from specific frame
   * sprite.gotoAndPlay(1); // Starts playing from second frame
   * ```
   * @param frameNumber - Frame index to start playing from (0-based)
   * @throws {Error} If frameNumber is out of bounds
   * @see {@link AnimatedSprite#gotoAndStop} For going to a frame without playing
   * @see {@link AnimatedSprite#play} For playing from current frame
   * @see {@link AnimatedSprite#currentFrame} For getting/setting current frame
   */
  gotoAndPlay(frameNumber) {
    this.currentFrame = frameNumber;
    this.play();
  }
  /**
   * Updates the object transform for rendering. This method handles animation timing, frame updates,
   * and manages looping behavior.
   * @example
   * ```ts
   * // Create an animated sprite with manual updates
   * const sprite = new AnimatedSprite({
   *     textures: [
   *         Texture.from('frame1.png'),
   *         Texture.from('frame2.png'),
   *         Texture.from('frame3.png')
   *     ],
   *     autoUpdate: false // Disable automatic updates
   * });
   *
   * // Manual update with app ticker
   * app.ticker.add((ticker) => {
   *     sprite.update(ticker);
   * });
   * ```
   * @param ticker - The ticker to use for updating the animation timing
   * @see {@link AnimatedSprite#autoUpdate} For controlling automatic updates
   * @see {@link AnimatedSprite#animationSpeed} For controlling animation speed
   * @see {@link Ticker} For timing system details
   */
  update(ticker) {
    if (!this._playing) {
      return;
    }
    const deltaTime = ticker.deltaTime;
    const elapsed = this.animationSpeed * deltaTime;
    const previousFrame = this.currentFrame;
    if (this._durations !== null) {
      let lag = this._currentTime % 1 * this._durations[this.currentFrame];
      lag += elapsed / 60 * 1e3;
      while (lag < 0) {
        this._currentTime--;
        lag += this._durations[this.currentFrame];
      }
      const sign2 = Math.sign(this.animationSpeed * deltaTime);
      this._currentTime = Math.floor(this._currentTime);
      while (lag >= this._durations[this.currentFrame]) {
        lag -= this._durations[this.currentFrame] * sign2;
        this._currentTime += sign2;
      }
      this._currentTime += lag / this._durations[this.currentFrame];
    } else {
      this._currentTime += elapsed;
    }
    if (this._currentTime < 0 && !this.loop) {
      this.gotoAndStop(0);
      if (this.onComplete) {
        this.onComplete();
      }
    } else if (this._currentTime >= this._textures.length && !this.loop) {
      this.gotoAndStop(this._textures.length - 1);
      if (this.onComplete) {
        this.onComplete();
      }
    } else if (previousFrame !== this.currentFrame) {
      if (this.loop && this.onLoop) {
        if (this.animationSpeed > 0 && this.currentFrame < previousFrame || this.animationSpeed < 0 && this.currentFrame > previousFrame) {
          this.onLoop();
        }
      }
      this._updateTexture();
    }
  }
  /** Updates the displayed texture to match the current frame index. */
  _updateTexture() {
    const currentFrame = this.currentFrame;
    if (this._previousFrame === currentFrame) {
      return;
    }
    this._previousFrame = currentFrame;
    this.texture = this._textures[currentFrame];
    if (this.updateAnchor && this.texture.defaultAnchor) {
      this.anchor.copyFrom(this.texture.defaultAnchor);
    }
    if (this.onFrameChange) {
      this.onFrameChange(this.currentFrame);
    }
  }
  /**
   * Stops the AnimatedSprite and destroys it.
   * This method stops the animation playback, removes it from the ticker,
   * and cleans up any resources associated with the sprite.
   * @param options - Options for destroying the sprite, such as whether to remove from parent
   * @example
   * ```ts
   * // Destroy the sprite when done
   * sprite.destroy();
   * // Or with options
   * sprite.destroy({ children: true, texture: true, textureSource: true });
   * ```
   */
  destroy(options = false) {
    const destroyTexture = typeof options === "boolean" ? options : options == null ? void 0 : options.texture;
    if (destroyTexture) {
      const destroyTextureSource = typeof options === "boolean" ? options : options == null ? void 0 : options.textureSource;
      this._textures.forEach((texture) => {
        if (this.texture !== texture) {
          texture.destroy(destroyTextureSource);
        }
      });
    }
    this._textures = [];
    this._durations = null;
    this.stop();
    super.destroy(options);
    this.onComplete = null;
    this.onFrameChange = null;
    this.onLoop = null;
  }
  /**
   * A short hand way of creating an AnimatedSprite from an array of frame ids.
   * Uses texture frames from the cache to create an animation sequence.
   * @example
   * ```ts
   * // Create from frame IDs
   * const frameIds = [
   *     'walk_001.png',
   *     'walk_002.png',
   *     'walk_003.png'
   * ];
   *
   * const walkingAnimation = AnimatedSprite.fromFrames(frameIds);
   * walkingAnimation.play();
   * ```
   * @param frames - The array of frame ids to use for the animation
   * @returns A new animated sprite using the frames
   * @see {@link Texture.from} For texture creation from frames
   * @see {@link Spritesheet} For loading spritesheets
   */
  static fromFrames(frames) {
    const textures = [];
    for (let i2 = 0; i2 < frames.length; ++i2) {
      textures.push(Texture.from(frames[i2]));
    }
    return new AnimatedSprite(textures);
  }
  /**
   * A short hand way of creating an AnimatedSprite from an array of image urls.
   * Each image will be used as a frame in the animation.
   * @example
   * ```ts
   * // Create from image URLs
   * const images = [
   *     'assets/walk1.png',
   *     'assets/walk2.png',
   *     'assets/walk3.png'
   * ];
   *
   * const walkingSprite = AnimatedSprite.fromImages(images);
   * walkingSprite.play();
   * ```
   * @param images - The array of image urls to use as frames
   * @returns A new animated sprite using the images as frames
   * @see {@link Assets} For asset loading and management
   * @see {@link Texture.from} For texture creation from images
   */
  static fromImages(images) {
    const textures = [];
    for (let i2 = 0; i2 < images.length; ++i2) {
      textures.push(Texture.from(images[i2]));
    }
    return new AnimatedSprite(textures);
  }
  /**
   * The total number of frames in the AnimatedSprite. This is the same as number of textures
   * assigned to the AnimatedSprite.
   * @example
   * ```ts
   * // Create an animated sprite
   * const sprite = new AnimatedSprite({
   *     textures: [
   *         Texture.from('frame1.png'),
   *         Texture.from('frame2.png'),
   *         Texture.from('frame3.png')
   *     ]
   * });
   *
   * // Get total frames
   * console.log(sprite.totalFrames); // Outputs: 3
   *
   * // Use with frame navigation
   * sprite.gotoAndStop(sprite.totalFrames - 1); // Go to last frame
   * ```
   * @readonly
   * @see {@link AnimatedSprite#currentFrame} For the current frame index
   * @see {@link AnimatedSprite#textures} For the array of textures
   * @returns {number} The total number of frames
   */
  get totalFrames() {
    return this._textures.length;
  }
  /**
   * The array of textures or frame objects used for the animation sequence.
   * Can be set to either an array of Textures or an array of FrameObjects with custom timing.
   * @example
   * ```ts
   * // Update textures at runtime
   * sprite.textures = [
   *     Texture.from('run1.png'),
   *     Texture.from('run2.png')
   * ];
   *
   * // Use custom frame timing
   * sprite.textures = [
   *     { texture: Texture.from('explosion1.png'), time: 100 },
   *     { texture: Texture.from('explosion2.png'), time: 200 },
   *     { texture: Texture.from('explosion3.png'), time: 300 }
   * ];
   *
   * // Use with spritesheet
   * const sheet = await Assets.load('animations.json');
   * sprite.textures = sheet.animations['walk'];
   * ```
   * @type {AnimatedSpriteFrames}
   * @see {@link FrameObject} For frame timing options
   * @see {@link Spritesheet} For loading from spritesheets
   */
  get textures() {
    return this._textures;
  }
  set textures(value2) {
    if (value2[0] instanceof Texture) {
      this._textures = value2;
      this._durations = null;
    } else {
      this._textures = [];
      this._durations = [];
      for (let i2 = 0; i2 < value2.length; i2++) {
        this._textures.push(value2[i2].texture);
        this._durations.push(value2[i2].time);
      }
    }
    this._previousFrame = null;
    this.gotoAndStop(0);
    this._updateTexture();
  }
  /**
   * Gets or sets the current frame index of the animation.
   * When setting, the value will be clamped between 0 and totalFrames - 1.
   * @example
   * ```ts
   * // Create an animated sprite
   * const sprite = new AnimatedSprite({
   *     textures: [
   *         Texture.from('walk1.png'),
   *         Texture.from('walk2.png'),
   *         Texture.from('walk3.png')
   *     ]
   * });
   *
   * // Get current frame
   * console.log(sprite.currentFrame); // 0
   *
   * // Set specific frame
   * sprite.currentFrame = 1; // Show second frame
   *
   * // Use with frame callbacks
   * sprite.onFrameChange = (frame) => {
   *     console.log(`Now showing frame: ${frame}`);
   * };
   * sprite.currentFrame = 2;
   * ```
   * @throws {Error} If attempting to set a frame index out of bounds
   * @see {@link AnimatedSprite#totalFrames} For the total number of frames
   * @see {@link AnimatedSprite#gotoAndPlay} For playing from a specific frame
   * @see {@link AnimatedSprite#gotoAndStop} For stopping at a specific frame
   */
  get currentFrame() {
    let currentFrame = Math.floor(this._currentTime) % this._textures.length;
    if (currentFrame < 0) {
      currentFrame += this._textures.length;
    }
    return currentFrame;
  }
  set currentFrame(value2) {
    if (value2 < 0 || value2 > this.totalFrames - 1) {
      throw new Error(`[AnimatedSprite]: Invalid frame index value ${value2}, expected to be between 0 and totalFrames ${this.totalFrames}.`);
    }
    const previousFrame = this.currentFrame;
    this._currentTime = value2;
    if (previousFrame !== this.currentFrame) {
      this._updateTexture();
    }
  }
  /**
   * Indicates if the AnimatedSprite is currently playing.
   * This is a read-only property that reflects the current playback state.
   * @example
   * ```ts
   * // Check if animation is playing
   * console.log('Playing:', sprite.playing); // true
   *
   * // Use with play control
   * if (!sprite.playing) {
   *     sprite.play();
   * }
   * ```
   * @readonly
   * @returns {boolean} True if the animation is currently playing
   * @see {@link AnimatedSprite#play} For starting playback
   * @see {@link AnimatedSprite#stop} For stopping playback
   * @see {@link AnimatedSprite#loop} For controlling looping behavior
   */
  get playing() {
    return this._playing;
  }
  /**
   * Controls whether the animation automatically updates using the shared ticker.
   * When enabled, the animation will update on each frame. When disabled, you must
   * manually call update() to advance the animation.
   * @example
   * ```ts
   * // Create sprite with auto-update disabled
   * const sprite = new AnimatedSprite({
   *     textures: [],
   *     autoUpdate: false
   * });
   *
   * // Manual update with app ticker
   * app.ticker.add((ticker) => {
   *     sprite.update(ticker);
   * });
   *
   * // Enable auto-update later
   * sprite.autoUpdate = true;
   * ```
   * @default true
   * @see {@link AnimatedSprite#update} For manual animation updates
   * @see {@link Ticker} For the timing system
   */
  get autoUpdate() {
    return this._autoUpdate;
  }
  set autoUpdate(value2) {
    if (value2 !== this._autoUpdate) {
      this._autoUpdate = value2;
      if (!this._autoUpdate && this._isConnectedToTicker) {
        Ticker.shared.remove(this.update, this);
        this._isConnectedToTicker = false;
      } else if (this._autoUpdate && !this._isConnectedToTicker && this._playing) {
        Ticker.shared.add(this.update, this);
        this._isConnectedToTicker = true;
      }
    }
  }
}
class Transform {
  /**
   * @param options - Options for the transform.
   * @param options.matrix - The matrix to use.
   * @param options.observer - The observer to use.
   */
  constructor({ matrix, observer } = {}) {
    this.dirty = true;
    this._matrix = matrix ?? new Matrix();
    this.observer = observer;
    this.position = new ObservablePoint(this, 0, 0);
    this.scale = new ObservablePoint(this, 1, 1);
    this.pivot = new ObservablePoint(this, 0, 0);
    this.skew = new ObservablePoint(this, 0, 0);
    this._rotation = 0;
    this._cx = 1;
    this._sx = 0;
    this._cy = 0;
    this._sy = 1;
  }
  /**
   * The transformation matrix computed from the transform's properties.
   * Combines position, scale, rotation, skew, and pivot into a single matrix.
   * @example
   * ```ts
   * // Get current matrix
   * const matrix = transform.matrix;
   * console.log(matrix.toString());
   * ```
   * @readonly
   * @see {@link Matrix} For matrix operations
   * @see {@link Transform.setFromMatrix} For setting transform from matrix
   */
  get matrix() {
    const lt = this._matrix;
    if (!this.dirty)
      return lt;
    lt.a = this._cx * this.scale.x;
    lt.b = this._sx * this.scale.x;
    lt.c = this._cy * this.scale.y;
    lt.d = this._sy * this.scale.y;
    lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
    lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);
    this.dirty = false;
    return lt;
  }
  /**
   * Called when a value changes.
   * @param point
   * @internal
   */
  _onUpdate(point) {
    var _a;
    this.dirty = true;
    if (point === this.skew) {
      this.updateSkew();
    }
    (_a = this.observer) == null ? void 0 : _a._onUpdate(this);
  }
  /** Called when the skew or the rotation changes. */
  updateSkew() {
    this._cx = Math.cos(this._rotation + this.skew.y);
    this._sx = Math.sin(this._rotation + this.skew.y);
    this._cy = -Math.sin(this._rotation - this.skew.x);
    this._sy = Math.cos(this._rotation - this.skew.x);
    this.dirty = true;
  }
  toString() {
    return `[pixi.js/math:Transform position=(${this.position.x}, ${this.position.y}) rotation=${this.rotation} scale=(${this.scale.x}, ${this.scale.y}) skew=(${this.skew.x}, ${this.skew.y}) ]`;
  }
  /**
   * Decomposes a matrix and sets the transforms properties based on it.
   * @example
   * ```ts
   * // Basic matrix decomposition
   * const transform = new Transform();
   * const matrix = new Matrix()
   *     .translate(100, 100)
   *     .rotate(Math.PI / 4)
   *     .scale(2, 2);
   *
   * transform.setFromMatrix(matrix);
   * console.log(transform.position.x); // 100
   * console.log(transform.rotation); // ~0.785 (/4)
   * ```
   * @param matrix - The matrix to decompose
   * @see {@link Matrix#decompose} For the decomposition logic
   * @see {@link Transform#matrix} For getting the current matrix
   */
  setFromMatrix(matrix) {
    matrix.decompose(this);
    this.dirty = true;
  }
  /**
   * The rotation of the object in radians.
   * @example
   * ```ts
   * // Basic rotation
   * transform.rotation = Math.PI / 4; // 45 degrees
   *
   * // Rotate around pivot point
   * transform.pivot.set(50, 50);
   * transform.rotation = Math.PI; // 180 degrees around pivot
   *
   * // Animate rotation
   * app.ticker.add(() => {
   *     transform.rotation += 0.1;
   * });
   * ```
   * @see {@link Transform#pivot} For rotation point
   * @see {@link Transform#skew} For skew effects
   */
  get rotation() {
    return this._rotation;
  }
  set rotation(value2) {
    if (this._rotation !== value2) {
      this._rotation = value2;
      this._onUpdate(this.skew);
    }
  }
}
const _TilingSprite = class _TilingSprite2 extends ViewContainer {
  constructor(...args) {
    let options = args[0] || {};
    if (options instanceof Texture) {
      options = { texture: options };
    }
    if (args.length > 1) {
      deprecation(v8_0_0, "use new TilingSprite({ texture, width:100, height:100 }) instead");
      options.width = args[1];
      options.height = args[2];
    }
    options = { ..._TilingSprite2.defaultOptions, ...options };
    const {
      texture,
      anchor: anchor2,
      tilePosition,
      tileScale,
      tileRotation,
      width,
      height,
      applyAnchorToTexture,
      roundPixels,
      ...rest
    } = options ?? {};
    super({
      label: "TilingSprite",
      ...rest
    });
    this.renderPipeId = "tilingSprite";
    this.batched = true;
    this.allowChildren = false;
    this._anchor = new ObservablePoint(
      {
        _onUpdate: () => {
          this.onViewUpdate();
        }
      }
    );
    this.applyAnchorToTexture = applyAnchorToTexture;
    this.texture = texture;
    this._width = width ?? texture.width;
    this._height = height ?? texture.height;
    this._tileTransform = new Transform({
      observer: {
        _onUpdate: () => this.onViewUpdate()
      }
    });
    if (anchor2)
      this.anchor = anchor2;
    this.tilePosition = tilePosition;
    this.tileScale = tileScale;
    this.tileRotation = tileRotation;
    this.roundPixels = roundPixels ?? false;
  }
  /**
   * Creates a new tiling sprite based on a source texture or image path.
   * This is a convenience method that automatically creates and manages textures.
   * @example
   * ```ts
   * // Create a new tiling sprite from an image path
   * const pattern = TilingSprite.from('pattern.png');
   * pattern.width = 300; // Set the width of the tiling area
   * pattern.height = 200; // Set the height of the tiling area
   *
   * // Create from options
   * const texture = Texture.from('pattern.png');
   * const pattern = TilingSprite.from(texture, {
   *     width: 300,
   *     height: 200,
   *     tileScale: { x: 0.5, y: 0.5 }
   * });
   * ```
   * @param source - The source to create the sprite from. Can be a path to an image or a texture
   * @param options - Additional options for the tiling sprite
   * @returns A new tiling sprite based on the source
   * @see {@link Texture.from} For texture creation details
   * @see {@link Assets} For asset loading and management
   */
  static from(source2, options = {}) {
    if (typeof source2 === "string") {
      return new _TilingSprite2({
        texture: Cache.get(source2),
        ...options
      });
    }
    return new _TilingSprite2({
      texture: source2,
      ...options
    });
  }
  /**
   * @see {@link TilingSpriteOptions.applyAnchorToTexture}
   * @deprecated since 8.0.0
   * @advanced
   */
  get uvRespectAnchor() {
    deprecation(v8_0_0, "uvRespectAnchor is deprecated, please use applyAnchorToTexture instead");
    return this.applyAnchorToTexture;
  }
  /** @advanced */
  set uvRespectAnchor(value2) {
    deprecation(v8_0_0, "uvRespectAnchor is deprecated, please use applyAnchorToTexture instead");
    this.applyAnchorToTexture = value2;
  }
  /**
   * Changes frame clamping in corresponding textureMatrix
   * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas
   * @default 0.5
   * @type {number}
   * @advanced
   */
  get clampMargin() {
    return this._texture.textureMatrix.clampMargin;
  }
  /** @advanced */
  set clampMargin(value2) {
    this._texture.textureMatrix.clampMargin = value2;
  }
  /**
   * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}
   * and passed to the constructor.
   *
   * - The default is `(0,0)`, this means the sprite's origin is the top left.
   * - Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.
   * - Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.
   *
   * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.
   * @example
   * ```ts
   * // Center the anchor point
   * sprite.anchor = 0.5; // Sets both x and y to 0.5
   * sprite.position.set(400, 300); // Sprite will be centered at this position
   *
   * // Set specific x/y anchor points
   * sprite.anchor = {
   *     x: 1, // Right edge
   *     y: 0  // Top edge
   * };
   *
   * // Using individual coordinates
   * sprite.anchor.set(0.5, 1); // Center-bottom
   *
   * // For rotation around center
   * sprite.anchor.set(0.5);
   * sprite.rotation = Math.PI / 4; // 45 degrees around center
   *
   * // For scaling from center
   * sprite.anchor.set(0.5);
   * sprite.scale.set(2); // Scales from center point
   * ```
   */
  get anchor() {
    return this._anchor;
  }
  set anchor(value2) {
    typeof value2 === "number" ? this._anchor.set(value2) : this._anchor.copyFrom(value2);
  }
  /**
   * The offset of the tiling texture.
   * Used to scroll or position the repeated pattern.
   * @example
   * ```ts
   * // Offset the tiling pattern by 100 pixels in both x and y directions
   * tilingSprite.tilePosition = { x: 100, y: 100 };
   * ```
   * @default {x: 0, y: 0}
   */
  get tilePosition() {
    return this._tileTransform.position;
  }
  set tilePosition(value2) {
    this._tileTransform.position.copyFrom(value2);
  }
  /**
   * Scale of the tiling texture.
   * Affects the size of each repeated instance of the texture.
   * @example
   * ```ts
   * // Scale the texture by 1.5 in both x and y directions
   * tilingSprite.tileScale = { x: 1.5, y: 1.5 };
   * ```
   * @default {x: 1, y: 1}
   */
  get tileScale() {
    return this._tileTransform.scale;
  }
  set tileScale(value2) {
    typeof value2 === "number" ? this._tileTransform.scale.set(value2) : this._tileTransform.scale.copyFrom(value2);
  }
  set tileRotation(value2) {
    this._tileTransform.rotation = value2;
  }
  /**
   * Rotation of the tiling texture in radians.
   * This controls the rotation applied to the texture before tiling.
   * @example
   * ```ts
   * // Rotate the texture by 45 degrees (in radians)
   * tilingSprite.tileRotation = Math.PI / 4; // 45 degrees
   * ```
   * @default 0
   */
  get tileRotation() {
    return this._tileTransform.rotation;
  }
  /**
   * The transform object that controls the tiling texture's position, scale, and rotation.
   * This transform is independent of the sprite's own transform properties.
   * @example
   * ```ts
   * // Access transform properties directly
   * sprite.tileTransform.position.set(100, 50);
   * sprite.tileTransform.scale.set(2);
   * sprite.tileTransform.rotation = Math.PI / 4;
   *
   * // Create smooth scrolling animation
   * app.ticker.add(() => {
   *     sprite.tileTransform.position.x += 1;
   *     sprite.tileTransform.rotation += 0.01;
   * });
   *
   * // Reset transform
   * sprite.tileTransform.position.set(0);
   * sprite.tileTransform.scale.set(1);
   * sprite.tileTransform.rotation = 0;
   * ```
   * @returns {Transform} The transform object for the tiling texture
   * @see {@link Transform} For transform operations
   * @see {@link TilingSprite#tilePosition} For position control
   * @see {@link TilingSprite#tileScale} For scale control
   * @see {@link TilingSprite#tileRotation} For rotation control
   * @advanced
   */
  get tileTransform() {
    return this._tileTransform;
  }
  set texture(value2) {
    value2 || (value2 = Texture.EMPTY);
    const currentTexture = this._texture;
    if (currentTexture === value2)
      return;
    if (currentTexture && currentTexture.dynamic)
      currentTexture.off("update", this.onViewUpdate, this);
    if (value2.dynamic)
      value2.on("update", this.onViewUpdate, this);
    this._texture = value2;
    this.onViewUpdate();
  }
  /**
   * The texture to use for tiling.
   * This is the image that will be repeated across the sprite.
   * @example
   * ```ts
   * // Use a texture from the asset cache
   * tilingSprite.texture = Texture.from('assets/pattern.png');
   * ```
   * @default Texture.WHITE
   */
  get texture() {
    return this._texture;
  }
  /**
   * The width of the tiling area. This defines how wide the area is that the texture will be tiled across.
   * @example
   * ```ts
   * // Create a tiling sprite
   * const sprite = new TilingSprite({
   *     texture: Texture.from('pattern.png'),
   *     width: 500,
   *     height: 300
   * });
   *
   * // Adjust width dynamically
   * sprite.width = 800; // Expands tiling area
   *
   * // Update on resize
   * window.addEventListener('resize', () => {
   *     sprite.width = app.screen.width;
   * });
   * ```
   * @see {@link TilingSprite#setSize} For setting both width and height efficiently
   * @see {@link TilingSprite#height} For setting height
   */
  set width(value2) {
    this._width = value2;
    this.onViewUpdate();
  }
  get width() {
    return this._width;
  }
  set height(value2) {
    this._height = value2;
    this.onViewUpdate();
  }
  /**
   * The height of the tiling area. This defines how tall the area is that the texture will be tiled across.
   * @example
   * ```ts
   * // Create a tiling sprite
   * const sprite = new TilingSprite({
   *     texture: Texture.from('pattern.png'),
   *     width: 500,
   *     height: 300
   * });
   *
   * // Adjust width dynamically
   * sprite.height = 800; // Expands tiling area
   *
   * // Update on resize
   * window.addEventListener('resize', () => {
   *     sprite.height = app.screen.height;
   * });
   * ```
   * @see {@link TilingSprite#setSize} For setting both width and height efficiently
   * @see {@link TilingSprite#width} For setting width
   */
  get height() {
    return this._height;
  }
  /**
   * Sets the size of the TilingSprite to the specified width and height.
   * This is faster than setting width and height separately as it only triggers one update.
   * @example
   * ```ts
   * // Set specific dimensions
   * sprite.setSize(300, 200); // Width: 300, Height: 200
   *
   * // Set uniform size (square)
   * sprite.setSize(400); // Width: 400, Height: 400
   *
   * // Set size using object
   * sprite.setSize({
   *     width: 500,
   *     height: 300
   * });
   * ```
   * @param value - This can be either a number for uniform sizing or a Size object with width/height properties
   * @param height - The height to set. Defaults to the value of `width` if not provided
   * @see {@link TilingSprite#width} For setting width only
   * @see {@link TilingSprite#height} For setting height only
   */
  setSize(value2, height) {
    if (typeof value2 === "object") {
      height = value2.height ?? value2.width;
      value2 = value2.width;
    }
    this._width = value2;
    this._height = height ?? value2;
    this.onViewUpdate();
  }
  /**
   * Retrieves the size of the TilingSprite as a {@link Size} object.
   * This method is more efficient than getting width and height separately as it only allocates one object.
   * @example
   * ```ts
   * // Get basic size
   * const size = sprite.getSize();
   * console.log(`Size: ${size.width}x${size.height}`);
   *
   * // Reuse existing size object
   * const reuseSize = { width: 0, height: 0 };
   * sprite.getSize(reuseSize);
   * ```
   * @param out - Optional object to store the size in, to avoid allocating a new object
   * @returns The size of the TilingSprite
   * @see {@link TilingSprite#width} For getting just the width
   * @see {@link TilingSprite#height} For getting just the height
   * @see {@link TilingSprite#setSize} For setting both width and height efficiently
   */
  getSize(out2) {
    out2 || (out2 = {});
    out2.width = this._width;
    out2.height = this._height;
    return out2;
  }
  /** @private */
  updateBounds() {
    const bounds = this._bounds;
    const anchor2 = this._anchor;
    const width = this._width;
    const height = this._height;
    bounds.minX = -anchor2._x * width;
    bounds.maxX = bounds.minX + width;
    bounds.minY = -anchor2._y * height;
    bounds.maxY = bounds.minY + height;
  }
  /**
   * Checks if the object contains the given point in local coordinates.
   * Takes into account the anchor offset when determining boundaries.
   * @example
   * ```ts
   * // Create a tiling sprite
   * const sprite = new TilingSprite({
   *     texture: Texture.from('pattern.png'),
   *     width: 200,
   *     height: 100,
   *     anchor: 0.5 // Center anchor
   * });
   *
   * // Basic point check
   * const contains = sprite.containsPoint({ x: 50, y: 25 });
   * console.log('Point is inside:', contains);
   *
   * // Check with different anchors
   * sprite.anchor.set(0); // Top-left anchor
   * console.log('Contains point:', sprite.containsPoint({ x: 150, y: 75 }));
   * ```
   * @param point - The point to check in local coordinates
   * @returns True if the point is within the sprite's bounds
   * @see {@link TilingSprite#toLocal} For converting global coordinates to local
   * @see {@link TilingSprite#anchor} For understanding boundary calculations
   */
  containsPoint(point) {
    const width = this._width;
    const height = this._height;
    const x1 = -width * this._anchor._x;
    let y1 = 0;
    if (point.x >= x1 && point.x <= x1 + width) {
      y1 = -height * this._anchor._y;
      if (point.y >= y1 && point.y <= y1 + height)
        return true;
    }
    return false;
  }
  /**
   * Destroys this sprite renderable and optionally its texture.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @example
   * tilingSprite.destroy();
   * tilingSprite.destroy(true);
   * tilingSprite.destroy({ texture: true, textureSource: true });
   */
  destroy(options = false) {
    super.destroy(options);
    this._anchor = null;
    this._tileTransform = null;
    this._bounds = null;
    const destroyTexture = typeof options === "boolean" ? options : options == null ? void 0 : options.texture;
    if (destroyTexture) {
      const destroyTextureSource = typeof options === "boolean" ? options : options == null ? void 0 : options.textureSource;
      this._texture.destroy(destroyTextureSource);
    }
    this._texture = null;
  }
};
_TilingSprite.defaultOptions = {
  /** The texture to use for the sprite. */
  texture: Texture.EMPTY,
  /** The anchor point of the sprite */
  anchor: { x: 0, y: 0 },
  /** The offset of the image that is being tiled. */
  tilePosition: { x: 0, y: 0 },
  /** Scaling of the image that is being tiled. */
  tileScale: { x: 1, y: 1 },
  /** The rotation of the image that is being tiled. */
  tileRotation: 0,
  /**
   * Flags whether the tiling pattern should originate from the origin instead of the top-left corner in
   * local space.
   *
   * This will make the texture coordinates assigned to each vertex dependent on the value of the anchor. Without
   * this, the top-left corner always gets the (0, 0) texture coordinate.
   * @default false
   */
  applyAnchorToTexture: false
};
let TilingSprite = _TilingSprite;
class AbstractText extends ViewContainer {
  constructor(options, styleClass) {
    const { text, resolution: resolution2, style, anchor: anchor2, width, height, roundPixels, ...rest } = options;
    super({
      ...rest
    });
    this.batched = true;
    this._resolution = null;
    this._autoResolution = true;
    this._didTextUpdate = true;
    this._styleClass = styleClass;
    this.text = text ?? "";
    this.style = style;
    this.resolution = resolution2 ?? null;
    this.allowChildren = false;
    this._anchor = new ObservablePoint(
      {
        _onUpdate: () => {
          this.onViewUpdate();
        }
      }
    );
    if (anchor2)
      this.anchor = anchor2;
    this.roundPixels = roundPixels ?? false;
    if (width !== void 0)
      this.width = width;
    if (height !== void 0)
      this.height = height;
  }
  /**
   * The anchor point of the text that controls the origin point for positioning and rotation.
   * Can be a number (same value for x/y) or a PointData object.
   * - (0,0) is top-left
   * - (0.5,0.5) is center
   * - (1,1) is bottom-right
   * ```ts
   * // Set anchor to center
   * const text = new Text({
   *     text: 'Hello Pixi!',
   *     anchor: 0.5 // Same as { x: 0.5, y: 0.5 }
   * });
   * // Set anchor to top-left
   * const text2 = new Text({
   *     text: 'Hello Pixi!',
   *     anchor: { x: 0, y: 0 } // Top-left corner
   * });
   * // Set anchor to bottom-right
   * const text3 = new Text({
   *     text: 'Hello Pixi!',
   *     anchor: { x: 1, y: 1 } // Bottom-right corner
   * });
   * ```
   * @default { x: 0, y: 0 }
   */
  get anchor() {
    return this._anchor;
  }
  set anchor(value2) {
    typeof value2 === "number" ? this._anchor.set(value2) : this._anchor.copyFrom(value2);
  }
  /**
   * The text content to display. Use '\n' for line breaks.
   * Accepts strings, numbers, or objects with toString() method.
   * @example
   * ```ts
   * const text = new Text({
   *     text: 'Hello Pixi!',
   * });
   * const multilineText = new Text({
   *     text: 'Line 1\nLine 2\nLine 3',
   * });
   * const numberText = new Text({
   *     text: 12345, // Will be converted to '12345'
   * });
   * const objectText = new Text({
   *     text: { toString: () => 'Object Text' }, // Custom toString
   * });
   *
   * // Update text dynamically
   * text.text = 'Updated Text'; // Re-renders with new text
   * text.text = 67890; // Updates to '67890'
   * text.text = { toString: () => 'Dynamic Text' }; // Uses custom toString method
   * // Clear text
   * text.text = ''; // Clears the text
   * ```
   * @default ''
   */
  set text(value2) {
    value2 = value2.toString();
    if (this._text === value2)
      return;
    this._text = value2;
    this.onViewUpdate();
  }
  get text() {
    return this._text;
  }
  /**
   * The resolution/device pixel ratio for rendering.
   * Higher values result in sharper text at the cost of performance.
   * Set to null for auto-resolution based on device.
   * @example
   * ```ts
   * const text = new Text({
   *     text: 'Hello Pixi!',
   *     resolution: 2 // High DPI for sharper text
   * });
   * const autoResText = new Text({
   *     text: 'Auto Resolution',
   *     resolution: null // Use device's pixel ratio
   * });
   * ```
   * @default null
   */
  set resolution(value2) {
    this._autoResolution = value2 === null;
    this._resolution = value2;
    this.onViewUpdate();
  }
  get resolution() {
    return this._resolution;
  }
  get style() {
    return this._style;
  }
  /**
   * The style configuration for the text.
   * Can be a TextStyle instance or a configuration object.
   * Supports canvas text styles, HTML text styles, and bitmap text styles.
   * @example
   * ```ts
   * const text = new Text({
   *     text: 'Styled Text',
   *     style: {
   *         fontSize: 24,
   *         fill: 0xff1010, // Red color
   *         fontFamily: 'Arial',
   *         align: 'center', // Center alignment
   *         stroke: { color: '#4a1850', width: 5 }, // Purple stroke
   *         dropShadow: {
   *             color: '#000000', // Black shadow
   *             blur: 4, // Shadow blur
   *             distance: 6 // Shadow distance
   *         }
   *     }
   * });
   * const htmlText = new HTMLText({
   *     text: 'HTML Styled Text',
   *     style: {
   *         fontSize: '20px',
   *         fill: 'blue',
   *         fontFamily: 'Verdana',
   *     }
   * });
   * const bitmapText = new BitmapText({
   *     text: 'Bitmap Styled Text',
   *     style: {
   *         fontName: 'Arial',
   *         fontSize: 32,
   *     }
   * })
   *
   * // Update style dynamically
   * text.style = {
   *     fontSize: 30, // Change font size
   *     fill: 0x00ff00, // Change color to green
   *     align: 'right', // Change alignment to right
   *     stroke: { color: '#000000', width: 2 }, // Add black stroke
   * }
   */
  set style(style) {
    var _a;
    style || (style = {});
    (_a = this._style) == null ? void 0 : _a.off("update", this.onViewUpdate, this);
    if (style instanceof this._styleClass) {
      this._style = style;
    } else {
      this._style = new this._styleClass(style);
    }
    this._style.on("update", this.onViewUpdate, this);
    this.onViewUpdate();
  }
  /**
   * The width of the sprite, setting this will actually modify the scale to achieve the value set.
   * @example
   * ```ts
   * // Set width directly
   * texture.width = 200;
   * console.log(texture.scale.x); // Scale adjusted to match width
   *
   * // For better performance when setting both width and height
   * texture.setSize(300, 400); // Avoids recalculating bounds twice
   * ```
   */
  get width() {
    return Math.abs(this.scale.x) * this.bounds.width;
  }
  set width(value2) {
    this._setWidth(value2, this.bounds.width);
  }
  /**
   * The height of the sprite, setting this will actually modify the scale to achieve the value set.
   * @example
   * ```ts
   * // Set height directly
   * texture.height = 200;
   * console.log(texture.scale.y); // Scale adjusted to match height
   *
   * // For better performance when setting both width and height
   * texture.setSize(300, 400); // Avoids recalculating bounds twice
   * ```
   */
  get height() {
    return Math.abs(this.scale.y) * this.bounds.height;
  }
  set height(value2) {
    this._setHeight(value2, this.bounds.height);
  }
  /**
   * Retrieves the size of the Text as a [Size]{@link Size} object based on the texture dimensions and scale.
   * This is faster than getting width and height separately as it only calculates the bounds once.
   * @example
   * ```ts
   * // Basic size retrieval
   * const text = new Text({
   *     text: 'Hello Pixi!',
   *     style: { fontSize: 24 }
   * });
   * const size = text.getSize();
   * console.log(`Size: ${size.width}x${size.height}`);
   *
   * // Reuse existing size object
   * const reuseSize = { width: 0, height: 0 };
   * text.getSize(reuseSize);
   * ```
   * @param out - Optional object to store the size in, to avoid allocating a new object
   * @returns The size of the Sprite
   * @see {@link Text#width} For getting just the width
   * @see {@link Text#height} For getting just the height
   * @see {@link Text#setSize} For setting both width and height
   */
  getSize(out2) {
    out2 || (out2 = {});
    out2.width = Math.abs(this.scale.x) * this.bounds.width;
    out2.height = Math.abs(this.scale.y) * this.bounds.height;
    return out2;
  }
  /**
   * Sets the size of the Text to the specified width and height.
   * This is faster than setting width and height separately as it only recalculates bounds once.
   * @example
   * ```ts
   * // Basic size setting
   * const text = new Text({
   *    text: 'Hello Pixi!',
   *    style: { fontSize: 24 }
   * });
   * text.setSize(100, 200); // Width: 100, Height: 200
   *
   * // Set uniform size
   * text.setSize(100); // Sets both width and height to 100
   *
   * // Set size with object
   * text.setSize({
   *     width: 200,
   *     height: 300
   * });
   * ```
   * @param value - This can be either a number or a {@link Size} object
   * @param height - The height to set. Defaults to the value of `width` if not provided
   * @see {@link Text#width} For setting width only
   * @see {@link Text#height} For setting height only
   */
  setSize(value2, height) {
    if (typeof value2 === "object") {
      height = value2.height ?? value2.width;
      value2 = value2.width;
    } else {
      height ?? (height = value2);
    }
    value2 !== void 0 && this._setWidth(value2, this.bounds.width);
    height !== void 0 && this._setHeight(height, this.bounds.height);
  }
  /**
   * Checks if the object contains the given point in local coordinates.
   * Uses the text's bounds for hit testing.
   * @example
   * ```ts
   * // Basic point check
   * const localPoint = { x: 50, y: 25 };
   * const contains = text.containsPoint(localPoint);
   * console.log('Point is inside:', contains);
   * ```
   * @param point - The point to check in local coordinates
   * @returns True if the point is within the text's bounds
   * @see {@link Container#toLocal} For converting global coordinates to local
   */
  containsPoint(point) {
    const width = this.bounds.width;
    const height = this.bounds.height;
    const x1 = -width * this.anchor.x;
    let y1 = 0;
    if (point.x >= x1 && point.x <= x1 + width) {
      y1 = -height * this.anchor.y;
      if (point.y >= y1 && point.y <= y1 + height)
        return true;
    }
    return false;
  }
  /** @internal */
  onViewUpdate() {
    if (!this.didViewUpdate)
      this._didTextUpdate = true;
    super.onViewUpdate();
  }
  /**
   * Destroys this text renderable and optionally its style texture.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @example
   * // Destroys the text and its style
   * text.destroy({ style: true, texture: true, textureSource: true });
   * text.destroy(true);
   * text.destroy() // Destroys the text, but not its style
   */
  destroy(options = false) {
    super.destroy(options);
    this.owner = null;
    this._bounds = null;
    this._anchor = null;
    if (typeof options === "boolean" ? options : options == null ? void 0 : options.style) {
      this._style.destroy(options);
    }
    this._style = null;
    this._text = null;
  }
  /**
   * Returns a unique key for this instance.
   * This key is used for caching.
   * @returns {string} Unique key for the instance
   */
  get styleKey() {
    return `${this._text}:${this._style.styleKey}:${this._resolution}`;
  }
}
function ensureTextOptions(args, name2) {
  let options = args[0] ?? {};
  if (typeof options === "string" || args[1]) {
    deprecation(v8_0_0, `use new ${name2}({ text: "hi!", style }) instead`);
    options = {
      text: options,
      style: args[1]
    };
  }
  return options;
}
let _internalCanvas = null;
let _internalContext = null;
function ensureInternalCanvas(width, height) {
  if (!_internalCanvas) {
    _internalCanvas = DOMAdapter.get().createCanvas(256, 128);
    _internalContext = _internalCanvas.getContext("2d", { willReadFrequently: true });
    _internalContext.globalCompositeOperation = "copy";
    _internalContext.globalAlpha = 1;
  }
  if (_internalCanvas.width < width || _internalCanvas.height < height) {
    _internalCanvas.width = nextPow2(width);
    _internalCanvas.height = nextPow2(height);
  }
}
function checkRow(data, width, y2) {
  for (let x2 = 0, index = 4 * y2 * width; x2 < width; ++x2, index += 4) {
    if (data[index + 3] !== 0)
      return false;
  }
  return true;
}
function checkColumn(data, width, x2, top, bottom) {
  const stride = 4 * width;
  for (let y2 = top, index = top * stride + 4 * x2; y2 <= bottom; ++y2, index += stride) {
    if (data[index + 3] !== 0)
      return false;
  }
  return true;
}
function getCanvasBoundingBox(...args) {
  let options = args[0];
  if (!options.canvas) {
    options = { canvas: args[0], resolution: args[1] };
  }
  const { canvas } = options;
  const resolution2 = Math.min(options.resolution ?? 1, 1);
  const width = options.width ?? canvas.width;
  const height = options.height ?? canvas.height;
  let output = options.output;
  ensureInternalCanvas(width, height);
  if (!_internalContext) {
    throw new TypeError("Failed to get canvas 2D context");
  }
  _internalContext.drawImage(
    canvas,
    0,
    0,
    width,
    height,
    0,
    0,
    width * resolution2,
    height * resolution2
  );
  const imageData = _internalContext.getImageData(0, 0, width, height);
  const data = imageData.data;
  let left = 0;
  let top = 0;
  let right = width - 1;
  let bottom = height - 1;
  while (top < height && checkRow(data, width, top))
    ++top;
  if (top === height)
    return Rectangle.EMPTY;
  while (checkRow(data, width, bottom))
    --bottom;
  while (checkColumn(data, width, left, top, bottom))
    ++left;
  while (checkColumn(data, width, right, top, bottom))
    --right;
  ++right;
  ++bottom;
  _internalContext.globalCompositeOperation = "source-over";
  _internalContext.strokeRect(left, top, right - left, bottom - top);
  _internalContext.globalCompositeOperation = "copy";
  output ?? (output = new Rectangle());
  output.set(left / resolution2, top / resolution2, (right - left) / resolution2, (bottom - top) / resolution2);
  return output;
}
const tempRect = new Rectangle();
class CanvasTextGeneratorClass {
  /**
   * Creates a canvas with the specified text rendered to it.
   *
   * Generates a canvas of appropriate size, renders the text with the provided style,
   * and returns both the canvas/context and a Rectangle representing the text bounds.
   *
   * When trim is enabled in the style, the frame will represent the bounds of the
   * non-transparent pixels, which can be smaller than the full canvas.
   * @param options - The options for generating the text canvas
   * @param options.text - The text to render
   * @param options.style - The style to apply to the text
   * @param options.resolution - The resolution of the canvas (defaults to 1)
   * @param options.padding
   * @returns An object containing the canvas/context and the frame (bounds) of the text
   */
  getCanvasAndContext(options) {
    const { text, style, resolution: resolution2 = 1 } = options;
    const padding = style._getFinalPadding();
    const measured = CanvasTextMetrics.measureText(text || " ", style);
    const width = Math.ceil(Math.ceil(Math.max(1, measured.width) + padding * 2) * resolution2);
    const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + padding * 2) * resolution2);
    const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(width, height);
    this._renderTextToCanvas(text, style, padding, resolution2, canvasAndContext);
    const frame = style.trim ? getCanvasBoundingBox({ canvas: canvasAndContext.canvas, width, height, resolution: 1, output: tempRect }) : tempRect.set(0, 0, width, height);
    return {
      canvasAndContext,
      frame
    };
  }
  /**
   * Returns a canvas and context to the pool.
   *
   * This should be called when you're done with the canvas to allow reuse
   * and prevent memory leaks.
   * @param canvasAndContext - The canvas and context to return to the pool
   */
  returnCanvasAndContext(canvasAndContext) {
    CanvasPool.returnCanvasAndContext(canvasAndContext);
  }
  /**
   * Renders text to its canvas, and updates its texture.
   * @param text - The text to render
   * @param style - The style of the text
   * @param padding - The padding of the text
   * @param resolution - The resolution of the text
   * @param canvasAndContext - The canvas and context to render the text to
   */
  _renderTextToCanvas(text, style, padding, resolution2, canvasAndContext) {
    var _a, _b, _c, _d;
    const { canvas, context: context2 } = canvasAndContext;
    const font = fontStringFromTextStyle(style);
    const measured = CanvasTextMetrics.measureText(text || " ", style);
    const lines = measured.lines;
    const lineHeight = measured.lineHeight;
    const lineWidths = measured.lineWidths;
    const maxLineWidth = measured.maxLineWidth;
    const fontProperties = measured.fontProperties;
    const height = canvas.height;
    context2.resetTransform();
    context2.scale(resolution2, resolution2);
    context2.textBaseline = style.textBaseline;
    if ((_a = style._stroke) == null ? void 0 : _a.width) {
      const strokeStyle = style._stroke;
      context2.lineWidth = strokeStyle.width;
      context2.miterLimit = strokeStyle.miterLimit;
      context2.lineJoin = strokeStyle.join;
      context2.lineCap = strokeStyle.cap;
    }
    context2.font = font;
    let linePositionX;
    let linePositionY;
    const passesCount = style.dropShadow ? 2 : 1;
    for (let i2 = 0; i2 < passesCount; ++i2) {
      const isShadowPass = style.dropShadow && i2 === 0;
      const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + padding * 2) : 0;
      const dsOffsetShadow = dsOffsetText * resolution2;
      if (isShadowPass) {
        context2.fillStyle = "black";
        context2.strokeStyle = "black";
        const shadowOptions = style.dropShadow;
        const dropShadowColor = shadowOptions.color;
        const dropShadowAlpha = shadowOptions.alpha;
        context2.shadowColor = Color.shared.setValue(dropShadowColor).setAlpha(dropShadowAlpha).toRgbaString();
        const dropShadowBlur = shadowOptions.blur * resolution2;
        const dropShadowDistance = shadowOptions.distance * resolution2;
        context2.shadowBlur = dropShadowBlur;
        context2.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;
        context2.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance + dsOffsetShadow;
      } else {
        context2.fillStyle = style._fill ? getCanvasFillStyle(style._fill, context2, measured, padding * 2) : null;
        if ((_b = style._stroke) == null ? void 0 : _b.width) {
          const strokePadding = style._stroke.width * 0.5 + padding * 2;
          context2.strokeStyle = getCanvasFillStyle(style._stroke, context2, measured, strokePadding);
        }
        context2.shadowColor = "black";
      }
      let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;
      if (lineHeight - fontProperties.fontSize < 0) {
        linePositionYShift = 0;
      }
      const strokeWidth = ((_c = style._stroke) == null ? void 0 : _c.width) ?? 0;
      for (let i22 = 0; i22 < lines.length; i22++) {
        linePositionX = strokeWidth / 2;
        linePositionY = strokeWidth / 2 + i22 * lineHeight + fontProperties.ascent + linePositionYShift;
        if (style.align === "right") {
          linePositionX += maxLineWidth - lineWidths[i22];
        } else if (style.align === "center") {
          linePositionX += (maxLineWidth - lineWidths[i22]) / 2;
        }
        if ((_d = style._stroke) == null ? void 0 : _d.width) {
          this._drawLetterSpacing(
            lines[i22],
            style,
            canvasAndContext,
            linePositionX + padding,
            linePositionY + padding - dsOffsetText,
            true
          );
        }
        if (style._fill !== void 0) {
          this._drawLetterSpacing(
            lines[i22],
            style,
            canvasAndContext,
            linePositionX + padding,
            linePositionY + padding - dsOffsetText
          );
        }
      }
    }
  }
  /**
   * Render the text with letter-spacing.
   *
   * This method handles rendering text with the correct letter spacing, using either:
   * 1. Native letter spacing if supported by the browser
   * 2. Manual letter spacing calculation if not natively supported
   *
   * For manual letter spacing, it calculates the position of each character
   * based on its width and the desired spacing.
   * @param text - The text to draw
   * @param style - The text style to apply
   * @param canvasAndContext - The canvas and context to draw to
   * @param x - Horizontal position to draw the text
   * @param y - Vertical position to draw the text
   * @param isStroke - Whether to render the stroke (true) or fill (false)
   * @private
   */
  _drawLetterSpacing(text, style, canvasAndContext, x2, y2, isStroke = false) {
    const { context: context2 } = canvasAndContext;
    const letterSpacing = style.letterSpacing;
    let useExperimentalLetterSpacing = false;
    if (CanvasTextMetrics.experimentalLetterSpacingSupported) {
      if (CanvasTextMetrics.experimentalLetterSpacing) {
        context2.letterSpacing = `${letterSpacing}px`;
        context2.textLetterSpacing = `${letterSpacing}px`;
        useExperimentalLetterSpacing = true;
      } else {
        context2.letterSpacing = "0px";
        context2.textLetterSpacing = "0px";
      }
    }
    if (letterSpacing === 0 || useExperimentalLetterSpacing) {
      if (isStroke) {
        context2.strokeText(text, x2, y2);
      } else {
        context2.fillText(text, x2, y2);
      }
      return;
    }
    let currentPosition = x2;
    const stringArray = CanvasTextMetrics.graphemeSegmenter(text);
    let previousWidth = context2.measureText(text).width;
    let currentWidth = 0;
    for (let i2 = 0; i2 < stringArray.length; ++i2) {
      const currentChar = stringArray[i2];
      if (isStroke) {
        context2.strokeText(currentChar, currentPosition, y2);
      } else {
        context2.fillText(currentChar, currentPosition, y2);
      }
      let textStr = "";
      for (let j2 = i2 + 1; j2 < stringArray.length; ++j2) {
        textStr += stringArray[j2];
      }
      currentWidth = context2.measureText(textStr).width;
      currentPosition += previousWidth - currentWidth + letterSpacing;
      previousWidth = currentWidth;
    }
  }
}
const CanvasTextGenerator = new CanvasTextGeneratorClass();
class Text extends AbstractText {
  constructor(...args) {
    const options = ensureTextOptions(args, "Text");
    super(options, TextStyle);
    this.renderPipeId = "text";
    if (options.textureStyle) {
      this.textureStyle = options.textureStyle instanceof TextureStyle ? options.textureStyle : new TextureStyle(options.textureStyle);
    }
  }
  /** @private */
  updateBounds() {
    const bounds = this._bounds;
    const anchor2 = this._anchor;
    let width = 0;
    let height = 0;
    if (this._style.trim) {
      const { frame, canvasAndContext } = CanvasTextGenerator.getCanvasAndContext({
        text: this.text,
        style: this._style,
        resolution: 1
      });
      CanvasTextGenerator.returnCanvasAndContext(canvasAndContext);
      width = frame.width;
      height = frame.height;
    } else {
      const canvasMeasurement = CanvasTextMetrics.measureText(
        this._text,
        this._style
      );
      width = canvasMeasurement.width;
      height = canvasMeasurement.height;
    }
    bounds.minX = -anchor2._x * width;
    bounds.maxX = bounds.minX + width;
    bounds.minY = -anchor2._y * height;
    bounds.maxY = bounds.minY + height;
  }
}
extensions.add(browserExt, webworkerExt);
function scaleColor(color, factor) {
  const r2 = Math.min(255, Math.max(0, Math.round((color >> 16 & 255) * factor)));
  const g2 = Math.min(255, Math.max(0, Math.round((color >> 8 & 255) * factor)));
  const b2 = Math.min(255, Math.max(0, Math.round((color & 255) * factor)));
  return r2 << 16 | g2 << 8 | b2;
}
function parseHexColor$1(hex) {
  if (!hex) return null;
  const cleaned = hex.trim().replace("#", "");
  if (!cleaned) return null;
  const value2 = Number.parseInt(cleaned, 16);
  return Number.isFinite(value2) ? value2 : null;
}
function resolveFloorColors(floorId) {
  const material = getFloorMaterial(floorId) ?? getFloorMaterial("unknown");
  const baseColor = parseHexColor$1(material == null ? void 0 : material.fallbackColor) ?? 1908016;
  const altColor = scaleColor(baseColor, 1.08);
  return { base: baseColor, alt: altColor, textureId: material == null ? void 0 : material.textureId };
}
function usePixiBoard(options) {
  const appRef = reactExports.useRef(null);
  const staticDepthLayerRef = reactExports.useRef(null);
  const dynamicDepthLayerRef = reactExports.useRef(null);
  const pathLayerRef = reactExports.useRef(null);
  const terrainNaturalLayerRef = reactExports.useRef(null);
  const terrainFxLayerRef = reactExports.useRef(null);
  const terrainLabelLayerRef = reactExports.useRef(null);
  const speechLayerRef = reactExports.useRef(null);
  const labelLayerRef = reactExports.useRef(null);
  const viewportRef = reactExports.useRef(null);
  const [pixiReadyTick, setPixiReadyTick] = reactExports.useState(0);
  const resizeRef = reactExports.useRef(null);
  const drawGridRef = reactExports.useRef(null);
  const animateRef = reactExports.useRef(options.animate ?? true);
  const appReadyRef = reactExports.useRef(false);
  const playableCellsRef = reactExports.useRef(null);
  const terrainRef = reactExports.useRef(null);
  const terrainMixRef = reactExports.useRef(null);
  const gridRef = reactExports.useRef({
    cols: options.grid.cols,
    rows: options.grid.rows
  });
  const zoomRef = reactExports.useRef(typeof options.zoom === "number" ? options.zoom : 1);
  const panRef = reactExports.useRef({
    x: typeof options.panX === "number" ? options.panX : 0,
    y: typeof options.panY === "number" ? options.panY : 0
  });
  zoomRef.current = typeof options.zoom === "number" ? options.zoom : 1;
  panRef.current = {
    x: typeof options.panX === "number" ? options.panX : 0,
    y: typeof options.panY === "number" ? options.panY : 0
  };
  animateRef.current = options.animate ?? true;
  playableCellsRef.current = options.playableCells ?? null;
  terrainRef.current = Array.isArray(options.terrain) ? options.terrain : null;
  terrainMixRef.current = Array.isArray(options.terrainMix) ? options.terrainMix : null;
  gridRef.current = {
    cols: Math.max(1, Math.floor(options.grid.cols)),
    rows: Math.max(1, Math.floor(options.grid.rows))
  };
  reactExports.useEffect(() => {
    var _a;
    (_a = resizeRef.current) == null ? void 0 : _a.call(resizeRef);
  }, [options.zoom, options.panX, options.panY]);
  reactExports.useEffect(() => {
    var _a, _b;
    (_a = drawGridRef.current) == null ? void 0 : _a.call(drawGridRef);
    (_b = resizeRef.current) == null ? void 0 : _b.call(resizeRef);
  }, [
    options.playableCells,
    options.terrain,
    options.terrainMix,
    options.grid.cols,
    options.grid.rows,
    pixiReadyTick
  ]);
  reactExports.useEffect(() => {
    if (!options.enabled) return;
    if (!options.containerRef.current || appRef.current) return;
    const app = new Application();
    appRef.current = app;
    let destroyed = false;
    let resizeHandler = null;
    let resizeObserver = null;
    let initialized = false;
    const initPixi = async () => {
      const backgroundColor = typeof options.backgroundColor === "number" ? options.backgroundColor : BOARD_BACKGROUND_COLOR;
      await app.init({
        width: getBoardWidth(gridRef.current.cols),
        height: getBoardHeight(gridRef.current.rows),
        background: backgroundColor,
        antialias: true,
        preference: "webgl",
        resolution: window.devicePixelRatio,
        autoDensity: true
      });
      initialized = true;
      appReadyRef.current = true;
      if (destroyed) return;
      const container = options.containerRef.current;
      if (!container) return;
      container.prepend(app.canvas);
      const root = new Container();
      root.sortableChildren = true;
      app.stage.addChild(root);
      const gridLayer = new Graphics();
      root.addChild(gridLayer);
      const drawGrid = () => {
        gridLayer.cacheAsTexture = false;
        gridLayer.clear();
        const { cols, rows } = gridRef.current;
        const terrain = terrainRef.current;
        const terrainMix = terrainMixRef.current;
        for (let gy = 0; gy < rows; gy++) {
          for (let gx = 0; gx < cols; gx++) {
            const playable = playableCellsRef.current;
            if (playable && playable.size > 0 && !playable.has(`${gx},${gy}`)) {
              continue;
            }
            const terrainIndex = gy * cols + gx;
            const cellTerrain = terrain && terrainIndex >= 0 && terrainIndex < terrain.length ? terrain[terrainIndex] : "unknown";
            const floorColors = resolveFloorColors(cellTerrain);
            const tileColor = floorColors.base;
            const center = gridToScreenForGrid(gx, gy, cols, rows);
            const x2 = center.x - TILE_SIZE / 2;
            const y2 = center.y - TILE_SIZE / 2;
            gridLayer.rect(x2, y2, TILE_SIZE, TILE_SIZE).fill({
              color: tileColor,
              alpha: 1
            });
            const mix = terrainMix ? terrainMix[terrainIndex] ?? null : null;
            if (mix) {
              const blendColor = resolveFloorColors(mix.blend).base;
              const left = x2;
              const top = y2;
              const right = x2 + TILE_SIZE;
              const bottom = y2 + TILE_SIZE;
              if (mix.corner === "NE") {
                gridLayer.moveTo(left, top);
                gridLayer.lineTo(right, top);
                gridLayer.lineTo(right, bottom);
              } else if (mix.corner === "SW") {
                gridLayer.moveTo(left, top);
                gridLayer.lineTo(right, bottom);
                gridLayer.lineTo(left, bottom);
              } else if (mix.corner === "NW") {
                gridLayer.moveTo(left, top);
                gridLayer.lineTo(right, top);
                gridLayer.lineTo(left, bottom);
              } else {
                gridLayer.moveTo(right, top);
                gridLayer.lineTo(right, bottom);
                gridLayer.lineTo(left, bottom);
              }
              gridLayer.closePath();
              gridLayer.fill({ color: blendColor, alpha: 1 });
            }
          }
        }
        gridLayer.cacheAsTexture = true;
      };
      drawGridRef.current = drawGrid;
      drawGrid();
      const terrainNaturalLayer = new Container();
      terrainNaturalLayer.name = "terrainNaturalLayer";
      root.addChild(terrainNaturalLayer);
      terrainNaturalLayerRef.current = terrainNaturalLayer;
      const terrainFxLayer = new Graphics();
      terrainFxLayer.name = "terrainFxLayer";
      root.addChild(terrainFxLayer);
      terrainFxLayerRef.current = terrainFxLayer;
      const terrainLabelLayer = new Container();
      terrainLabelLayer.name = "terrainLabelLayer";
      root.addChild(terrainLabelLayer);
      terrainLabelLayerRef.current = terrainLabelLayer;
      const pathLayer = new Graphics();
      pathLayer.name = "pathLayer";
      root.addChild(pathLayer);
      pathLayerRef.current = pathLayer;
      const labelLayer = new Container();
      labelLayer.name = "labelLayer";
      root.addChild(labelLayer);
      labelLayerRef.current = labelLayer;
      const staticDepthLayer = new Container();
      staticDepthLayer.name = "staticDepthLayer";
      staticDepthLayer.sortableChildren = true;
      root.addChild(staticDepthLayer);
      staticDepthLayerRef.current = staticDepthLayer;
      const dynamicDepthLayer = new Container();
      dynamicDepthLayer.name = "dynamicDepthLayer";
      dynamicDepthLayer.sortableChildren = true;
      root.addChild(dynamicDepthLayer);
      dynamicDepthLayerRef.current = dynamicDepthLayer;
      const speechLayer = new Container();
      speechLayer.name = "speechLayer";
      root.addChild(speechLayer);
      speechLayerRef.current = speechLayer;
      setPixiReadyTick((tick) => tick + 1);
      const resize = () => {
        const parent = options.containerRef.current;
        if (!parent) return;
        const width = Math.max(1, parent.clientWidth);
        const height = Math.max(1, parent.clientHeight);
        app.renderer.resize(width, height);
        const { cols, rows } = gridRef.current;
        const boardW = getBoardWidth(cols);
        const boardH = getBoardHeight(rows);
        const baseScale = Math.min(width / boardW, height / boardH);
        const zoom = zoomRef.current;
        const scale = baseScale * zoom;
        const offsetX = (width - boardW * scale) / 2 + panRef.current.x;
        const offsetY = (height - boardH * scale) / 2 + panRef.current.y;
        root.scale.set(scale);
        root.position.set(offsetX, offsetY);
        viewportRef.current = { scale, offsetX, offsetY };
        const canvas = app.canvas;
        canvas.style.width = "100%";
        canvas.style.height = "100%";
        canvas.style.display = "block";
        if (!animateRef.current) {
          app.render();
        }
      };
      resizeHandler = resize;
      resizeRef.current = resize;
      resize();
      resizeObserver = new ResizeObserver(() => resize());
      resizeObserver.observe(container);
      window.addEventListener("resize", resize);
    };
    void initPixi();
    return () => {
      destroyed = true;
      appReadyRef.current = false;
      if (resizeObserver) resizeObserver.disconnect();
      if (resizeHandler) window.removeEventListener("resize", resizeHandler);
      if (initialized && appRef.current) {
        appRef.current.destroy(true);
      }
      appRef.current = null;
      staticDepthLayerRef.current = null;
      dynamicDepthLayerRef.current = null;
      pathLayerRef.current = null;
      terrainNaturalLayerRef.current = null;
      terrainFxLayerRef.current = null;
      terrainLabelLayerRef.current = null;
      speechLayerRef.current = null;
      labelLayerRef.current = null;
      viewportRef.current = null;
      resizeRef.current = null;
      drawGridRef.current = null;
    };
  }, [options.enabled, options.containerRef]);
  reactExports.useEffect(() => {
    const app = appRef.current;
    if (!app || !app.renderer || !app.renderer.background) return;
    app.renderer.background.color = typeof options.backgroundColor === "number" ? options.backgroundColor : BOARD_BACKGROUND_COLOR;
  }, [options.backgroundColor]);
  reactExports.useEffect(() => {
    const app = appRef.current;
    if (!app || !app.ticker || !appReadyRef.current) return;
    const animate = options.animate ?? true;
    const maxFps = typeof options.maxFps === "number" ? options.maxFps : 0;
    app.ticker.maxFPS = maxFps > 0 ? maxFps : 0;
    if (animate) {
      if (!app.ticker.started) app.ticker.start();
    } else {
      if (app.ticker.started) app.ticker.stop();
      app.render();
    }
  }, [options.animate, options.maxFps, pixiReadyTick]);
  reactExports.useEffect(() => {
    const app = appRef.current;
    if (!app || !appReadyRef.current) return;
    if (options.animate ?? true) return;
    if (typeof options.renderTick !== "number") return;
    app.render();
  }, [options.renderTick, options.animate]);
  return {
    appRef,
    staticDepthLayerRef,
    dynamicDepthLayerRef,
    pathLayerRef,
    terrainNaturalLayerRef,
    terrainFxLayerRef,
    terrainLabelLayerRef,
    speechLayerRef,
    labelLayerRef,
    viewportRef,
    pixiReadyTick
  };
}
const DEPTH_Z = {
  walls: 0,
  obstacleBase: 1e4,
  decor: 12e3,
  effects: 14e3,
  tokens: 16e3,
  overhead: 1e5
};
function usePixiDecorations(options) {
  reactExports.useEffect(() => {
    var _a;
    const depthLayer = options.depthLayerRef.current;
    if (!depthLayer) return;
    depthLayer.cacheAsTexture = false;
    for (const child of [...depthLayer.children]) {
      if (child.label === "decor") {
        depthLayer.removeChild(child);
        (_a = child.destroy) == null ? void 0 : _a.call(child);
      }
    }
    const visibleCells = options.visibleCells ?? null;
    const showAll = Boolean(options.showAllLevels);
    const cellKey = (x2, y2) => `${x2},${y2}`;
    for (const decor of options.decorations) {
      const key2 = cellKey(decor.x, decor.y);
      const isVisible = showAll || ((visibleCells == null ? void 0 : visibleCells.has(key2)) ?? true);
      if (!isVisible) continue;
      const center = gridToScreenForGrid(decor.x, decor.y, options.grid.cols, options.grid.rows);
      const size2 = TILE_SIZE * 0.5;
      const x2 = center.x - size2 / 2;
      const y2 = center.y - size2 / 2;
      const color = decor.layer === "wall" ? 11569754 : 7049018;
      const g2 = new Graphics();
      g2.rect(x2, y2, size2, size2).fill({
        color,
        alpha: 0.75
      });
      g2.label = "decor";
      g2.zIndex = center.y + DEPTH_Z.decor;
      depthLayer.addChild(g2);
    }
    depthLayer.cacheAsTexture = true;
  }, [
    options.depthLayerRef,
    options.decorations,
    options.pixiReadyTick,
    options.grid,
    options.heightMap,
    options.activeLevel,
    options.visibleCells,
    options.showAllLevels
  ]);
}
const __vite_glob_0_0$2 = "/assets/brazier-Bdb9cdt5.png";
const __vite_glob_0_1$1 = "/assets/bush-DRumHcsT.png";
const __vite_glob_0_2$1 = "/assets/chair-wood-CHKrC39s.png";
const __vite_glob_0_3$1 = "/assets/charette-wood-D1AY6TMb.png";
const __vite_glob_0_4$1 = "/assets/log-DUetiJOF.png";
const __vite_glob_0_5 = "/assets/table-wood-C1MEGPWE.png";
const __vite_glob_0_6 = "/assets/tree-oak-canopy-shadow-DLOt3fwP.png";
const __vite_glob_0_7 = "/assets/tree-oak-canopy-DfHX1yEy.png";
const __vite_glob_0_8 = "/assets/tree-oak-trunk-shadow-2eBSH8AZ.png";
const __vite_glob_0_9 = "/assets/tree-oak-trunk-D9sZ5gKu.png";
const __vite_glob_1_0$1 = "/assets/fire-1-CFpuDXDr.png";
const __vite_glob_1_1$1 = "/assets/fire-2-0i6lg8hn.png";
const __vite_glob_1_2$1 = "/assets/fire-3-BkBszcLR.png";
const __vite_glob_1_3$1 = "/assets/sword-1-CQHRu9MN.png";
const __vite_glob_1_4 = "/assets/sword-2-BSXf_6uJ.png";
const __vite_glob_1_5 = "/assets/sword-3-XgvILPli.png";
const __vite_glob_1_6 = "/assets/sword-4-Bxo5Z0xN.png";
const pngModules$2 = /* @__PURE__ */ Object.assign({
  "./data/maps/obstacles/sprite/brazier.png": __vite_glob_0_0$2,
  "./data/maps/obstacles/sprite/bush.png": __vite_glob_0_1$1,
  "./data/maps/obstacles/sprite/chair-wood.png": __vite_glob_0_2$1,
  "./data/maps/obstacles/sprite/charette-wood.png": __vite_glob_0_3$1,
  "./data/maps/obstacles/sprite/log.png": __vite_glob_0_4$1,
  "./data/maps/obstacles/sprite/table-wood.png": __vite_glob_0_5,
  "./data/maps/obstacles/sprite/tree-oak-canopy-shadow.png": __vite_glob_0_6,
  "./data/maps/obstacles/sprite/tree-oak-canopy.png": __vite_glob_0_7,
  "./data/maps/obstacles/sprite/tree-oak-trunk-shadow.png": __vite_glob_0_8,
  "./data/maps/obstacles/sprite/tree-oak-trunk.png": __vite_glob_0_9
});
const effectAnimationModules = /* @__PURE__ */ Object.assign({
  "./data/effects/sprite/animate/fire-1.png": __vite_glob_1_0$1,
  "./data/effects/sprite/animate/fire-2.png": __vite_glob_1_1$1,
  "./data/effects/sprite/animate/fire-3.png": __vite_glob_1_2$1,
  "./data/effects/sprite/fight/sword-1.png": __vite_glob_1_3$1,
  "./data/effects/sprite/fight/sword-2.png": __vite_glob_1_4,
  "./data/effects/sprite/fight/sword-3.png": __vite_glob_1_5,
  "./data/effects/sprite/fight/sword-4.png": __vite_glob_1_6
});
const OBSTACLE_PNG_BY_KEY = {};
const EFFECT_ANIMATION_FRAMES_BY_KEY = {};
const loadedObstacleAliases = /* @__PURE__ */ new Set();
const pendingObstacleAliases = /* @__PURE__ */ new Set();
for (const [path2, url] of Object.entries(pngModules$2)) {
  const file = path2.split("/").pop() ?? "";
  const baseName = file.replace(/\.png$/i, "");
  if (!baseName) continue;
  OBSTACLE_PNG_BY_KEY[`obstacle:${baseName}`] = url;
}
const effectFramesByKey = {};
for (const [path2, url] of Object.entries(effectAnimationModules)) {
  const file = path2.split("/").pop() ?? "";
  const baseName = file.replace(/\.png$/i, "");
  if (!baseName) continue;
  const match = baseName.match(/^(.*?)-(\d+)$/);
  if (!match) continue;
  const prefix = match[1];
  const index = Number.parseInt(match[2], 10);
  if (!Number.isFinite(index)) continue;
  const key2 = `effect:${prefix}`;
  if (!effectFramesByKey[key2]) effectFramesByKey[key2] = [];
  effectFramesByKey[key2].push({ index, url });
}
for (const [key2, entries] of Object.entries(effectFramesByKey)) {
  const sorted = [...entries].sort((a2, b2) => a2.index - b2.index);
  EFFECT_ANIMATION_FRAMES_BY_KEY[key2] = sorted.map((entry) => entry.url);
}
function getObstaclePngUrl(spriteKey) {
  if (!spriteKey) return null;
  const url = OBSTACLE_PNG_BY_KEY[spriteKey];
  return url ?? null;
}
function getObstacleAnimationFrames(spriteKey) {
  if (!spriteKey) return null;
  const frames = EFFECT_ANIMATION_FRAMES_BY_KEY[spriteKey];
  return frames ?? null;
}
function getEffectAnimationKeys() {
  return Object.keys(EFFECT_ANIMATION_FRAMES_BY_KEY);
}
function collectObstacleAssets(spriteKey) {
  const assets = [];
  if (!spriteKey) return assets;
  if (spriteKey.startsWith("obstacle:")) {
    const url = OBSTACLE_PNG_BY_KEY[spriteKey];
    if (url) {
      assets.push({
        alias: url,
        src: url,
        data: {
          autoGenerateMipmaps: true,
          scaleMode: "linear",
          mipmapFilter: "linear",
          maxAnisotropy: 4
        }
      });
    }
  } else if (spriteKey.startsWith("effect:")) {
    const frames = EFFECT_ANIMATION_FRAMES_BY_KEY[spriteKey];
    if (frames && frames.length > 0) {
      frames.forEach((src) => {
        assets.push({
          alias: src,
          src,
          data: {
            autoGenerateMipmaps: true,
            scaleMode: "linear",
            mipmapFilter: "linear",
            maxAnisotropy: 4
          }
        });
      });
    }
  }
  return assets;
}
async function preloadObstaclePngTexturesFor(spriteKeys) {
  if (!Array.isArray(spriteKeys) || spriteKeys.length === 0) return;
  const assets = /* @__PURE__ */ new Map();
  for (const spriteKey of spriteKeys) {
    if (!spriteKey) continue;
    const entries = collectObstacleAssets(spriteKey);
    for (const entry of entries) {
      if (loadedObstacleAliases.has(entry.alias) || pendingObstacleAliases.has(entry.alias)) continue;
      assets.set(entry.alias, entry);
      pendingObstacleAliases.add(entry.alias);
    }
  }
  if (assets.size === 0) return;
  try {
    for (const asset of assets.values()) {
      Assets.add(asset);
    }
    const aliases = [...assets.keys()];
    await Assets.load(aliases);
    for (const alias of aliases) {
      loadedObstacleAliases.add(alias);
      pendingObstacleAliases.delete(alias);
    }
  } catch (error) {
    for (const alias of assets.keys()) {
      pendingObstacleAliases.delete(alias);
    }
    throw error;
  }
}
function usePixiEffects(options) {
  const hashString012 = (input) => {
    let hash = 2166136261;
    for (let i2 = 0; i2 < input.length; i2++) {
      hash ^= input.charCodeAt(i2);
      hash = Math.imul(hash, 16777619);
    }
    return (hash >>> 0) / 4294967295;
  };
  const lerpColor = (a2, b2, t2) => {
    const ar = a2 >> 16 & 255;
    const ag = a2 >> 8 & 255;
    const ab = a2 & 255;
    const br = b2 >> 16 & 255;
    const bg = b2 >> 8 & 255;
    const bb = b2 & 255;
    const rr = Math.round(ar + (br - ar) * t2);
    const rg = Math.round(ag + (bg - ag) * t2);
    const rb = Math.round(ab + (bb - ab) * t2);
    return rr << 16 | rg << 8 | rb;
  };
  reactExports.useEffect(() => {
    var _a;
    const depthLayer = options.depthLayerRef.current;
    if (!depthLayer) return;
    for (const child of [...depthLayer.children]) {
      if (child.label === "effect") {
        depthLayer.removeChild(child);
        (_a = child.destroy) == null ? void 0 : _a.call(child);
      }
    }
    if (options.suspendRendering) return;
    const typeById = /* @__PURE__ */ new Map();
    for (const t2 of options.effectTypes) typeById.set(t2.id, t2);
    const showAll = Boolean(options.showAllLevels);
    const visibleCells = options.visibleCells ?? null;
    const cellKey = (x2, y2) => `${x2},${y2}`;
    for (const effect of options.effects) {
      if (effect.active === false) continue;
      if (effect.sourceObstacleId) continue;
      const def = typeById.get(effect.typeId) ?? null;
      const appearance2 = def == null ? void 0 : def.appearance;
      if (!(appearance2 == null ? void 0 : appearance2.spriteKey)) continue;
      const isVisible = showAll || ((visibleCells == null ? void 0 : visibleCells.has(cellKey(effect.x, effect.y))) ?? true);
      if (!isVisible) continue;
      const spriteUrl = getObstaclePngUrl(appearance2.spriteKey);
      const animationFrames = spriteUrl ? null : getObstacleAnimationFrames(appearance2.spriteKey);
      if (!spriteUrl && (!animationFrames || animationFrames.length === 0)) continue;
      let sprite;
      if (animationFrames && animationFrames.length > 0) {
        const textures = animationFrames.map((frame) => Texture.from(frame));
        const anim = new AnimatedSprite(textures);
        anim.animationSpeed = typeof appearance2.animationSpeed === "number" ? appearance2.animationSpeed : 0.15;
        anim.loop = typeof appearance2.animationLoop === "boolean" ? appearance2.animationLoop : true;
        anim.play();
        sprite = anim;
      } else {
        sprite = Sprite.from(spriteUrl);
      }
      sprite.anchor.set(0.5, 0.5);
      const seed = `${effect.id}:${effect.typeId}`;
      const t2 = hashString012(seed);
      const scaleBase = typeof appearance2.scale === "number" ? appearance2.scale : 1;
      if (typeof appearance2.targetSize === "number" && appearance2.targetSize > 0) {
        const texture = sprite instanceof AnimatedSprite ? sprite.textures[0] : sprite.texture;
        const baseWidth = (texture == null ? void 0 : texture.width) ?? 0;
        const baseHeight = (texture == null ? void 0 : texture.height) ?? 0;
        const baseSize = Math.max(baseWidth, baseHeight);
        if (baseSize > 0) {
          const fitScale = appearance2.targetSize / baseSize;
          sprite.scale.set(scaleBase * fitScale);
        } else {
          sprite.scale.set(scaleBase);
        }
      } else {
        sprite.scale.set(scaleBase);
      }
      if (appearance2.scaleRange) {
        const { min, max } = appearance2.scaleRange;
        const scale = min + (max - min) * t2;
        sprite.scale.set(sprite.scale.x * scale, sprite.scale.y * scale);
      }
      const alphaBase = typeof appearance2.alpha === "number" ? appearance2.alpha : 1;
      if (appearance2.alphaRange) {
        const { min, max } = appearance2.alphaRange;
        sprite.alpha = alphaBase * (min + (max - min) * t2);
      } else {
        sprite.alpha = alphaBase;
      }
      if (typeof appearance2.tint === "number") {
        sprite.tint = appearance2.tint;
      } else if (appearance2.tintRange) {
        sprite.tint = lerpColor(appearance2.tintRange.dark, appearance2.tintRange.light, t2);
      } else {
        sprite.tint = 16777215;
      }
      const center = gridToScreenForGrid(effect.x, effect.y, options.grid.cols, options.grid.rows);
      sprite.x = center.x;
      sprite.y = center.y;
      if (typeof effect.rotationDeg === "number") {
        sprite.rotation = effect.rotationDeg * Math.PI / 180;
      } else {
        sprite.rotation = 0;
      }
      const container = new Container();
      container.label = "effect";
      container.addChild(sprite);
      container.zIndex = center.y + DEPTH_Z.effects;
      depthLayer.addChild(container);
    }
  }, [
    options.depthLayerRef,
    options.effects,
    options.effectTypes,
    options.pixiReadyTick,
    options.grid,
    options.visibleCells,
    options.showAllLevels
  ]);
}
function usePixiGridLabels(options) {
  reactExports.useEffect(() => {
    const labelLayer = options.labelLayerRef.current;
    if (!labelLayer) return;
    const removed = labelLayer.removeChildren();
    for (const child of removed) {
      child.destroy();
    }
    if (!options.showLabels) return;
    const fontSize = Math.max(9, Math.round(TILE_SIZE * 0.18));
    const { cols, rows } = options.grid;
    const obstacles = Array.isArray(options.obstacles) ? options.obstacles : [];
    const obstacleTypes = Array.isArray(options.obstacleTypes) ? options.obstacleTypes : [];
    const obstacleById = /* @__PURE__ */ new Map();
    for (const t2 of obstacleTypes) obstacleById.set(t2.id, t2);
    const obstacleLabels = /* @__PURE__ */ new Map();
    for (const obs of obstacles) {
      if (obs.hp <= 0) continue;
      const def = obstacleById.get(obs.typeId);
      const cells = getObstacleOccupiedCells(obs, def);
      const label2 = `${(def == null ? void 0 : def.label) ?? obs.typeId}#${obs.id}`;
      for (const cell of cells) {
        const key2 = `${cell.x},${cell.y}`;
        const list = obstacleLabels.get(key2);
        if (list) {
          list.push(label2);
        } else {
          obstacleLabels.set(key2, [label2]);
        }
      }
    }
    for (let y2 = 0; y2 < rows; y2++) {
      for (let x2 = 0; x2 < cols; x2++) {
        if (options.playableCells && options.playableCells.size > 0 && !options.playableCells.has(`${x2},${y2}`)) {
          continue;
        }
        const center = gridToScreenForGrid(x2, y2, cols, rows);
        const obstacleIds = obstacleLabels.get(`${x2},${y2}`);
        const labelText = obstacleIds ? `${x2},${y2}
obs:${obstacleIds.join(",")}` : `${x2},${y2}`;
        const label2 = new Text(labelText, {
          fontFamily: "Arial",
          fontSize,
          fill: 16777215,
          stroke: { color: 0, width: 3 },
          align: "center"
        });
        label2.anchor.set(0.5, 0.5);
        label2.alpha = 0.9;
        label2.x = center.x;
        label2.y = center.y;
        labelLayer.addChild(label2);
      }
    }
  }, [
    options.labelLayerRef,
    options.showLabels,
    options.playableCells,
    options.grid,
    options.heightMap,
    options.activeLevel,
    options.obstacles,
    options.obstacleTypes,
    options.pixiReadyTick
  ]);
}
const __vite_glob_0_0$1 = "/assets/dirt-LTjHs14a.png";
const __vite_glob_0_1 = "/assets/grass-ezd6-yvM.png";
const __vite_glob_0_2 = "/assets/grass1-BhKGjZDt.png";
const __vite_glob_0_3 = "/assets/grass2-DwO1ZHjA.png";
const __vite_glob_0_4 = "/assets/mud-DbHiHwwD.png";
const tilingModules = /* @__PURE__ */ Object.assign({
  "./game/map/floors/tiling/dirt.png": __vite_glob_0_0$1,
  "./game/map/floors/tiling/grass.png": __vite_glob_0_1,
  "./game/map/floors/tiling/grass1.png": __vite_glob_0_2,
  "./game/map/floors/tiling/grass2.png": __vite_glob_0_3,
  "./game/map/floors/tiling/mud.png": __vite_glob_0_4
});
const FLOOR_TILING_BY_ID = {};
const FLOOR_TILING_VARIANTS_BY_ID = {};
const FLOOR_BUMP_BY_ID = {};
const loadedAliases = /* @__PURE__ */ new Set();
const pendingAliases = /* @__PURE__ */ new Set();
const resizedTextureByKey = /* @__PURE__ */ new Map();
const resizedPendingByKey = /* @__PURE__ */ new Set();
const tilingEntries = Object.entries(tilingModules).map(([path2, url]) => {
  const file = path2.split("/").pop() ?? "";
  const baseName = file.replace(/\.png$/i, "");
  return { baseName, url };
});
const tilingBaseNames = new Set(tilingEntries.map((entry) => entry.baseName));
for (const { baseName, url } of tilingEntries) {
  if (!baseName) continue;
  if (baseName.endsWith("-bump")) {
    const id2 = baseName.replace(/-bump$/i, "");
    if (id2) FLOOR_BUMP_BY_ID[id2] = url;
    continue;
  }
  if (/^bump-/i.test(baseName)) {
    const id2 = baseName.replace(/^bump-/i, "");
    if (id2) FLOOR_BUMP_BY_ID[id2] = url;
    continue;
  }
  const variantMatch = baseName.match(/^(.*?)(?:[-_]?)(\d+)$/);
  const hasVariantSuffix = Boolean(variantMatch && variantMatch[1]);
  const baseId = hasVariantSuffix ? (variantMatch == null ? void 0 : variantMatch[1]) ?? "" : baseName;
  const isVariantOfExisting = hasVariantSuffix && tilingBaseNames.has(baseId);
  if (!isVariantOfExisting) {
    FLOOR_TILING_BY_ID[baseName] = url;
    const list = FLOOR_TILING_VARIANTS_BY_ID[baseName] ?? [];
    list.push(url);
    FLOOR_TILING_VARIANTS_BY_ID[baseName] = list;
  } else if (baseId) {
    const list = FLOOR_TILING_VARIANTS_BY_ID[baseId] ?? [];
    list.push(url);
    FLOOR_TILING_VARIANTS_BY_ID[baseId] = list;
  }
}
for (const [id2, list] of Object.entries(FLOOR_TILING_VARIANTS_BY_ID)) {
  const unique = Array.from(new Set(list));
  unique.sort();
  FLOOR_TILING_VARIANTS_BY_ID[id2] = unique;
}
function getFloorTilingUrl(id2) {
  if (!id2) return null;
  return FLOOR_TILING_BY_ID[id2] ?? null;
}
function getFloorTilingVariantUrls(id2) {
  if (!id2) return [];
  return FLOOR_TILING_VARIANTS_BY_ID[id2] ?? [];
}
function getFloorBumpUrl(id2) {
  if (!id2) return null;
  return FLOOR_BUMP_BY_ID[id2] ?? null;
}
async function loadImage(url) {
  const img = new Image();
  img.decoding = "async";
  img.crossOrigin = "anonymous";
  const done = new Promise((resolve, reject) => {
    img.onload = () => resolve();
    img.onerror = () => reject(new Error(`Failed to load image: ${url}`));
  });
  img.src = url;
  await done;
  return img;
}
async function buildResizedTexture(url, size2) {
  const image = await loadImage(url);
  const canvas = document.createElement("canvas");
  canvas.width = size2;
  canvas.height = size2;
  const ctx = canvas.getContext("2d");
  if (!ctx) {
    throw new Error("Cannot get 2D context for floor tiling resize.");
  }
  ctx.imageSmoothingEnabled = true;
  ctx.drawImage(image, 0, 0, size2, size2);
  const texture = Texture.from(canvas);
  if (texture.source) {
    texture.source.scaleMode = "linear";
    texture.source.mipmapFilter = "linear";
    texture.source.autoGenerateMipmaps = true;
    texture.source.addressMode = "repeat";
  }
  console.log("[floor-tiling] resized", url, "->", size2, "x", size2);
  return texture;
}
function getFloorTilingTextureFromUrl(url, size2) {
  if (!url) return null;
  const key2 = `${url}:${size2}`;
  return resizedTextureByKey.get(key2) ?? null;
}
function getFloorBumpTexture(id2, size2) {
  if (!id2) return null;
  const url = getFloorBumpUrl(id2);
  if (!url) return null;
  const key2 = `${url}:${size2}`;
  return resizedTextureByKey.get(key2) ?? null;
}
async function preloadFloorTilingTexturesFor(ids, size2) {
  if (!Array.isArray(ids) || ids.length === 0) return;
  const assets = /* @__PURE__ */ new Map();
  for (const id2 of ids) {
    const urls = [...getFloorTilingVariantUrls(id2), getFloorBumpUrl(id2)].filter(Boolean);
    for (const url of urls) {
      if (loadedAliases.has(url) || pendingAliases.has(url)) continue;
      assets.set(url, {
        alias: url,
        src: url,
        data: {
          autoGenerateMipmaps: true,
          scaleMode: "linear",
          mipmapFilter: "linear",
          maxAnisotropy: 4
        }
      });
      pendingAliases.add(url);
    }
  }
  if (assets.size === 0 && ids.length > 0) {
    for (const id2 of ids) {
      const urls = [...getFloorTilingVariantUrls(id2), getFloorBumpUrl(id2)].filter(Boolean);
      for (const url of urls) {
        const key2 = `${url}:${size2}`;
        if (resizedTextureByKey.has(key2) || resizedPendingByKey.has(key2)) continue;
        resizedPendingByKey.add(key2);
        buildResizedTexture(url, size2).then((texture) => {
          resizedTextureByKey.set(key2, texture);
        }).finally(() => {
          resizedPendingByKey.delete(key2);
        });
      }
    }
    return;
  }
  try {
    for (const asset of assets.values()) {
      Assets.add(asset);
    }
    const aliases = [...assets.keys()];
    await Assets.load(aliases);
    for (const alias of aliases) {
      loadedAliases.add(alias);
      pendingAliases.delete(alias);
    }
    for (const id2 of ids) {
      const urls = [...getFloorTilingVariantUrls(id2), getFloorBumpUrl(id2)].filter(Boolean);
      for (const url of urls) {
        const key2 = `${url}:${size2}`;
        if (resizedTextureByKey.has(key2) || resizedPendingByKey.has(key2)) continue;
        resizedPendingByKey.add(key2);
        buildResizedTexture(url, size2).then((texture) => {
          resizedTextureByKey.set(key2, texture);
        }).finally(() => {
          resizedPendingByKey.delete(key2);
        });
      }
    }
  } catch (error) {
    for (const alias of assets.keys()) {
      pendingAliases.delete(alias);
    }
    throw error;
  }
}
const DEFAULT_FILTER_VERT = `
in vec2 aPosition;
out vec2 vTextureCoord;

uniform vec4 uInputSize;
uniform vec4 uOutputFrame;
uniform vec4 uOutputTexture;

vec4 filterVertexPosition(void)
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;

    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0 * uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

vec2 filterTextureCoord(void)
{
    return aPosition * (uOutputFrame.zw * uInputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`;
function hash01(x2, y2, seed) {
  const n2 = x2 * 374761393 + y2 * 668265263 + seed * 1442695041;
  let h2 = (n2 ^ n2 >> 13) * 1274126177;
  h2 = (h2 ^ h2 >> 16) >>> 0;
  return h2 % 1e3 / 1e3;
}
function hasNaturalTag(tags2) {
  if (!tags2 || tags2.length === 0) return false;
  return tags2.includes("nature") || tags2.includes("natural");
}
function parseHexColor(hex) {
  if (!hex) return null;
  const cleaned = hex.trim().replace("#", "");
  if (!cleaned) return null;
  const value2 = Number.parseInt(cleaned, 16);
  return Number.isFinite(value2) ? value2 : null;
}
function hashString(value2) {
  let hash = 2166136261;
  for (let i2 = 0; i2 < value2.length; i2++) {
    hash ^= value2.charCodeAt(i2);
    hash = Math.imul(hash, 16777619);
  }
  return hash >>> 0;
}
function isSamePoint(a2, b2) {
  return a2.x === b2.x && a2.y === b2.y;
}
function pointKey(p2) {
  return `${p2.x},${p2.y}`;
}
function smoothClosedLoop(points, iterations) {
  if (points.length < 3 || iterations <= 0) return points;
  let result = points;
  for (let i2 = 0; i2 < iterations; i2++) {
    const next = [];
    for (let j2 = 0; j2 < result.length; j2++) {
      const p0 = result[j2];
      const p1 = result[(j2 + 1) % result.length];
      next.push({ x: p0.x * 0.75 + p1.x * 0.25, y: p0.y * 0.75 + p1.y * 0.25 });
      next.push({ x: p0.x * 0.25 + p1.x * 0.75, y: p0.y * 0.25 + p1.y * 0.75 });
    }
    result = next;
  }
  return result;
}
function displaceLoop(points, iterations, amplitude, seed) {
  if (points.length < 3 || iterations <= 0 || amplitude <= 0) return points;
  let result = points;
  for (let i2 = 0; i2 < iterations; i2++) {
    const next = [];
    for (let j2 = 0; j2 < result.length; j2++) {
      const p0 = result[j2];
      const p1 = result[(j2 + 1) % result.length];
      const mx = (p0.x + p1.x) * 0.5;
      const my = (p0.y + p1.y) * 0.5;
      const jitterX = (hash01(Math.round(mx * 100), Math.round(my * 100), seed) - 0.5) * 2 * amplitude;
      const jitterY = (hash01(Math.round(mx * 100), Math.round(my * 100), seed + 17) - 0.5) * 2 * amplitude;
      next.push(p0);
      next.push({ x: mx + jitterX, y: my + jitterY });
    }
    result = next;
  }
  return result;
}
function buildLoopsFromSegments(segments) {
  const loops = [];
  const used = new Array(segments.length).fill(false);
  const byPoint = /* @__PURE__ */ new Map();
  segments.forEach((seg, index) => {
    const aKey = pointKey(seg.a);
    const bKey = pointKey(seg.b);
    const listA = byPoint.get(aKey);
    if (listA) listA.push(index);
    else byPoint.set(aKey, [index]);
    const listB = byPoint.get(bKey);
    if (listB) listB.push(index);
    else byPoint.set(bKey, [index]);
  });
  for (let i2 = 0; i2 < segments.length; i2++) {
    if (used[i2]) continue;
    used[i2] = true;
    const seg = segments[i2];
    const points = [seg.a, seg.b];
    let current = seg.b;
    let previous = seg.a;
    while (true) {
      const candidates = byPoint.get(pointKey(current)) ?? [];
      const nextIndex = candidates.find((index) => !used[index]);
      if (nextIndex === void 0) break;
      used[nextIndex] = true;
      const nextSeg = segments[nextIndex];
      const nextPoint = isSamePoint(nextSeg.a, current) ? nextSeg.b : nextSeg.a;
      if (isSamePoint(nextPoint, previous)) break;
      points.push(nextPoint);
      previous = current;
      current = nextPoint;
      if (isSamePoint(current, points[0])) break;
    }
    if (points.length >= 3) {
      if (!isSamePoint(points[0], points[points.length - 1])) {
        points.push(points[0]);
      }
      loops.push(points.slice(0, points.length - 1));
    }
  }
  return loops;
}
function canvasBlendTriangle(ctx, corner, left, top, right, bottom) {
  ctx.beginPath();
  if (corner === "NE") {
    ctx.moveTo(left, top);
    ctx.lineTo(right, top);
    ctx.lineTo(right, bottom);
  } else if (corner === "NW") {
    ctx.moveTo(left, top);
    ctx.lineTo(right, top);
    ctx.lineTo(left, bottom);
  } else if (corner === "SE") {
    ctx.moveTo(right, top);
    ctx.lineTo(right, bottom);
    ctx.lineTo(left, bottom);
  } else {
    ctx.moveTo(left, top);
    ctx.lineTo(right, bottom);
    ctx.lineTo(left, bottom);
  }
  ctx.closePath();
  ctx.fill();
}
function canvasBaseTriangle(ctx, corner, left, top, right, bottom) {
  ctx.beginPath();
  if (corner === "NE") {
    ctx.moveTo(left, top);
    ctx.lineTo(right, bottom);
    ctx.lineTo(left, bottom);
  } else if (corner === "NW") {
    ctx.moveTo(right, top);
    ctx.lineTo(right, bottom);
    ctx.lineTo(left, bottom);
  } else if (corner === "SE") {
    ctx.moveTo(left, top);
    ctx.lineTo(right, top);
    ctx.lineTo(left, bottom);
  } else {
    ctx.moveTo(left, top);
    ctx.lineTo(right, top);
    ctx.lineTo(right, bottom);
  }
  ctx.closePath();
  ctx.fill();
}
function usePixiNaturalTiling(options) {
  const [readyTick, setReadyTick] = reactExports.useState(0);
  const texturedIds = reactExports.useMemo(() => {
    const list = [];
    for (const mat of options.materials.values()) {
      if (getFloorTilingUrl(mat.id) || getFloorBumpUrl(mat.id)) list.push(mat.id);
    }
    list.sort();
    return list;
  }, [options.materials]);
  const naturalIds = reactExports.useMemo(() => {
    const list = [];
    for (const mat of options.materials.values()) {
      if (hasNaturalTag(mat.tags)) list.push(mat.id);
    }
    list.sort();
    return list;
  }, [options.materials]);
  reactExports.useEffect(() => {
    let cancelled = false;
    void (async () => {
      try {
        await preloadFloorTilingTexturesFor(texturedIds, 256);
        if (!cancelled) setReadyTick((t2) => t2 + 1);
      } catch (error) {
        if (!cancelled) {
          console.warn("Failed to preload floor tiling textures:", error);
        }
      }
    })();
    return () => {
      cancelled = true;
    };
  }, [texturedIds.join("|")]);
  reactExports.useEffect(() => {
    var _a;
    const layer = options.layerRef.current;
    if (!layer) return;
    const removed = layer.removeChildren();
    for (const child of removed) {
      child.destroy();
    }
    const terrain = Array.isArray(options.terrain) ? options.terrain : null;
    if (!terrain || terrain.length === 0) return;
    const terrainMix = Array.isArray(options.terrainMix) ? options.terrainMix : null;
    const playable = options.playableCells ?? null;
    const { cols, rows } = options.grid;
    const boardW = getBoardWidth(cols);
    const boardH = getBoardHeight(rows);
    const isPlayable2 = (x2, y2) => {
      if (!playable || playable.size === 0) return true;
      return playable.has(`${x2},${y2}`);
    };
    const getTerrainAt2 = (x2, y2) => {
      if (x2 < 0 || y2 < 0 || x2 >= cols || y2 >= rows) return "unknown";
      const index = y2 * cols + x2;
      return terrain[index] ?? "unknown";
    };
    const getMixAt = (x2, y2) => {
      if (!terrainMix) return null;
      if (x2 < 0 || y2 < 0 || x2 >= cols || y2 >= rows) return null;
      return terrainMix[y2 * cols + x2] ?? null;
    };
    const getEdgeTerrain = (x2, y2, edge) => {
      if (!isPlayable2(x2, y2)) return null;
      const base = getTerrainAt2(x2, y2);
      const mix = getMixAt(x2, y2);
      if (!mix) return base;
      const blend = mix.blend;
      if (mix.corner === "NE") {
        return edge === "N" || edge === "E" ? blend : base;
      }
      if (mix.corner === "NW") {
        return edge === "N" || edge === "W" ? blend : base;
      }
      if (mix.corner === "SE") {
        return edge === "S" || edge === "E" ? blend : base;
      }
      return edge === "S" || edge === "W" ? blend : base;
    };
    const collectBoundarySegments = (id2) => {
      const segments = [];
      for (let y2 = 0; y2 < rows; y2++) {
        for (let x2 = 0; x2 < cols; x2++) {
          if (!isPlayable2(x2, y2)) continue;
          const mix = getMixAt(x2, y2);
          const left = x2;
          const top = y2;
          const right = x2 + 1;
          const bottom = y2 + 1;
          const northEdge = getEdgeTerrain(x2, y2, "N");
          const southEdge = getEdgeTerrain(x2, y2, "S");
          const westEdge = getEdgeTerrain(x2, y2, "W");
          const eastEdge = getEdgeTerrain(x2, y2, "E");
          if (northEdge === id2) {
            const neighbor = getEdgeTerrain(x2, y2 - 1, "S");
            if (!neighbor || neighbor !== id2) {
              segments.push({ a: { x: left, y: top }, b: { x: right, y: top } });
            }
          }
          if (southEdge === id2) {
            const neighbor = getEdgeTerrain(x2, y2 + 1, "N");
            if (!neighbor || neighbor !== id2) {
              segments.push({ a: { x: left, y: bottom }, b: { x: right, y: bottom } });
            }
          }
          if (westEdge === id2) {
            const neighbor = getEdgeTerrain(x2 - 1, y2, "E");
            if (!neighbor || neighbor !== id2) {
              segments.push({ a: { x: left, y: top }, b: { x: left, y: bottom } });
            }
          }
          if (eastEdge === id2) {
            const neighbor = getEdgeTerrain(x2 + 1, y2, "W");
            if (!neighbor || neighbor !== id2) {
              segments.push({ a: { x: right, y: top }, b: { x: right, y: bottom } });
            }
          }
          if (mix && (mix.base === id2 || mix.blend === id2) && mix.base !== mix.blend) {
            if (mix.corner === "NE" || mix.corner === "SW") {
              segments.push({ a: { x: left, y: top }, b: { x: right, y: bottom } });
            } else {
              segments.push({ a: { x: right, y: top }, b: { x: left, y: bottom } });
            }
          }
        }
      }
      return segments;
    };
    const animatedFilters = [];
    const resolveLightValue = (x2, y2) => {
      const idx = y2 * cols + x2;
      if (Array.isArray(options.lightLevels) && options.lightLevels.length > 0) {
        const value2 = options.lightLevels[idx];
        return Number.isFinite(value2) ? Math.max(0, Math.min(1, value2)) : 1;
      }
      if (Array.isArray(options.lightMap) && options.lightMap.length > 0) {
        const value2 = options.lightMap[idx];
        return Number.isFinite(value2) ? Math.max(0, Math.min(1, value2)) : 1;
      }
      return 1;
    };
    const buildLightTexture = () => {
      if ((!Array.isArray(options.lightLevels) || options.lightLevels.length === 0) && (!Array.isArray(options.lightMap) || options.lightMap.length === 0)) {
        return null;
      }
      const canvas = document.createElement("canvas");
      canvas.width = cols;
      canvas.height = rows;
      const ctx = canvas.getContext("2d");
      if (!ctx) return null;
      const image = ctx.createImageData(cols, rows);
      for (let y2 = 0; y2 < rows; y2++) {
        for (let x2 = 0; x2 < cols; x2++) {
          const light2 = resolveLightValue(x2, y2);
          const value2 = Math.round(light2 * 255);
          const idx = (y2 * cols + x2) * 4;
          image.data[idx] = value2;
          image.data[idx + 1] = value2;
          image.data[idx + 2] = value2;
          image.data[idx + 3] = 255;
        }
      }
      ctx.putImageData(image, 0, 0);
      const texture = Texture.from(canvas);
      if (texture.source) {
        texture.source.scaleMode = "nearest";
        texture.source.addressMode = "clamp-to-edge";
      }
      return texture;
    };
    const lightTexture = buildLightTexture();
    for (const id2 of texturedIds) {
      const variantUrls = getFloorTilingVariantUrls(id2);
      const fallbackUrl = getFloorTilingUrl(id2);
      const resolvedVariants = variantUrls.length > 0 ? variantUrls : fallbackUrl ? [fallbackUrl] : [null];
      const variantCount = resolvedVariants.length;
      const variantSeed = hashString(id2);
      const hasVariants = variantCount > 1;
      const variantIndices = [...Array(variantCount).keys()];
      const bumpUrl = getFloorBumpUrl(id2);
      const resizedBump = getFloorBumpTexture(id2, 256);
      const bumpTexture = resizedBump ?? (bumpUrl ? Assets.get(bumpUrl) ?? Texture.from(bumpUrl) : null);
      const material = options.materials.get(id2);
      const fallbackColor2 = parseHexColor(material == null ? void 0 : material.fallbackColor) ?? 4156218;
      const solidColor2 = parseHexColor((material == null ? void 0 : material.solidColor) ?? null);
      if (bumpTexture == null ? void 0 : bumpTexture.source) {
        bumpTexture.source.scaleMode = "linear";
        bumpTexture.source.mipmapFilter = "linear";
        bumpTexture.source.autoGenerateMipmaps = true;
        bumpTexture.source.maxAnisotropy = 4;
        bumpTexture.source.addressMode = "repeat";
        console.log(
          "[floor-tiling] bump",
          id2,
          "size",
          bumpTexture.width,
          "x",
          bumpTexture.height,
          "grid",
          cols,
          "x",
          rows
        );
      }
      if (!bumpTexture && bumpUrl) {
        console.warn("[floor-tiling] bump texture missing for", id2, "url", bumpUrl);
      }
      const pickVariantIndex = (x2, y2) => {
        if (!hasVariants) return 0;
        const t2 = hash01(x2, y2, variantSeed);
        return Math.min(variantCount - 1, Math.floor(t2 * variantCount));
      };
      const baseMaskCanvas = document.createElement("canvas");
      baseMaskCanvas.width = boardW;
      baseMaskCanvas.height = boardH;
      const baseCtx = baseMaskCanvas.getContext("2d");
      if (!baseCtx) continue;
      baseCtx.fillStyle = "#ffffff";
      baseCtx.imageSmoothingEnabled = true;
      if (naturalIds.includes(id2)) {
        const segments = collectBoundarySegments(id2);
        const loops = buildLoopsFromSegments(segments);
        const seed = 1337;
        const displacedLoops = loops.map((loop) => displaceLoop(loop, 2, 0.22, seed));
        const smoothLoops = displacedLoops.map((loop) => smoothClosedLoop(loop, 1));
        baseCtx.beginPath();
        for (const loop of smoothLoops) {
          if (loop.length < 3) continue;
          baseCtx.moveTo(loop[0].x * TILE_SIZE, loop[0].y * TILE_SIZE);
          for (let i2 = 1; i2 < loop.length; i2++) {
            baseCtx.lineTo(loop[i2].x * TILE_SIZE, loop[i2].y * TILE_SIZE);
          }
          baseCtx.closePath();
        }
        baseCtx.save();
        baseCtx.lineJoin = "round";
        baseCtx.lineCap = "round";
        baseCtx.lineWidth = TILE_SIZE * 0.6;
        baseCtx.strokeStyle = "#ffffff";
        baseCtx.stroke();
        baseCtx.restore();
        try {
          baseCtx.fill("evenodd");
        } catch {
          baseCtx.fill();
        }
      } else {
        for (let y2 = 0; y2 < rows; y2++) {
          for (let x2 = 0; x2 < cols; x2++) {
            if (!isPlayable2(x2, y2)) continue;
            const cell = getTerrainAt2(x2, y2);
            const mix = getMixAt(x2, y2);
            const left = x2 * TILE_SIZE;
            const top = y2 * TILE_SIZE;
            const right = left + TILE_SIZE;
            const bottom = top + TILE_SIZE;
            if (!mix) {
              if (cell === id2) {
                baseCtx.fillRect(left, top, TILE_SIZE, TILE_SIZE);
              }
            } else {
              if (mix.blend === id2) {
                canvasBlendTriangle(baseCtx, mix.corner, left, top, right, bottom);
              }
              if (mix.base === id2) {
                canvasBaseTriangle(baseCtx, mix.corner, left, top, right, bottom);
              }
            }
          }
        }
      }
      const baseMaskTexture = Texture.from(baseMaskCanvas);
      const baseMaskSprite = new Sprite(baseMaskTexture);
      baseMaskSprite.x = 0;
      baseMaskSprite.y = 0;
      baseMaskSprite.alpha = 1e-3;
      baseMaskSprite.label = `natural-mask:${id2}:base`;
      const materialContainer = new Container();
      materialContainer.mask = baseMaskSprite;
      layer.addChild(baseMaskSprite);
      layer.addChild(materialContainer);
      const hasAnyTexture = resolvedVariants.some((url) => Boolean(url));
      const backgroundTint = solidColor2 ?? fallbackColor2;
      if (solidColor2 !== null || !bumpTexture && hasAnyTexture) {
        const backgroundSprite = new TilingSprite({ texture: Texture.WHITE, width: boardW, height: boardH });
        backgroundSprite.tint = backgroundTint;
        backgroundSprite.x = 0;
        backgroundSprite.y = 0;
        backgroundSprite.tileScale.set(1, 1);
        materialContainer.addChild(backgroundSprite);
      }
      if (!hasAnyTexture) {
        const solidSprite = new TilingSprite({ texture: Texture.WHITE, width: boardW, height: boardH });
        solidSprite.tint = fallbackColor2;
        solidSprite.x = 0;
        solidSprite.y = 0;
        solidSprite.tileScale.set(1, 1);
        materialContainer.addChild(solidSprite);
        continue;
      }
      for (const variantIndex of variantIndices) {
        const variantUrl = resolvedVariants[variantIndex] ?? null;
        if (!variantUrl) continue;
        const resizedTexture = getFloorTilingTextureFromUrl(variantUrl, 256);
        const baseTexture = resizedTexture ?? Assets.get(variantUrl) ?? Texture.from(variantUrl);
        if (baseTexture.source) {
          baseTexture.source.scaleMode = "linear";
          baseTexture.source.mipmapFilter = "linear";
          baseTexture.source.autoGenerateMipmaps = true;
          baseTexture.source.maxAnisotropy = 4;
          baseTexture.source.addressMode = "repeat";
        }
        const sprite = new TilingSprite({ texture: baseTexture, width: boardW, height: boardH });
        sprite.x = 0;
        sprite.y = 0;
        if (bumpTexture) {
          const fragment = `
            precision highp float;
            in vec2 vTextureCoord;
            out vec4 finalColor;
            uniform sampler2D uTexture;
            uniform sampler2D uBump;
            uniform sampler2D uLightMap;
            uniform vec2 uBumpScale;
            uniform vec2 uLightMapSize;
            uniform float uIntensity;
            uniform float uTime;
            uniform float uWindSpeed;
            uniform float uWindStrength;
            uniform float uLightEnabled;
            uniform float uDebug;
            void main(void){
              vec4 base = texture(uTexture, vTextureCoord);
              vec2 wind = vec2(uTime * uWindSpeed, uTime * uWindSpeed * 0.7);
              vec2 bumpUV = vTextureCoord * uBumpScale + wind;
              vec3 bump = texture(uBump, bumpUV).rgb;
              float h = dot(bump, vec3(0.3333));
              vec3 n = normalize(vec3(bump.r * 2.0 - 1.0, bump.g * 2.0 - 1.0, bump.b * 2.0 - 1.0));
              vec3 lightDir = normalize(vec3(0.35, 0.6, 0.8));
              float ndl = max(dot(n, lightDir), 0.0);
              float light = mix(h, ndl, 0.65);
              vec2 lightCoord = (floor(vTextureCoord * uLightMapSize) + 0.5) / uLightMapSize;
              float lightSample = texture(uLightMap, lightCoord).r;
              float lightFactor = mix(1.0, mix(0.35, 1.0, lightSample), step(0.5, uLightEnabled));
              float signedLight = (light - 0.5) * (uIntensity * 2.0) * uWindStrength * lightFactor;
              vec3 lit = base.rgb * (1.0 + signedLight);
              vec3 debugColor = vec3(h);
              vec3 outColor = mix(lit, debugColor, step(0.5, uDebug));
              finalColor = vec4(outColor, base.a);
            }
          `;
          const intensity = typeof options.bumpIntensity === "number" ? options.bumpIntensity : 0.45;
          const windSpeed = typeof options.windSpeed === "number" ? options.windSpeed : 0.06;
          const windStrength = typeof options.windStrength === "number" ? options.windStrength : 1;
          const uniforms = new UniformGroup({
            uBumpScale: { value: [cols, rows], type: "vec2<f32>" },
            uLightMapSize: { value: [cols, rows], type: "vec2<f32>" },
            uIntensity: { value: intensity, type: "f32" },
            uTime: { value: 0, type: "f32" },
            uWindSpeed: { value: windSpeed, type: "f32" },
            uWindStrength: { value: windStrength, type: "f32" },
            uLightEnabled: { value: lightTexture ? 1 : 0, type: "f32" },
            uDebug: { value: options.bumpDebug ? 1 : 0, type: "f32" }
          });
          const glProgram = GlProgram.from({
            vertex: DEFAULT_FILTER_VERT,
            fragment
          });
          const filter = new Filter({
            glProgram,
            resources: {
              uBump: bumpTexture,
              uLightMap: lightTexture ?? Texture.WHITE,
              bumpUniforms: uniforms
            }
          });
          sprite.filters = [filter];
          animatedFilters.push({ uniforms, startAt: performance.now() });
        }
        const texW = baseTexture.width || TILE_SIZE;
        const texH = baseTexture.height || TILE_SIZE;
        sprite.tileScale.set(TILE_SIZE / texW, TILE_SIZE / texH);
        const maskCanvas = document.createElement("canvas");
        maskCanvas.width = boardW;
        maskCanvas.height = boardH;
        const ctx = maskCanvas.getContext("2d");
        if (!ctx) continue;
        ctx.fillStyle = "#ffffff";
        ctx.imageSmoothingEnabled = true;
        for (let y2 = 0; y2 < rows; y2++) {
          for (let x2 = 0; x2 < cols; x2++) {
            if (!isPlayable2(x2, y2)) continue;
            const cell = getTerrainAt2(x2, y2);
            const mix = getMixAt(x2, y2);
            const hasId = !mix ? cell === id2 : mix.base === id2 || mix.blend === id2;
            if (!hasId) continue;
            if (hasVariants && pickVariantIndex(x2, y2) !== variantIndex) continue;
            ctx.fillRect(x2 * TILE_SIZE, y2 * TILE_SIZE, TILE_SIZE, TILE_SIZE);
          }
        }
        const maskTexture = Texture.from(maskCanvas);
        const maskSprite = new Sprite(maskTexture);
        maskSprite.x = 0;
        maskSprite.y = 0;
        maskSprite.alpha = 1e-3;
        maskSprite.label = `natural-mask:${id2}:v${variantIndex}`;
        sprite.mask = maskSprite;
        materialContainer.addChild(sprite);
        materialContainer.addChild(maskSprite);
      }
    }
    let rafId = null;
    if (animatedFilters.length > 0) {
      const tick = () => {
        const now = performance.now();
        for (const entry of animatedFilters) {
          const t2 = (now - entry.startAt) / 1e3;
          entry.uniforms.uniforms.uTime = t2;
        }
        rafId = window.requestAnimationFrame(tick);
      };
      rafId = window.requestAnimationFrame(tick);
    }
    (_a = options.onInvalidate) == null ? void 0 : _a.call(options);
    return () => {
      if (rafId !== null) window.cancelAnimationFrame(rafId);
    };
  }, [
    options.layerRef,
    options.terrain,
    options.terrainMix,
    options.playableCells,
    options.grid,
    options.materials,
    options.lightLevels,
    options.lightMap,
    options.bumpIntensity,
    options.windSpeed,
    options.windStrength,
    options.bumpDebug,
    options.pixiReadyTick,
    options.onInvalidate,
    texturedIds,
    naturalIds,
    readyTick
  ]);
}
function usePixiObstacles(options) {
  const hashString012 = (input) => {
    let hash = 2166136261;
    for (let i2 = 0; i2 < input.length; i2++) {
      hash ^= input.charCodeAt(i2);
      hash = Math.imul(hash, 16777619);
    }
    return (hash >>> 0) / 4294967295;
  };
  const lerpColor = (a2, b2, t2) => {
    const ar = a2 >> 16 & 255;
    const ag = a2 >> 8 & 255;
    const ab = a2 & 255;
    const br = b2 >> 16 & 255;
    const bg = b2 >> 8 & 255;
    const bb = b2 & 255;
    const rr = Math.round(ar + (br - ar) * t2);
    const rg = Math.round(ag + (bg - ag) * t2);
    const rb = Math.round(ab + (bb - ab) * t2);
    return rr << 16 | rg << 8 | rb;
  };
  const resolvePaletteLayer = (def, layerKey, paletteId) => {
    const appearance2 = def == null ? void 0 : def.appearance;
    if (!(appearance2 == null ? void 0 : appearance2.palettes)) return null;
    const resolvedId = paletteId ?? appearance2.paletteId ?? "default";
    const palette = appearance2.palettes[resolvedId] ?? appearance2.palettes[appearance2.paletteId ?? "default"] ?? null;
    if (!(palette == null ? void 0 : palette.layers)) return null;
    return palette.layers[layerKey] ?? null;
  };
  const resolveShadowSpec = (def) => {
    var _a, _b, _c;
    const heightClass = String(((_a = def == null ? void 0 : def.appearance) == null ? void 0 : _a.heightClass) ?? "medium").toLowerCase();
    const stretchRaw = Number.isFinite((_b = def == null ? void 0 : def.appearance) == null ? void 0 : _b.shadowStretch) ? (_c = def == null ? void 0 : def.appearance) == null ? void 0 : _c.shadowStretch : 1;
    const stretchClamped = Math.min(12, Math.max(0, stretchRaw));
    const lengthPx = Math.max(2, Math.round(stretchClamped * TILE_SIZE));
    if (heightClass === "low") {
      return {
        alpha: 0.22,
        lengthPx
      };
    }
    if (heightClass === "tall") {
      return {
        alpha: 0.36,
        lengthPx
      };
    }
    return {
      alpha: 0.3,
      lengthPx
    };
  };
  const resolveShadowOffset = (heightClass, lengthPx) => {
    const base = Math.max(2, Math.round(lengthPx * 0.18));
    if (heightClass === "low") return Math.max(2, Math.round(base * 0.85));
    if (heightClass === "tall") return Math.max(3, Math.round(base * 1.35));
    return base;
  };
  const shadowAnchorCache = /* @__PURE__ */ new WeakMap();
  const resolveShadowAnchor = (texture) => {
    var _a;
    const cached = shadowAnchorCache.get(texture);
    if (cached) return cached;
    const fallback = { x: 0.5, y: 1 };
    const source2 = ((_a = texture.source) == null ? void 0 : _a.resource) ?? texture.resource ?? null;
    const image = (source2 == null ? void 0 : source2.source) ?? (source2 && typeof source2.width === "number" && typeof source2.height === "number" ? source2 : null);
    if (!image) {
      shadowAnchorCache.set(texture, fallback);
      return fallback;
    }
    const width = image.width ?? 0;
    const height = image.height ?? 0;
    if (width <= 0 || height <= 0) {
      shadowAnchorCache.set(texture, fallback);
      return fallback;
    }
    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext("2d");
    if (!ctx) {
      shadowAnchorCache.set(texture, fallback);
      return fallback;
    }
    try {
      ctx.drawImage(image, 0, 0);
      const data = ctx.getImageData(0, 0, width, height).data;
      let minX = width;
      let minY = height;
      let maxX = 0;
      let maxY = 0;
      let found = false;
      for (let y2 = 0; y2 < height; y2++) {
        const row = y2 * width * 4;
        for (let x2 = 0; x2 < width; x2++) {
          const alpha = data[row + x2 * 4 + 3];
          if (alpha > 8) {
            found = true;
            if (x2 < minX) minX = x2;
            if (y2 < minY) minY = y2;
            if (x2 > maxX) maxX = x2;
            if (y2 > maxY) maxY = y2;
          }
        }
      }
      if (!found) {
        shadowAnchorCache.set(texture, fallback);
        return fallback;
      }
      const centerX = (minX + maxX) / 2;
      const bottomY = maxY;
      const anchor2 = {
        x: width > 1 ? centerX / (width - 1) : 0.5,
        y: height > 1 ? bottomY / (height - 1) : 1
      };
      shadowAnchorCache.set(texture, anchor2);
      return anchor2;
    } catch {
      shadowAnchorCache.set(texture, fallback);
      return fallback;
    }
  };
  const isCanopyLayer = (layer) => {
    if (!(layer == null ? void 0 : layer.spriteKey)) return false;
    const id2 = String(layer.id ?? "").toLowerCase();
    const key2 = layer.spriteKey.toLowerCase();
    return id2.includes("canopy") || key2.includes("canopy");
  };
  const shouldRenderShadowForLayer = (layer) => {
    if (!(layer == null ? void 0 : layer.spriteKey)) return false;
    if (layer.renderLayer === "overhead" && !isCanopyLayer(layer)) return false;
    return layer.spriteKey.startsWith("obstacle:");
  };
  const getFootprintGrid = (def) => {
    var _a;
    if (!((_a = def == null ? void 0 : def.variants) == null ? void 0 : _a.length)) return null;
    let minX = Number.POSITIVE_INFINITY;
    let minY = Number.POSITIVE_INFINITY;
    let maxX = Number.NEGATIVE_INFINITY;
    let maxY = Number.NEGATIVE_INFINITY;
    for (const variant of def.variants) {
      for (const cell of variant.footprint ?? []) {
        if (cell.x < minX) minX = cell.x;
        if (cell.y < minY) minY = cell.y;
        if (cell.x > maxX) maxX = cell.x;
        if (cell.y > maxY) maxY = cell.y;
      }
    }
    if (!Number.isFinite(minX) || !Number.isFinite(minY) || !Number.isFinite(maxX) || !Number.isFinite(maxY)) {
      return null;
    }
    return { tilesX: Math.max(1, Math.round(maxX - minX + 1)), tilesY: Math.max(1, Math.round(maxY - minY + 1)) };
  };
  reactExports.useEffect(() => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s;
    const depthLayer = options.depthLayerRef.current;
    if (!depthLayer) return;
    depthLayer.cacheAsTexture = false;
    for (const child of [...depthLayer.children]) {
      if (child.label === "obstacle" || child.label === "obstacle-layer" || child.label === "obstacle-shadow") {
        depthLayer.removeChild(child);
        (_a = child.destroy) == null ? void 0 : _a.call(child);
      }
    }
    if (options.suspendRendering) return;
    const typeById = /* @__PURE__ */ new Map();
    for (const t2 of options.obstacleTypes) typeById.set(t2.id, t2);
    const visibleCells = options.visibleCells ?? null;
    const showAll = Boolean(options.showAllLevels);
    const cellKey = (x2, y2) => `${x2},${y2}`;
    const tokens = Array.isArray(options.tokens) ? options.tokens : [];
    const tokenOccupied = /* @__PURE__ */ new Set();
    for (const token of tokens) {
      if (token.hp <= 0) continue;
      for (const cell of getTokenOccupiedCells(token)) {
        tokenOccupied.add(cellKey(cell.x, cell.y));
      }
    }
    let hasAnyAnimatedLayer = false;
    for (const obs of options.obstacles) {
      if (obs.hp <= 0) continue;
      const def = typeById.get(obs.typeId) ?? null;
      const isTree = (def == null ? void 0 : def.id) === "tree-oak";
      const occupied = getObstacleOccupiedCells(obs, def);
      const tint = Number.isFinite((_b = def == null ? void 0 : def.appearance) == null ? void 0 : _b.tint) ? (_c = def == null ? void 0 : def.appearance) == null ? void 0 : _c.tint : 9329195;
      const center = occupied.length > 0 ? occupied.map((cell) => gridToScreenForGrid(cell.x, cell.y, options.grid.cols, options.grid.rows)).reduce(
        (acc, pt) => ({ x: acc.x + pt.x, y: acc.y + pt.y }),
        { x: 0, y: 0 }
      ) : gridToScreenForGrid(obs.x, obs.y, options.grid.cols, options.grid.rows);
      if (occupied.length > 0) {
        center.x /= occupied.length;
        center.y /= occupied.length;
      }
      const isAnyTokenBelow = occupied.some((cell) => tokenOccupied.has(cellKey(cell.x, cell.y)));
      const layers = ((_d = def == null ? void 0 : def.appearance) == null ? void 0 : _d.layers) && def.appearance.layers.length > 0 ? def.appearance.layers : ((_e = def == null ? void 0 : def.appearance) == null ? void 0 : _e.spriteKey) ? [{ spriteKey: def.appearance.spriteKey }] : [];
      let treeCanopyVisible = false;
      const paletteKey = String(options.paletteId ?? ((_f = def == null ? void 0 : def.appearance) == null ? void 0 : _f.paletteId) ?? "default").toLowerCase();
      const forceLeaflessShadow = isTree && (paletteKey === "winter" || paletteKey === "dead" || paletteKey === "leafless");
      if (isTree && layers.length > 0) {
        for (const layer of layers) {
          if (!isCanopyLayer(layer)) continue;
          const visibleRule = layer.visible ?? "always";
          if (visibleRule === "hideWhenTokenBelow" && isAnyTokenBelow) continue;
          const layerKey = layer.id ?? layer.spriteKey;
          const paletteLayer = resolvePaletteLayer(def, layerKey, options.paletteId);
          if ((paletteLayer == null ? void 0 : paletteLayer.visible) === false) continue;
          treeCanopyVisible = true;
          break;
        }
      }
      const treeUseLeaflessShadow = forceLeaflessShadow || !treeCanopyVisible;
      let renderedLayers = 0;
      let hasAnimatedLayer = false;
      if (layers.length > 0) {
        const footprintGrid = getFootprintGrid(def);
        const sorted = [...layers].sort((a2, b2) => (a2.z ?? 0) - (b2.z ?? 0));
        for (const layer of sorted) {
          const visibleRule = layer.visible ?? "always";
          if (visibleRule === "hideWhenTokenBelow" && isAnyTokenBelow) {
            continue;
          }
          const isLit = ((_g = obs.state) == null ? void 0 : _g.lit) !== false;
          const layerId = String(layer.id ?? "").toLowerCase();
          if (!isLit && (layerId.includes("flame") || layerId.includes("fire") || layer.spriteKey.toLowerCase().startsWith("effect:"))) {
            continue;
          }
          const layerKey = layer.id ?? layer.spriteKey;
          const paletteLayer = resolvePaletteLayer(def, layerKey, options.paletteId);
          if ((paletteLayer == null ? void 0 : paletteLayer.visible) === false) {
            continue;
          }
          const spriteUrl = getObstaclePngUrl(layer.spriteKey);
          const animationFrames = spriteUrl ? null : getObstacleAnimationFrames(layer.spriteKey);
          if (!spriteUrl && (!animationFrames || animationFrames.length === 0)) continue;
          let sprite;
          if (animationFrames && animationFrames.length > 0) {
            hasAnimatedLayer = true;
            hasAnyAnimatedLayer = true;
            const textures = animationFrames.map((frame) => Texture.from(frame));
            const anim = new AnimatedSprite(textures);
            const speed2 = typeof layer.animationSpeed === "number" ? layer.animationSpeed : typeof ((_h = def == null ? void 0 : def.appearance) == null ? void 0 : _h.animationSpeed) === "number" ? def.appearance.animationSpeed : 0.15;
            const loop = typeof layer.animationLoop === "boolean" ? layer.animationLoop : typeof ((_i = def == null ? void 0 : def.appearance) == null ? void 0 : _i.animationLoop) === "boolean" ? def.appearance.animationLoop : true;
            anim.animationSpeed = speed2;
            anim.loop = loop;
            anim.play();
            sprite = anim;
          } else {
            sprite = Sprite.from(spriteUrl);
          }
          sprite.anchor.set(0.5, 0.5);
          const orientation = obs.orientation ?? "right";
          sprite.rotation = orientationToRotationDeg(orientation) * Math.PI / 180;
          const scaleBase = typeof obs.tokenScale === "number" ? obs.tokenScale / 100 : 1;
          const scaleLayer = typeof layer.scale === "number" ? layer.scale : 1;
          const scaleAppearance = typeof ((_j = def == null ? void 0 : def.appearance) == null ? void 0 : _j.scale) === "number" ? def.appearance.scale : 1;
          const gridSpec = layer.spriteGrid ?? ((_k = def == null ? void 0 : def.appearance) == null ? void 0 : _k.spriteGrid) ?? footprintGrid ?? null;
          const preserveAspect = typeof layer.preserveAspect === "boolean" ? layer.preserveAspect : Boolean((_l = def == null ? void 0 : def.appearance) == null ? void 0 : _l.preserveAspect);
          const tileSize = gridSpec && typeof gridSpec.tileSize === "number" && gridSpec.tileSize > 0 ? gridSpec.tileSize : TILE_SIZE;
          if (gridSpec && sprite.texture.width > 0 && sprite.texture.height > 0) {
            const targetW = gridSpec.tilesX * tileSize;
            const targetH = gridSpec.tilesY * tileSize;
            const scaleX = targetW / sprite.texture.width;
            const scaleY = targetH / sprite.texture.height;
            const scale = preserveAspect ? Math.min(scaleX, scaleY) : null;
            if (scale) {
              sprite.scale.set(scale * scaleBase * scaleLayer * scaleAppearance);
            } else {
              sprite.scale.set(
                scaleX * scaleBase * scaleLayer * scaleAppearance,
                scaleY * scaleBase * scaleLayer * scaleAppearance
              );
            }
          } else {
            sprite.scale.set(scaleBase * scaleLayer * scaleAppearance);
          }
          const alpha = typeof (paletteLayer == null ? void 0 : paletteLayer.alpha) === "number" ? paletteLayer.alpha : typeof layer.alpha === "number" ? layer.alpha : 1;
          sprite.alpha = alpha;
          let tint2 = null;
          if (Number.isFinite(paletteLayer == null ? void 0 : paletteLayer.tint)) {
            tint2 = paletteLayer == null ? void 0 : paletteLayer.tint;
          } else if (paletteLayer == null ? void 0 : paletteLayer.tintRange) {
            const seed = `${obs.id}:${layerKey}:${options.paletteId ?? ((_m = def == null ? void 0 : def.appearance) == null ? void 0 : _m.paletteId) ?? "default"}`;
            const t2 = hashString012(seed);
            tint2 = lerpColor(paletteLayer.tintRange.dark, paletteLayer.tintRange.light, t2);
          } else if (Number.isFinite(layer.tint)) {
            tint2 = layer.tint;
          } else if (Number.isFinite((_n = def == null ? void 0 : def.appearance) == null ? void 0 : _n.tint)) {
            tint2 = (_o = def == null ? void 0 : def.appearance) == null ? void 0 : _o.tint;
          }
          sprite.tint = tint2 ?? 16777215;
          sprite.x = center.x;
          sprite.y = center.y;
          sprite.label = "obstacle-layer";
          const baseLayer = layer.renderLayer === "overhead" ? DEPTH_Z.overhead : DEPTH_Z.obstacleBase;
          sprite.zIndex = center.y + baseLayer + (layer.z ?? 0);
          if (!hasAnimatedLayer && shouldRenderShadowForLayer(layer)) {
            if ((def == null ? void 0 : def.id) === "brazier" && isLit) {
              depthLayer.addChild(sprite);
              renderedLayers += 1;
              continue;
            }
            const shadowSpec = resolveShadowSpec(def);
            const shadowMode = ((_p = def == null ? void 0 : def.appearance) == null ? void 0 : _p.shadowMode) ?? "default";
            const useTreeShadow = isTree && (isCanopyLayer(layer) || String(layer.id ?? "").toLowerCase().includes("trunk"));
            let shadowTexture = sprite.texture;
            if (useTreeShadow) {
              const key2 = treeUseLeaflessShadow ? ((_q = def == null ? void 0 : def.appearance) == null ? void 0 : _q.shadowSpriteLeafless) ?? "obstacle:tree-oak-trunk-shadow" : ((_r = def == null ? void 0 : def.appearance) == null ? void 0 : _r.shadowSpriteLeafy) ?? "obstacle:tree-oak-canopy-shadow";
              const url = getObstaclePngUrl(key2);
              if (url) shadowTexture = Texture.from(url);
            }
            if (useTreeShadow) {
              if (!treeUseLeaflessShadow && !isCanopyLayer(layer)) {
                depthLayer.addChild(sprite);
                renderedLayers += 1;
                continue;
              }
              if (treeUseLeaflessShadow && isCanopyLayer(layer)) {
                depthLayer.addChild(sprite);
                renderedLayers += 1;
                continue;
              }
            }
            const shadow = new Sprite(shadowTexture);
            const shadowGroup = new Container();
            const lightAngleDeg = typeof options.lightAngleDeg === "number" ? options.lightAngleDeg : 90;
            const lightAngle = lightAngleDeg * Math.PI / 180;
            const shadowAngle = shadowMode === "tall" ? lightAngle + Math.PI : lightAngle;
            shadowGroup.x = center.x;
            shadowGroup.y = center.y;
            shadowGroup.rotation = shadowAngle;
            shadow.anchor.set(0.5, 0.5);
            shadow.rotation = shadowMode === "tall" ? 0 : sprite.rotation - lightAngle;
            const gridBaseWidth = gridSpec && Number.isFinite(gridSpec.tilesX) ? gridSpec.tilesX * tileSize * scaleBase * scaleLayer * scaleAppearance : 0;
            const gridBaseHeight = gridSpec && Number.isFinite(gridSpec.tilesY) ? gridSpec.tilesY * tileSize * scaleBase * scaleLayer * scaleAppearance : 0;
            const baseWidth = gridBaseWidth > 0 ? gridBaseWidth : sprite.width > 0 ? sprite.width : shadow.texture.width > 0 ? shadow.texture.width * sprite.scale.x : 0;
            const baseHeight = gridBaseHeight > 0 ? gridBaseHeight : sprite.height > 0 ? sprite.height : shadow.texture.height > 0 ? shadow.texture.height * sprite.scale.y : 0;
            const heightClass = String(((_s = def == null ? void 0 : def.appearance) == null ? void 0 : _s.heightClass) ?? "medium").toLowerCase();
            if (shadowMode === "tall") {
              const anchor2 = resolveShadowAnchor(shadowTexture);
              shadow.anchor.set(anchor2.x, anchor2.y);
            }
            if (baseWidth > 0 && baseHeight > 0) {
              shadow.width = baseWidth;
              shadow.height = baseHeight;
              const sizeFactor = Math.max(1, baseHeight / TILE_SIZE);
              const desiredLength = shadowSpec.lengthPx * sizeFactor;
              shadowGroup.scale.y = desiredLength / baseHeight;
            } else {
              shadow.scale.set(sprite.scale.x, sprite.scale.y);
              shadowGroup.scale.y = 1;
            }
            const offsetPx = shadowMode === "tall" ? 0 : resolveShadowOffset(heightClass, shadowSpec.lengthPx);
            shadow.x = 0;
            shadow.y = offsetPx;
            const alphaScale = isCanopyLayer(layer) ? 1 : Number.isFinite(alpha) ? alpha : 1;
            shadow.alpha = Math.max(0.05, Math.min(0.55, shadowSpec.alpha * alphaScale));
            shadow.tint = 0;
            shadow.label = "obstacle-shadow";
            shadowGroup.label = "obstacle-shadow";
            shadowGroup.zIndex = center.y + baseLayer + (layer.z ?? 0) - 2;
            shadowGroup.addChild(shadow);
            depthLayer.addChild(shadowGroup);
          }
          depthLayer.addChild(sprite);
          renderedLayers += 1;
        }
      }
      if (renderedLayers === 0) {
        for (const cell of occupied) {
          const key2 = cellKey(cell.x, cell.y);
          const isVisible = showAll || ((visibleCells == null ? void 0 : visibleCells.has(key2)) ?? true);
          if (!isVisible) continue;
          const center2 = gridToScreenForGrid(cell.x, cell.y, options.grid.cols, options.grid.rows);
          const size2 = TILE_SIZE * 0.9;
          const x2 = center2.x - size2 / 2;
          const y2 = center2.y - size2 / 2;
          const g2 = new Graphics();
          g2.rect(x2, y2, size2, size2).fill({
            color: tint,
            alpha: 0.85
          });
          g2.label = "obstacle-layer";
          g2.zIndex = center2.y + DEPTH_Z.obstacleBase;
          depthLayer.addChild(g2);
        }
      }
    }
    if (!hasAnyAnimatedLayer) {
      depthLayer.cacheAsTexture = true;
    }
  }, [
    options.depthLayerRef,
    options.obstacles,
    options.obstacleTypes,
    options.tokens,
    options.pixiReadyTick,
    options.grid,
    options.heightMap,
    options.activeLevel,
    options.visibleCells,
    options.showAllLevels,
    options.lightAngleDeg
  ]);
}
function usePixiOverlays(options) {
  reactExports.useEffect(() => {
    const pathLayer = options.pathLayerRef.current;
    if (!pathLayer) return;
    const fogLayer = (() => {
      const parent = pathLayer.parent;
      if (!parent) return pathLayer;
      const existing = parent.__fogLayer;
      if (existing) return existing;
      const layer = new Graphics();
      layer.filters = [new BlurFilter({ strength: 4, quality: 3 })];
      parent.__fogLayer = layer;
      parent.addChild(layer);
      return layer;
    })();
    const lightLayer = (() => {
      const parent = pathLayer.parent;
      if (!parent) return pathLayer;
      const existing = parent.__lightLayer;
      const desiredIndex = parent.children.findIndex(
        (child) => child && typeof child.name === "string" && child.name === "staticDepthLayer"
      );
      if (existing) {
        if (desiredIndex >= 0) {
          const targetIndex = Math.max(0, desiredIndex);
          if (parent.getChildIndex(existing) !== targetIndex) {
            parent.setChildIndex(existing, targetIndex);
          }
        }
        return existing;
      }
      const layer = new Graphics();
      layer.filters = [new BlurFilter({ strength: 6, quality: 3 })];
      layer.blendMode = "add";
      parent.__lightLayer = layer;
      if (desiredIndex >= 0) {
        parent.addChildAt(layer, Math.max(0, desiredIndex));
      } else {
        parent.addChild(layer);
      }
      return layer;
    })();
    pathLayer.clear();
    fogLayer.clear();
    lightLayer.clear();
    lightLayer.removeChildren();
    const lineSpecs = options.effectSpecs.filter((spec) => spec.kind === "line");
    for (const spec of lineSpecs) {
      if (typeof spec.toX !== "number" || typeof spec.toY !== "number") continue;
      const start2 = gridToScreenForGrid(options.player.x, options.player.y, options.grid.cols, options.grid.rows);
      const end = gridToScreenForGrid(spec.toX, spec.toY, options.grid.cols, options.grid.rows);
      const color = typeof spec.color === "number" ? spec.color : 7328383;
      const alpha = typeof spec.alpha === "number" ? spec.alpha : 0.9;
      const thickness = typeof spec.thickness === "number" ? spec.thickness : 2;
      pathLayer.lineStyle(thickness, color, alpha);
      pathLayer.moveTo(start2.x, start2.y);
      pathLayer.lineTo(end.x, end.y);
    }
    const activeEffects = options.effectSpecs.filter((spec) => spec.kind !== "line").map((spec) => {
      switch (spec.kind) {
        case "circle":
          return generateCircleEffect(
            spec.id,
            options.player.x,
            options.player.y,
            spec.radius ?? 1,
            { playableCells: options.playableCells ?? null }
          );
        case "rectangle":
          return generateRectangleEffect(
            spec.id,
            options.player.x,
            options.player.y,
            spec.width ?? 1,
            spec.height ?? 1,
            { playableCells: options.playableCells ?? null }
          );
        case "cone":
          return generateConeEffect(
            spec.id,
            options.player.x,
            options.player.y,
            spec.range ?? 1,
            spec.direction ?? "right",
            void 0,
            { playableCells: options.playableCells ?? null }
          );
        default:
          return { id: spec.id, type: "circle", cells: [] };
      }
    });
    const buildCellKey2 = (x2, y2) => `${x2},${y2}`;
    const visibleCells = options.visibleCells ?? null;
    const visionCells = options.visionCells ?? null;
    const isNight = Boolean(options.isNight);
    const showAll = Boolean(options.showAllLevels);
    const isCellInView = (x2, y2) => {
      if (showAll) return true;
      if (!visibleCells || visibleCells.size === 0) return true;
      return visibleCells.has(buildCellKey2(x2, y2));
    };
    const isCellPlayable = (x2, y2) => {
      if (!options.playableCells || options.playableCells.size === 0) return true;
      return options.playableCells.has(`${x2},${y2}`);
    };
    const cellRect = (x2, y2) => {
      const center = gridToScreenForGrid(x2, y2, options.grid.cols, options.grid.rows);
      return {
        x: center.x - TILE_SIZE / 2,
        y: center.y - TILE_SIZE / 2,
        size: TILE_SIZE
      };
    };
    Array.isArray(options.lightMap) ? options.lightMap : null;
    const activeSources = [];
    if (Array.isArray(options.lightSources)) {
      activeSources.push(...options.lightSources);
    }
    if (options.playerTorchOn) {
      activeSources.push({
        x: options.player.x,
        y: options.player.y,
        radius: Math.max(1, Math.floor(options.playerTorchRadius ?? 4))
      });
    }
    const gridToScreenRaw = (x2, y2) => ({
      x: x2 * TILE_SIZE + TILE_SIZE / 2,
      y: y2 * TILE_SIZE + TILE_SIZE / 2
    });
    const buildSegmentsForLighting = () => {
      const minX = -0.5;
      const minY = -0.5;
      const maxX = options.grid.cols - 0.5;
      const maxY = options.grid.rows - 0.5;
      const segments = [
        { ax: minX, ay: minY, bx: maxX, by: minY },
        { ax: maxX, ay: minY, bx: maxX, by: maxY },
        { ax: maxX, ay: maxY, bx: minX, by: maxY },
        { ax: minX, ay: maxY, bx: minX, by: minY }
      ];
      const blocked = options.obstacleVisionCells ?? null;
      if (blocked && blocked.size > 0) {
        const isBlocked = (x2, y2) => blocked.has(buildCellKey2(x2, y2));
        const pushEdge = (ax, ay, bx, by) => {
          segments.push({ ax, ay, bx, by });
        };
        for (const key2 of blocked) {
          const [xs, ys] = key2.split(",");
          const x2 = Number(xs);
          const y2 = Number(ys);
          if (!Number.isFinite(x2) || !Number.isFinite(y2)) continue;
          if (!isCellPlayable(x2, y2)) continue;
          const left = x2 - 0.5;
          const right = x2 + 0.5;
          const top = y2 - 0.5;
          const bottom = y2 + 0.5;
          if (!isBlocked(x2, y2 - 1)) pushEdge(left, top, right, top);
          if (!isBlocked(x2 + 1, y2)) pushEdge(right, top, right, bottom);
          if (!isBlocked(x2, y2 + 1)) pushEdge(right, bottom, left, bottom);
          if (!isBlocked(x2 - 1, y2)) pushEdge(left, bottom, left, top);
        }
      }
      if (options.wallVisionEdges && options.wallVisionEdges.size > 0) {
        for (const wall of options.wallVisionEdges.values()) {
          const x2 = wall.x;
          const y2 = wall.y;
          const left = x2 - 0.5;
          const right = x2 + 0.5;
          const top = y2 - 0.5;
          const bottom = y2 + 0.5;
          switch (wall.dir) {
            case "N":
              segments.push({ ax: left, ay: top, bx: right, by: top });
              break;
            case "E":
              segments.push({ ax: right, ay: top, bx: right, by: bottom });
              break;
            case "S":
              segments.push({ ax: left, ay: bottom, bx: right, by: bottom });
              break;
            case "W":
              segments.push({ ax: left, ay: top, bx: left, by: bottom });
              break;
          }
        }
      }
      return segments;
    };
    const lightSegments = buildSegmentsForLighting();
    const intersectRaySegment = (origin, angle, seg) => {
      const dx = Math.cos(angle);
      const dy = Math.sin(angle);
      const sx = seg.bx - seg.ax;
      const sy = seg.by - seg.ay;
      const det = dx * sy - dy * sx;
      if (Math.abs(det) < 1e-8) return null;
      const ox = seg.ax - origin.x;
      const oy = seg.ay - origin.y;
      const t2 = (ox * sy - oy * sx) / det;
      const u2 = (ox * dy - oy * dx) / det;
      if (t2 < 0) return null;
      if (u2 < -1e-4 || u2 > 1 + 1e-4) return null;
      return t2;
    };
    const traceLightPolygon = (source2) => {
      const origin = { x: source2.x, y: source2.y };
      const maxDist = Math.max(0.5, source2.radius);
      const angles = [];
      const baseSegments = 140;
      for (let i2 = 0; i2 <= baseSegments; i2++) {
        angles.push(i2 / baseSegments * Math.PI * 2 - Math.PI);
      }
      const EPS = 1e-4;
      for (const seg of lightSegments) {
        const a1 = Math.atan2(seg.ay - origin.y, seg.ax - origin.x);
        const a2 = Math.atan2(seg.by - origin.y, seg.bx - origin.x);
        angles.push(a1 - EPS, a1, a1 + EPS, a2 - EPS, a2, a2 + EPS);
      }
      angles.sort((a2, b2) => a2 - b2);
      const pts = angles.map((angle) => {
        let best = null;
        for (const seg of lightSegments) {
          const t2 = intersectRaySegment(origin, angle, seg);
          if (t2 === null) continue;
          if (best === null || t2 < best) best = t2;
        }
        const dist = Math.min(best ?? maxDist, maxDist);
        return {
          x: origin.x + Math.cos(angle) * dist,
          y: origin.y + Math.sin(angle) * dist
        };
      });
      return pts.map((p2) => gridToScreenRaw(p2.x, p2.y));
    };
    const getLightGradientTexture = () => {
      const parent = pathLayer.parent;
      if (parent == null ? void 0 : parent.__lightGradientTexture) return parent.__lightGradientTexture;
      const size2 = 256;
      const canvas = document.createElement("canvas");
      canvas.width = size2;
      canvas.height = size2;
      const ctx = canvas.getContext("2d");
      if (!ctx) {
        const fallback = Texture.WHITE;
        if (parent) parent.__lightGradientTexture = fallback;
        return fallback;
      }
      const cx = size2 / 2;
      const cy = size2 / 2;
      const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, size2 / 2);
      grad.addColorStop(0, "rgba(255,255,255,1)");
      grad.addColorStop(1, "rgba(255,255,255,0)");
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, size2, size2);
      const texture = Texture.from(canvas);
      if (parent) parent.__lightGradientTexture = texture;
      return texture;
    };
    if (activeSources.length > 0) {
      const gradientTexture = getLightGradientTexture();
      const minAlpha = 0.1;
      const maxAlpha = 0.7;
      const extraAlpha = Math.max(0, maxAlpha - minAlpha);
      for (const source2 of activeSources) {
        const pts = traceLightPolygon(source2);
        if (pts.length < 3) continue;
        const color = source2.color ?? 16773580;
        const center = gridToScreenRaw(source2.x, source2.y);
        const radiusPx = Math.max(1, source2.radius) * TILE_SIZE;
        const baseSprite = new Sprite(gradientTexture);
        baseSprite.anchor.set(0.5);
        baseSprite.position.set(center.x, center.y);
        baseSprite.width = radiusPx * 2;
        baseSprite.height = radiusPx * 2;
        baseSprite.tint = color;
        baseSprite.alpha = minAlpha;
        lightLayer.addChild(baseSprite);
        if (extraAlpha > 0.01) {
          const mask = new Graphics();
          mask.moveTo(pts[0].x, pts[0].y);
          for (let i2 = 1; i2 < pts.length; i2++) {
            mask.lineTo(pts[i2].x, pts[i2].y);
          }
          mask.closePath();
          mask.fill({ color: 16777215, alpha: 1 });
          const litSprite = new Sprite(gradientTexture);
          litSprite.anchor.set(0.5);
          litSprite.position.set(center.x, center.y);
          litSprite.width = radiusPx * 2;
          litSprite.height = radiusPx * 2;
          litSprite.tint = color;
          litSprite.alpha = extraAlpha;
          litSprite.mask = mask;
          lightLayer.addChild(litSprite);
          lightLayer.addChild(mask);
        }
      }
    }
    const fogColor = isNight ? 0 : 16777215;
    const fogAlpha = isNight ? 0 : 0.35;
    const hasVisibilityMask = Boolean(visionCells || visibleCells || options.visibilityLevels);
    const directionToAngleRad = (dir) => {
      switch (dir) {
        case "up":
          return -Math.PI / 2;
        case "down":
          return Math.PI / 2;
        case "left":
          return Math.PI;
        case "right":
          return 0;
        case "up-left":
          return -3 * Math.PI / 4;
        case "up-right":
          return -Math.PI / 4;
        case "down-left":
          return 3 * Math.PI / 4;
        case "down-right":
          return Math.PI / 4;
        default:
          return 0;
      }
    };
    if (hasVisibilityMask && fogAlpha > 0) {
      const cols = options.grid.cols;
      const rows = options.grid.rows;
      const profile = getVisionProfileForToken(options.player);
      const centerGrid = { x: options.player.x, y: options.player.y };
      const centerScreen = gridToScreenRaw(centerGrid.x, centerGrid.y);
      const range = Math.max(0, profile.range ?? 0);
      if (range > 0) {
        const facing = getFacingForToken(options.player);
        const coneApertureDeg = profile.shape === "circle" ? 360 : Math.max(10, Math.min(180, profile.apertureDeg ?? 90));
        const apertureRad = coneApertureDeg * Math.PI / 180;
        const angleCenter = directionToAngleRad(facing);
        const normalizeAngle2 = (a2) => {
          let v2 = a2;
          while (v2 <= -Math.PI) v2 += Math.PI * 2;
          while (v2 > Math.PI) v2 -= Math.PI * 2;
          return v2;
        };
        const isAngleInCone = (angle) => {
          if (profile.shape === "circle") return true;
          const delta = normalizeAngle2(angle - angleCenter);
          return Math.abs(delta) <= apertureRad / 2;
        };
        const startAngle = angleCenter - Math.PI;
        const endAngle = angleCenter + Math.PI;
        const segments = profile.shape === "circle" ? 360 : 520;
        const minX = -0.5;
        const minY = -0.5;
        const maxX = cols - 0.5;
        const maxY = rows - 0.5;
        const EPS = 1e-4;
        const opaque = options.obstacleVisionCells ?? null;
        const isOpaque = (x2, y2) => Boolean(opaque && opaque.has(buildCellKey2(x2, y2)));
        const blockerSegments = [];
        if (opaque && opaque.size > 0) {
          const pushEdge = (ax, ay, bx, by) => {
            blockerSegments.push({ ax, ay, bx, by });
          };
          for (const key2 of opaque) {
            const [xs, ys] = key2.split(",");
            const x2 = Number(xs);
            const y2 = Number(ys);
            if (!Number.isFinite(x2) || !Number.isFinite(y2)) continue;
            if (!isCellPlayable(x2, y2)) continue;
            const left = x2 - 0.5;
            const right = x2 + 0.5;
            const top = y2 - 0.5;
            const bottom = y2 + 0.5;
            if (!isOpaque(x2, y2 - 1)) pushEdge(left, top, right, top);
            if (!isOpaque(x2 + 1, y2)) pushEdge(right, top, right, bottom);
            if (!isOpaque(x2, y2 + 1)) pushEdge(right, bottom, left, bottom);
            if (!isOpaque(x2 - 1, y2)) pushEdge(left, bottom, left, top);
          }
        }
        const wallSegments = [];
        if (options.wallVisionEdges && options.wallVisionEdges.size > 0) {
          for (const wall of options.wallVisionEdges.values()) {
            const x2 = wall.x;
            const y2 = wall.y;
            const left = x2 - 0.5;
            const right = x2 + 0.5;
            const top = y2 - 0.5;
            const bottom = y2 + 0.5;
            switch (wall.dir) {
              case "N":
                wallSegments.push({ ax: left, ay: top, bx: right, by: top });
                break;
              case "E":
                wallSegments.push({ ax: right, ay: top, bx: right, by: bottom });
                break;
              case "S":
                wallSegments.push({ ax: left, ay: bottom, bx: right, by: bottom });
                break;
              case "W":
                wallSegments.push({ ax: left, ay: top, bx: left, by: bottom });
                break;
            }
          }
        }
        const boundarySegments = [
          { ax: minX, ay: minY, bx: maxX, by: minY },
          { ax: maxX, ay: minY, bx: maxX, by: maxY },
          { ax: maxX, ay: maxY, bx: minX, by: maxY },
          { ax: minX, ay: maxY, bx: minX, by: minY }
        ];
        const segmentsAll = [
          ...boundarySegments,
          ...blockerSegments,
          ...wallSegments
        ];
        const intersectRaySegment2 = (angle, seg) => {
          const dx = Math.cos(angle);
          const dy = Math.sin(angle);
          const sx = seg.bx - seg.ax;
          const sy = seg.by - seg.ay;
          const det = dx * sy - dy * sx;
          if (Math.abs(det) < 1e-8) return null;
          const ox = seg.ax - centerGrid.x;
          const oy = seg.ay - centerGrid.y;
          const t2 = (ox * sy - oy * sx) / det;
          const u2 = (ox * dy - oy * dx) / det;
          if (t2 < 0) return null;
          if (u2 < -EPS || u2 > 1 + EPS) return null;
          return t2;
        };
        const nearestHit = (angle, segs) => {
          let best = null;
          for (const seg of segs) {
            const t2 = intersectRaySegment2(angle, seg);
            if (t2 === null) continue;
            if (best === null || t2 < best) best = t2;
          }
          return best;
        };
        const farBoundForAngle = (angle) => Math.max(0, nearestHit(angle, boundarySegments) ?? range);
        const visibilityCapFromLevels = (_angle, farDist) => Math.min(farDist, range);
        const samples = [];
        const makeSample = (angle, forceInCone) => {
          const farDist = Math.min(farBoundForAngle(angle), range);
          const inCone = forceInCone ?? isAngleInCone(angle);
          if (!inCone) {
            return { angle, clearDist: 0, farDist, inCone: false };
          }
          const hitAll = nearestHit(angle, segmentsAll);
          const geomVisible = hitAll === null ? farDist : Math.max(0, Math.min(hitAll, farDist));
          const capVisible = visibilityCapFromLevels(angle, farDist);
          const clearDist = Math.max(0, Math.min(geomVisible, capVisible));
          return { angle, clearDist, farDist, inCone: true };
        };
        const angles = [];
        for (let i2 = 0; i2 <= segments; i2++) {
          const t2 = segments === 0 ? 0 : i2 / segments;
          angles.push(startAngle + (endAngle - startAngle) * t2);
        }
        const endpointAngles = [];
        for (const seg of [...blockerSegments, ...wallSegments]) {
          const a1 = Math.atan2(seg.ay - centerGrid.y, seg.ax - centerGrid.x);
          const a2 = Math.atan2(seg.by - centerGrid.y, seg.bx - centerGrid.x);
          endpointAngles.push(a1 - EPS, a1, a1 + EPS, a2 - EPS, a2, a2 + EPS);
        }
        if (profile.shape !== "circle") {
          angles.push(angleCenter - apertureRad / 2, angleCenter + apertureRad / 2);
        }
        const allAngles = [...angles, ...endpointAngles];
        allAngles.sort((a2, b2) => a2 - b2);
        for (const angle of allAngles) {
          samples.push(makeSample(angle));
        }
        const toScreenAt = (angle, dist) => {
          const gx = centerGrid.x + Math.cos(angle) * dist;
          const gy = centerGrid.y + Math.sin(angle) * dist;
          return gridToScreenRaw(gx, gy);
        };
        const regions = [];
        let currentRegion = [];
        for (let i2 = 0; i2 < samples.length; i2++) {
          const s2 = samples[i2];
          const prev = currentRegion[currentRegion.length - 1];
          if (!prev) {
            currentRegion.push(s2);
            continue;
          }
          if (prev.inCone !== s2.inCone) {
            const boundaryAngle = s2.angle;
            currentRegion.push(makeSample(boundaryAngle, prev.inCone));
            regions.push(currentRegion);
            currentRegion = [makeSample(boundaryAngle, s2.inCone)];
          }
          currentRegion.push(s2);
        }
        if (currentRegion.length > 1) regions.push(currentRegion);
        const baseMin = 0.55;
        const drawRegionFog = (region) => {
          for (let i2 = 0; i2 < region.length - 1; i2++) {
            const a2 = region[i2];
            const b2 = region[i2 + 1];
            let startA = Math.max(0, Math.min(a2.clearDist, a2.farDist));
            let startB = Math.max(0, Math.min(b2.clearDist, b2.farDist));
            if (a2.inCone && a2.clearDist > 0) startA = Math.max(baseMin, startA);
            if (b2.inCone && b2.clearDist > 0) startB = Math.max(baseMin, startB);
            if (a2.farDist - startA <= 0.01 && b2.farDist - startB <= 0.01) continue;
            const p1 = toScreenAt(a2.angle, startA);
            const p2 = toScreenAt(b2.angle, startB);
            const q2 = toScreenAt(b2.angle, b2.farDist);
            const q1 = toScreenAt(a2.angle, a2.farDist);
            fogLayer.moveTo(p1.x, p1.y);
            fogLayer.lineTo(p2.x, p2.y);
            fogLayer.lineTo(q2.x, q2.y);
            fogLayer.lineTo(q1.x, q1.y);
            fogLayer.closePath();
            fogLayer.fill({ color: fogColor, alpha: fogAlpha });
          }
        };
        for (const region of regions) {
          drawRegionFog(region);
        }
        if (options.showFogSegments) {
          pathLayer.setStrokeStyle({ width: 2, color: 16777215, alpha: 0.85 });
          const coneRegion = regions.find((r2) => r2.some((s2) => s2.inCone)) ?? samples;
          const coneSamples = coneRegion.filter((s2) => s2.inCone && s2.clearDist > 0);
          if (coneSamples.length > 0) {
            pathLayer.moveTo(centerScreen.x, centerScreen.y);
            for (const s2 of coneSamples) {
              const dist = Math.max(baseMin, s2.clearDist);
              const p2 = toScreenAt(s2.angle, dist);
              pathLayer.lineTo(p2.x, p2.y);
            }
            pathLayer.closePath();
            pathLayer.stroke();
          }
        }
      }
    }
    if (options.closedCells && options.closedCells.size > 0) {
      for (let y2 = 0; y2 < options.grid.rows; y2++) {
        for (let x2 = 0; x2 < options.grid.cols; x2++) {
          if (!isCellInView(x2, y2)) continue;
          if (!isCellPlayable(x2, y2)) continue;
          const key2 = buildCellKey2(x2, y2);
          if (!options.closedCells.has(key2)) continue;
          const rect = cellRect(x2, y2);
          pathLayer.rect(rect.x, rect.y, rect.size, rect.size).fill({
            color: 0,
            alpha: 0.5
          });
        }
      }
    }
    for (const effect of activeEffects) {
      for (const cell of effect.cells) {
        if (!isCellInView(cell.x, cell.y)) continue;
        if (options.playableCells && options.playableCells.size > 0 && !options.playableCells.has(`${cell.x},${cell.y}`)) {
          continue;
        }
        if (options.obstacleVisionCells && options.obstacleVisionCells.size > 0 && !isCellVisible(
          options.player,
          cell,
          options.obstacleVisionCells,
          options.playableCells ?? null,
          options.wallVisionEdges ?? null,
          options.lightLevels ?? null,
          options.grid
        )) {
          continue;
        }
        const rect = cellRect(cell.x, cell.y);
        const color = effect.type === "circle" ? 3447003 : effect.type === "rectangle" ? 3066993 : 15158332;
        pathLayer.rect(rect.x, rect.y, rect.size, rect.size).fill({
          color,
          alpha: 0.45
        });
      }
    }
    if (options.showVisionDebug) {
      const allTokens = [options.player, ...options.enemies];
      for (const token of allTokens) {
        const visionEffect = computeVisionEffectForToken(token, options.playableCells ?? null);
        for (const cell of visionEffect.cells) {
          if (!isCellInView(cell.x, cell.y)) continue;
          if (options.playableCells && options.playableCells.size > 0 && !options.playableCells.has(`${cell.x},${cell.y}`)) {
            continue;
          }
          if (!isCellVisible(
            token,
            cell,
            options.obstacleVisionCells ?? null,
            options.playableCells ?? null,
            options.wallVisionEdges ?? null,
            options.lightLevels ?? null,
            options.grid
          )) {
            continue;
          }
          const rect = cellRect(cell.x, cell.y);
          const color = token.type === "player" ? 2719929 : 12597547;
          pathLayer.rect(rect.x, rect.y, rect.size, rect.size).fill({
            color,
            alpha: token.type === "player" ? 0.25 : 0.2
          });
        }
      }
    }
    const occupiedTokens = [options.player, ...options.enemies];
    for (const token of occupiedTokens) {
      const color = token.type === "player" ? 3066993 : 15158332;
      for (const cell of getTokenOccupiedCells(token)) {
        if (!isCellInView(cell.x, cell.y)) continue;
        const rect = cellRect(cell.x, cell.y);
        pathLayer.rect(rect.x, rect.y, rect.size, rect.size).fill({
          color,
          alpha: 0.2
        });
      }
    }
    const selectedIds = options.selectedTargetIds && options.selectedTargetIds.length > 0 ? options.selectedTargetIds : options.selectedTargetId ? [options.selectedTargetId] : [];
    if (selectedIds.length > 0) {
      for (const id2 of selectedIds) {
        const target = options.enemies.find((e2) => e2.id === id2) ?? null;
        if (!target) continue;
        for (const cell of getTokenOccupiedCells(target)) {
          if (!isCellInView(cell.x, cell.y)) continue;
          const rect = cellRect(cell.x, cell.y);
          pathLayer.rect(rect.x, rect.y, rect.size, rect.size).fill({
            color: 3447003,
            alpha: 0.6
          });
        }
      }
    }
    if (options.selectedObstacleCell && isCellInView(options.selectedObstacleCell.x, options.selectedObstacleCell.y)) {
      const rect = cellRect(options.selectedObstacleCell.x, options.selectedObstacleCell.y);
      pathLayer.rect(rect.x, rect.y, rect.size, rect.size).fill({
        color: 10181046,
        alpha: 0.6
      });
    }
    if (options.selectedPath.length > 0) {
      const last = options.selectedPath[options.selectedPath.length - 1];
      const rect = cellRect(last.x, last.y);
      pathLayer.rect(rect.x, rect.y, rect.size, rect.size).fill({
        color: 15844367,
        alpha: 0.2
      });
    }
    for (const enemy of options.enemies) {
      if (!enemy.plannedPath || enemy.plannedPath.length === 0) continue;
      if (!isCellInView(enemy.x, enemy.y)) continue;
      const pathNodes = enemy.plannedPath;
      const first = pathNodes[0];
      const start2 = gridToScreenForGrid(first.x, first.y, options.grid.cols, options.grid.rows);
      pathLayer.setStrokeStyle({
        width: 3,
        color: 15158332,
        alpha: 0.9
      });
      pathLayer.moveTo(start2.x, start2.y);
      for (const node of pathNodes.slice(1)) {
        const p2 = gridToScreenForGrid(node.x, node.y, options.grid.cols, options.grid.rows);
        pathLayer.lineTo(p2.x, p2.y);
      }
      pathLayer.stroke();
    }
    if (options.showGridLines) {
      const cols = options.grid.cols;
      const rows = options.grid.rows;
      pathLayer.setStrokeStyle({ width: 1, color: 16777215, alpha: 0.25 });
      for (let x2 = 0; x2 <= cols; x2++) {
        const px = x2 * TILE_SIZE;
        pathLayer.moveTo(px, 0);
        pathLayer.lineTo(px, rows * TILE_SIZE);
      }
      for (let y2 = 0; y2 <= rows; y2++) {
        const py = y2 * TILE_SIZE;
        pathLayer.moveTo(0, py);
        pathLayer.lineTo(cols * TILE_SIZE, py);
      }
      pathLayer.stroke();
    }
    if (options.selectedPath.length === 0) return;
    pathLayer.setStrokeStyle({
      width: 6,
      color: 15844367,
      alpha: 1
    });
    const start = gridToScreenForGrid(options.player.x, options.player.y, options.grid.cols, options.grid.rows);
    pathLayer.moveTo(start.x, start.y);
    for (const node of options.selectedPath) {
      const p2 = gridToScreenForGrid(node.x, node.y, options.grid.cols, options.grid.rows);
      pathLayer.lineTo(p2.x, p2.y);
    }
    pathLayer.stroke();
  }, [
    options.pathLayerRef,
    options.player,
    options.enemies,
    options.selectedPath,
    options.effectSpecs,
    options.selectedTargetId,
    options.selectedTargetIds,
    options.selectedObstacleCell,
    options.showVisionDebug,
    options.showFogSegments,
    options.showLightOverlay,
    options.showGridLines,
    options.lightMap,
    options.lightSources,
    options.playerTorchOn,
    options.playerTorchRadius,
    options.lightLevels,
    options.lightTints,
    options.isNight,
    options.pixiReadyTick,
    options.playableCells,
    options.grid,
    options.heightMap,
    options.activeLevel,
    options.visibleCells,
    options.visionCells,
    options.visibilityLevels,
    options.showAllLevels,
    options.obstacleVisionCells,
    options.closedCells,
    options.wallVisionEdges
  ]);
}
function usePixiTerrainFx(options) {
  reactExports.useEffect(() => {
    const fxLayer = options.terrainFxLayerRef.current;
    const labelLayer = options.terrainLabelLayerRef.current;
    if (!fxLayer || !labelLayer) return;
    fxLayer.clear();
    const removed = labelLayer.removeChildren();
    for (const child of removed) {
      child.destroy();
    }
    if (!options.showTerrainIds && !options.showTerrainContours) return;
    const terrain = Array.isArray(options.terrain) ? options.terrain : null;
    if (!terrain || terrain.length === 0) return;
    const { cols, rows } = options.grid;
    const playable = options.playableCells;
    const terrainMix = Array.isArray(options.terrainMix) ? options.terrainMix : null;
    const isPlayable2 = (x2, y2) => {
      if (!playable || playable.size === 0) return true;
      return playable.has(`${x2},${y2}`);
    };
    const getTerrainAt2 = (x2, y2) => {
      if (x2 < 0 || y2 < 0 || x2 >= cols || y2 >= rows) return "unknown";
      const index = y2 * cols + x2;
      return terrain[index] ?? "unknown";
    };
    const getMixAt = (x2, y2) => {
      if (!terrainMix) return null;
      if (x2 < 0 || y2 < 0 || x2 >= cols || y2 >= rows) return null;
      return terrainMix[y2 * cols + x2] ?? null;
    };
    const getEdgeTerrain = (x2, y2, edge) => {
      if (!isPlayable2(x2, y2)) return null;
      const base = getTerrainAt2(x2, y2);
      const mix = getMixAt(x2, y2);
      if (!mix) return base;
      const blend = mix.blend;
      if (mix.corner === "NE") {
        return edge === "N" || edge === "E" ? blend : base;
      }
      if (mix.corner === "NW") {
        return edge === "N" || edge === "W" ? blend : base;
      }
      if (mix.corner === "SE") {
        return edge === "S" || edge === "E" ? blend : base;
      }
      return edge === "S" || edge === "W" ? blend : base;
    };
    if (options.showTerrainContours) {
      fxLayer.setStrokeStyle({ width: 2, color: 16777215, alpha: 0.65 });
      for (let y2 = 0; y2 < rows; y2++) {
        for (let x2 = 0; x2 < cols; x2++) {
          if (!isPlayable2(x2, y2)) continue;
          const baseTerrain = getTerrainAt2(x2, y2);
          const center = gridToScreenForGrid(x2, y2, cols, rows);
          const left = center.x - TILE_SIZE / 2;
          const top = center.y - TILE_SIZE / 2;
          const right = left + TILE_SIZE;
          const bottom = top + TILE_SIZE;
          const mix = getMixAt(x2, y2);
          const northEdge = getEdgeTerrain(x2, y2, "N");
          const southEdge = getEdgeTerrain(x2, y2, "S");
          const westEdge = getEdgeTerrain(x2, y2, "W");
          const eastEdge = getEdgeTerrain(x2, y2, "E");
          const northNeighbor = getEdgeTerrain(x2, y2 - 1, "S");
          const southNeighbor = getEdgeTerrain(x2, y2 + 1, "N");
          const westNeighbor = getEdgeTerrain(x2 - 1, y2, "E");
          const eastNeighbor = getEdgeTerrain(x2 + 1, y2, "W");
          const northDiff = !northNeighbor || northNeighbor !== northEdge;
          const southDiff = !southNeighbor || southNeighbor !== southEdge;
          const westDiff = !westNeighbor || westNeighbor !== westEdge;
          const eastDiff = !eastNeighbor || eastNeighbor !== eastEdge;
          if (northDiff) {
            fxLayer.moveTo(left, top);
            fxLayer.lineTo(right, top);
            fxLayer.stroke();
          }
          if (southDiff) {
            fxLayer.moveTo(left, bottom);
            fxLayer.lineTo(right, bottom);
            fxLayer.stroke();
          }
          if (westDiff) {
            fxLayer.moveTo(left, top);
            fxLayer.lineTo(left, bottom);
            fxLayer.stroke();
          }
          if (eastDiff) {
            fxLayer.moveTo(right, top);
            fxLayer.lineTo(right, bottom);
            fxLayer.stroke();
          }
          if (mix && mix.blend !== baseTerrain) {
            if (mix.corner === "NE" || mix.corner === "SW") {
              fxLayer.moveTo(left, top);
              fxLayer.lineTo(right, bottom);
              fxLayer.stroke();
            } else {
              fxLayer.moveTo(right, top);
              fxLayer.lineTo(left, bottom);
              fxLayer.stroke();
            }
          }
        }
      }
    }
    if (options.showTerrainIds) {
      const fontSize = Math.max(10, Math.round(TILE_SIZE * 0.2));
      for (let y2 = 0; y2 < rows; y2++) {
        for (let x2 = 0; x2 < cols; x2++) {
          if (!isPlayable2(x2, y2)) continue;
          const cellTerrain = getTerrainAt2(x2, y2);
          const idValue = options.terrainIdMap.get(cellTerrain) ?? 0;
          const center = gridToScreenForGrid(x2, y2, cols, rows);
          const label2 = new Text(String(idValue), {
            fontFamily: "Arial",
            fontSize,
            fill: 16777215,
            stroke: { color: 0, width: 3 },
            align: "center"
          });
          label2.anchor.set(0.5, 0.5);
          label2.alpha = 0.9;
          label2.x = center.x;
          label2.y = center.y;
          labelLayer.addChild(label2);
        }
      }
    }
  }, [
    options.terrainFxLayerRef,
    options.terrainLabelLayerRef,
    options.showTerrainIds,
    options.showTerrainContours,
    options.playableCells,
    options.grid,
    options.terrain,
    options.terrainMix,
    options.terrainIdMap,
    options.pixiReadyTick
  ]);
}
function usePixiSpeechBubbles(options) {
  reactExports.useEffect(() => {
    const speechLayer = options.speechLayerRef.current;
    if (!speechLayer) return;
    speechLayer.removeChildren();
    const allTokens = [options.player, ...options.enemies];
    const bubbleByTokenId = new Map(
      options.speechBubbles.map((b2) => [b2.tokenId, b2])
    );
    const padding = 6;
    const maxWidth = 140;
    const baseOffsetY = TILE_SIZE * 0.9;
    const items = [];
    const cellKey = (x2, y2) => `${x2},${y2}`;
    const visibleCells = options.visibleCells ?? null;
    const showAll = Boolean(options.showAllLevels);
    for (const token of allTokens) {
      if (isTokenDead(token)) continue;
      const occupied = getTokenOccupiedCells(token);
      const isVisible = showAll || token.type === "player" || occupied.some((c2) => (visibleCells == null ? void 0 : visibleCells.has(cellKey(c2.x, c2.y))) ?? true);
      if (!isVisible) continue;
      const bubble = bubbleByTokenId.get(token.id);
      if (!bubble) continue;
      if (!bubble.text.trim()) continue;
      const screenPos = gridToScreenForGrid(token.x, token.y, options.grid.cols, options.grid.rows);
      const bubbleContainer = new Container();
      const bubbleBg = new Graphics();
      const textObj = new Text(bubble.text, {
        fontFamily: "Arial",
        fontSize: 11,
        fill: 0,
        align: "center",
        wordWrap: true,
        wordWrapWidth: maxWidth - 10
      });
      const width = Math.min(maxWidth, textObj.width + 10);
      const height = textObj.height + 8;
      bubbleBg.roundRect(-width / 2, -height, width, height, 7).fill({ color: 16777215, alpha: 0.92 });
      textObj.x = -textObj.width / 2;
      textObj.y = -height + 4;
      bubbleContainer.addChild(bubbleBg);
      bubbleContainer.addChild(textObj);
      const x2 = screenPos.x;
      const y2 = screenPos.y - baseOffsetY;
      bubbleContainer.x = x2;
      bubbleContainer.y = y2;
      speechLayer.addChild(bubbleContainer);
      items.push({
        x: x2 - width / 2,
        y: y2 - height,
        width,
        height,
        view: bubbleContainer
      });
    }
    items.sort((a2, b2) => a2.y - b2.y);
    const placed = [];
    for (const item of items) {
      let currentY = item.y;
      let tries = 0;
      const overlaps = (a2, bx, by) => {
        const ax1 = a2.x;
        const ay1 = a2.y;
        const ax2 = a2.x + a2.width;
        const ay2 = a2.y + a2.height;
        const bx1 = bx;
        const by1 = by;
        const bx2 = bx + item.width;
        const by2 = by + item.height;
        return ax1 < bx2 && ax2 > bx1 && ay1 < by2 && ay2 > by1;
      };
      while (tries < 20) {
        const colliding = placed.find((p2) => overlaps(p2, item.x, currentY));
        if (!colliding) break;
        currentY = colliding.y - item.height - padding;
        tries += 1;
      }
      const dy = currentY - item.y;
      if (dy !== 0) {
        item.view.y += dy;
        item.y = currentY;
      }
      placed.push(item);
    }
  }, [
    options.speechLayerRef,
    options.player,
    options.enemies,
    options.speechBubbles,
    options.pixiReadyTick,
    options.grid,
    options.heightMap,
    options.activeLevel,
    options.visibleCells,
    options.showAllLevels
  ]);
}
const __vite_glob_0_0 = "/assets/character-CN68FcGi.png";
const __vite_glob_1_0 = "/assets/archer-1-tTUzWM2l.png";
const __vite_glob_1_1 = "/assets/assassin-1-CKsLE6ez.png";
const __vite_glob_1_2 = "/assets/brute-1-DWEKbL2R.png";
const __vite_glob_1_3 = "/assets/ghost-1-BuTxPqFA.png";
const pngModules$1 = {
  .../* @__PURE__ */ Object.assign({
    "./data/characters/sprite/character.png": __vite_glob_0_0
  }),
  .../* @__PURE__ */ Object.assign({
    "./data/enemies/sprite/archer-1.png": __vite_glob_1_0,
    "./data/enemies/sprite/assassin-1.png": __vite_glob_1_1,
    "./data/enemies/sprite/brute-1.png": __vite_glob_1_2,
    "./data/enemies/sprite/ghost-1.png": __vite_glob_1_3
  })
};
const TOKEN_PNG_BY_BASE = {};
for (const [path2, url] of Object.entries(pngModules$1)) {
  const file = path2.split("/").pop() ?? "";
  const baseName = file.replace(/\.png$/i, "");
  if (!baseName) continue;
  const match = baseName.match(/^(.*?)-(\d+)$/);
  const baseKey = match ? match[1] : baseName;
  const index = match ? Number.parseInt(match[2], 10) : 1;
  if (!TOKEN_PNG_BY_BASE[baseKey]) {
    TOKEN_PNG_BY_BASE[baseKey] = [];
  }
  TOKEN_PNG_BY_BASE[baseKey].push({ url, index, name: baseName });
}
for (const key2 of Object.keys(TOKEN_PNG_BY_BASE)) {
  TOKEN_PNG_BY_BASE[key2].sort((a2, b2) => {
    if (a2.index !== b2.index) return a2.index - b2.index;
    return a2.name.localeCompare(b2.name);
  });
}
function hashString01(input) {
  let hash = 2166136261;
  for (let i2 = 0; i2 < input.length; i2++) {
    hash ^= input.charCodeAt(i2);
    hash = Math.imul(hash, 16777619);
  }
  return (hash >>> 0) / 4294967295;
}
function getTokenSpriteUrl(spriteKey, seed, variants2) {
  var _a, _b;
  if (!spriteKey) return null;
  const entries = TOKEN_PNG_BY_BASE[spriteKey];
  if (!entries || entries.length === 0) return null;
  const allowed = Array.isArray(variants2) && variants2.length > 0 ? entries.filter((entry) => variants2.includes(entry.index)) : entries;
  if (allowed.length === 0) return null;
  if (allowed.length === 1) return ((_a = allowed[0]) == null ? void 0 : _a.url) ?? null;
  const t2 = seed ? hashString01(`${spriteKey}:${seed}`) : Math.random();
  const index = Math.max(0, Math.min(allowed.length - 1, Math.floor(t2 * allowed.length)));
  return ((_b = allowed[index]) == null ? void 0 : _b.url) ?? null;
}
const loadedTokenAliases = /* @__PURE__ */ new Set();
const pendingTokenAliases = /* @__PURE__ */ new Set();
function resolveTokenEntries(spriteKey, variants2) {
  const entries = TOKEN_PNG_BY_BASE[spriteKey];
  if (!entries || entries.length === 0) return [];
  if (Array.isArray(variants2) && variants2.length > 0) {
    return entries.filter((entry) => variants2.includes(entry.index));
  }
  return entries;
}
async function preloadTokenPngTexturesFor(requests) {
  if (!Array.isArray(requests) || requests.length === 0) return;
  const assets = /* @__PURE__ */ new Map();
  for (const request of requests) {
    const spriteKey = request == null ? void 0 : request.spriteKey;
    if (!spriteKey) continue;
    const entries = resolveTokenEntries(spriteKey, request.variants ?? null);
    for (const entry of entries) {
      const alias = entry.url;
      if (loadedTokenAliases.has(alias) || pendingTokenAliases.has(alias)) continue;
      assets.set(alias, {
        alias,
        src: entry.url,
        data: {
          autoGenerateMipmaps: true,
          scaleMode: "linear",
          mipmapFilter: "linear",
          maxAnisotropy: 4
        }
      });
      pendingTokenAliases.add(alias);
    }
  }
  if (assets.size === 0) return;
  try {
    for (const asset of assets.values()) {
      Assets.add(asset);
    }
    const aliases = [...assets.keys()];
    await Assets.load(aliases);
    for (const alias of aliases) {
      loadedTokenAliases.add(alias);
      pendingTokenAliases.delete(alias);
    }
  } catch (error) {
    for (const alias of assets.keys()) {
      pendingTokenAliases.delete(alias);
    }
    throw error;
  }
}
function usePixiTokens(options) {
  const resolveTokenShadowSpec = (token) => {
    const footprint2 = token.footprint;
    const sizeFactor = (footprint2 == null ? void 0 : footprint2.kind) === "rect" ? Math.max(1, Math.max(footprint2.width, footprint2.height)) : (footprint2 == null ? void 0 : footprint2.kind) === "cells" ? Math.max(1, footprint2.cells.length) : 1;
    const scale = Math.min(2.2, Math.max(1, sizeFactor));
    return {
      offsetX: Math.max(4, Math.round(TILE_SIZE * 0.12 * scale)),
      offsetY: Math.max(6, Math.round(TILE_SIZE * 0.16 * scale)),
      alpha: 0.28
    };
  };
  const getTokenGridSpec = (token) => {
    const spec = token.footprint;
    if ((spec == null ? void 0 : spec.kind) === "rect") {
      return {
        tilesX: Math.max(1, Math.floor(spec.width)),
        tilesY: Math.max(1, Math.floor(spec.height))
      };
    }
    if ((spec == null ? void 0 : spec.kind) === "cells" && spec.cells.length > 0) {
      let minX = Number.POSITIVE_INFINITY;
      let minY = Number.POSITIVE_INFINITY;
      let maxX = Number.NEGATIVE_INFINITY;
      let maxY = Number.NEGATIVE_INFINITY;
      for (const cell of spec.cells) {
        minX = Math.min(minX, cell.x);
        minY = Math.min(minY, cell.y);
        maxX = Math.max(maxX, cell.x);
        maxY = Math.max(maxY, cell.y);
      }
      if (Number.isFinite(minX) && Number.isFinite(minY) && Number.isFinite(maxX) && Number.isFinite(maxY)) {
        return {
          tilesX: Math.max(1, Math.round(maxX - minX + 1)),
          tilesY: Math.max(1, Math.round(maxY - minY + 1))
        };
      }
    }
    return { tilesX: 1, tilesY: 1 };
  };
  reactExports.useEffect(() => {
    var _a, _b, _c, _d;
    const depthLayer = options.depthLayerRef.current;
    if (!depthLayer) return;
    for (const child of [...depthLayer.children]) {
      if (child.label === "token") {
        depthLayer.removeChild(child);
        (_a = child.destroy) == null ? void 0 : _a.call(child);
      }
    }
    if (options.suspendRendering) return;
    const allTokens = [options.player, ...options.enemies];
    const cellKey = (x2, y2) => `${x2},${y2}`;
    const showAll = Boolean(options.showAllLevels);
    const visibleCells = options.visibleCells ?? null;
    const lightAngleDeg = typeof options.lightAngleDeg === "number" ? options.lightAngleDeg : 90;
    const lightAngle = lightAngleDeg * Math.PI / 180;
    for (const token of allTokens) {
      const occupied = getTokenOccupiedCells(token);
      const isVisible = showAll || token.type === "player" || occupied.some((c2) => (visibleCells == null ? void 0 : visibleCells.has(cellKey(c2.x, c2.y))) ?? true);
      if (!isVisible) continue;
      const center = gridToScreenForGrid(token.x, token.y, options.grid.cols, options.grid.rows);
      const container = new Container();
      const spriteKey = (_b = token.appearance) == null ? void 0 : _b.spriteKey;
      const spriteUrl = getTokenSpriteUrl(spriteKey, token.id, (_c = token.appearance) == null ? void 0 : _c.spriteVariants);
      const dead = isTokenDead(token);
      const shadowSpec = resolveTokenShadowSpec(token);
      const shadowAlpha = dead ? shadowSpec.alpha * 0.6 : shadowSpec.alpha;
      const shadowDistance = Math.max(2, Math.round(Math.hypot(shadowSpec.offsetX, shadowSpec.offsetY)));
      if (spriteUrl) {
        const sprite = Sprite.from(spriteUrl);
        sprite.anchor.set(0.5, 0.5);
        const orientation = getDefaultOrientationForToken(token);
        const orientationDeg = orientationToRotationDeg(orientation);
        const screenDeg = (360 - orientationDeg) % 360;
        const spriteFacingScreenDeg = (360 - orientationToRotationDeg("up")) % 360;
        const rotationDeg = screenDeg - spriteFacingScreenDeg;
        sprite.rotation = rotationDeg * Math.PI / 180;
        const gridSpec = getTokenGridSpec(token);
        const scaleBase = typeof ((_d = token.appearance) == null ? void 0 : _d.tokenScale) === "number" ? token.appearance.tokenScale / 100 : 1;
        const needsFallback = !sprite.texture.valid || sprite.texture.width <= 1 || sprite.texture.height <= 1;
        if (needsFallback) {
          const color = token.type === "player" ? 3066993 : 15158332;
          const radius = TILE_SIZE * 0.3;
          const disc = new Graphics();
          const fallbackShadowGroup = new Container();
          fallbackShadowGroup.rotation = lightAngle;
          const shadow2 = new Graphics();
          shadow2.circle(0, shadowDistance, radius * 0.95).fill({
            color: 0,
            alpha: Math.max(0.05, Math.min(0.5, shadowAlpha))
          });
          fallbackShadowGroup.addChild(shadow2);
          container.addChild(fallbackShadowGroup);
          disc.circle(0, 0, radius).fill({
            color: dead ? 6710886 : color,
            alpha: dead ? 0.6 : 0.95
          });
          container.addChild(disc);
        }
        if (sprite.texture.width > 0 && sprite.texture.height > 0) {
          const targetW = gridSpec.tilesX * TILE_SIZE;
          const targetH = gridSpec.tilesY * TILE_SIZE;
          const scaleX = targetW / sprite.texture.width;
          const scaleY = targetH / sprite.texture.height;
          sprite.scale.set(scaleX * scaleBase, scaleY * scaleBase);
        } else {
          sprite.scale.set(scaleBase);
        }
        sprite.alpha = dead ? 0.6 : 0.95;
        sprite.tint = dead ? 6710886 : 16777215;
        sprite.x = 0;
        sprite.y = 0;
        const shadowGroup = new Container();
        shadowGroup.rotation = lightAngle;
        const shadow = Sprite.from(sprite.texture);
        shadow.anchor.set(0.5, 0.5);
        shadow.rotation = sprite.rotation - lightAngle;
        shadow.scale.set(sprite.scale.x, sprite.scale.y);
        shadow.alpha = Math.max(0.05, Math.min(0.5, shadowAlpha));
        shadow.tint = 0;
        shadow.x = 0;
        shadow.y = shadowDistance;
        shadowGroup.addChild(shadow);
        container.addChild(shadowGroup);
        container.addChild(sprite);
      } else {
        const color = token.type === "player" ? 3066993 : 15158332;
        const radius = TILE_SIZE * 0.3;
        const disc = new Graphics();
        const shadowGroup = new Container();
        shadowGroup.rotation = lightAngle;
        const shadow = new Graphics();
        shadow.circle(0, shadowDistance, radius * 0.95).fill({
          color: 0,
          alpha: Math.max(0.05, Math.min(0.5, shadowAlpha))
        });
        shadowGroup.addChild(shadow);
        container.addChild(shadowGroup);
        disc.circle(0, 0, radius).fill({
          color: dead ? 6710886 : color,
          alpha: dead ? 0.6 : 0.95
        });
        container.addChild(disc);
      }
      container.x = center.x;
      container.y = center.y;
      container.label = "token";
      container.zIndex = center.y + DEPTH_Z.tokens;
      depthLayer.addChild(container);
    }
  }, [
    options.depthLayerRef,
    options.player,
    options.enemies,
    options.pixiReadyTick,
    options.grid,
    options.heightMap,
    options.activeLevel,
    options.visibleCells,
    options.showAllLevels,
    options.lightAngleDeg,
    options.suspendRendering
  ]);
}
const WALL_COLORS = {
  wall: 14604232,
  low: 13219226,
  door: 10189386
};
function usePixiWalls(options) {
  reactExports.useEffect(() => {
    var _a;
    const depthLayer = options.depthLayerRef.current;
    if (!depthLayer) return;
    depthLayer.cacheAsTexture = false;
    for (const child of [...depthLayer.children]) {
      if (child.label === "wall") {
        depthLayer.removeChild(child);
        (_a = child.destroy) == null ? void 0 : _a.call(child);
      }
    }
    if (!options.walls.length) return;
    const visibleCells = options.visibleCells ?? null;
    const showAll = Boolean(options.showAllLevels);
    const g2 = new Graphics();
    const thickness = TILE_SIZE / 3;
    const half = thickness / 2;
    const doorLength = thickness * 1.6;
    const doorWidth = thickness * 0.9;
    const isVisibleSegment = (segment) => {
      if (showAll || !visibleCells || visibleCells.size === 0) return true;
      const cells = getAdjacentCellsForEdge(segment);
      const aKey = `${cells.a.x},${cells.a.y}`;
      const bKey = `${cells.b.x},${cells.b.y}`;
      return visibleCells.has(aKey) || visibleCells.has(bKey);
    };
    const visibleSegments = options.walls.filter((seg) => isVisibleSegment(seg));
    const vertexMap = /* @__PURE__ */ new Map();
    const preferColor = (a2, b2) => {
      const priority = (c2) => c2 === WALL_COLORS.wall ? 3 : c2 === WALL_COLORS.low ? 2 : c2 === WALL_COLORS.door ? 1 : 0;
      return priority(a2) >= priority(b2) ? a2 : b2;
    };
    const addVertex = (vx2, vy2, seg, isHorizontal) => {
      const key2 = `${vx2},${vy2}`;
      const existing = vertexMap.get(key2);
      const color = WALL_COLORS[seg.kind] ?? WALL_COLORS.wall;
      const hasDoor = seg.kind === "door";
      if (!existing) {
        vertexMap.set(key2, {
          hasHorizontal: isHorizontal,
          hasVertical: !isHorizontal,
          hasDoor,
          color
        });
        return;
      }
      existing.hasHorizontal = existing.hasHorizontal || isHorizontal;
      existing.hasVertical = existing.hasVertical || !isHorizontal;
      existing.hasDoor = existing.hasDoor || hasDoor;
      existing.color = preferColor(existing.color, color);
    };
    for (const seg of visibleSegments) {
      const isHorizontal = seg.dir === "N" || seg.dir === "S";
      if (isHorizontal) {
        const yLine = seg.dir === "N" ? seg.y : seg.y + 1;
        addVertex(seg.x, yLine, seg, true);
        addVertex(seg.x + 1, yLine, seg, true);
      } else {
        const xLine = seg.dir === "W" ? seg.x : seg.x + 1;
        addVertex(xLine, seg.y, seg, false);
        addVertex(xLine, seg.y + 1, seg, false);
      }
    }
    const drawHingedRect = (hx, hy, w2, h2, angle, color) => {
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      const hh = h2 / 2;
      const p1x = hx + (0 * cos - -hh * sin);
      const p1y = hy + (0 * sin + -hh * cos);
      const p2x = hx + (w2 * cos - -hh * sin);
      const p2y = hy + (w2 * sin + -hh * cos);
      const p3x = hx + (w2 * cos - hh * sin);
      const p3y = hy + (w2 * sin + hh * cos);
      const p4x = hx + (0 * cos - hh * sin);
      const p4y = hy + (0 * sin + hh * cos);
      g2.poly([p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y]).fill({ color, alpha: 1 });
      g2.poly([p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y]).stroke({ width: 1, color: 0, alpha: 1 });
    };
    for (const seg of visibleSegments) {
      const baseX = seg.x * TILE_SIZE;
      const baseY = seg.y * TILE_SIZE;
      let x2 = baseX;
      let y2 = baseY;
      let w2 = TILE_SIZE;
      let h2 = TILE_SIZE;
      switch (seg.dir) {
        case "N":
          x2 = baseX;
          y2 = baseY - half;
          w2 = TILE_SIZE;
          h2 = thickness;
          break;
        case "S":
          x2 = baseX;
          y2 = baseY + TILE_SIZE - half;
          w2 = TILE_SIZE;
          h2 = thickness;
          break;
        case "W":
          x2 = baseX - half;
          y2 = baseY;
          w2 = thickness;
          h2 = TILE_SIZE;
          break;
        case "E":
          x2 = baseX + TILE_SIZE - half;
          y2 = baseY;
          w2 = thickness;
          h2 = TILE_SIZE;
          break;
      }
      const color = WALL_COLORS[seg.kind] ?? WALL_COLORS.wall;
      g2.rect(x2, y2, w2, h2).fill({ color, alpha: 1 });
      g2.rect(x2, y2, w2, h2).stroke({ width: 2, color: 0, alpha: 1 });
      if (seg.kind === "door") {
        const isHorizontal = seg.dir === "N" || seg.dir === "S";
        const closedAngle = isHorizontal ? 0 : Math.PI / 2;
        let swing = 0;
        if (seg.state === "open") {
          if (seg.dir === "N") swing = Math.PI / 2;
          if (seg.dir === "S") swing = -Math.PI / 2;
          if (seg.dir === "W") swing = -Math.PI / 2;
          if (seg.dir === "E") swing = Math.PI / 2;
        }
        const angle = closedAngle + swing;
        let hx = baseX;
        let hy = baseY;
        if (seg.dir === "N") hy = baseY - half + thickness / 2;
        if (seg.dir === "S") hy = baseY + TILE_SIZE - half + thickness / 2;
        if (seg.dir === "W") hx = baseX - half + thickness / 2;
        if (seg.dir === "E") hx = baseX + TILE_SIZE - half + thickness / 2;
        drawHingedRect(hx, hy, doorLength, doorWidth, angle, WALL_COLORS.door);
      }
    }
    for (const [key2, info] of vertexMap) {
      if (!info.hasHorizontal || !info.hasVertical) continue;
      if (info.hasDoor) continue;
      const [vxStr, vyStr] = key2.split(",");
      const vx2 = Number(vxStr);
      const vy2 = Number(vyStr);
      if (!Number.isFinite(vx2) || !Number.isFinite(vy2)) continue;
      const px = vx2 * TILE_SIZE - half;
      const py = vy2 * TILE_SIZE - half;
      g2.rect(px, py, thickness, thickness).fill({ color: info.color, alpha: 1 });
      g2.rect(px, py, thickness, thickness).stroke({ width: 1, color: 0, alpha: 1 });
    }
    g2.label = "wall";
    g2.zIndex = DEPTH_Z.walls;
    depthLayer.addChild(g2);
    depthLayer.cacheAsTexture = true;
  }, [
    options.depthLayerRef,
    options.walls,
    options.pixiReadyTick,
    options.grid,
    options.heightMap,
    options.activeLevel,
    options.visibleCells,
    options.showAllLevels
  ]);
}
const COIN_IDS = {
  pp: "obj_piece_platine",
  po: "obj_piece_or",
  pa: "obj_piece_argent",
  pc: "obj_piece_cuivre"
};
const COIN_VALUES_CP = {
  pp: 1e3,
  po: 100,
  pa: 10
};
function isCoinId(id2) {
  return Object.values(COIN_IDS).includes(id2);
}
function moneyToCopper(value2) {
  if (!value2) return 0;
  const pp = Number(value2.pp ?? value2.platinum ?? 0) || 0;
  const po = Number(value2.po ?? value2.gold ?? 0) || 0;
  const pa = Number(value2.pa ?? value2.silver ?? 0) || 0;
  const pc = Number(value2.pc ?? value2.copper ?? 0) || 0;
  return pp * COIN_VALUES_CP.pp + po * COIN_VALUES_CP.po + pa * COIN_VALUES_CP.pa + pc;
}
function copperToMoney(total) {
  let remaining = Math.max(0, Math.floor(total || 0));
  const pp = Math.floor(remaining / COIN_VALUES_CP.pp);
  remaining -= pp * COIN_VALUES_CP.pp;
  const po = Math.floor(remaining / COIN_VALUES_CP.po);
  remaining -= po * COIN_VALUES_CP.po;
  const pa = Math.floor(remaining / COIN_VALUES_CP.pa);
  remaining -= pa * COIN_VALUES_CP.pa;
  const pc = remaining;
  return { pp, po, pa, pc };
}
function normalizeMoney(value2) {
  return copperToMoney(moneyToCopper(value2));
}
function scaleMoney(value2, factor) {
  return copperToMoney(moneyToCopper(value2) * Math.max(0, Math.floor(factor)));
}
function moneyToCoinStacks(value2) {
  const normalized = normalizeMoney(value2);
  return Object.keys(COIN_IDS).map((denom) => ({
    id: COIN_IDS[denom],
    qty: Number(normalized[denom] ?? 0) || 0
  })).filter((entry) => entry.qty > 0);
}
function EquipmentTab(props) {
  const {
    toggleSectionLock,
    getLockButtonState,
    renderPendingBadge,
    getPendingCountForSection,
    lockButtonBaseStyle,
    equipSubTab,
    setEquipSubTab,
    equipMessage,
    setEquipMessage,
    slotGroups,
    renderSlotGroup,
    packSlotStatus,
    inventoryItems,
    getItemLabel,
    getItemCategories,
    canUseClothingPieces,
    equipmentSlots,
    resolveStoredSlotId,
    packSlots,
    getSlotLabel,
    getItemWeight,
    storeItemInPack,
    updateItemSlot,
    isSectionLocked,
    getItemUnitValue,
    isCurrencyItem,
    moneyToCopper: moneyToCopper2,
    formatMoneyValue: formatMoneyValue2,
    onSellRequest,
    setPrimaryWeapon,
    isItemHarmonisable,
    isItemHarmonized,
    toggleItemHarmonization,
    removeManualItem,
    renderSourceDotsWithLabels,
    getItemSources,
    carryWeight,
    carryCapacityMax,
    weaponOptions,
    toolItems,
    armorItems,
    objectItems,
    addManualItem
  } = props;
  const formatRangeLabel = (weapon) => {
    const properties2 = (weapon == null ? void 0 : weapon.properties) ?? {};
    const thrown = properties2 == null ? void 0 : properties2.thrown;
    const range = properties2 == null ? void 0 : properties2.range;
    if (thrown && typeof thrown.normal === "number" && typeof thrown.long === "number") {
      return `jet ${thrown.normal}/${thrown.long} m`;
    }
    if (range && typeof range.normal === "number") {
      if (typeof range.long === "number" && range.long > range.normal) {
        return `portee ${range.normal}/${range.long} m`;
      }
      return `portee ${range.normal} m`;
    }
    if (typeof (properties2 == null ? void 0 : properties2.reach) === "number" && properties2.reach > 0) {
      return `allonge ${properties2.reach} m`;
    }
    return "portee -";
  };
  const formatWeaponSummary = (weapon) => {
    var _a, _b;
    const category2 = String((weapon == null ? void 0 : weapon.category) ?? "?");
    const damageDice = String(((_a = weapon == null ? void 0 : weapon.damage) == null ? void 0 : _a.dice) ?? "?");
    const damageType = String(((_b = weapon == null ? void 0 : weapon.damage) == null ? void 0 : _b.damageType) ?? "?");
    const extraDamage2 = Array.isArray(weapon == null ? void 0 : weapon.extraDamage) ? weapon.extraDamage : [];
    const extras = extraDamage2.map((entry) => {
      const dice = String((entry == null ? void 0 : entry.dice) ?? "").trim();
      const type2 = String((entry == null ? void 0 : entry.damageType) ?? "").trim();
      if (!dice || !type2) return null;
      const when = String((entry == null ? void 0 : entry.when) ?? "onHit");
      return when === "onHit" ? `+${dice} ${type2}` : `+${dice} ${type2} (${when})`;
    }).filter(Boolean).join(" + ");
    const rangeLabel = formatRangeLabel(weapon);
    const damageLabel = extras ? `${damageDice} ${damageType} + ${extras}` : `${damageDice} ${damageType}`;
    return `${category2} | ${damageLabel} | ${rangeLabel}`;
  };
  const weaponById = /* @__PURE__ */ new Map();
  weaponOptions.forEach((weapon) => {
    if (weapon == null ? void 0 : weapon.id) weaponById.set(String(weapon.id), weapon);
  });
  const getWeaponSummaryForItem = (item) => {
    if ((item == null ? void 0 : item.type) !== "weapon") return null;
    const weapon = weaponById.get(String(item.id));
    if (!weapon) return null;
    return formatWeaponSummary(weapon);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: 8 }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, color: "#b0b8c4" }, children: "Equipez les objets compatibles dans chaque slot. Les selections respectent les categories." }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          type: "button",
          onClick: () => toggleSectionLock("equip"),
          style: {
            ...lockButtonBaseStyle,
            marginLeft: "auto",
            background: getLockButtonState("equip").background
          },
          children: [
            getLockButtonState("equip").label,
            renderPendingBadge(getPendingCountForSection("equip"))
          ]
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", gap: 8, marginTop: 8 }, children: [
      { id: "slots", label: "Equipement" },
      { id: "loot", label: "Boite a loot" }
    ].map((tab) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        type: "button",
        onClick: () => setEquipSubTab(tab.id),
        style: {
          padding: "4px 10px",
          borderRadius: 8,
          border: "1px solid rgba(255,255,255,0.15)",
          background: equipSubTab === tab.id ? "rgba(46, 204, 113, 0.18)" : "rgba(255,255,255,0.06)",
          color: "#f5f5f5",
          cursor: "pointer",
          fontSize: 11,
          fontWeight: 700
        },
        children: tab.label
      },
      tab.id
    )) }),
    equipMessage && /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        style: {
          marginTop: 6,
          padding: "6px 10px",
          borderRadius: 8,
          border: "1px solid rgba(255,255,255,0.18)",
          background: "rgba(231, 76, 60, 0.18)",
          fontSize: 11,
          color: "#f5f5f5",
          display: "flex",
          alignItems: "center",
          gap: 8
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: equipMessage }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              type: "button",
              onClick: () => setEquipMessage(null),
              style: {
                marginLeft: "auto",
                border: "none",
                background: "transparent",
                color: "#f5f5f5",
                cursor: "pointer",
                fontSize: 12,
                fontWeight: 700
              },
              children: "OK"
            }
          )
        ]
      }
    ),
    equipSubTab === "slots" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          style: {
            marginTop: 8,
            display: "grid",
            gridTemplateColumns: "repeat(auto-fit, minmax(240px, 1fr))",
            gap: 10
          },
          children: [
            renderSlotGroup(
              slotGroups.body,
              "Vetements / Armures",
              "Corps: armure ou vetement. Vetements secondaires actifs si vetement au corps."
            ),
            renderSlotGroup(slotGroups.weapons, "Armes et protections"),
            renderSlotGroup(slotGroups.jewelry, "Bijoux"),
            renderSlotGroup(slotGroups.bag, "Paquetage"),
            renderSlotGroup(slotGroups.beltPacks, "Ceinture (bourses)")
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 11, color: "rgba(255,255,255,0.6)", marginTop: 6 }, children: (() => {
        const mainBag = packSlotStatus("paquetage");
        const belt1 = packSlotStatus("ceinture_bourse_1");
        const belt2 = packSlotStatus("ceinture_bourse_2");
        const mainLabel = mainBag.bagId ? `${mainBag.storedWeight.toFixed(1)} / ${mainBag.capacity.toFixed(1)} poids` : "aucun sac equipe";
        const belt1Label = belt1.bagId ? `${belt1.storedWeight.toFixed(1)} / ${belt1.capacity.toFixed(1)} poids` : "";
        const belt2Label = belt2.bagId ? `${belt2.storedWeight.toFixed(1)} / ${belt2.capacity.toFixed(1)} poids` : "";
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            "Paquetage: ",
            mainLabel
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            "Ceinture: bourse 1 ",
            belt1Label,
            "  bourse 2 ",
            belt2Label
          ] })
        ] });
      })() }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          style: {
            marginTop: 10,
            borderRadius: 8,
            border: "1px solid rgba(255,255,255,0.12)",
            background: "rgba(12,12,18,0.75)",
            padding: 10,
            display: "flex",
            flexDirection: "column",
            gap: 8
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, fontWeight: 700 }, children: "Inventaire" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 11, color: "rgba(255,255,255,0.6)" }, children: "Equiper un slot ou ranger dans un sac (si disponible)." }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 11, color: "rgba(255,255,255,0.6)" }, children: [
              "Capacite de port: ",
              carryWeight.toFixed(1),
              " / ",
              carryCapacityMax.toFixed(1),
              " kg"
            ] }),
            inventoryItems.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.6)" }, children: "Aucun item pour l'instant." }),
            inventoryItems.map((item, idx) => {
              const eligibleSlots = equipmentSlots.filter((slot) => {
                if (slot.requiresClothingBody && !canUseClothingPieces) return false;
                const categories = getItemCategories(item);
                return categories.some((cat) => slot.accepts.includes(cat));
              });
              const itemSources = getItemSources(item);
              const storedSlotId = resolveStoredSlotId(item);
              const packOptions = Array.from(packSlots).map((slotId) => {
                const status = packSlotStatus(slotId);
                if (!status.bagId || status.capacity <= 0) return null;
                const containerItem = inventoryItems.find(
                  (entry) => (entry == null ? void 0 : entry.equippedSlot) === slotId && (entry == null ? void 0 : entry.id) === status.bagId
                );
                const itemWeight = getItemWeight(item) * (Number((item == null ? void 0 : item.qty) ?? 1) || 1);
                const alreadyStored = storedSlotId === slotId;
                const bagWeight = status.totalWeight - status.storedWeight;
                const capacityOk = alreadyStored || status.storedWeight + itemWeight <= status.capacity;
                const totalOk = typeof status.maxTotal === "number" ? alreadyStored || bagWeight + status.storedWeight + itemWeight <= status.maxTotal : true;
                const selfOk = !containerItem || containerItem !== item;
                return {
                  slotId,
                  label: getSlotLabel(slotId),
                  canStore: Boolean(selfOk && capacityOk && totalOk)
                };
              }).filter(Boolean);
              const itemValue = getItemUnitValue(item);
              const canSell = !isCurrencyItem(item) && !isSectionLocked("equip") && itemValue && moneyToCopper2(itemValue) > 0;
              const qtyLabel = ((item == null ? void 0 : item.qty) ?? 1) > 1 ? ` x${item.qty}` : "";
              const weaponSummary = getWeaponSummaryForItem(item);
              const harmonisable2 = isItemHarmonisable(item);
              const harmonized = harmonisable2 ? isItemHarmonized(item) : false;
              return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "div",
                {
                  style: {
                    display: "grid",
                    gridTemplateColumns: "1fr auto auto auto auto auto",
                    gap: 8,
                    alignItems: "center",
                    fontSize: 12
                  },
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      "span",
                      {
                        style: {
                          display: "flex",
                          flexDirection: "column",
                          alignItems: "flex-start",
                          gap: 2
                        },
                        children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsxs(
                            "span",
                            {
                              style: { display: "inline-flex", alignItems: "center", gap: 6 },
                              title: weaponSummary ?? void 0,
                              children: [
                                getItemLabel(item),
                                qtyLabel,
                                renderSourceDotsWithLabels(itemSources)
                              ]
                            }
                          ),
                          weaponSummary && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: 10, color: "rgba(255,255,255,0.62)" }, children: weaponSummary }),
                          harmonisable2 && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { style: { fontSize: 10, color: "rgba(130, 220, 255, 0.82)" }, children: [
                            "Harmonisation: ",
                            harmonized ? "active" : "inactive"
                          ] })
                        ]
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      "select",
                      {
                        value: storedSlotId ? `__pack:${storedSlotId}` : item.equippedSlot ? item.equippedSlot : "",
                        onChange: (e2) => {
                          const value2 = e2.target.value;
                          if (value2.startsWith("__pack:")) {
                            const slotId = value2.replace("__pack:", "");
                            storeItemInPack(idx, slotId);
                            return;
                          }
                          if (!value2) {
                            updateItemSlot(idx, null);
                            return;
                          }
                          updateItemSlot(idx, value2);
                        },
                        style: {
                          background: "#0f0f19",
                          color: "#f5f5f5",
                          border: "1px solid #333",
                          borderRadius: 6,
                          padding: "2px 6px",
                          fontSize: 11
                        },
                        disabled: isSectionLocked("equip"),
                        children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "", children: "Non equipe" }),
                          eligibleSlots.map((slot) => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: slot.id, children: slot.label }, `item-slot-${idx}-${slot.id}`)),
                          packOptions.map((option) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
                            "option",
                            {
                              value: `__pack:${option.slotId}`,
                              disabled: !option.canStore,
                              children: [
                                "Ranger dans ",
                                option.label
                              ]
                            },
                            `item-pack-${idx}-${option.slotId}`
                          ))
                        ]
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "button",
                      {
                        type: "button",
                        onClick: () => {
                          if (!canSell) return;
                          onSellRequest(idx, item, itemValue);
                        },
                        disabled: !canSell,
                        style: {
                          borderRadius: 6,
                          border: "1px solid rgba(255,255,255,0.2)",
                          background: canSell ? "rgba(241, 196, 15, 0.2)" : "rgba(255,255,255,0.06)",
                          color: canSell ? "#f8e58c" : "rgba(255,255,255,0.5)",
                          cursor: canSell ? "pointer" : "not-allowed",
                          fontSize: 12,
                          padding: "2px 6px",
                          fontWeight: 700
                        },
                        title: "Vendre",
                        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "14", height: "14", viewBox: "0 0 24 24", "aria-hidden": "true", children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx(
                            "circle",
                            {
                              cx: "12",
                              cy: "12",
                              r: "8",
                              fill: "none",
                              stroke: "currentColor",
                              strokeWidth: "2"
                            }
                          ),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(
                            "path",
                            {
                              d: "M9 12h6m-3-3v6",
                              stroke: "currentColor",
                              strokeWidth: "2",
                              strokeLinecap: "round"
                            }
                          )
                        ] })
                      }
                    ),
                    harmonisable2 && /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "button",
                      {
                        type: "button",
                        onClick: () => toggleItemHarmonization(idx),
                        disabled: isSectionLocked("equip"),
                        style: {
                          borderRadius: 6,
                          border: "1px solid rgba(255,255,255,0.2)",
                          background: harmonized ? "rgba(52, 152, 219, 0.25)" : "rgba(255,255,255,0.08)",
                          color: harmonized ? "#9ed8ff" : "#f5f5f5",
                          cursor: isSectionLocked("equip") ? "not-allowed" : "pointer",
                          fontSize: 12,
                          padding: "2px 6px",
                          fontWeight: 700
                        },
                        title: harmonized ? "Desharmoniser" : "Harmoniser",
                        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "14", height: "14", viewBox: "0 0 24 24", "aria-hidden": "true", children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx(
                            "circle",
                            {
                              cx: "8",
                              cy: "12",
                              r: "4",
                              fill: "none",
                              stroke: "currentColor",
                              strokeWidth: "2"
                            }
                          ),
                          /* @__PURE__ */ jsxRuntimeExports.jsx(
                            "circle",
                            {
                              cx: "16",
                              cy: "12",
                              r: "4",
                              fill: "none",
                              stroke: "currentColor",
                              strokeWidth: "2"
                            }
                          )
                        ] })
                      }
                    ),
                    item.type === "weapon" && /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "button",
                      {
                        type: "button",
                        onClick: () => setPrimaryWeapon(idx),
                        style: {
                          borderRadius: 6,
                          border: "1px solid rgba(255,255,255,0.2)",
                          background: item.isPrimaryWeapon ? "rgba(241, 196, 15, 0.25)" : "rgba(255,255,255,0.08)",
                          color: item.isPrimaryWeapon ? "#f8e58c" : "#f5f5f5",
                          cursor: "pointer",
                          fontSize: 12,
                          padding: "2px 6px",
                          fontWeight: 700
                        },
                        title: "Definir comme arme principale",
                        children: ""
                      }
                    ),
                    item.source === "manual" && !isCurrencyItem(item) && /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "button",
                      {
                        type: "button",
                        onClick: () => removeManualItem(idx),
                        style: {
                          padding: "2px 6px",
                          borderRadius: 6,
                          border: "1px solid rgba(255,255,255,0.2)",
                          background: "rgba(231,76,60,0.18)",
                          color: "#f5f5f5",
                          cursor: "pointer",
                          fontSize: 11
                        },
                        children: "Retirer"
                      }
                    )
                  ]
                },
                `inv-${idx}`
              );
            })
          ]
        }
      )
    ] }),
    equipSubTab === "loot" && /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        style: {
          marginTop: 10,
          borderRadius: 8,
          border: "1px solid rgba(255,255,255,0.12)",
          background: "rgba(12,12,18,0.75)",
          padding: 10,
          display: "flex",
          flexDirection: "column",
          gap: 8
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, fontWeight: 700 }, children: "Boite a loot infinie" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 11, color: "rgba(255,255,255,0.6)" }, children: "Ajoutez des items pour tester." }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, fontWeight: 700, marginTop: 4 }, children: "Armes" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              style: {
                display: "grid",
                gridTemplateColumns: "repeat(auto-fit, minmax(180px, 1fr))",
                gap: 6
              },
              children: weaponOptions.map((weapon) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "button",
                {
                  type: "button",
                  onClick: () => addManualItem(`weapon:${weapon.id}`),
                  style: {
                    textAlign: "left",
                    borderRadius: 8,
                    border: "1px solid rgba(255,255,255,0.12)",
                    background: "rgba(10,10,16,0.8)",
                    color: "#f5f5f5",
                    padding: "6px 8px",
                    cursor: "pointer",
                    fontSize: 12
                  },
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontWeight: 700 }, children: [
                      "+ ",
                      weapon.name,
                      " (",
                      weapon.subtype,
                      ")"
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 10, color: "rgba(255,255,255,0.65)", marginTop: 2 }, children: formatWeaponSummary(weapon) })
                  ]
                },
                `loot-weapon-${weapon.id}`
              ))
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, fontWeight: 700, marginTop: 6 }, children: "Outils" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              style: {
                display: "grid",
                gridTemplateColumns: "repeat(auto-fit, minmax(180px, 1fr))",
                gap: 6
              },
              children: [
                toolItems.map((tool) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "button",
                  {
                    type: "button",
                    onClick: () => addManualItem(`tool:${tool.id}`),
                    style: {
                      textAlign: "left",
                      borderRadius: 8,
                      border: "1px solid rgba(255,255,255,0.12)",
                      background: "rgba(10,10,16,0.8)",
                      color: "#f5f5f5",
                      padding: "6px 8px",
                      cursor: "pointer",
                      fontSize: 12
                    },
                    children: [
                      "+ ",
                      tool.label
                    ]
                  },
                  `loot-tool-${tool.id}`
                )),
                toolItems.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.6)" }, children: "Aucun outil disponible." })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, fontWeight: 700, marginTop: 6 }, children: "Armures" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              style: {
                display: "grid",
                gridTemplateColumns: "repeat(auto-fit, minmax(180px, 1fr))",
                gap: 6
              },
              children: [
                armorItems.map((armor) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "button",
                  {
                    type: "button",
                    onClick: () => addManualItem(`armor:${armor.id}`),
                    style: {
                      textAlign: "left",
                      borderRadius: 8,
                      border: "1px solid rgba(255,255,255,0.12)",
                      background: "rgba(10,10,16,0.8)",
                      color: "#f5f5f5",
                      padding: "6px 8px",
                      cursor: "pointer",
                      fontSize: 12
                    },
                    children: [
                      "+ ",
                      armor.label
                    ]
                  },
                  `loot-armor-${armor.id}`
                )),
                armorItems.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.6)" }, children: "Aucune armure chargee pour l'instant." })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, fontWeight: 700, marginTop: 6 }, children: "Autres" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              style: {
                display: "grid",
                gridTemplateColumns: "repeat(auto-fit, minmax(180px, 1fr))",
                gap: 6
              },
              children: [
                objectItems.map((obj) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "button",
                  {
                    type: "button",
                    onClick: () => addManualItem(`object:${obj.id}`),
                    style: {
                      textAlign: "left",
                      borderRadius: 8,
                      border: "1px solid rgba(255,255,255,0.12)",
                      background: "rgba(10,10,16,0.8)",
                      color: "#f5f5f5",
                      padding: "6px 8px",
                      cursor: "pointer",
                      fontSize: 12
                    },
                    children: [
                      "+ ",
                      obj.label
                    ]
                  },
                  `loot-object-${obj.id}`
                )),
                objectItems.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.6)" }, children: "Aucun autre item charge pour l'instant." })
              ]
            }
          )
        ]
      }
    )
  ] });
}
function ChoiceModal(props) {
  const { open, title, options, selected, count: count2, onToggle, onClose, onConfirm } = props;
  if (!open) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      style: {
        position: "fixed",
        inset: 0,
        background: "rgba(0,0,0,0.55)",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        zIndex: 999
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          style: {
            width: "min(520px, 92vw)",
            background: "#141421",
            border: "1px solid rgba(255,255,255,0.18)",
            borderRadius: 12,
            padding: 16,
            display: "flex",
            flexDirection: "column",
            gap: 12
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 14, fontWeight: 800 }, children: title }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.7)" }, children: [
              "Choix requis: ",
              count2,
              " ",
              count2 > 1 ? "elements" : "element"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                style: {
                  display: "grid",
                  gridTemplateColumns: "repeat(auto-fit, minmax(160px, 1fr))",
                  gap: 8
                },
                children: options.map((option) => {
                  const isSelected = selected.includes(option.id);
                  return /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "button",
                    {
                      type: "button",
                      onClick: () => onToggle(option.id),
                      style: {
                        textAlign: "left",
                        borderRadius: 8,
                        border: `1px solid ${isSelected ? "#6fd3a8" : "rgba(255,255,255,0.12)"}`,
                        background: isSelected ? "rgba(46, 204, 113, 0.14)" : "rgba(12,12,18,0.75)",
                        color: "#f5f5f5",
                        padding: "8px 10px",
                        cursor: "pointer",
                        fontSize: 12
                      },
                      children: option.label
                    },
                    option.id
                  );
                })
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: 8, justifyContent: "flex-end" }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  type: "button",
                  onClick: onClose,
                  style: {
                    padding: "6px 10px",
                    borderRadius: 8,
                    border: "1px solid rgba(255,255,255,0.15)",
                    background: "rgba(255,255,255,0.06)",
                    color: "#f5f5f5",
                    cursor: "pointer",
                    fontSize: 12,
                    fontWeight: 700
                  },
                  children: "Fermer"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  type: "button",
                  onClick: onConfirm,
                  disabled: selected.length < count2,
                  style: {
                    padding: "6px 10px",
                    borderRadius: 8,
                    border: "1px solid rgba(255,255,255,0.15)",
                    background: selected.length < count2 ? "rgba(80,80,90,0.55)" : "rgba(46, 204, 113, 0.16)",
                    color: "#f5f5f5",
                    cursor: selected.length < count2 ? "not-allowed" : "pointer",
                    fontSize: 12,
                    fontWeight: 700
                  },
                  children: "Valider"
                }
              )
            ] })
          ]
        }
      )
    }
  );
}
function ConfirmModal(props) {
  const { open, title, message, onCancel, onConfirm } = props;
  if (!open) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      style: {
        position: "fixed",
        inset: 0,
        background: "rgba(0,0,0,0.55)",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        zIndex: 998
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          style: {
            width: "min(480px, 92vw)",
            background: "#141421",
            border: "1px solid rgba(255,255,255,0.18)",
            borderRadius: 12,
            padding: 16,
            display: "flex",
            flexDirection: "column",
            gap: 12
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 14, fontWeight: 800 }, children: title }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.7)" }, children: message }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: 8, justifyContent: "flex-end" }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  type: "button",
                  onClick: onCancel,
                  style: {
                    padding: "6px 10px",
                    borderRadius: 8,
                    border: "1px solid rgba(255,255,255,0.15)",
                    background: "rgba(255,255,255,0.06)",
                    color: "#f5f5f5",
                    cursor: "pointer",
                    fontSize: 12,
                    fontWeight: 700
                  },
                  children: "Annuler"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  type: "button",
                  onClick: onConfirm,
                  style: {
                    padding: "6px 10px",
                    borderRadius: 8,
                    border: "1px solid rgba(255,255,255,0.15)",
                    background: "rgba(231, 76, 60, 0.2)",
                    color: "#f5f5f5",
                    cursor: "pointer",
                    fontSize: 12,
                    fontWeight: 700
                  },
                  children: "Continuer"
                }
              )
            ] })
          ]
        }
      )
    }
  );
}
function AsiModal(props) {
  const {
    open,
    entry,
    step,
    type: type2,
    stats,
    originalStats,
    statKeys,
    asiBonusMap,
    getBaseScore,
    getNonAsiBonusSumForStat,
    setType,
    setStep,
    onClose,
    onConfirmType,
    onConfirmStats,
    updateStat,
    canAllocateMoreAsi
  } = props;
  if (!open) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      style: {
        position: "fixed",
        inset: 0,
        background: "rgba(0,0,0,0.55)",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        zIndex: 1e3
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          style: {
            width: "min(560px, 92vw)",
            background: "#141421",
            border: "1px solid rgba(255,255,255,0.18)",
            borderRadius: 12,
            padding: 16,
            display: "flex",
            flexDirection: "column",
            gap: 12
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 14, fontWeight: 800 }, children: entry ? `Niveau ${entry.level}  ${entry.classLabel}` : "Choix d'amelioration" }),
            step === "type" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.7)" }, children: "Souhaitez-vous augmenter les caracteristiques ou choisir un don ?" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", gap: 8 }, children: [
                { id: "asi", label: "Augmenter les caracteristiques" },
                { id: "feat", label: "Choisir un don" }
              ].map((opt) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  type: "button",
                  onClick: () => setType(opt.id),
                  style: {
                    padding: "6px 10px",
                    borderRadius: 8,
                    border: "1px solid rgba(255,255,255,0.15)",
                    background: type2 === opt.id ? "rgba(79,125,242,0.2)" : "rgba(255,255,255,0.06)",
                    color: "#f5f5f5",
                    cursor: "pointer",
                    fontSize: 12,
                    fontWeight: 700
                  },
                  children: opt.label
                },
                opt.id
              )) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: 8, justifyContent: "flex-end" }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    type: "button",
                    onClick: onClose,
                    style: {
                      padding: "6px 10px",
                      borderRadius: 8,
                      border: "1px solid rgba(255,255,255,0.15)",
                      background: "rgba(255,255,255,0.06)",
                      color: "#f5f5f5",
                      cursor: "pointer",
                      fontSize: 12,
                      fontWeight: 700
                    },
                    children: "Fermer"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    type: "button",
                    onClick: onConfirmType,
                    style: {
                      padding: "6px 10px",
                      borderRadius: 8,
                      border: "1px solid rgba(255,255,255,0.15)",
                      background: "rgba(46, 204, 113, 0.16)",
                      color: "#f5f5f5",
                      cursor: "pointer",
                      fontSize: 12,
                      fontWeight: 700
                    },
                    children: "Valider"
                  }
                )
              ] })
            ] }),
            step === "feat" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.7)" }, children: "Dons indisponibles pour l'instant." }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: 8, justifyContent: "flex-end" }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    type: "button",
                    onClick: () => setStep("type"),
                    style: {
                      padding: "6px 10px",
                      borderRadius: 8,
                      border: "1px solid rgba(255,255,255,0.15)",
                      background: "rgba(255,255,255,0.06)",
                      color: "#f5f5f5",
                      cursor: "pointer",
                      fontSize: 12,
                      fontWeight: 700
                    },
                    children: "Retour"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    type: "button",
                    onClick: onClose,
                    style: {
                      padding: "6px 10px",
                      borderRadius: 8,
                      border: "1px solid rgba(255,255,255,0.15)",
                      background: "rgba(255,255,255,0.06)",
                      color: "#f5f5f5",
                      cursor: "pointer",
                      fontSize: 12,
                      fontWeight: 700
                    },
                    children: "Fermer"
                  }
                )
              ] })
            ] }),
            step === "asi" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              (() => {
                const spent = Object.values(stats).reduce(
                  (sum, value2) => sum + (Number(value2) || 0),
                  0
                );
                const remaining = Math.max(0, 2 - spent);
                return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.7)" }, children: [
                  "Capital disponible : ",
                  remaining
                ] });
              })(),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  style: {
                    display: "grid",
                    gridTemplateColumns: "repeat(auto-fit, minmax(160px, 1fr))",
                    gap: 8
                  },
                  children: statKeys.map((stat) => {
                    const base = getBaseScore(stat);
                    const nonAsi = getNonAsiBonusSumForStat(stat);
                    const original = Number(originalStats[stat] ?? 0) || 0;
                    const totalAsi = Number(asiBonusMap[stat] ?? 0) || 0;
                    const otherAsi = Math.max(0, totalAsi - original);
                    const current = Number(stats[stat] ?? 0) || 0;
                    const total = base + nonAsi + otherAsi + current;
                    const spent = Object.values(stats).reduce(
                      (sum, value2) => sum + (Number(value2) || 0),
                      0
                    );
                    const remaining = Math.max(0, 2 - spent);
                    const canIncrease = remaining > 0 && current < 2 && total < 20;
                    const canDecrease = current > 0;
                    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      "div",
                      {
                        style: {
                          borderRadius: 8,
                          border: "1px solid rgba(255,255,255,0.12)",
                          background: "rgba(10,10,16,0.8)",
                          padding: 8,
                          display: "flex",
                          flexDirection: "column",
                          gap: 6
                        },
                        children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: 6 }, children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, fontWeight: 700 }, children: stat }),
                            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 11, color: "rgba(255,255,255,0.6)" }, children: [
                              "Total: ",
                              Math.min(20, total)
                            ] })
                          ] }),
                          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: 6 }, children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx(
                              "button",
                              {
                                type: "button",
                                onClick: () => canDecrease && updateStat(stat, -1),
                                disabled: !canDecrease,
                                style: {
                                  width: 26,
                                  height: 26,
                                  borderRadius: 6,
                                  border: "1px solid #333",
                                  background: canDecrease ? "#141421" : "rgba(80,80,90,0.55)",
                                  color: "#f5f5f5",
                                  cursor: canDecrease ? "pointer" : "not-allowed",
                                  display: "grid",
                                  placeItems: "center",
                                  fontSize: 12,
                                  fontWeight: 700
                                },
                                children: "-"
                              }
                            ),
                            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { minWidth: 24, textAlign: "center", fontSize: 12 }, children: [
                              "+",
                              current
                            ] }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx(
                              "button",
                              {
                                type: "button",
                                onClick: () => canIncrease && updateStat(stat, 1),
                                disabled: !canIncrease,
                                style: {
                                  width: 26,
                                  height: 26,
                                  borderRadius: 6,
                                  border: "1px solid #333",
                                  background: canIncrease ? "#141421" : "rgba(80,80,90,0.55)",
                                  color: "#f5f5f5",
                                  cursor: canIncrease ? "pointer" : "not-allowed",
                                  display: "grid",
                                  placeItems: "center",
                                  fontSize: 12,
                                  fontWeight: 700
                                },
                                children: "+"
                              }
                            )
                          ] })
                        ]
                      },
                      `asi-modal-${stat}`
                    );
                  })
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: 8, justifyContent: "flex-end" }, children: [
                (() => {
                  const spent = Object.values(stats).reduce(
                    (sum, value2) => sum + (Number(value2) || 0),
                    0
                  );
                  const remaining = Math.max(0, 2 - spent);
                  const canAllocateMore = entry && canAllocateMoreAsi(entry.key, stats);
                  return remaining > 0 && canAllocateMore ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "span",
                    {
                      style: { alignSelf: "center", fontSize: 11, color: "rgba(255,255,255,0.6)" },
                      children: "Utilisez les 2 points."
                    }
                  ) : null;
                })(),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    type: "button",
                    onClick: () => setStep("type"),
                    style: {
                      padding: "6px 10px",
                      borderRadius: 8,
                      border: "1px solid rgba(255,255,255,0.15)",
                      background: "rgba(255,255,255,0.06)",
                      color: "#f5f5f5",
                      cursor: "pointer",
                      fontSize: 12,
                      fontWeight: 700
                    },
                    children: "Retour"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    type: "button",
                    onClick: onConfirmStats,
                    disabled: (() => {
                      const spent = Object.values(stats).reduce(
                        (sum, value2) => sum + (Number(value2) || 0),
                        0
                      );
                      if (spent >= 2) return false;
                      if (!entry) return true;
                      return canAllocateMoreAsi(entry.key, stats);
                    })(),
                    style: {
                      padding: "6px 10px",
                      borderRadius: 8,
                      border: "1px solid rgba(255,255,255,0.15)",
                      background: (() => {
                        const spent = Object.values(stats).reduce(
                          (sum, value2) => sum + (Number(value2) || 0),
                          0
                        );
                        if (spent >= 2) return "rgba(46, 204, 113, 0.16)";
                        if (!entry) return "rgba(80,80,90,0.55)";
                        const canAllocateMore = canAllocateMoreAsi(entry.key, stats);
                        return canAllocateMore ? "rgba(80,80,90,0.55)" : "rgba(46, 204, 113, 0.16)";
                      })(),
                      color: "#f5f5f5",
                      cursor: (() => {
                        const spent = Object.values(stats).reduce(
                          (sum, value2) => sum + (Number(value2) || 0),
                          0
                        );
                        if (spent >= 2) return "pointer";
                        if (!entry) return "not-allowed";
                        const canAllocateMore = canAllocateMoreAsi(entry.key, stats);
                        return canAllocateMore ? "not-allowed" : "pointer";
                      })(),
                      fontSize: 12,
                      fontWeight: 700
                    },
                    children: "Valider"
                  }
                )
              ] })
            ] })
          ]
        }
      )
    }
  );
}
const isCurrencySpec = (type2, id2) => type2 === "object" && isCoinId(id2);
const updateEquipmentListQty = (list, resolveItemType, buildItemSpec, type2, id2, delta) => {
  let updated = false;
  const next = list.map((entry) => {
    if (updated) return entry;
    const resolved = resolveItemType(entry);
    if (resolved.type !== type2 || resolved.id !== id2) return entry;
    updated = true;
    const nextQty = (resolved.qty ?? 1) + delta;
    if (nextQty <= 0) return null;
    return buildItemSpec(type2, id2, nextQty);
  }).filter(Boolean);
  return next;
};
const formatMoneyValue = (money) => {
  const parts = [];
  const pp = Number(money.pp ?? 0) || 0;
  const po = Number(money.po ?? 0) || 0;
  const pa = Number(money.pa ?? 0) || 0;
  const pc = Number(money.pc ?? 0) || 0;
  if (pp) parts.push(`${pp} pp`);
  if (po) parts.push(`${po} po`);
  if (pa) parts.push(`${pa} pa`);
  if (pc) parts.push(`${pc} pc`);
  return parts.length > 0 ? parts.join(" ") : "0";
};
const buildInventoryEntries = (specs, source2, origin, createInstanceId) => {
  const entries = [];
  specs.forEach((spec) => {
    const qty = Math.max(1, Math.floor(Number(spec.qty || 1)));
    if (isCurrencySpec(spec.type, spec.id)) {
      entries.push({
        type: spec.type,
        id: spec.id,
        qty,
        source: source2,
        origin,
        instanceId: createInstanceId("item"),
        equippedSlot: null,
        storedIn: null,
        isPrimaryWeapon: false
      });
      return;
    }
    for (let i2 = 0; i2 < qty; i2 += 1) {
      entries.push({
        type: spec.type,
        id: spec.id,
        qty: 1,
        source: source2,
        origin,
        instanceId: createInstanceId("item"),
        equippedSlot: null,
        storedIn: null,
        isPrimaryWeapon: false
      });
    }
  });
  return entries;
};
const appendInventoryEntries = (base, entries) => {
  let next = [...base];
  entries.forEach((entry) => {
    if (isCurrencySpec(entry.type, entry.id)) {
      const existingIndex = next.findIndex(
        (item) => (item == null ? void 0 : item.type) === "object" && (item == null ? void 0 : item.id) === entry.id && ((item == null ? void 0 : item.storedIn) ?? null) === ((entry == null ? void 0 : entry.storedIn) ?? null)
      );
      if (existingIndex >= 0) {
        const existing = next[existingIndex];
        next[existingIndex] = {
          ...existing,
          instanceId: (existing == null ? void 0 : existing.instanceId) ?? (entry == null ? void 0 : entry.instanceId),
          qty: ((existing == null ? void 0 : existing.qty) ?? 1) + ((entry == null ? void 0 : entry.qty) ?? 1)
        };
        return;
      }
    }
    next = [...next, entry];
  });
  return next;
};
function StatsTab(props) {
  const {
    statsMode,
    setStatsMode,
    canLockStats,
    toggleSectionLock,
    resetStats,
    isSectionLocked,
    lockButtonBaseStyle,
    getLockButtonState,
    renderPendingBadge,
    getPendingCountForSection,
    getPointBuySummary,
    statKeys,
    getBaseScore,
    getBonusSumForStat,
    computeMod,
    getStatSources,
    renderSourceDots,
    setScore,
    canAdjustPointBuy
  } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: 8 }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, color: "#b0b8c4" }, children: "Ajustez les caracteristiques. Le modificateur se met a jour." }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", gap: 6 }, children: [
        { id: "normal", label: "Normal" },
        { id: "manual", label: "Manuel" }
      ].map((mode) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          type: "button",
          onClick: () => setStatsMode(mode.id),
          style: {
            padding: "4px 8px",
            borderRadius: 8,
            border: "1px solid rgba(255,255,255,0.15)",
            background: statsMode === mode.id ? "rgba(79,125,242,0.2)" : "rgba(255,255,255,0.06)",
            color: "#f5f5f5",
            cursor: "pointer",
            fontSize: 11,
            fontWeight: 700
          },
          children: mode.label
        },
        mode.id
      )) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          type: "button",
          onClick: () => !isSectionLocked("stats") && resetStats(),
          disabled: isSectionLocked("stats"),
          style: {
            padding: "4px 8px",
            borderRadius: 8,
            border: "1px solid rgba(255,255,255,0.15)",
            background: "rgba(255,255,255,0.08)",
            color: "#f5f5f5",
            cursor: isSectionLocked("stats") ? "not-allowed" : "pointer",
            fontSize: 11,
            fontWeight: 700,
            opacity: isSectionLocked("stats") ? 0.6 : 1
          },
          children: "Reset"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          type: "button",
          onClick: () => {
            if (!canLockStats()) return;
            toggleSectionLock("stats");
          },
          style: {
            ...lockButtonBaseStyle,
            marginLeft: "auto",
            background: getLockButtonState("stats").background,
            cursor: canLockStats() ? "pointer" : "not-allowed",
            opacity: canLockStats() ? 1 : 0.7
          },
          children: [
            getLockButtonState("stats").label,
            renderPendingBadge(getPendingCountForSection("stats"))
          ]
        }
      )
    ] }),
    (() => {
      const summary2 = getPointBuySummary();
      if (statsMode !== "normal") {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            style: {
              marginTop: 6,
              fontSize: 11,
              color: "rgba(255,255,255,0.7)",
              display: "flex",
              gap: 10,
              alignItems: "center"
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Capital: illimite (mode manuel)" })
          }
        );
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          style: {
            marginTop: 6,
            fontSize: 11,
            color: "rgba(255,255,255,0.7)",
            display: "flex",
            gap: 10,
            alignItems: "center"
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Points: 27" }),
            summary2.invalid ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { color: "#f1c40f" }, children: "Hors barme (8-15)" }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                "Utilises: ",
                summary2.total
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "span",
                {
                  style: {
                    color: summary2.remaining !== null && summary2.remaining < 0 ? "#e74c3c" : "#6fd3a8"
                  },
                  children: [
                    "Restants: ",
                    summary2.remaining ?? "-"
                  ]
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Regle: acquisition par points (8-15). Bonus via classe/historique/espece." })
          ]
        }
      );
    })(),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        style: {
          display: "grid",
          gridTemplateColumns: "repeat(auto-fit, minmax(140px, 1fr))",
          gap: 10
        },
        children: statKeys.map((stat) => {
          const baseScore = getBaseScore(stat);
          const bonus = getBonusSumForStat(stat);
          const totalScore = Math.max(1, Math.min(30, baseScore + bonus));
          const mod = computeMod(totalScore);
          const sources2 = getStatSources(stat);
          const canDecrease = !isSectionLocked("stats") && (statsMode !== "normal" || canAdjustPointBuy(stat, -1));
          const canIncrease = !isSectionLocked("stats") && (statsMode !== "normal" || canAdjustPointBuy(stat, 1));
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              style: {
                padding: 10,
                borderRadius: 8,
                border: "1px solid rgba(255,255,255,0.12)",
                background: "rgba(12,12,18,0.75)",
                display: "flex",
                flexDirection: "column",
                gap: 6
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, fontWeight: 700, display: "flex", alignItems: "center", gap: 6 }, children: [
                  stat,
                  sources2.length > 0 && renderSourceDots(sources2)
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "div",
                  {
                    style: {
                      display: "grid",
                      gridTemplateColumns: "30px 1fr 30px",
                      gap: 6,
                      alignItems: "center"
                    },
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "button",
                        {
                          type: "button",
                          onClick: () => canDecrease && setScore(stat, totalScore - 1),
                          disabled: !canDecrease,
                          style: {
                            width: 30,
                            height: 30,
                            borderRadius: 6,
                            border: "1px solid #333",
                            background: "#141421",
                            color: "#f5f5f5",
                            cursor: canDecrease ? "pointer" : "not-allowed",
                            opacity: canDecrease ? 1 : 0.5,
                            display: "grid",
                            placeItems: "center"
                          },
                          "aria-label": `Diminuer ${stat}`,
                          children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "12", height: "12", viewBox: "0 0 12 12", "aria-hidden": "true", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "2", y: "5.25", width: "8", height: "1.5", fill: "currentColor" }) })
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "input",
                        {
                          type: "number",
                          min: statsMode === "normal" ? 8 : 1,
                          max: statsMode === "normal" ? 15 : 30,
                          value: totalScore,
                          onChange: (e2) => !isSectionLocked("stats") && setScore(stat, Number(e2.target.value)),
                          disabled: isSectionLocked("stats"),
                          style: {
                            width: "100%",
                            background: "#0f0f19",
                            color: "#f5f5f5",
                            border: "1px solid #333",
                            borderRadius: 6,
                            padding: "4px 6px",
                            textAlign: "center",
                            appearance: "textfield",
                            WebkitAppearance: "textfield",
                            MozAppearance: "textfield"
                          }
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "button",
                        {
                          type: "button",
                          onClick: () => canIncrease && setScore(stat, totalScore + 1),
                          disabled: !canIncrease,
                          style: {
                            width: 30,
                            height: 30,
                            borderRadius: 6,
                            border: "1px solid #333",
                            background: "#141421",
                            color: "#f5f5f5",
                            cursor: canIncrease ? "pointer" : "not-allowed",
                            opacity: canIncrease ? 1 : 0.5,
                            display: "grid",
                            placeItems: "center"
                          },
                          "aria-label": `Augmenter ${stat}`,
                          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "12", height: "12", viewBox: "0 0 12 12", "aria-hidden": "true", children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "2", y: "5.25", width: "8", height: "1.5", fill: "currentColor" }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "5.25", y: "2", width: "1.5", height: "8", fill: "currentColor" })
                          ] })
                        }
                      )
                    ]
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 11, color: "rgba(255,255,255,0.6)" }, children: [
                  "Base: ",
                  baseScore,
                  bonus !== 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { style: { marginLeft: 6 }, children: [
                    "Bonus: ",
                    bonus > 0 ? `+${bonus}` : bonus
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { style: { marginLeft: 6 }, children: [
                    "Total: ",
                    totalScore
                  ] })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.7)" }, children: [
                  "Modificateur: ",
                  mod >= 0 ? `+${mod}` : mod
                ] })
              ]
            },
            stat
          );
        })
      }
    )
  ] });
}
function SkillsTab(props) {
  const {
    skillsMode,
    setSkillsMode,
    resetSkills,
    isSectionLocked,
    toggleSectionLock,
    lockButtonBaseStyle,
    getLockButtonState,
    renderPendingBadge,
    getPendingCountForSection,
    competenceOptions,
    expertises,
    competences,
    resolveLevel,
    computeMod,
    getScore,
    skillAbilityMap,
    renderSourceDots,
    getSkillSources,
    canEditSkills,
    toggleCompetence,
    toggleExpertise
  } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: 8 }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, color: "#b0b8c4" }, children: "Cochez les competences pour simuler les impacts de jeu." }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", gap: 6 }, children: [
        { id: "normal", label: "Normal" },
        { id: "manual", label: "Manuel" }
      ].map((mode) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          type: "button",
          onClick: () => setSkillsMode(mode.id),
          style: {
            padding: "4px 8px",
            borderRadius: 8,
            border: "1px solid rgba(255,255,255,0.15)",
            background: skillsMode === mode.id ? "rgba(79,125,242,0.2)" : "rgba(255,255,255,0.06)",
            color: "#f5f5f5",
            cursor: "pointer",
            fontSize: 11,
            fontWeight: 700
          },
          children: mode.label
        },
        mode.id
      )) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          type: "button",
          onClick: () => !isSectionLocked("skills") && resetSkills(),
          disabled: isSectionLocked("skills"),
          style: {
            padding: "4px 8px",
            borderRadius: 8,
            border: "1px solid rgba(255,255,255,0.15)",
            background: "rgba(255,255,255,0.08)",
            color: "#f5f5f5",
            cursor: isSectionLocked("skills") ? "not-allowed" : "pointer",
            fontSize: 11,
            fontWeight: 700,
            opacity: isSectionLocked("skills") ? 0.6 : 1
          },
          children: "Reset"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          type: "button",
          onClick: () => toggleSectionLock("skills"),
          style: {
            ...lockButtonBaseStyle,
            marginLeft: "auto",
            background: getLockButtonState("skills").background
          },
          children: [
            getLockButtonState("skills").label,
            renderPendingBadge(getPendingCountForSection("skills"))
          ]
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        style: {
          display: "grid",
          gridTemplateColumns: "repeat(auto-fit, minmax(200px, 1fr))",
          gap: 10
        },
        children: competenceOptions.map((skill) => {
          const isExpert = expertises.includes(skill.id);
          const isProf = competences.includes(skill.id);
          const level2 = resolveLevel();
          const prof = 2 + Math.floor((level2 - 1) / 4);
          const abilityKey = skillAbilityMap[skill.id];
          const scoreKey = abilityKey === "STR" ? "FOR" : abilityKey === "DEX" ? "DEX" : abilityKey === "CON" ? "CON" : abilityKey === "INT" ? "INT" : abilityKey === "WIS" ? "SAG" : "CHA";
          const mod = computeMod(getScore(scoreKey));
          const bonus = mod + (isExpert ? prof * 2 : isProf ? prof : 0);
          const bonusLabel = bonus >= 0 ? `+${bonus}` : bonus;
          const cardBackground = isExpert ? "rgba(241, 196, 15, 0.18)" : isProf ? "rgba(79,125,242,0.2)" : "rgba(12,12,18,0.75)";
          const cardBorder = isExpert ? "1px solid rgba(241,196,15,0.55)" : isProf ? "1px solid rgba(79,125,242,0.55)" : "1px solid rgba(255,255,255,0.12)";
          const cardShadow = isExpert ? "0 0 12px rgba(241,196,15,0.45)" : "none";
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              style: {
                padding: 10,
                borderRadius: 8,
                border: cardBorder,
                background: cardBackground,
                boxShadow: cardShadow,
                display: "flex",
                flexDirection: "column",
                gap: 8
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "div",
                  {
                    style: {
                      display: "flex",
                      justifyContent: "space-between",
                      gap: 8,
                      alignItems: "center"
                    },
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, fontWeight: 700 }, children: skill.label }),
                      renderSourceDots(getSkillSources(skill.id)),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 11, color: "rgba(255,255,255,0.6)" }, children: skillAbilityMap[skill.id] })
                    ]
                  }
                ),
                skillsMode === "normal" ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "div",
                  {
                    style: {
                      display: "flex",
                      alignItems: "center",
                      justifyContent: "center",
                      minHeight: 40
                    },
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "div",
                      {
                        style: {
                          fontSize: 20,
                          fontWeight: 800,
                          color: isExpert ? "#f1c40f" : isProf ? "#4f7df2" : "#f5f5f5"
                        },
                        children: bonusLabel
                      }
                    )
                  }
                ) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: 10, alignItems: "center" }, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { style: { display: "flex", gap: 6, alignItems: "center" }, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "input",
                        {
                          type: "checkbox",
                          checked: competences.includes(skill.id),
                          onChange: () => canEditSkills && toggleCompetence(skill.id),
                          disabled: !canEditSkills,
                          style: { accentColor: "#4f7df2" }
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: 12 }, children: "Maitrise" })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { style: { display: "flex", gap: 6, alignItems: "center" }, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "input",
                        {
                          type: "checkbox",
                          checked: expertises.includes(skill.id),
                          onChange: () => canEditSkills && toggleExpertise(skill.id),
                          disabled: !canEditSkills || !competences.includes(skill.id),
                          style: { accentColor: "#f1c40f" }
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: 12 }, children: "Expertise" })
                    ] })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.7)" }, children: [
                    "Bonus: ",
                    bonusLabel
                  ] })
                ] })
              ]
            },
            skill.id
          );
        })
      }
    )
  ] });
}
function MasteriesTab(props) {
  const {
    masteriesMode,
    setMasteriesMode,
    resetMasteries,
    isSectionLocked,
    toggleSectionLock,
    lockButtonBaseStyle,
    getLockButtonState,
    renderPendingBadge,
    getPendingCountForSection,
    weaponProficiencyOptions,
    unlockedWeaponMasteries,
    unlockedFightingStyles,
    armorMasteryOptions,
    toolMasteryOptions,
    weaponMasteries,
    armorMasteries,
    toolMasteries,
    toggleWeaponMastery,
    toggleArmorMastery,
    toggleToolMastery,
    canEditMasteries,
    renderSourceDots,
    getMasterySources
  } = props;
  const renderMasteryGrid = (title, items, selected, onToggle, kind2) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, fontWeight: 700, marginTop: 6 }, children: title }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        style: {
          display: "grid",
          gridTemplateColumns: "repeat(auto-fit, minmax(160px, 1fr))",
          gap: 8,
          marginTop: 6
        },
        children: items.map((item) => {
          const isActive = selected.includes(item.id);
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              type: "button",
              onClick: () => canEditMasteries && onToggle(item.id),
              disabled: !canEditMasteries,
              style: {
                textAlign: "left",
                borderRadius: 8,
                border: `1px solid ${isActive ? "rgba(79,125,242,0.6)" : "rgba(255,255,255,0.12)"}`,
                background: isActive ? "rgba(79,125,242,0.18)" : "rgba(12,12,18,0.75)",
                color: "#f5f5f5",
                padding: "8px 10px",
                cursor: canEditMasteries ? "pointer" : "not-allowed",
                fontSize: 12,
                display: "flex",
                alignItems: "center",
                justifyContent: "space-between",
                gap: 6
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: item.label }),
                renderSourceDots(getMasterySources(kind2, item.id))
              ]
            },
            item.id
          );
        })
      }
    )
  ] });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: 8 }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, color: "#b0b8c4" }, children: "Selectionnez les maitrises. Elles influenceront les bonus et malus." }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", gap: 6 }, children: [
        { id: "normal", label: "Normal" },
        { id: "manual", label: "Manuel" }
      ].map((mode) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          type: "button",
          onClick: () => setMasteriesMode(mode.id),
          style: {
            padding: "4px 8px",
            borderRadius: 8,
            border: "1px solid rgba(255,255,255,0.15)",
            background: masteriesMode === mode.id ? "rgba(79,125,242,0.2)" : "rgba(255,255,255,0.06)",
            color: "#f5f5f5",
            cursor: "pointer",
            fontSize: 11,
            fontWeight: 700
          },
          children: mode.label
        },
        mode.id
      )) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          type: "button",
          onClick: () => !isSectionLocked("masteries") && resetMasteries(),
          disabled: isSectionLocked("masteries"),
          style: {
            padding: "4px 8px",
            borderRadius: 8,
            border: "1px solid rgba(255,255,255,0.15)",
            background: "rgba(255,255,255,0.08)",
            color: "#f5f5f5",
            cursor: isSectionLocked("masteries") ? "not-allowed" : "pointer",
            fontSize: 11,
            fontWeight: 700,
            opacity: isSectionLocked("masteries") ? 0.6 : 1
          },
          children: "Reset"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          type: "button",
          onClick: () => toggleSectionLock("masteries"),
          style: {
            ...lockButtonBaseStyle,
            marginLeft: "auto",
            background: getLockButtonState("masteries").background
          },
          children: [
            getLockButtonState("masteries").label,
            renderPendingBadge(getPendingCountForSection("masteries"))
          ]
        }
      )
    ] }),
    renderMasteryGrid(
      "Armes",
      weaponProficiencyOptions,
      weaponMasteries,
      toggleWeaponMastery,
      "weapons"
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, fontWeight: 700, marginTop: 6 }, children: "Bottes d'armes debloquees" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          style: {
            marginTop: 6,
            borderRadius: 8,
            border: "1px solid rgba(255,255,255,0.12)",
            background: "rgba(12,12,18,0.75)",
            padding: "8px 10px",
            fontSize: 12,
            color: "#d9deea"
          },
          children: unlockedWeaponMasteries.length > 0 ? unlockedWeaponMasteries.map((item) => item.label).join(", ") : "Aucune mastery debloquee"
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, fontWeight: 700, marginTop: 6 }, children: "Styles de combat debloques" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          style: {
            marginTop: 6,
            borderRadius: 8,
            border: "1px solid rgba(255,255,255,0.12)",
            background: "rgba(12,12,18,0.75)",
            padding: "8px 10px",
            fontSize: 12,
            color: "#d9deea"
          },
          children: unlockedFightingStyles.length > 0 ? unlockedFightingStyles.map((item) => item.label).join(", ") : "Aucun style de combat debloque"
        }
      )
    ] }),
    renderMasteryGrid(
      "Armures",
      armorMasteryOptions,
      armorMasteries,
      toggleArmorMastery,
      "armors"
    ),
    renderMasteryGrid("Outils", toolMasteryOptions, toolMasteries, toggleToolMastery, "tools")
  ] });
}
function BackgroundsTab(props) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
  const {
    isSectionLocked,
    lockButtonBaseStyle,
    getLockButtonState,
    renderPendingBadge,
    getPendingCountForSection,
    backgroundOptions,
    selectedBackgroundId,
    handleBackgroundSelect,
    onLockClick,
    activeBackground,
    getBackgroundFeatureInfo,
    getBackgroundToolChoice,
    getBackgroundLanguageChoice,
    getBackgroundSkillProficiencies,
    getBackgroundToolProficiencies,
    formatEquipmentLabel,
    toolMasteryOptions,
    competenceOptions
  } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: 8 }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, color: "#b0b8c4" }, children: "Choisissez un historique. Un seul background peut etre actif." }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          type: "button",
          onClick: onLockClick,
          style: {
            ...lockButtonBaseStyle,
            marginLeft: "auto",
            background: getLockButtonState("backgrounds").background
          },
          children: [
            getLockButtonState("backgrounds").label,
            renderPendingBadge(getPendingCountForSection("backgrounds"))
          ]
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        style: {
          display: "grid",
          gridTemplateColumns: "minmax(220px, 1.1fr) minmax(240px, 1fr)",
          gap: 12,
          alignItems: "start"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              style: {
                display: "grid",
                gridTemplateColumns: "repeat(auto-fit, minmax(180px, 1fr))",
                gap: 10,
                alignContent: "start"
              },
              children: backgroundOptions.map((bg) => {
                const isSelected = selectedBackgroundId === bg.id;
                return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "button",
                  {
                    type: "button",
                    onClick: () => handleBackgroundSelect(bg),
                    disabled: isSectionLocked("backgrounds"),
                    style: {
                      textAlign: "left",
                      borderRadius: 10,
                      border: `1px solid ${isSelected ? "#6fd3a8" : "rgba(255,255,255,0.12)"}`,
                      background: isSelected ? "rgba(46, 204, 113, 0.14)" : "rgba(12,12,18,0.75)",
                      color: "#f5f5f5",
                      padding: 12,
                      display: "flex",
                      flexDirection: "column",
                      gap: 6,
                      minHeight: 120,
                      opacity: isSectionLocked("backgrounds") ? 0.6 : 1,
                      cursor: isSectionLocked("backgrounds") ? "not-allowed" : "pointer"
                    },
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 13, fontWeight: 800 }, children: bg.label }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.7)" }, children: bg.description })
                    ]
                  },
                  bg.id
                );
              })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              style: {
                borderRadius: 12,
                border: "1px solid rgba(255,255,255,0.12)",
                background: "rgba(12,12,18,0.75)",
                padding: 12,
                display: "flex",
                flexDirection: "column",
                gap: 10,
                minHeight: 260
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "div",
                  {
                    style: {
                      width: "100%",
                      aspectRatio: "16 / 9",
                      borderRadius: 10,
                      border: "1px dashed rgba(255,255,255,0.18)",
                      background: "rgba(8,8,12,0.65)",
                      display: "grid",
                      placeItems: "center",
                      color: "rgba(255,255,255,0.35)",
                      fontSize: 12
                    },
                    children: "Image 16:9"
                  }
                ),
                activeBackground ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 13, fontWeight: 800 }, children: activeBackground.label }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.7)" }, children: activeBackground.description }),
                  getBackgroundFeatureInfo(activeBackground) && /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    "div",
                    {
                      style: {
                        padding: 8,
                        borderRadius: 8,
                        border: "1px solid rgba(255,255,255,0.12)",
                        background: "rgba(10,10,16,0.8)",
                        fontSize: 12,
                        color: "rgba(255,255,255,0.7)"
                      },
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontWeight: 700, marginBottom: 4 }, children: (_a = getBackgroundFeatureInfo(activeBackground)) == null ? void 0 : _a.label }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: (_b = getBackgroundFeatureInfo(activeBackground)) == null ? void 0 : _b.description })
                      ]
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.6)" }, children: [
                    "Competences: ",
                    getBackgroundSkillProficiencies(activeBackground).map((id2) => {
                      var _a2;
                      return ((_a2 = competenceOptions.find((c2) => c2.id === id2)) == null ? void 0 : _a2.label) ?? id2;
                    }).join(", ") || ""
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.6)" }, children: [
                    "Outils: ",
                    getBackgroundToolProficiencies(activeBackground).map((id2) => {
                      var _a2;
                      return ((_a2 = toolMasteryOptions.find((t2) => t2.id === id2)) == null ? void 0 : _a2.label) ?? id2;
                    }).join(", ") || ""
                  ] }),
                  getBackgroundToolChoice(activeBackground) && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.6)" }, children: [
                    "Outils (choix ",
                    ((_c = getBackgroundToolChoice(activeBackground)) == null ? void 0 : _c.count) ?? 0,
                    "):",
                    " ",
                    (((_d = getBackgroundToolChoice(activeBackground)) == null ? void 0 : _d.options) ?? []).map((id2) => {
                      var _a2;
                      return ((_a2 = toolMasteryOptions.find((t2) => t2.id === id2)) == null ? void 0 : _a2.label) ?? id2;
                    }).join(", ")
                  ] }),
                  (activeBackground == null ? void 0 : activeBackground.toolNotes) && activeBackground.toolNotes.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.6)" }, children: [
                    "Outils: ",
                    activeBackground.toolNotes.join(", ")
                  ] }),
                  getBackgroundLanguageChoice(activeBackground) && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.6)" }, children: [
                    "Langues: ",
                    ((_e = getBackgroundLanguageChoice(activeBackground)) == null ? void 0 : _e.count) ?? 0,
                    " au choix"
                  ] }),
                  (activeBackground == null ? void 0 : activeBackground.equipment) && activeBackground.equipment.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.6)" }, children: [
                    "Materiel: ",
                    activeBackground.equipment.map(formatEquipmentLabel).join(", ")
                  ] }),
                  getBackgroundFeatureInfo(activeBackground) && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.7)" }, children: [
                    "Aptitude: ",
                    ((_f = getBackgroundFeatureInfo(activeBackground)) == null ? void 0 : _f.label) ?? "",
                    ((_g = getBackgroundFeatureInfo(activeBackground)) == null ? void 0 : _g.description) ? `  ${(_h = getBackgroundFeatureInfo(activeBackground)) == null ? void 0 : _h.description}` : ""
                  ] }),
                  ((_i = activeBackground == null ? void 0 : activeBackground.traits) == null ? void 0 : _i.bond) && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.6)" }, children: [
                    "Lien: ",
                    activeBackground.traits.bond
                  ] }),
                  ((_j = activeBackground == null ? void 0 : activeBackground.traits) == null ? void 0 : _j.flaw) && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.6)" }, children: [
                    "Defaut: ",
                    activeBackground.traits.flaw
                  ] })
                ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.6)" }, children: "Aucun historique selectionne." })
              ]
            }
          )
        ]
      }
    )
  ] });
}
function ClassesTab(props) {
  const {
    activeClassTab,
    resolvedClassTab,
    setActiveClassTab,
    isSectionLocked,
    lockButtonBaseStyle,
    getClassLockButtonState,
    renderPendingBadge,
    getPendingCountForSection,
    resetClassImpactsForSlot,
    hasPendingClassChoicesForSlot,
    startClassDefine,
    setClassLockForSlot,
    resolveLevel,
    setLevel,
    classOptions,
    subclassOptions,
    isActiveClassLocked,
    activeClassSlot,
    activeClassId,
    activeSubclassId,
    activeClassEntry,
    handleClassSelect,
    setSubclassSelection,
    setClassLevel,
    isSecondaryEnabled,
    enableSecondaryClass,
    removeSecondaryClass
  } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, color: "#b0b8c4" }, children: "Definissez le niveau global, puis choisissez vos classes." }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 13, display: "flex", alignItems: "center", gap: 10 }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Niveau global :" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          style: {
            display: "flex",
            alignItems: "center",
            gap: 6,
            padding: "4px 6px",
            borderRadius: 8,
            border: "1px solid #2a2a3a",
            background: "#0f0f19"
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "button",
                onClick: () => !isSectionLocked("classes") && setLevel(resolveLevel() - 1),
                disabled: isSectionLocked("classes"),
                style: {
                  width: 30,
                  height: 30,
                  borderRadius: 6,
                  border: "1px solid #333",
                  background: "#141421",
                  color: "#f5f5f5",
                  cursor: isSectionLocked("classes") ? "not-allowed" : "pointer",
                  display: "grid",
                  placeItems: "center",
                  opacity: isSectionLocked("classes") ? 0.6 : 1
                },
                "aria-label": "Diminuer le niveau",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "12", height: "12", viewBox: "0 0 12 12", "aria-hidden": "true", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "2", y: "5.25", width: "8", height: "1.5", fill: "currentColor" }) })
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "number",
                min: 1,
                max: 20,
                value: resolveLevel(),
                onChange: (e2) => !isSectionLocked("classes") && setLevel(Number(e2.target.value)),
                disabled: isSectionLocked("classes"),
                style: {
                  width: 60,
                  background: "#0f0f19",
                  color: "#f5f5f5",
                  border: "1px solid #333",
                  borderRadius: 6,
                  padding: "4px 6px",
                  textAlign: "center",
                  appearance: "textfield",
                  WebkitAppearance: "textfield",
                  MozAppearance: "textfield",
                  opacity: isSectionLocked("classes") ? 0.6 : 1
                }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "button",
                onClick: () => !isSectionLocked("classes") && setLevel(resolveLevel() + 1),
                disabled: isSectionLocked("classes"),
                style: {
                  width: 30,
                  height: 30,
                  borderRadius: 6,
                  border: "1px solid #333",
                  background: "#141421",
                  color: "#f5f5f5",
                  cursor: isSectionLocked("classes") ? "not-allowed" : "pointer",
                  display: "grid",
                  placeItems: "center",
                  opacity: isSectionLocked("classes") ? 0.6 : 1
                },
                "aria-label": "Augmenter le niveau",
                children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "12", height: "12", viewBox: "0 0 12 12", "aria-hidden": "true", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "2", y: "5.25", width: "8", height: "1.5", fill: "currentColor" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "5.25", y: "2", width: "1.5", height: "8", fill: "currentColor" })
                ] })
              }
            )
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { style: { fontSize: 12, color: "rgba(255,255,255,0.7)" }, children: [
        "Bonus de maitrise: +",
        2 + Math.floor((resolveLevel() - 1) / 4)
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          type: "button",
          onClick: () => {
            if (isActiveClassLocked) {
              resetClassImpactsForSlot(activeClassSlot);
              return;
            }
            if (hasPendingClassChoicesForSlot(activeClassSlot)) {
              startClassDefine(activeClassSlot);
              return;
            }
            setClassLockForSlot(activeClassSlot, true);
          },
          style: {
            ...lockButtonBaseStyle,
            marginLeft: "auto",
            padding: "6px 10px",
            background: getClassLockButtonState().background,
            fontSize: 12
          },
          children: [
            getClassLockButtonState().label,
            renderPendingBadge(getPendingCountForSection("classes"))
          ]
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: 8, marginTop: 8, flexWrap: "wrap" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          type: "button",
          onClick: () => setActiveClassTab("primary"),
          style: {
            padding: "6px 10px",
            borderRadius: 6,
            border: `1px solid ${resolvedClassTab === "primary" ? "#6fd3a8" : "#333"}`,
            background: resolvedClassTab === "primary" ? "rgba(46, 204, 113, 0.16)" : "#0f0f19",
            color: "#c9cfdd",
            cursor: "pointer",
            fontSize: 12,
            fontWeight: 700
          },
          children: "Classe principale"
        }
      ),
      resolveLevel() > 2 && /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          type: "button",
          onClick: () => setActiveClassTab("secondary"),
          style: {
            padding: "6px 10px",
            borderRadius: 6,
            border: `1px solid ${resolvedClassTab === "secondary" ? "#6fd3a8" : "#333"}`,
            background: resolvedClassTab === "secondary" ? "rgba(46, 204, 113, 0.16)" : "#0f0f19",
            color: "#c9cfdd",
            cursor: "pointer",
            fontSize: 12,
            fontWeight: 700
          },
          children: "2eme classe"
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        style: {
          display: "grid",
          gridTemplateColumns: "minmax(220px, 1.1fr) minmax(240px, 1fr)",
          gap: 12,
          alignItems: "start"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              style: {
                display: "grid",
                gridTemplateColumns: "repeat(auto-fit, minmax(180px, 1fr))",
                gap: 10,
                alignContent: "start"
              },
              children: [
                resolvedClassTab === "secondary" && !isSecondaryEnabled && /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "button",
                  {
                    type: "button",
                    onClick: () => !isActiveClassLocked && enableSecondaryClass(),
                    disabled: isActiveClassLocked,
                    style: {
                      textAlign: "center",
                      borderRadius: 12,
                      border: "1px dashed rgba(255,255,255,0.25)",
                      background: "rgba(12,12,18,0.6)",
                      color: "#f5f5f5",
                      padding: 14,
                      cursor: isActiveClassLocked ? "not-allowed" : "pointer",
                      display: "flex",
                      flexDirection: "column",
                      gap: 10,
                      alignItems: "center",
                      justifyContent: "center",
                      minHeight: 180
                    },
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "div",
                        {
                          style: {
                            width: 46,
                            height: 46,
                            borderRadius: 12,
                            border: "1px solid rgba(255,255,255,0.25)",
                            display: "grid",
                            placeItems: "center",
                            fontSize: 28,
                            fontWeight: 700
                          },
                          children: "+"
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.7)" }, children: "Activer une 2eme classe" })
                    ]
                  }
                ),
                classOptions.map((cls) => {
                  const isSelected = activeClassId === cls.id;
                  const isDisabled = isActiveClassLocked || resolvedClassTab === "secondary" && !isSecondaryEnabled;
                  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    "button",
                    {
                      type: "button",
                      onClick: () => {
                        if (isDisabled) return;
                        handleClassSelect(cls, activeClassSlot);
                      },
                      disabled: isDisabled,
                      style: {
                        textAlign: "left",
                        borderRadius: 10,
                        border: `1px solid ${isSelected ? "#6fd3a8" : "rgba(255,255,255,0.12)"}`,
                        background: isSelected ? "rgba(46, 204, 113, 0.14)" : "rgba(12,12,18,0.75)",
                        color: "#f5f5f5",
                        padding: 12,
                        cursor: isDisabled ? "not-allowed" : "pointer",
                        display: "flex",
                        flexDirection: "column",
                        gap: 6,
                        minHeight: 120,
                        opacity: isDisabled ? 0.55 : 1
                      },
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 13, fontWeight: 800 }, children: cls.label }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.7)" }, children: cls.description })
                      ]
                    },
                    `${resolvedClassTab}-${cls.id}`
                  );
                })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              style: {
                borderRadius: 12,
                border: "1px solid rgba(255,255,255,0.12)",
                background: "rgba(12,12,18,0.75)",
                padding: 12,
                display: "flex",
                flexDirection: "column",
                gap: 10,
                minHeight: 260
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 14, fontWeight: 800 }, children: resolvedClassTab === "secondary" ? "2eme classe" : "Classe principale" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.6)" }, children: "Niveau dans cette classe :" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "div",
                  {
                    style: {
                      display: "flex",
                      alignItems: "center",
                      gap: 6,
                      padding: "4px 6px",
                      borderRadius: 8,
                      border: "1px solid #2a2a3a",
                      background: "#0f0f19",
                      width: "fit-content"
                    },
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "button",
                        {
                          type: "button",
                          onClick: () => !isActiveClassLocked && setClassLevel(activeClassSlot, (Number(activeClassEntry == null ? void 0 : activeClassEntry.niveau) || 1) - 1),
                          disabled: isActiveClassLocked || resolvedClassTab === "secondary" && !isSecondaryEnabled,
                          style: {
                            width: 30,
                            height: 30,
                            borderRadius: 6,
                            border: "1px solid #333",
                            background: "#141421",
                            color: "#f5f5f5",
                            cursor: isActiveClassLocked ? "not-allowed" : "pointer",
                            display: "grid",
                            placeItems: "center",
                            opacity: isActiveClassLocked ? 0.6 : 1
                          },
                          "aria-label": "Diminuer le niveau de classe",
                          children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "12", height: "12", viewBox: "0 0 12 12", "aria-hidden": "true", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "2", y: "5.25", width: "8", height: "1.5", fill: "currentColor" }) })
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "input",
                        {
                          type: "number",
                          min: 1,
                          max: isSecondaryEnabled ? Math.max(1, resolveLevel() - 1) : resolveLevel(),
                          value: (activeClassEntry == null ? void 0 : activeClassEntry.niveau) ?? (activeClassSlot === 1 ? resolveLevel() : 0),
                          onChange: (e2) => !isActiveClassLocked && setClassLevel(activeClassSlot, Number(e2.target.value)),
                          disabled: isActiveClassLocked || resolvedClassTab === "secondary" && !isSecondaryEnabled,
                          style: {
                            width: 60,
                            background: "#0f0f19",
                            color: "#f5f5f5",
                            border: "1px solid #333",
                            borderRadius: 6,
                            padding: "4px 6px",
                            textAlign: "center",
                            appearance: "textfield",
                            WebkitAppearance: "textfield",
                            MozAppearance: "textfield",
                            opacity: isActiveClassLocked ? 0.6 : 1
                          }
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "button",
                        {
                          type: "button",
                          onClick: () => !isActiveClassLocked && setClassLevel(activeClassSlot, (Number(activeClassEntry == null ? void 0 : activeClassEntry.niveau) || 1) + 1),
                          disabled: isActiveClassLocked || resolvedClassTab === "secondary" && !isSecondaryEnabled,
                          style: {
                            width: 30,
                            height: 30,
                            borderRadius: 6,
                            border: "1px solid #333",
                            background: "#141421",
                            color: "#f5f5f5",
                            cursor: isActiveClassLocked ? "not-allowed" : "pointer",
                            display: "grid",
                            placeItems: "center",
                            opacity: isActiveClassLocked ? 0.6 : 1
                          },
                          "aria-label": "Augmenter le niveau de classe",
                          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "12", height: "12", viewBox: "0 0 12 12", "aria-hidden": "true", children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "2", y: "5.25", width: "8", height: "1.5", fill: "currentColor" }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "5.25", y: "2", width: "1.5", height: "8", fill: "currentColor" })
                          ] })
                        }
                      )
                    ]
                  }
                ),
                resolvedClassTab === "secondary" && isSecondaryEnabled && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    type: "button",
                    onClick: () => !isActiveClassLocked && removeSecondaryClass(),
                    disabled: isActiveClassLocked,
                    style: {
                      marginTop: 8,
                      alignSelf: "flex-start",
                      padding: "6px 10px",
                      borderRadius: 8,
                      border: "1px solid rgba(255,255,255,0.15)",
                      background: "rgba(231,76,60,0.14)",
                      color: "#f5f5f5",
                      cursor: isActiveClassLocked ? "not-allowed" : "pointer",
                      fontSize: 12,
                      fontWeight: 700,
                      opacity: isActiveClassLocked ? 0.6 : 1
                    },
                    children: "Supprimer la 2eme classe"
                  }
                ),
                (() => {
                  const cls = classOptions.find((c2) => c2.id === activeClassId);
                  if (!cls) {
                    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.6)" }, children: "Choisissez d'abord une classe." });
                  }
                  const threshold = cls.subclassLevel ?? 1;
                  const level2 = Number(activeClassEntry == null ? void 0 : activeClassEntry.niveau) || (activeClassSlot === 1 ? resolveLevel() : 0);
                  if (level2 < threshold) {
                    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      "div",
                      {
                        style: {
                          padding: 10,
                          borderRadius: 10,
                          border: "1px dashed rgba(255,255,255,0.2)",
                          background: "rgba(8,8,12,0.6)",
                          color: "rgba(255,255,255,0.6)",
                          fontSize: 12
                        },
                        children: [
                          "Sous-classe verrouillee jusqu'au niveau ",
                          threshold,
                          "."
                        ]
                      }
                    );
                  }
                  const allowedIds = Array.isArray(cls.subclassIds) ? cls.subclassIds : [];
                  const subclasses = subclassOptions.filter((sub) => sub.classId === cls.id);
                  return /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "div",
                    {
                      style: {
                        display: "grid",
                        gridTemplateColumns: "repeat(auto-fit, minmax(200px, 1fr))",
                        gap: 10
                      },
                      children: subclasses.map((sub) => {
                        const isAllowed = allowedIds.length === 0 || allowedIds.includes(sub.id);
                        const isSelected = activeSubclassId === sub.id;
                        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                          "button",
                          {
                            type: "button",
                            onClick: () => {
                              if (!isAllowed || isActiveClassLocked) return;
                              setSubclassSelection(sub.id, activeClassSlot);
                            },
                            disabled: !isAllowed || isActiveClassLocked,
                            style: {
                              textAlign: "left",
                              borderRadius: 10,
                              border: `1px solid ${isSelected ? "#f1c40f" : "rgba(255,255,255,0.12)"}`,
                              background: isSelected ? "rgba(241, 196, 15, 0.14)" : "rgba(12,12,18,0.75)",
                              color: "#f5f5f5",
                              padding: 12,
                              cursor: isAllowed && !isActiveClassLocked ? "pointer" : "not-allowed",
                              display: "flex",
                              flexDirection: "column",
                              gap: 6,
                              minHeight: 110,
                              opacity: isAllowed && !isActiveClassLocked ? 1 : 0.5
                            },
                            children: [
                              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 13, fontWeight: 800 }, children: sub.label }),
                              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.7)" }, children: sub.description })
                            ]
                          },
                          `${activeClassSlot}-${sub.id}`
                        );
                      })
                    }
                  );
                })()
              ]
            }
          )
        ]
      }
    )
  ] });
}
function SpeciesTab(props) {
  var _a;
  const {
    isSectionLocked,
    lockButtonBaseStyle,
    getLockButtonState,
    renderPendingBadge,
    getPendingCountForSection,
    onLockClick,
    raceOptions,
    selectedRaceId,
    handleSpeciesSelect,
    activeRace,
    getRaceTraits
  } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: 8 }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, color: "#b0b8c4" }, children: "Choisissez une espece. Ce choix met a jour raceId dans le personnage." }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          type: "button",
          onClick: onLockClick,
          style: {
            ...lockButtonBaseStyle,
            marginLeft: "auto",
            background: getLockButtonState("species").background
          },
          children: [
            getLockButtonState("species").label,
            renderPendingBadge(getPendingCountForSection("species"))
          ]
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        style: {
          display: "grid",
          gridTemplateColumns: "minmax(220px, 1.1fr) minmax(240px, 1fr)",
          gap: 12,
          alignItems: "start"
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              style: {
                display: "grid",
                gridTemplateColumns: "repeat(auto-fit, minmax(180px, 1fr))",
                gap: 10,
                alignContent: "start"
              },
              children: raceOptions.map((race) => {
                const isSelected = selectedRaceId === race.id;
                return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "button",
                  {
                    type: "button",
                    onClick: () => handleSpeciesSelect(race.id),
                    disabled: isSectionLocked("species"),
                    style: {
                      textAlign: "left",
                      borderRadius: 10,
                      border: `1px solid ${isSelected ? "#6fd3a8" : "rgba(255,255,255,0.12)"}`,
                      background: isSelected ? "rgba(46, 204, 113, 0.14)" : "rgba(12,12,18,0.75)",
                      color: "#f5f5f5",
                      padding: 12,
                      display: "flex",
                      flexDirection: "column",
                      gap: 6,
                      minHeight: 120,
                      opacity: isSectionLocked("species") ? 0.6 : 1,
                      cursor: isSectionLocked("species") ? "not-allowed" : "pointer"
                    },
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 13, fontWeight: 800 }, children: race.label }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.7)" }, children: race.description }),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 11, color: "rgba(255,255,255,0.5)" }, children: [
                        "ID: ",
                        race.id
                      ] })
                    ]
                  },
                  race.id
                );
              })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              style: {
                borderRadius: 12,
                border: "1px solid rgba(255,255,255,0.12)",
                background: "rgba(12,12,18,0.75)",
                padding: 12,
                display: "flex",
                flexDirection: "column",
                gap: 10,
                minHeight: 260
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "div",
                  {
                    style: {
                      width: "100%",
                      aspectRatio: "16 / 9",
                      borderRadius: 10,
                      border: "1px dashed rgba(255,255,255,0.18)",
                      background: "rgba(8,8,12,0.65)",
                      display: "grid",
                      placeItems: "center",
                      color: "rgba(255,255,255,0.35)",
                      fontSize: 12
                    },
                    children: "Image 16:9"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 14, fontWeight: 800 }, children: activeRace ? activeRace.label : "Selectionnez une espece" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.75)" }, children: activeRace ? activeRace.description : "Selectionnez une espece pour voir les details." }),
                activeRace && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.6)" }, children: [
                  "Vitesse: ",
                  activeRace.speed ?? "?",
                  " | Taille: ",
                  activeRace.size ?? "?"
                ] }),
                activeRace && getRaceTraits(activeRace).length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.6)" }, children: [
                  "Traits: ",
                  getRaceTraits(activeRace).map((trait) => trait.label).join(", ")
                ] }),
                activeRace && ((_a = activeRace.vision) == null ? void 0 : _a.mode) && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.6)" }, children: [
                  "Vision: ",
                  activeRace.vision.mode,
                  activeRace.vision.range ? ` ${activeRace.vision.range}ft` : ""
                ] })
              ]
            }
          )
        ]
      }
    )
  ] });
}
function ProfileTab(props) {
  var _a, _b, _c, _d;
  const {
    character,
    profileDetails,
    setNameField,
    setPhysiqueDetail,
    setProfileDetail,
    isSectionLocked,
    toggleSectionLock,
    lockButtonBaseStyle,
    getLockButtonState,
    renderPendingBadge,
    getPendingCountForSection
  } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: 8 }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, color: "#b0b8c4" }, children: "Renseignez le profil du personnage (pre-rempli)." }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          type: "button",
          onClick: () => toggleSectionLock("profile"),
          style: {
            ...lockButtonBaseStyle,
            marginLeft: "auto",
            background: getLockButtonState("profile").background
          },
          children: [
            getLockButtonState("profile").label,
            renderPendingBadge(getPendingCountForSection("profile"))
          ]
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        style: {
          display: "grid",
          gridTemplateColumns: "repeat(auto-fit, minmax(180px, 1fr))",
          gap: 10
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { style: { fontSize: 12, display: "flex", flexDirection: "column", gap: 6 }, children: [
            "Prenom",
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "text",
                value: ((_a = character.nom) == null ? void 0 : _a.prenom) ?? "",
                onChange: (e2) => setNameField("prenom", e2.target.value),
                disabled: isSectionLocked("profile"),
                style: {
                  background: "#0f0f19",
                  color: "#f5f5f5",
                  border: "1px solid #333",
                  borderRadius: 6,
                  padding: "6px 8px",
                  fontSize: 12,
                  opacity: isSectionLocked("profile") ? 0.6 : 1
                }
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { style: { fontSize: 12, display: "flex", flexDirection: "column", gap: 6 }, children: [
            "Nom complet",
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "text",
                value: ((_b = character.nom) == null ? void 0 : _b.nomcomplet) ?? "",
                onChange: (e2) => setNameField("nomcomplet", e2.target.value),
                disabled: isSectionLocked("profile"),
                style: {
                  background: "#0f0f19",
                  color: "#f5f5f5",
                  border: "1px solid #333",
                  borderRadius: 6,
                  padding: "6px 8px",
                  fontSize: 12,
                  opacity: isSectionLocked("profile") ? 0.6 : 1
                }
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { style: { fontSize: 12, display: "flex", flexDirection: "column", gap: 6 }, children: [
            "Surnom",
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "text",
                value: ((_c = character.nom) == null ? void 0 : _c.surnom) ?? "",
                onChange: (e2) => setNameField("surnom", e2.target.value),
                disabled: isSectionLocked("profile"),
                style: {
                  background: "#0f0f19",
                  color: "#f5f5f5",
                  border: "1px solid #333",
                  borderRadius: 6,
                  padding: "6px 8px",
                  fontSize: 12,
                  opacity: isSectionLocked("profile") ? 0.6 : 1
                }
              }
            )
          ] })
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { style: { fontSize: 12, display: "flex", flexDirection: "column", gap: 6 }, children: [
      "Traits physiques (general)",
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "textarea",
        {
          value: ((_d = character.descriptionPersonnage) == null ? void 0 : _d.physique) ?? "",
          onChange: (e2) => setPhysiqueDetail(e2.target.value),
          disabled: isSectionLocked("profile"),
          rows: 3,
          style: {
            resize: "vertical",
            minHeight: 70,
            background: "#0f0f19",
            color: "#f5f5f5",
            border: "1px solid #333",
            borderRadius: 6,
            padding: "8px 10px",
            fontSize: 12,
            opacity: isSectionLocked("profile") ? 0.6 : 1
          }
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        style: {
          display: "grid",
          gridTemplateColumns: "repeat(auto-fit, minmax(180px, 1fr))",
          gap: 10
        },
        children: [
          { id: "visage", label: "Visage" },
          { id: "cheveux", label: "Cheveux" },
          { id: "yeux", label: "Yeux" },
          { id: "silhouette", label: "Silhouette" }
        ].map((field) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "label",
          {
            style: { fontSize: 12, display: "flex", flexDirection: "column", gap: 6 },
            children: [
              field.label,
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "text",
                  value: profileDetails[field.id] ?? "",
                  onChange: (e2) => setProfileDetail(field.id, e2.target.value),
                  disabled: isSectionLocked("profile"),
                  style: {
                    background: "#0f0f19",
                    color: "#f5f5f5",
                    border: "1px solid #333",
                    borderRadius: 6,
                    padding: "6px 8px",
                    fontSize: 12,
                    opacity: isSectionLocked("profile") ? 0.6 : 1
                  }
                }
              )
            ]
          },
          field.id
        ))
      }
    )
  ] });
}
const spellCatalogList = [
  aid,
  arcaneBolt,
  rayonDeFeu,
  vagueArdente,
  auraOfPurity,
  beaconOfHope,
  greaterRestoration,
  heroism,
  minorWard,
  rarysTelepathicBond,
  resilientSphere,
  sanctuary,
  sending,
  wardingBond
];
const spellCatalogById = new Map(spellCatalogList.map((spell) => [spell.id, spell]));
const spellCatalog = {
  list: spellCatalogList,
  byId: spellCatalogById
};
function SheetTab(props) {
  const {
    character,
    onChangeCharacter,
    choiceSelections,
    magicSources,
    spellcastingSelections,
    renderValidatedBadge,
    getSectionValidated,
    activeRace,
    getRaceTraits,
    activeBackground,
    getBackgroundFeatureInfo,
    getBackgroundSkillProficiencies,
    getBackgroundToolProficiencies,
    competenceOptions,
    toolMasteryOptions,
    classPrimary,
    classSecondary,
    classEntry,
    secondaryClassEntry,
    selectedSubclassId,
    selectedSecondarySubclassId,
    subclassOptions,
    asiSelections,
    getScore,
    computeMod,
    resolveLevel,
    computeArmorClassFromEquipment: computeArmorClassFromEquipment2,
    computeMaxHp,
    competences,
    expertises,
    skillAbilityMap,
    weaponMasteries,
    unlockedWeaponMasteries,
    unlockedFightingStyles,
    armorMasteries,
    toolMasteries,
    EQUIPMENT_SLOTS,
    materielSlots,
    packSlots,
    packSlotStatus,
    inventoryItems,
    getSlotLabel,
    formatEquipmentLabel
  } = props;
  const [showCharacterJson, setShowCharacterJson] = reactExports.useState(false);
  const featureById = reactExports.useMemo(() => {
    const map = /* @__PURE__ */ new Map();
    loadFeatureTypesFromIndex().forEach((feature) => {
      if (!(feature == null ? void 0 : feature.id)) return;
      map.set(String(feature.id), feature);
    });
    return map;
  }, []);
  const featureLabelById = reactExports.useMemo(() => {
    const map = /* @__PURE__ */ new Map();
    featureById.forEach((feature) => {
      if (!(feature == null ? void 0 : feature.id)) return;
      map.set(String(feature.id), String(feature.label ?? feature.id));
    });
    return map;
  }, [featureById]);
  const actionLabelById = reactExports.useMemo(() => {
    const map = /* @__PURE__ */ new Map();
    loadActionTypesFromIndex().forEach((action2) => {
      if (!(action2 == null ? void 0 : action2.id)) return;
      map.set(String(action2.id), String(action2.name ?? action2.id));
    });
    return map;
  }, []);
  const reactionLabelById = reactExports.useMemo(() => {
    const map = /* @__PURE__ */ new Map();
    loadReactionTypesFromIndex().forEach((reaction) => {
      if (!(reaction == null ? void 0 : reaction.id)) return;
      map.set(String(reaction.id), String(reaction.name ?? reaction.id));
    });
    return map;
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "grid", gridTemplateColumns: "repeat(auto-fit, minmax(240px, 1fr))", gap: 12 }, children: (() => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i;
    const statLabels = {
      FOR: "Force",
      DEX: "Dexterite",
      CON: "Constitution",
      INT: "Intelligence",
      SAG: "Sagesse",
      CHA: "Charisme"
    };
    const getSpellId = (entry) => typeof entry === "string" ? entry : entry.id;
    const getSpellName = (id2) => {
      var _a2;
      return ((_a2 = spellCatalog.byId.get(id2)) == null ? void 0 : _a2.name) ?? id2;
    };
    const getCasterContribution = (progression2, level2) => {
      if (progression2 === "full") return level2;
      if (progression2 === "half") return Math.floor(level2 / 2);
      if (progression2 === "third") return Math.floor(level2 / 3);
      return 0;
    };
    const totalCasterLevel = magicSources.reduce(
      (sum, item) => sum + getCasterContribution(item.casterProgression, item.classLevel),
      0
    );
    const slotsTable = ((_a = magicSources.find((item) => item.slotsByLevel)) == null ? void 0 : _a.slotsByLevel) ?? null;
    const slots = slotsTable ? slotsTable[String(Math.max(0, totalCasterLevel))] ?? [] : [];
    const slotsSummary = slots.length > 0 ? slots.map((count2, idx) => count2 > 0 ? `${idx + 1}: ${count2}` : null).filter(Boolean).join(" | ") : "";
    const backgroundChoices = (choiceSelections == null ? void 0 : choiceSelections.background) ?? {};
    const backgroundTools = Array.isArray(backgroundChoices.tools) ? backgroundChoices.tools : [];
    const backgroundLanguages = Array.isArray(backgroundChoices.languages) ? backgroundChoices.languages : [];
    const derivedGrants = ((_b = character == null ? void 0 : character.derived) == null ? void 0 : _b.grants) ?? {};
    const derivedFeatures = Array.isArray(derivedGrants.features) ? derivedGrants.features : [];
    const derivedActions = Array.isArray(derivedGrants.actions) ? derivedGrants.actions : [];
    const derivedReactions = Array.isArray(derivedGrants.reactions) ? derivedGrants.reactions : [];
    const derivedResources = Array.isArray(derivedGrants.resources) ? derivedGrants.resources : [];
    const derivedPassifs = Array.isArray(derivedGrants.passifs) ? derivedGrants.passifs : [];
    const derivedSpells = Array.isArray(derivedGrants.spells) ? derivedGrants.spells : [];
    const listFeatureActionIds = (featureId) => {
      var _a2;
      const grants2 = ((_a2 = featureById.get(featureId)) == null ? void 0 : _a2.grants) ?? [];
      return grants2.filter((grant) => String((grant == null ? void 0 : grant.kind) ?? "").toLowerCase() === "action").flatMap((grant) => Array.isArray(grant == null ? void 0 : grant.ids) ? grant.ids : []).map((id2) => String(id2)).filter(Boolean);
    };
    const listFeatureReactionIds = (featureId) => {
      var _a2;
      const grants2 = ((_a2 = featureById.get(featureId)) == null ? void 0 : _a2.grants) ?? [];
      return grants2.filter((grant) => String((grant == null ? void 0 : grant.kind) ?? "").toLowerCase() === "reaction").flatMap((grant) => Array.isArray(grant == null ? void 0 : grant.ids) ? grant.ids : []).map((id2) => String(id2)).filter(Boolean);
    };
    const resolveGrantLabel = (kind2, id2) => {
      var _a2;
      if (!id2) return id2;
      const normalized = String(kind2 ?? "").toLowerCase();
      if (normalized === "action" || normalized === "actions") return actionLabelById.get(id2) ?? id2;
      if (normalized === "reaction" || normalized === "reactions") return reactionLabelById.get(id2) ?? id2;
      if (normalized === "feature" || normalized === "features") return featureLabelById.get(id2) ?? id2;
      if (normalized === "spell" || normalized === "spells") return ((_a2 = spellCatalog.byId.get(id2)) == null ? void 0 : _a2.name) ?? id2;
      return id2;
    };
    const getSourceLabel = (value2) => {
      const normalized = String(value2 ?? "").toLowerCase();
      if (normalized === "class") return "Classe";
      if (normalized === "subclass") return "Sous-classe";
      if (normalized === "race") return "Espece";
      if (normalized === "background") return "Historique";
      if (normalized === "feature") return "Feature";
      if (normalized === "item") return "Objet";
      if (normalized === "manual") return "Manuel";
      return value2 || "Source";
    };
    const getUsageLabel = (entry) => {
      const usage2 = entry == null ? void 0 : entry.usage;
      if (!usage2) return null;
      const type2 = String(usage2.type ?? "").toLowerCase();
      if (type2 === "slot") return "slot";
      if (type2 === "at-will") return "a volonte";
      if (type2 === "limited" || type2 === "charge") {
        if (typeof usage2.remainingUses === "number" && typeof usage2.maxUses === "number") {
          return `${usage2.remainingUses}/${usage2.maxUses}`;
        }
        if (typeof usage2.maxUses === "number") return `${usage2.maxUses}`;
        return type2 === "charge" ? "charges" : "limite";
      }
      return type2 || null;
    };
    const expandedDerivedActions = Array.from(
      /* @__PURE__ */ new Set([
        ...derivedActions.map((id2) => String(id2)).filter(Boolean),
        ...derivedFeatures.flatMap((featureId) => listFeatureActionIds(String(featureId)))
      ])
    );
    const expandedDerivedReactions = Array.from(
      /* @__PURE__ */ new Set([
        ...derivedReactions.map((id2) => String(id2)).filter(Boolean),
        ...derivedFeatures.flatMap((featureId) => listFeatureReactionIds(String(featureId)))
      ])
    );
    const adaptableSkill = ((_c = choiceSelections == null ? void 0 : choiceSelections.race) == null ? void 0 : _c.adaptableSkill) ?? "";
    const formatAsiSuffix = (classId2, level2) => {
      const key2 = `${classId2}:${level2}`;
      const asiEntry = asiSelections[key2] ?? (classId2 === (classPrimary == null ? void 0 : classPrimary.id) ? asiSelections[String(level2)] : null);
      if ((asiEntry == null ? void 0 : asiEntry.type) === "feat") {
        return "Don";
      }
      if ((asiEntry == null ? void 0 : asiEntry.type) === "asi") {
        const stats = asiEntry.stats ?? {};
        const parts = Object.entries(stats).map(([stat, value2]) => `+${value2} ${statLabels[stat] ?? stat}`).join(", ");
        return parts || "non choisi";
      }
      return "non choisi";
    };
    const buildProgressionLines = (progression2, maxLevel, sourceLabel, classIdForAsi) => {
      if (!progression2) return [];
      const levels = Object.keys(progression2).map((key2) => Number(key2)).filter((level2) => Number.isFinite(level2) && level2 > 0 && level2 <= maxLevel).sort((a2, b2) => a2 - b2);
      return levels.map((level2) => {
        const entry = progression2[String(level2)] ?? {};
        const grants2 = Array.isArray(entry.grants) ? entry.grants : [];
        const desc = entry.description ? entry.description : "";
        const grantLabels = grants2.map((grant) => {
          const kind2 = String((grant == null ? void 0 : grant.kind) ?? "").toLowerCase();
          const ids = Array.isArray(grant == null ? void 0 : grant.ids) ? grant.ids.map((id2) => String(id2)).filter(Boolean) : [];
          if (!kind2 || ids.length === 0) return "";
          if (kind2 === "bonus" && ids.includes("asi-or-feat") && classIdForAsi) {
            return `ASI/Don (${formatAsiSuffix(classIdForAsi, level2)})`;
          }
          const labelByKind = {
            feature: "Features",
            features: "Features",
            action: "Actions",
            actions: "Actions",
            reaction: "Reactions",
            reactions: "Reactions",
            resource: "Ressources",
            resources: "Ressources",
            passif: "Passifs",
            passifs: "Passifs",
            passive: "Passifs",
            passives: "Passifs",
            spell: "Sorts",
            spells: "Sorts",
            trait: "Traits",
            traits: "Traits",
            skill: "Competences",
            skills: "Competences",
            tool: "Outils",
            tools: "Outils",
            language: "Langues",
            languages: "Langues",
            bonus: "Bonus"
          };
          const resolved = ids.map((id2) => resolveGrantLabel(kind2, id2));
          const kindLabel = labelByKind[kind2] ?? kind2;
          return `${kindLabel}: ${resolved.join(", ")}`;
        }).filter(Boolean);
        const parts = [desc, ...grantLabels].filter(Boolean);
        const summary2 = parts.length > 0 ? parts.join(" | ") : "Aucun gain explicite";
        return `Niveau ${level2}  ${sourceLabel}: ${summary2}`;
      });
    };
    const buildClassProgressionDisplay = (cls, subclass, level2) => {
      if (!cls || level2 <= 0) return [];
      const classLines = buildProgressionLines(
        cls.progression,
        level2,
        `Classe ${cls.label}`,
        cls.id
      );
      const subclassLines = subclass ? buildProgressionLines(
        subclass.progression,
        level2,
        `Sous-classe ${subclass.label}`,
        cls.id
      ) : [];
      return [...classLines, ...subclassLines];
    };
    const primarySubclass = selectedSubclassId ? subclassOptions.find((sub) => sub.id === selectedSubclassId) ?? null : null;
    const secondarySubclass = selectedSecondarySubclassId ? subclassOptions.find((sub) => sub.id === selectedSecondarySubclassId) ?? null : null;
    const primaryLevel = Number(classEntry == null ? void 0 : classEntry.niveau) || 0;
    const secondaryLevel = Number(secondaryClassEntry == null ? void 0 : secondaryClassEntry.niveau) || 0;
    const globalLevel = resolveLevel();
    const primaryProgressionLines = buildClassProgressionDisplay(
      classPrimary,
      primarySubclass,
      primaryLevel
    );
    const secondaryProgressionLines = buildClassProgressionDisplay(
      classSecondary,
      secondarySubclass,
      secondaryLevel
    );
    const raceProgressionLines = activeRace ? buildProgressionLines(
      activeRace == null ? void 0 : activeRace.progression,
      globalLevel,
      `Espece ${activeRace.label}`,
      null
    ) : [];
    const backgroundProgressionLines = activeBackground ? buildProgressionLines(
      activeBackground == null ? void 0 : activeBackground.progression,
      globalLevel,
      `Historique ${activeBackground.label}`,
      null
    ) : [];
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          style: {
            borderRadius: 10,
            border: "1px solid rgba(255,255,255,0.12)",
            background: "rgba(12,12,18,0.75)",
            padding: 12,
            display: "flex",
            flexDirection: "column",
            gap: 8
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 13, fontWeight: 800, display: "flex", alignItems: "center", gap: 8 }, children: [
              "Identite",
              renderValidatedBadge(getSectionValidated("profile"))
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.7)" }, children: [
              "Nom: ",
              ((_d = character == null ? void 0 : character.nom) == null ? void 0 : _d.nomcomplet) ?? ""
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.7)" }, children: [
              "Prenom: ",
              ((_e = character == null ? void 0 : character.nom) == null ? void 0 : _e.prenom) ?? "",
              " | Surnom:",
              " ",
              ((_f = character == null ? void 0 : character.nom) == null ? void 0 : _f.surnom) ?? ""
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.7)" }, children: [
              "Age: ",
              (character == null ? void 0 : character.age) ?? "",
              " | Sexe: ",
              (character == null ? void 0 : character.sexe) ?? ""
            ] })
          ]
        }
      ),
      magicSources.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          style: {
            borderRadius: 10,
            border: "1px solid rgba(255,255,255,0.12)",
            background: "rgba(12,12,18,0.75)",
            padding: 12,
            display: "flex",
            flexDirection: "column",
            gap: 8
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 13, fontWeight: 800, display: "flex", alignItems: "center", gap: 8 }, children: [
              "Magie",
              renderValidatedBadge(getSectionValidated("magic"))
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.6)" }, children: [
              "Emplacements (total): ",
              slotsSummary
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "grid", gap: 10 }, children: magicSources.map((source2) => {
              var _a2, _b2, _c2, _d2;
              const selection = spellcastingSelections[source2.key] ?? {};
              const knownSpells = Array.isArray(selection.knownSpells) ? selection.knownSpells : [];
              const preparedSpells = Array.isArray(selection.preparedSpells) ? selection.preparedSpells : [];
              const grantedSpells = Array.isArray(selection.grantedSpells) ? selection.grantedSpells : [];
              const preparedList = source2.preparation === "prepared" ? preparedSpells : knownSpells;
              const preparedIds = new Set(preparedList.map((spell) => getSpellId(spell)));
              const grantedIds = new Set(grantedSpells.map((spell) => getSpellId(spell)));
              const freePreparedFromGrants = Boolean(source2.freePreparedFromGrants);
              const preparedCount = Array.from(preparedIds).filter(
                (id2) => !(freePreparedFromGrants && grantedIds.has(id2))
              ).length;
              const preparedLimit = source2.preparation === "prepared" ? Math.max(0, source2.classLevel) : null;
              const storageLabel = source2.storage === "memory" ? "Memoire" : source2.storage === "innate" ? "Inne" : "Grimoire";
              const grantedNames = grantedSpells.length > 0 ? grantedSpells.map((spell) => getSpellName(getSpellId(spell))) : source2.spellIds.map((id2) => getSpellName(id2));
              const preparedNames = preparedList.map((spell) => getSpellName(getSpellId(spell)));
              const spellGrantEntries = Array.isArray(
                (_b2 = (_a2 = character == null ? void 0 : character.spellcastingState) == null ? void 0 : _a2.spellGrants) == null ? void 0 : _b2[source2.key]
              ) ? ((_d2 = (_c2 = character == null ? void 0 : character.spellcastingState) == null ? void 0 : _c2.spellGrants) == null ? void 0 : _d2[source2.key]) ?? [] : [];
              const sourceUsageSummary = Array.from(
                new Set(
                  spellGrantEntries.map((entry) => {
                    const sourcePart = `${getSourceLabel(
                      String((entry == null ? void 0 : entry.sourceType) ?? "")
                    )}${(entry == null ? void 0 : entry.sourceId) ? `:${entry.sourceId}` : ""}`;
                    const usagePart = getUsageLabel(entry);
                    return usagePart ? `${sourcePart} (${usagePart})` : sourcePart;
                  }).filter(Boolean)
                )
              );
              return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "div",
                {
                  style: {
                    borderRadius: 8,
                    border: "1px solid rgba(255,255,255,0.12)",
                    background: "rgba(10,10,16,0.8)",
                    padding: "8px 10px",
                    display: "grid",
                    gap: 6
                  },
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, fontWeight: 700, color: "#f5f5f5" }, children: [
                      source2.label,
                      " (niv ",
                      source2.classLevel,
                      ")"
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 11, color: "rgba(255,255,255,0.65)" }, children: [
                      "Methode: ",
                      source2.preparation === "prepared" ? "Prepare" : "Connu",
                      " | Stockage:",
                      " ",
                      storageLabel
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 11, color: "rgba(255,255,255,0.65)" }, children: source2.preparation === "prepared" ? `Sorts prepares: ${preparedCount}${preparedLimit !== null ? ` / ${preparedLimit}` : ""}` : `Sorts connus: ${preparedIds.size}` }),
                    sourceUsageSummary.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 11, color: "rgba(255,255,255,0.6)" }, children: [
                      "Provenance/usage: ",
                      sourceUsageSummary.join(" | ")
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 11, color: "rgba(255,255,255,0.65)" }, children: [
                      "Sorts ",
                      source2.preparation === "prepared" ? "prepares" : "connus",
                      ":",
                      " ",
                      preparedNames.join(", ") || ""
                    ] }),
                    grantedNames.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 11, color: "rgba(255,255,255,0.55)" }, children: [
                      "Sorts imposes: ",
                      grantedNames.join(", ")
                    ] })
                  ]
                },
                `sheet-magic-${source2.key}`
              );
            }) })
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          style: {
            borderRadius: 10,
            border: "1px solid rgba(255,255,255,0.12)",
            background: "rgba(12,12,18,0.75)",
            padding: 12,
            display: "flex",
            flexDirection: "column",
            gap: 8
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 13, fontWeight: 800, display: "flex", alignItems: "center", gap: 8 }, children: [
              "Espece",
              renderValidatedBadge(getSectionValidated("species"))
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.7)" }, children: activeRace ? `${activeRace.label} (${activeRace.id})` : "" }),
            getRaceTraits(activeRace).length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexWrap: "wrap", gap: 6 }, children: getRaceTraits(activeRace).map((trait) => /* @__PURE__ */ jsxRuntimeExports.jsx(
              "span",
              {
                style: {
                  padding: "2px 6px",
                  borderRadius: 999,
                  border: "1px solid rgba(255,255,255,0.18)",
                  background: "rgba(46, 204, 113, 0.12)",
                  fontSize: 11,
                  color: "rgba(255,255,255,0.75)"
                },
                children: trait.label
              },
              `trait-${trait.id}`
            )) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.6)" }, children: [
              "Traits: ",
              getRaceTraits(activeRace).map((trait) => trait.label).join(", ") || ""
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.6)" }, children: [
              "Choix adapte: ",
              adaptableSkill ? ((_g = competenceOptions.find((c2) => c2.id === adaptableSkill)) == null ? void 0 : _g.label) ?? adaptableSkill : ""
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.6)" }, children: [
              "Vitesse: ",
              (activeRace == null ? void 0 : activeRace.speed) ?? "",
              " | Taille: ",
              (activeRace == null ? void 0 : activeRace.size) ?? ""
            ] }),
            raceProgressionLines.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.6)" }, children: [
              "Progression (niveau global ",
              globalLevel,
              "):",
              raceProgressionLines.map((line) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginTop: 4 }, children: line }, `prog-race-${line}`))
            ] })
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          style: {
            borderRadius: 10,
            border: "1px solid rgba(255,255,255,0.12)",
            background: "rgba(12,12,18,0.75)",
            padding: 12,
            display: "flex",
            flexDirection: "column",
            gap: 8
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 13, fontWeight: 800, display: "flex", alignItems: "center", gap: 8 }, children: [
              "Historique",
              renderValidatedBadge(getSectionValidated("backgrounds"))
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.7)" }, children: activeBackground ? `${activeBackground.label} (${activeBackground.id})` : "" }),
            getBackgroundFeatureInfo(activeBackground) && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexWrap: "wrap", gap: 6 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "span",
              {
                style: {
                  padding: "2px 6px",
                  borderRadius: 999,
                  border: "1px solid rgba(255,255,255,0.18)",
                  background: "rgba(241, 196, 15, 0.16)",
                  fontSize: 11,
                  color: "rgba(255,255,255,0.75)"
                },
                children: ((_h = getBackgroundFeatureInfo(activeBackground)) == null ? void 0 : _h.label) ?? "Aptitude"
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.6)" }, children: [
              "Competences:",
              " ",
              getBackgroundSkillProficiencies(activeBackground).map((id2) => {
                var _a2;
                return ((_a2 = competenceOptions.find((c2) => c2.id === id2)) == null ? void 0 : _a2.label) ?? id2;
              }).join(", ") || ""
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.6)" }, children: [
              "Outils:",
              " ",
              getBackgroundToolProficiencies(activeBackground).map((id2) => {
                var _a2;
                return ((_a2 = toolMasteryOptions.find((t2) => t2.id === id2)) == null ? void 0 : _a2.label) ?? id2;
              }).join(", ") || ""
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.6)" }, children: [
              "Choix outils:",
              " ",
              backgroundTools.length ? backgroundTools.map((id2) => {
                var _a2;
                return ((_a2 = toolMasteryOptions.find((t2) => t2.id === id2)) == null ? void 0 : _a2.label) ?? id2;
              }).join(", ") : ""
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.6)" }, children: [
              "Choix langues: ",
              backgroundLanguages.join(", ") || ""
            ] }),
            backgroundProgressionLines.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.6)" }, children: [
              "Progression (niveau global ",
              globalLevel,
              "):",
              backgroundProgressionLines.map((line) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginTop: 4 }, children: line }, `prog-bg-${line}`))
            ] })
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          style: {
            borderRadius: 10,
            border: "1px solid rgba(255,255,255,0.12)",
            background: "rgba(12,12,18,0.75)",
            padding: 12,
            display: "flex",
            flexDirection: "column",
            gap: 8
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 13, fontWeight: 800, display: "flex", alignItems: "center", gap: 8 }, children: [
              "Classes",
              renderValidatedBadge(getSectionValidated("classes"))
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.7)" }, children: [
              "Classe principale:",
              " ",
              classPrimary ? `${classPrimary.label}${primarySubclass ? `  ${primarySubclass.label}` : ""} (niv ${primaryLevel})` : ""
            ] }),
            primaryProgressionLines.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.6)" }, children: [
              "Progression:",
              primaryProgressionLines.map((line) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginTop: 4 }, children: line }, `prog-primary-${line}`))
            ] }),
            classSecondary && secondaryLevel > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.7)" }, children: [
                "Classe secondaire:",
                " ",
                classSecondary ? `${classSecondary.label}${secondarySubclass ? `  ${secondarySubclass.label}` : ""} (niv ${secondaryLevel})` : ""
              ] }),
              secondaryProgressionLines.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.6)" }, children: [
                "Progression:",
                secondaryProgressionLines.map((line) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginTop: 4 }, children: line }, `prog-secondary-${line}`))
              ] })
            ] })
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          style: {
            borderRadius: 10,
            border: "1px solid rgba(255,255,255,0.12)",
            background: "rgba(12,12,18,0.75)",
            padding: 12,
            display: "flex",
            flexDirection: "column",
            gap: 8
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 13, fontWeight: 800 }, children: "Projection derivee" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.65)" }, children: [
              "Features:",
              " ",
              derivedFeatures.map((id2) => featureLabelById.get(String(id2)) ?? id2).join(", ") || "-"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.65)" }, children: [
              "Actions derivees (directes):",
              " ",
              derivedActions.map((id2) => actionLabelById.get(String(id2)) ?? id2).join(", ") || "-"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.65)" }, children: [
              "Actions effectives (avec features):",
              " ",
              expandedDerivedActions.map((id2) => actionLabelById.get(String(id2)) ?? id2).join(", ") || "-"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.65)" }, children: [
              "Reactions derivees (directes):",
              " ",
              derivedReactions.map((id2) => reactionLabelById.get(String(id2)) ?? id2).join(", ") || "-"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.65)" }, children: [
              "Reactions effectives (avec features):",
              " ",
              expandedDerivedReactions.map((id2) => reactionLabelById.get(String(id2)) ?? id2).join(", ") || "-"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.65)" }, children: [
              "Ressources derivees: ",
              derivedResources.join(", ") || "-"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.65)" }, children: [
              "Passifs derives: ",
              derivedPassifs.join(", ") || "-"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.65)" }, children: [
              "Sorts derives: ",
              derivedSpells.join(", ") || "-"
            ] })
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          style: {
            borderRadius: 10,
            border: "1px solid rgba(255,255,255,0.12)",
            background: "rgba(12,12,18,0.75)",
            padding: 12,
            display: "flex",
            flexDirection: "column",
            gap: 8
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 13, fontWeight: 800, display: "flex", alignItems: "center", gap: 8 }, children: [
              "Caracteristiques",
              renderValidatedBadge(getSectionValidated("stats"))
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                style: {
                  display: "grid",
                  gridTemplateColumns: "repeat(2, minmax(140px, 1fr))",
                  gap: 8
                },
                children: [
                  { id: "FOR", label: "Force" },
                  { id: "DEX", label: "Dexterite" },
                  { id: "CON", label: "Constitution" },
                  { id: "INT", label: "Intelligence" },
                  { id: "SAG", label: "Sagesse" },
                  { id: "CHA", label: "Charisme" }
                ].map((stat) => {
                  const value2 = getScore(stat.id);
                  const mod = computeMod(value2);
                  const modLabel = mod >= 0 ? `+${mod}` : `${mod}`;
                  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    "div",
                    {
                      style: {
                        borderRadius: 8,
                        border: "1px solid rgba(255,255,255,0.12)",
                        background: "rgba(10,10,16,0.8)",
                        padding: "6px 8px",
                        display: "flex",
                        justifyContent: "space-between",
                        alignItems: "center",
                        gap: 8
                      },
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: 12, color: "rgba(255,255,255,0.7)" }, children: stat.label }),
                        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { style: { fontSize: 12, color: "rgba(255,255,255,0.85)", fontWeight: 700 }, children: [
                          value2,
                          " ",
                          modLabel
                        ] })
                      ]
                    },
                    `stat-sheet-${stat.id}`
                  );
                })
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "div",
              {
                style: {
                  display: "grid",
                  gridTemplateColumns: "repeat(auto-fit, minmax(160px, 1fr))",
                  gap: 8
                },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    "div",
                    {
                      style: {
                        fontSize: 13,
                        fontWeight: 800,
                        color: "#cfe4ff",
                        background: "rgba(79,125,242,0.18)",
                        border: "1px solid rgba(79,125,242,0.5)",
                        borderRadius: 8,
                        padding: "6px 8px"
                      },
                      children: [
                        "CA (dynamique): ",
                        computeArmorClassFromEquipment2()
                      ]
                    }
                  ),
                  Boolean(choiceSelections == null ? void 0 : choiceSelections.sheetValidated) && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      "div",
                      {
                        style: {
                          fontSize: 13,
                          fontWeight: 800,
                          color: "#ffe9a6",
                          background: "rgba(241,196,15,0.16)",
                          border: "1px solid rgba(241,196,15,0.5)",
                          borderRadius: 8,
                          padding: "6px 8px"
                        },
                        children: [
                          "PV max: ",
                          ((_i = character == null ? void 0 : character.combatStats) == null ? void 0 : _i.maxHp) ?? ""
                        ]
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.6)" }, children: [
                      "Des de vie: ",
                      (classPrimary == null ? void 0 : classPrimary.hitDie) ? `d${classPrimary.hitDie} x${Number(classEntry == null ? void 0 : classEntry.niveau) || 0}` : "",
                      (classSecondary == null ? void 0 : classSecondary.hitDie) && Number(secondaryClassEntry == null ? void 0 : secondaryClassEntry.niveau) ? ` + d${classSecondary.hitDie} x${Number(secondaryClassEntry == null ? void 0 : secondaryClassEntry.niveau) || 0}` : ""
                    ] })
                  ] })
                ]
              }
            )
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          style: {
            borderRadius: 10,
            border: "1px solid rgba(255,255,255,0.12)",
            background: "rgba(12,12,18,0.75)",
            padding: 12,
            display: "flex",
            flexDirection: "column",
            gap: 8
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 13, fontWeight: 800, display: "flex", alignItems: "center", gap: 8 }, children: [
              "Competences",
              renderValidatedBadge(getSectionValidated("skills"))
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "div",
              {
                style: {
                  fontSize: 18,
                  fontWeight: 800,
                  color: "#4f7df2",
                  textAlign: "center"
                },
                children: [
                  "Bonus de maitrise: ",
                  (() => {
                    const level2 = resolveLevel();
                    const prof = 2 + Math.floor((level2 - 1) / 4);
                    return prof >= 0 ? `+${prof}` : prof;
                  })()
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.7)" }, children: (() => {
              const merged = Array.from(
                /* @__PURE__ */ new Set([...competences ?? [], ...expertises ?? []])
              );
              if (merged.length === 0) return "";
              return merged.map((id2) => {
                var _a2;
                const label2 = ((_a2 = competenceOptions.find((c2) => c2.id === id2)) == null ? void 0 : _a2.label) ?? id2;
                const abilityKey = skillAbilityMap[id2];
                const scoreKey = abilityKey === "STR" ? "FOR" : abilityKey === "DEX" ? "DEX" : abilityKey === "CON" ? "CON" : abilityKey === "INT" ? "INT" : abilityKey === "WIS" ? "SAG" : "CHA";
                const mod = computeMod(getScore(scoreKey));
                const level2 = resolveLevel();
                const prof = 2 + Math.floor((level2 - 1) / 4);
                const isExpert = expertises.includes(id2);
                const isProf = competences.includes(id2);
                const bonus = mod + (isExpert ? prof * 2 : isProf ? prof : 0);
                const bonusLabel = bonus >= 0 ? `+${bonus}` : bonus;
                const suffix = isExpert ? " (Expertise)" : "";
                return `${label2}${suffix}: ${bonusLabel}`;
              }).join(", ");
            })() })
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          style: {
            borderRadius: 10,
            border: "1px solid rgba(255,255,255,0.12)",
            background: "rgba(12,12,18,0.75)",
            padding: 12,
            display: "flex",
            flexDirection: "column",
            gap: 8
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 13, fontWeight: 800, display: "flex", alignItems: "center", gap: 8 }, children: [
              "Maitrises",
              renderValidatedBadge(getSectionValidated("masteries"))
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.7)" }, children: [
              "Armes: ",
              weaponMasteries.join(", ") || ""
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.7)" }, children: [
              "Bottes d'armes:",
              " ",
              unlockedWeaponMasteries.map((entry) => entry.label).join(", ") || ""
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.7)" }, children: [
              "Styles de combat:",
              " ",
              unlockedFightingStyles.map((entry) => entry.label).join(", ") || ""
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.7)" }, children: [
              "Armures: ",
              armorMasteries.join(", ") || ""
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.6)" }, children: [
              "Outils: ",
              toolMasteries.join(", ") || ""
            ] })
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          style: {
            borderRadius: 10,
            border: "1px solid rgba(255,255,255,0.12)",
            background: "rgba(12,12,18,0.75)",
            padding: 12,
            display: "flex",
            flexDirection: "column",
            gap: 8
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 13, fontWeight: 800, display: "flex", alignItems: "center", gap: 8 }, children: [
              "Materiel",
              renderValidatedBadge(getSectionValidated("equip"))
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.6)" }, children: EQUIPMENT_SLOTS.filter((slot) => Boolean(materielSlots[slot.id])).length > 0 ? EQUIPMENT_SLOTS.filter((slot) => Boolean(materielSlots[slot.id])).map((slot) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginTop: 4 }, children: [
              slot.label,
              ": ",
              formatEquipmentLabel(String(materielSlots[slot.id]))
            ] }, `slot-${slot.id}`)) : "" }),
            (() => {
              const packEntries = Array.from(packSlots).map((slotId) => {
                const status = packSlotStatus(slotId);
                if (!status.bagId) return null;
                const bagContents = inventoryItems.filter((item) => {
                  const inSlot = (item == null ? void 0 : item.storedIn) === slotId || slotId === "paquetage" && status.bagId && (item == null ? void 0 : item.storedIn) === status.bagId;
                  return inSlot;
                });
                return {
                  slotId,
                  status,
                  contents: bagContents,
                  label: getSlotLabel(slotId)
                };
              }).filter(Boolean);
              if (packEntries.length === 0) return null;
              return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "div",
                {
                  style: {
                    marginTop: 6,
                    padding: 8,
                    borderRadius: 8,
                    border: "1px solid rgba(255,255,255,0.12)",
                    background: "rgba(10,10,16,0.7)",
                    display: "flex",
                    flexDirection: "column",
                    gap: 8
                  },
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, fontWeight: 800 }, children: "Sacs" }),
                    packEntries.map((entry) => {
                      const capacityLabel = entry.status.capacity > 0 ? entry.status.capacity.toFixed(1) : "?";
                      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "grid", gap: 4 }, children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsxs(
                          "div",
                          {
                            style: { fontSize: 12, color: "rgba(255,255,255,0.7)" },
                            children: [
                              entry.label,
                              ": ",
                              formatEquipmentLabel(entry.status.bagId ?? "")
                            ]
                          }
                        ),
                        /* @__PURE__ */ jsxRuntimeExports.jsxs(
                          "div",
                          {
                            style: { fontSize: 12, color: "rgba(255,255,255,0.6)" },
                            children: [
                              "Capacite: ",
                              entry.status.storedWeight.toFixed(1),
                              " /",
                              " ",
                              capacityLabel
                            ]
                          }
                        ),
                        /* @__PURE__ */ jsxRuntimeExports.jsxs(
                          "div",
                          {
                            style: { fontSize: 12, color: "rgba(255,255,255,0.6)" },
                            children: [
                              "Contenu:",
                              entry.contents.length > 0 ? entry.contents.map((item) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
                                "div",
                                {
                                  style: { marginTop: 4 },
                                  children: [
                                    formatEquipmentLabel(item.id),
                                    " x",
                                    item.qty ?? 1
                                  ]
                                },
                                `bag-${entry.slotId}-${item.id}`
                              )) : " "
                            ]
                          }
                        )
                      ] }, `bag-${entry.slotId}`);
                    })
                  ]
                }
              );
            })()
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          style: {
            borderRadius: 10,
            border: "1px solid rgba(255,255,255,0.12)",
            background: "rgba(12,12,18,0.75)",
            padding: 12,
            display: "flex",
            flexDirection: "column",
            gap: 8
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 13, fontWeight: 800 }, children: "Validation fiche" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.6)" }, children: "PV calcules avec les des de vie et le mod CON." }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "button",
                onClick: () => {
                  const maxHp = computeMaxHp();
                  const nextCombatStats = {
                    ...character.combatStats ?? {},
                    maxHp,
                    level: resolveLevel()
                  };
                  const nextChoiceSelections = {
                    ...choiceSelections,
                    sheetValidated: true
                  };
                  onChangeCharacter({
                    ...character,
                    pvActuels: maxHp,
                    combatStats: nextCombatStats,
                    choiceSelections: nextChoiceSelections
                  });
                },
                disabled: ![
                  "species",
                  "backgrounds",
                  "classes",
                  "stats",
                  "skills",
                  "masteries",
                  "equip",
                  "profile",
                  ...magicSources.length > 0 ? ["magic"] : []
                ].every((section) => getSectionValidated(section)),
                style: {
                  padding: "8px 12px",
                  borderRadius: 8,
                  border: "1px solid rgba(255,255,255,0.15)",
                  background: "rgba(46, 204, 113, 0.16)",
                  color: "#f5f5f5",
                  cursor: "pointer",
                  fontSize: 12,
                  fontWeight: 800,
                  opacity: [
                    "species",
                    "backgrounds",
                    "classes",
                    "stats",
                    "skills",
                    "masteries",
                    "equip",
                    "profile",
                    ...magicSources.length > 0 ? ["magic"] : []
                  ].every((section) => getSectionValidated(section)) ? 1 : 0.5
                },
                children: "Valider la fiche complete"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "button",
                onClick: () => setShowCharacterJson((prev) => !prev),
                style: {
                  padding: "6px 10px",
                  borderRadius: 8,
                  border: "1px solid rgba(255,255,255,0.15)",
                  background: "rgba(255,255,255,0.08)",
                  color: "#f5f5f5",
                  cursor: "pointer",
                  fontSize: 12,
                  fontWeight: 700
                },
                children: showCharacterJson ? "Masquer le JSON" : "Afficher le JSON"
              }
            ),
            showCharacterJson && /* @__PURE__ */ jsxRuntimeExports.jsx(
              "pre",
              {
                style: {
                  margin: 0,
                  maxHeight: 280,
                  overflow: "auto",
                  whiteSpace: "pre-wrap",
                  wordBreak: "break-word",
                  fontSize: 11,
                  color: "rgba(255,255,255,0.8)",
                  background: "#0f0f19",
                  border: "1px solid rgba(255,255,255,0.12)",
                  borderRadius: 8,
                  padding: 8
                },
                children: JSON.stringify({ ...character, choiceSelections }, null, 2)
              }
            )
          ]
        }
      )
    ] });
  })() }) });
}
function MagicTab(props) {
  const {
    magicSources,
    activeMagicTab,
    setActiveMagicTab,
    isSectionLocked,
    toggleSectionLock,
    lockButtonBaseStyle,
    getLockButtonState,
    spellcastingSelections,
    spellGrantsBySource,
    updateSpellcastingSelection,
    computeMod,
    getScore,
    resolveLevel,
    getCasterContribution,
    resolveItemTags,
    inventoryItems,
    formatEquipmentLabel,
    getSpellId,
    makeSpellEntry
  } = props;
  const magicLocked = isSectionLocked("magic");
  const getSourceLabel = (value2) => {
    const normalized = String(value2 ?? "").toLowerCase();
    if (normalized === "class") return "Classe";
    if (normalized === "subclass") return "Sous-classe";
    if (normalized === "race") return "Espece";
    if (normalized === "background") return "Historique";
    if (normalized === "feature") return "Feature";
    if (normalized === "item") return "Objet";
    if (normalized === "manual") return "Manuel";
    return value2 || "Source";
  };
  const getUsageLabel = (entry) => {
    const usage2 = entry == null ? void 0 : entry.usage;
    if (!usage2) return null;
    const type2 = String(usage2.type ?? "").toLowerCase();
    if (type2 === "slot") return "slot";
    if (type2 === "at-will") return "a volonte";
    if (type2 === "limited") {
      if (typeof usage2.remainingUses === "number" && typeof usage2.maxUses === "number") {
        return `${usage2.remainingUses}/${usage2.maxUses}`;
      }
      if (typeof usage2.maxUses === "number") return `${usage2.maxUses}/repos`;
      return "usage limite";
    }
    if (type2 === "charge") {
      if (typeof usage2.remainingUses === "number" && typeof usage2.maxUses === "number") {
        return `charges ${usage2.remainingUses}/${usage2.maxUses}`;
      }
      if (typeof usage2.maxUses === "number") return `charges ${usage2.maxUses}`;
      return "charges";
    }
    return type2 || null;
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: 8 }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, color: "#b0b8c4" }, children: "Gestion de la magie selon les sources verrouillees." }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          type: "button",
          onClick: () => toggleSectionLock("magic"),
          style: {
            ...lockButtonBaseStyle,
            marginLeft: "auto",
            background: getLockButtonState("magic").background
          },
          children: getLockButtonState("magic").label
        }
      )
    ] }),
    magicSources.length > 1 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", gap: 8, flexWrap: "wrap" }, children: magicSources.map((source2, idx) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        type: "button",
        onClick: () => setActiveMagicTab(idx),
        disabled: magicLocked,
        style: {
          padding: "6px 10px",
          borderRadius: 6,
          border: `1px solid ${idx === activeMagicTab ? "#8e44ad" : "rgba(255,255,255,0.12)"}`,
          background: idx === activeMagicTab ? "rgba(142, 68, 173, 0.2)" : "#0f0f19",
          color: "#c9cfdd",
          cursor: magicLocked ? "not-allowed" : "pointer",
          fontSize: 12,
          fontWeight: 700,
          opacity: magicLocked ? 0.6 : 1
        },
        children: source2.label
      },
      `magic-tab-${source2.key}`
    )) }),
    (() => {
      var _a, _b;
      const source2 = magicSources[activeMagicTab] ?? magicSources[0];
      if (!source2) return null;
      const selection = spellcastingSelections[source2.key] ?? {};
      const knownSpells = Array.isArray(selection.knownSpells) ? selection.knownSpells : [];
      const preparedSpells = Array.isArray(selection.preparedSpells) ? selection.preparedSpells : [];
      const grantedSpells = Array.isArray(selection.grantedSpells) ? selection.grantedSpells : [];
      const legacyFocusItemId = selection.focusItemId ?? "";
      const focusInstanceId = selection.focusInstanceId ?? (legacyFocusItemId ? ((_a = inventoryItems.find((item) => (item == null ? void 0 : item.id) === legacyFocusItemId)) == null ? void 0 : _a.instanceId) ?? "" : "");
      const storage2 = source2.storage ?? selection.storage ?? "memory";
      const grimoireItemId = selection.grimoireItemId ?? "";
      const totalCasterLevel = magicSources.reduce(
        (sum, item) => sum + getCasterContribution(item.casterProgression, item.classLevel),
        0
      );
      const slotsTable = ((_b = magicSources.find((item) => item.slotsByLevel)) == null ? void 0 : _b.slotsByLevel) ?? null;
      const slots = slotsTable ? slotsTable[String(Math.max(0, totalCasterLevel))] ?? [] : [];
      const maxSpellLevel = slots.reduce((max, count2, idx) => count2 > 0 ? idx + 1 : max, 0);
      const dc = 8 + computeMod(getScore(source2.ability)) + (2 + Math.floor((resolveLevel() - 1) / 4));
      const spellAttack = computeMod(getScore(source2.ability)) + (2 + Math.floor((resolveLevel() - 1) / 4));
      const focusTypes = Array.isArray(source2.focusTypes) ? source2.focusTypes : [];
      const focusOptions = inventoryItems.filter((item) => {
        if (!(item == null ? void 0 : item.instanceId)) return false;
        if (!(item == null ? void 0 : item.equippedSlot)) return false;
        if (focusTypes.length === 0) return true;
        const tags2 = resolveItemTags(item.id);
        return focusTypes.some((tag) => tags2.includes(tag));
      });
      const storageLabel = storage2 === "memory" ? "Memoire" : storage2 === "innate" ? "Inne" : "Grimoire";
      const preparedList = source2.preparation === "prepared" ? preparedSpells : knownSpells;
      const preparedIds = new Set(preparedList.map((spell) => getSpellId(spell)));
      const grantedIds = new Set(grantedSpells.map((spell) => getSpellId(spell)));
      const spellFilterTags = Array.isArray(source2.spellFilterTags) ? source2.spellFilterTags.map((tag) => String(tag).toLowerCase()) : [];
      const availableSpells = spellCatalog.list.filter((spell) => {
        if (spellFilterTags.length === 0) return true;
        const tags2 = Array.isArray(spell.tags) ? spell.tags.map((tag) => String(tag).toLowerCase()) : [];
        return spellFilterTags.some((tag) => tags2.includes(tag));
      }).filter((spell) => {
        if (preparedIds.has(spell.id) || grantedIds.has(spell.id)) return true;
        if (typeof spell.level !== "number") return true;
        return spell.level <= maxSpellLevel;
      }).sort((a2, b2) => {
        const levelA = typeof a2.level === "number" ? a2.level : 0;
        const levelB = typeof b2.level === "number" ? b2.level : 0;
        if (levelA !== levelB) return levelA - levelB;
        return (a2.name || "").localeCompare(b2.name || "");
      });
      const freePreparedFromGrants = Boolean(source2.freePreparedFromGrants);
      const preparedCount = Array.from(preparedIds).filter(
        (id2) => !(freePreparedFromGrants && grantedIds.has(id2))
      ).length;
      const preparedLimit = source2.preparation === "prepared" ? Math.max(0, source2.classLevel) : null;
      const canPrepareMore = preparedLimit === null ? true : preparedCount < preparedLimit;
      const canEditMagic = !magicLocked;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          style: {
            borderRadius: 10,
            border: "1px solid rgba(255,255,255,0.12)",
            background: "rgba(12,12,18,0.75)",
            padding: 12,
            display: "flex",
            flexDirection: "column",
            gap: 10
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", flexWrap: "wrap", gap: 12 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.7)" }, children: [
                "Carac principale: ",
                source2.ability
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.7)" }, children: [
                "Methode: ",
                source2.preparation === "prepared" ? "Prepare" : "Connu"
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.7)" }, children: [
                "Niveau lanceur total: ",
                totalCasterLevel
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.7)" }, children: [
                "DD sort: ",
                dc,
                " | Attaque magique: ",
                spellAttack >= 0 ? `+${spellAttack}` : spellAttack
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.6)" }, children: "Emplacements (total)" }),
            slots.length > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                style: {
                  display: "grid",
                  gridTemplateColumns: "repeat(auto-fit, minmax(140px, 1fr))",
                  gap: 8
                },
                children: slots.map((count2, idx) => {
                  if (count2 <= 0) return null;
                  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    "div",
                    {
                      style: {
                        borderRadius: 8,
                        border: "1px solid rgba(255,255,255,0.12)",
                        padding: "6px 8px",
                        background: "rgba(15,15,25,0.6)"
                      },
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 11, color: "rgba(255,255,255,0.7)" }, children: [
                          "Niveau ",
                          idx + 1
                        ] }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexWrap: "wrap", gap: 4, marginTop: 6 }, children: Array.from({ length: count2 }).map((_, slotIdx) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                          "span",
                          {
                            style: {
                              width: 14,
                              height: 14,
                              borderRadius: 3,
                              border: "1px solid rgba(255,255,255,0.35)",
                              background: "rgba(255,255,255,0.08)",
                              display: "inline-block"
                            }
                          },
                          `slot-${source2.key}-${idx}-${slotIdx}`
                        )) })
                      ]
                    },
                    `slots-${source2.key}-${idx}`
                  );
                })
              }
            ) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.5)" }, children: "" }),
            (source2.spellIds.length > 0 || grantedSpells.length > 0) && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.6)" }, children: [
              "Sorts de progression:",
              " ",
              (grantedSpells.length > 0 ? grantedSpells.map((spell) => {
                var _a2;
                const id2 = getSpellId(spell);
                return ((_a2 = spellCatalog.byId.get(id2)) == null ? void 0 : _a2.name) ?? id2;
              }) : source2.spellIds.map((id2) => {
                var _a2;
                return ((_a2 = spellCatalog.byId.get(id2)) == null ? void 0 : _a2.name) ?? id2;
              })).join(", ")
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "div",
              {
                style: {
                  display: "grid",
                  gridTemplateColumns: "repeat(auto-fit, minmax(220px, 1fr))",
                  gap: 12
                },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.7)", marginBottom: 6 }, children: storage2 === "memory" ? "Sorts memorises" : source2.preparation === "prepared" ? "Sorts prepares" : "Sorts connus" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      "div",
                      {
                        style: {
                          display: "flex",
                          justifyContent: "space-between",
                          alignItems: "center",
                          gap: 8,
                          marginBottom: 6
                        },
                        children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 11, color: "rgba(255,255,255,0.65)" }, children: source2.preparation === "prepared" ? `Preparation: ${preparedCount}${preparedLimit !== null ? ` / ${preparedLimit}` : ""}` : `Connus: ${preparedIds.size}` }),
                          grantedSpells.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 11, color: "rgba(255,255,255,0.55)" }, children: [
                            "Sorts imposes: ",
                            grantedSpells.length
                          ] })
                        ]
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "div",
                      {
                        style: {
                          display: "grid",
                          gridTemplateColumns: "repeat(auto-fit, minmax(220px, 1fr))",
                          gap: 8
                        },
                        children: availableSpells.map((spell) => {
                          const spellId = spell.id;
                          const isGranted = grantedIds.has(spellId);
                          const isPrepared = preparedIds.has(spellId) || isGranted;
                          const canToggle = !isGranted && (isPrepared || canPrepareMore);
                          const stateSourceEntries = Array.isArray(spellGrantsBySource == null ? void 0 : spellGrantsBySource[source2.key]) ? (spellGrantsBySource == null ? void 0 : spellGrantsBySource[source2.key]) ?? [] : [];
                          const stateEntry = stateSourceEntries.find((entry) => (entry == null ? void 0 : entry.spellId) === spellId) ?? null;
                          const originEntries = [
                            ...preparedSpells,
                            ...knownSpells,
                            ...grantedSpells
                          ].filter((entry) => {
                            return typeof entry !== "string" && getSpellId(entry) === spellId;
                          }).map((entry) => entry.origin).filter(Boolean);
                          const fallbackSourceText = originEntries.length > 0 ? originEntries.map((origin) => {
                            const sourceType = getSourceLabel(String((origin == null ? void 0 : origin.kind) ?? ""));
                            const sourceId = (origin == null ? void 0 : origin.id) ? String(origin.id) : "";
                            return sourceId ? `${sourceType}:${sourceId}` : sourceType;
                          }).join(", ") : getSourceLabel(source2.key.split(":")[0] ?? "");
                          const sourceBadgeText = stateEntry ? `${getSourceLabel(String(stateEntry.sourceType ?? ""))}${stateEntry.sourceId ? `:${stateEntry.sourceId}` : ""}` : fallbackSourceText;
                          const usageBadgeText = getUsageLabel(stateEntry);
                          const levelLabel = spell.level === 0 ? "Cantrip" : `Niv ${spell.level}`;
                          const components2 = spell.components ?? {};
                          const componentLabel = [
                            components2.verbal ? "V" : null,
                            components2.somatic ? "S" : null,
                            components2.material ? "M" : null
                          ].filter(Boolean).join("/");
                          return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                            "div",
                            {
                              style: {
                                borderRadius: 8,
                                border: "1px solid rgba(255,255,255,0.12)",
                                background: "rgba(12,12,18,0.7)",
                                padding: "8px 10px",
                                display: "flex",
                                flexDirection: "column",
                                gap: 6
                              },
                              children: [
                                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", justifyContent: "space-between", gap: 8 }, children: [
                                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, fontWeight: 700, color: "#f5f5f5" }, children: spell.name || spell.id }),
                                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: 6, flexWrap: "wrap", justifyContent: "flex-end" }, children: [
                                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                                      "span",
                                      {
                                        style: {
                                          fontSize: 10,
                                          padding: "2px 6px",
                                          borderRadius: 999,
                                          background: "rgba(255,255,255,0.12)",
                                          color: "rgba(255,255,255,0.7)"
                                        },
                                        children: levelLabel
                                      }
                                    ),
                                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                                      "span",
                                      {
                                        style: {
                                          fontSize: 10,
                                          padding: "2px 6px",
                                          borderRadius: 999,
                                          background: "rgba(255,255,255,0.12)",
                                          color: "rgba(255,255,255,0.7)"
                                        },
                                        children: spell.school
                                      }
                                    ),
                                    spell.category && /* @__PURE__ */ jsxRuntimeExports.jsx(
                                      "span",
                                      {
                                        style: {
                                          fontSize: 10,
                                          padding: "2px 6px",
                                          borderRadius: 999,
                                          background: "rgba(255,255,255,0.12)",
                                          color: "rgba(255,255,255,0.7)"
                                        },
                                        children: spell.category
                                      }
                                    ),
                                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                                      "span",
                                      {
                                        style: {
                                          fontSize: 10,
                                          padding: "2px 6px",
                                          borderRadius: 999,
                                          background: "rgba(52, 152, 219, 0.2)",
                                          color: "rgba(255,255,255,0.85)",
                                          border: "1px solid rgba(52,152,219,0.45)"
                                        },
                                        children: sourceBadgeText
                                      }
                                    ),
                                    usageBadgeText && /* @__PURE__ */ jsxRuntimeExports.jsx(
                                      "span",
                                      {
                                        style: {
                                          fontSize: 10,
                                          padding: "2px 6px",
                                          borderRadius: 999,
                                          background: "rgba(241, 196, 15, 0.16)",
                                          color: "rgba(255,255,255,0.85)",
                                          border: "1px solid rgba(241,196,15,0.45)"
                                        },
                                        children: usageBadgeText
                                      }
                                    )
                                  ] })
                                ] }),
                                spell.summary && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 11, color: "rgba(255,255,255,0.65)" }, children: spell.summary }),
                                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", justifyContent: "space-between", gap: 8 }, children: [
                                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 10, color: "rgba(255,255,255,0.55)" }, children: isGranted ? "Impose" : isPrepared ? "Prepare" : "Disponible" }),
                                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 10, color: "rgba(255,255,255,0.55)" }, children: componentLabel ? `Composantes: ${componentLabel}` : "Composantes: " }),
                                  !isGranted && /* @__PURE__ */ jsxRuntimeExports.jsx(
                                    "button",
                                    {
                                      type: "button",
                                      onClick: () => {
                                        const list = source2.preparation === "prepared" ? preparedSpells : knownSpells;
                                        if (isPrepared) {
                                          const next2 = list.filter((item) => getSpellId(item) !== spellId);
                                          if (source2.preparation === "prepared") {
                                            updateSpellcastingSelection(source2.key, { preparedSpells: next2 });
                                          } else {
                                            updateSpellcastingSelection(source2.key, { knownSpells: next2 });
                                          }
                                          return;
                                        }
                                        if (!canPrepareMore) return;
                                        const next = [
                                          ...list,
                                          makeSpellEntry(spellId, { kind: "manual", sourceKey: source2.key })
                                        ];
                                        if (source2.preparation === "prepared") {
                                          updateSpellcastingSelection(source2.key, { preparedSpells: next });
                                        } else {
                                          updateSpellcastingSelection(source2.key, { knownSpells: next });
                                        }
                                      },
                                      disabled: !canToggle || !canEditMagic,
                                      style: {
                                        padding: "4px 8px",
                                        borderRadius: 6,
                                        border: "1px solid rgba(255,255,255,0.18)",
                                        background: isPrepared ? "rgba(231, 76, 60, 0.2)" : "rgba(46, 204, 113, 0.18)",
                                        color: "#f5f5f5",
                                        cursor: canToggle && canEditMagic ? "pointer" : "not-allowed",
                                        fontSize: 11,
                                        fontWeight: 700,
                                        opacity: canToggle && canEditMagic ? 1 : 0.5
                                      },
                                      children: isPrepared ? "Retirer" : "Preparer"
                                    }
                                  )
                                ] })
                              ]
                            },
                            `spell-card-${source2.key}-${spellId}`
                          );
                        })
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.7)", marginBottom: 6 }, children: "Focalisateur" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      "select",
                      {
                        value: focusInstanceId,
                        onChange: (e2) => updateSpellcastingSelection(source2.key, {
                          focusInstanceId: e2.target.value || null
                        }),
                        disabled: magicLocked,
                        style: {
                          width: "100%",
                          background: "#0f0f19",
                          color: "#f5f5f5",
                          border: "1px solid #333",
                          borderRadius: 6,
                          padding: "6px 8px",
                          fontSize: 12,
                          opacity: magicLocked ? 0.6 : 1
                        },
                        children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "", children: "Aucun" }),
                          focusOptions.map((item) => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: item.instanceId, children: formatEquipmentLabel(item.id) }, `focus-${item.instanceId}`))
                        ]
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.7)", marginTop: 10 }, children: [
                      "Stockage des sorts: ",
                      storageLabel
                    ] }),
                    storage2 === "grimoire" && /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      "select",
                      {
                        value: grimoireItemId,
                        onChange: (e2) => updateSpellcastingSelection(source2.key, {
                          grimoireItemId: e2.target.value || null
                        }),
                        disabled: magicLocked,
                        style: {
                          width: "100%",
                          background: "#0f0f19",
                          color: "#f5f5f5",
                          border: "1px solid #333",
                          borderRadius: 6,
                          padding: "6px 8px",
                          fontSize: 12,
                          marginTop: 6,
                          opacity: magicLocked ? 0.6 : 1
                        },
                        children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "", children: "Choisir un grimoire" }),
                          inventoryItems.filter((item) => item.type === "object").map((item) => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: item.id, children: formatEquipmentLabel(item.id) }, `grimoire-${item.id}`))
                        ]
                      }
                    )
                  ] })
                ]
              }
            )
          ]
        }
      );
    })()
  ] });
}
function MagicPanel(props) {
  const {
    magicSources,
    activeMagicTab,
    setActiveMagicTab,
    isSectionLocked,
    toggleSectionLock,
    lockButtonBaseStyle,
    getLockButtonState,
    spellcastingSelections,
    spellGrantsBySource,
    updateSpellcastingSelection,
    computeMod,
    getScore,
    resolveLevel,
    getCasterContribution,
    resolveItemTags,
    inventoryItems,
    formatEquipmentLabel,
    getSpellId,
    makeSpellEntry
  } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    MagicTab,
    {
      magicSources,
      activeMagicTab,
      setActiveMagicTab,
      isSectionLocked,
      toggleSectionLock,
      lockButtonBaseStyle,
      getLockButtonState,
      spellcastingSelections,
      spellGrantsBySource,
      updateSpellcastingSelection,
      computeMod,
      getScore,
      resolveLevel,
      getCasterContribution,
      resolveItemTags,
      inventoryItems,
      formatEquipmentLabel,
      getSpellId,
      makeSpellEntry
    }
  );
}
const WEAPON_PROFICIENCY_OPTIONS = [
  { id: "simple", label: "Simple" },
  { id: "martiale", label: "Martiale" },
  { id: "speciale", label: "Speciale" },
  { id: "monastique", label: "Monastique" }
];
const WEAPON_MASTERY_OPTIONS = [
  { id: "coup-double", label: "Coup double" },
  { id: "ecorchure", label: "Ecorchure" },
  { id: "enchainement", label: "Enchainement" },
  { id: "ouverture", label: "Ouverture" },
  { id: "poussee", label: "Poussee" },
  { id: "ralentissement", label: "Ralentissement" },
  { id: "renversement", label: "Renversement" },
  { id: "sape", label: "Sape" }
];
function CombatSetupScreen(props) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B;
  const [activeMainTab, setActiveMainTab] = reactExports.useState("map");
  const [activePlayerTab, setActivePlayerTab] = reactExports.useState("species");
  const [activeClassTab, setActiveClassTab] = reactExports.useState("primary");
  const [equipSubTab, setEquipSubTab] = reactExports.useState("slots");
  const [equipMessage, setEquipMessage] = reactExports.useState(null);
  const [statsMode, setStatsMode] = reactExports.useState("normal");
  const [skillsMode, setSkillsMode] = reactExports.useState("normal");
  const [masteriesMode, setMasteriesMode] = reactExports.useState("normal");
  const weaponOptions = reactExports.useMemo(() => {
    const list = Array.isArray(props.weaponTypes) ? [...props.weaponTypes] : [];
    list.sort((a2, b2) => {
      const sa = `${a2.subtype}:${a2.name}`.toLowerCase();
      const sb = `${b2.subtype}:${b2.name}`.toLowerCase();
      return sa.localeCompare(sb);
    });
    return list;
  }, [props.weaponTypes]);
  const raceOptions = reactExports.useMemo(() => {
    const list = Array.isArray(props.raceTypes) ? [...props.raceTypes] : [];
    list.sort((a2, b2) => a2.label.toLowerCase().localeCompare(b2.label.toLowerCase()));
    return list;
  }, [props.raceTypes]);
  const selectedRaceId = ((_a = props.character) == null ? void 0 : _a.raceId) ?? "";
  const getRaceTraitIds = (race) => {
    if (!race) return [];
    const grants2 = Array.isArray(race == null ? void 0 : race.grants) ? race.grants : [];
    const ids = [];
    grants2.forEach((grant) => {
      if ((grant == null ? void 0 : grant.kind) !== "trait") return;
      const list = Array.isArray(grant == null ? void 0 : grant.ids) ? grant.ids : [];
      list.forEach((id2) => ids.push(id2));
    });
    return Array.from(new Set(ids));
  };
  const getRaceTraits = (race) => {
    if (!race) return [];
    const traits2 = Array.isArray(race.traits) ? race.traits : [];
    const grantedIds = getRaceTraitIds(race);
    if (grantedIds.length === 0) return traits2;
    const byId = new Map(traits2.map((trait) => [trait.id, trait]));
    return grantedIds.map((id2) => byId.get(id2) ?? { id: id2, label: id2, description: "" });
  };
  const hasRaceTrait = (traitId) => {
    const traits2 = getRaceTraits(activeRace);
    return traits2.some((trait) => trait.id === traitId);
  };
  const backgroundOptions = reactExports.useMemo(() => {
    const list = Array.isArray(props.backgroundTypes) ? [...props.backgroundTypes] : [];
    list.sort((a2, b2) => a2.label.toLowerCase().localeCompare(b2.label.toLowerCase()));
    return list;
  }, [props.backgroundTypes]);
  const selectedBackgroundId = ((_b = props.character) == null ? void 0 : _b.backgroundId) ?? "";
  const getBackgroundGrants = (bg) => {
    if (!bg) return [];
    const list = Array.isArray(bg == null ? void 0 : bg.grants) ? bg.grants : [];
    return list.filter((grant) => grant && grant.kind).map((grant) => ({
      kind: String(grant.kind),
      ids: Array.isArray(grant.ids) ? grant.ids : [],
      meta: grant.meta
    }));
  };
  const getBackgroundSkillProficiencies = (bg) => {
    if (!bg) return [];
    const grantIds = getBackgroundGrants(bg).filter((grant) => grant.kind === "skill").flatMap((grant) => grant.ids);
    if (grantIds.length > 0) return Array.from(new Set(grantIds));
    return [];
  };
  const getBackgroundToolProficiencies = (bg) => {
    if (!bg) return [];
    const grantIds = getBackgroundGrants(bg).filter((grant) => grant.kind === "tool").flatMap((grant) => grant.ids);
    if (grantIds.length > 0) return Array.from(new Set(grantIds));
    return [];
  };
  const getBackgroundToolChoice = (bg) => {
    var _a2, _b2;
    if (!bg) return null;
    const grant = getBackgroundGrants(bg).find((item) => item.kind === "tool-choice") ?? null;
    if (grant) {
      const count2 = Number(((_a2 = grant.meta) == null ? void 0 : _a2.count) ?? 0);
      const options = Array.isArray((_b2 = grant.meta) == null ? void 0 : _b2.options) ? grant.meta.options : [];
      return { count: count2, options };
    }
    return null;
  };
  const getBackgroundLanguageChoice = (bg) => {
    var _a2;
    if (!bg) return null;
    const grant = getBackgroundGrants(bg).find((item) => item.kind === "language-choice") ?? null;
    if (grant) {
      const count2 = Number(((_a2 = grant.meta) == null ? void 0 : _a2.count) ?? 0);
      return { count: count2 };
    }
    return null;
  };
  const getBackgroundFeatureInfo = (bg) => {
    var _a2;
    if (!bg) return null;
    const grant = getBackgroundGrants(bg).find((item) => item.kind === "feature") ?? null;
    if (!grant) return null;
    const meta = grant.meta ?? {};
    const label2 = meta.label ?? ((_a2 = grant.ids) == null ? void 0 : _a2[0]) ?? "";
    const description2 = meta.description ?? "";
    return { label: label2, description: description2 };
  };
  const toolItems = Array.isArray(props.toolItems) ? props.toolItems : [];
  const objectItems = Array.isArray(props.objectItems) ? props.objectItems : [];
  const armorItems = Array.isArray(props.armorItems) ? props.armorItems : [];
  const languageOptions = reactExports.useMemo(() => {
    const list = Array.isArray(props.languageTypes) ? [...props.languageTypes] : [];
    list.sort((a2, b2) => a2.label.toLowerCase().localeCompare(b2.label.toLowerCase()));
    return list;
  }, [props.languageTypes]);
  const creationLocks = ((_c = props.character) == null ? void 0 : _c.creationLocks) ?? {};
  const classLocks = ((_d = props.character) == null ? void 0 : _d.classLocks) ?? {};
  const legacyClassLock = Boolean((_e = props.character) == null ? void 0 : _e.classLock);
  const isPrimaryClassLocked = typeof classLocks.primary === "boolean" ? classLocks.primary : legacyClassLock;
  const isSecondaryClassLocked = Boolean(classLocks.secondary);
  const isSectionLocked = (id2) => {
    var _a2, _b2;
    if (id2 === "classes") {
      const secondaryEnabled = Boolean((_b2 = (_a2 = props.character) == null ? void 0 : _a2.classe) == null ? void 0 : _b2[2]);
      if (secondaryEnabled) {
        return resolvedClassTab === "secondary" ? isSecondaryClassLocked : isPrimaryClassLocked;
      }
      return isPrimaryClassLocked;
    }
    return Boolean(creationLocks == null ? void 0 : creationLocks[id2]);
  };
  const setSectionLock = (id2, value2) => {
    const nextLocks = { ...creationLocks, [id2]: value2 };
    let nextCharacter = { ...props.character, creationLocks: nextLocks };
    if (value2 && id2 === "equip") {
      nextCharacter = applySkillsAndMasteriesReset(nextCharacter);
    }
    props.onChangeCharacter(nextCharacter);
  };
  const toggleSectionLock = (id2) => {
    setSectionLock(id2, !(creationLocks == null ? void 0 : creationLocks[id2]));
  };
  const classOptions = reactExports.useMemo(() => {
    const list = Array.isArray(props.classTypes) ? [...props.classTypes] : [];
    list.sort((a2, b2) => a2.label.toLowerCase().localeCompare(b2.label.toLowerCase()));
    return list;
  }, [props.classTypes]);
  const subclassOptions = reactExports.useMemo(() => {
    return Array.isArray(props.subclassTypes) ? [...props.subclassTypes] : [];
  }, [props.subclassTypes]);
  const classEntry = ((_g = (_f = props.character) == null ? void 0 : _f.classe) == null ? void 0 : _g[1]) ?? null;
  const secondaryClassEntry = ((_i = (_h = props.character) == null ? void 0 : _h.classe) == null ? void 0 : _i[2]) ?? null;
  const isSecondaryEnabled = Boolean(secondaryClassEntry);
  const selectedClassId = (classEntry == null ? void 0 : classEntry.classeId) ?? "";
  const selectedSubclassId = (classEntry == null ? void 0 : classEntry.subclasseId) ?? "";
  const selectedSecondaryClassId = (secondaryClassEntry == null ? void 0 : secondaryClassEntry.classeId) ?? "";
  const selectedSecondarySubclassId = (secondaryClassEntry == null ? void 0 : secondaryClassEntry.subclasseId) ?? "";
  const activeRace = raceOptions.find((race) => race.id === selectedRaceId) ?? null;
  const activeBackground = backgroundOptions.find((bg) => bg.id === selectedBackgroundId) ?? null;
  const profileDetails = ((_j = props.character) == null ? void 0 : _j.profileDetails) ?? {};
  const classPrimary = classOptions.find((cls) => cls.id === selectedClassId) ?? null;
  const classSecondary = classOptions.find((cls) => cls.id === selectedSecondaryClassId) ?? null;
  const featureTypes = reactExports.useMemo(() => loadFeatureTypesFromIndex(), []);
  const featureById = reactExports.useMemo(() => {
    const map = /* @__PURE__ */ new Map();
    featureTypes.forEach((feature) => {
      if (feature == null ? void 0 : feature.id) map.set(String(feature.id), feature);
    });
    return map;
  }, [featureTypes]);
  const activeFeatureDefs = reactExports.useMemo(() => {
    var _a2, _b2, _c2;
    const featureIds = Array.isArray((_c2 = (_b2 = (_a2 = props.character) == null ? void 0 : _a2.derived) == null ? void 0 : _b2.grants) == null ? void 0 : _c2.features) ? props.character.derived.grants.features.map((id2) => String(id2)).filter(Boolean) : [];
    return featureIds.map((id2) => featureById.get(id2) ?? null).filter((feature) => Boolean(feature));
  }, [featureById, props.character]);
  const choiceSelections = ((_k = props.character) == null ? void 0 : _k.choiceSelections) ?? {};
  const classFeatureSelections = (choiceSelections == null ? void 0 : choiceSelections.classFeatures) ?? {};
  const equipmentAuto = Array.isArray((_l = props.character) == null ? void 0 : _l.equipmentAuto) ? props.character.equipmentAuto : [];
  const equipmentManual = Array.isArray((_m = props.character) == null ? void 0 : _m.equipmentManual) ? props.character.equipmentManual : [];
  const inventoryItems = Array.isArray((_n = props.character) == null ? void 0 : _n.inventoryItems) ? props.character.inventoryItems : [];
  const objectItemMap = reactExports.useMemo(() => {
    const map = /* @__PURE__ */ new Map();
    for (const item of objectItems) map.set(item.id, item);
    return map;
  }, [objectItems]);
  const toolItemMap = reactExports.useMemo(() => {
    const map = /* @__PURE__ */ new Map();
    for (const item of toolItems) map.set(item.id, item);
    return map;
  }, [toolItems]);
  const armorItemMap = reactExports.useMemo(() => {
    const map = /* @__PURE__ */ new Map();
    for (const item of armorItems) map.set(item.id, item);
    return map;
  }, [armorItems]);
  const weaponItemMap = reactExports.useMemo(() => {
    const map = /* @__PURE__ */ new Map();
    for (const item of weaponOptions) map.set(item.id, item);
    return map;
  }, [weaponOptions]);
  const inventoryInitRef = reactExports.useRef(false);
  const instanceSeedRef = reactExports.useRef(
    `${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 8)}`
  );
  const instanceCounterRef = reactExports.useRef(0);
  const pendingLocks = (choiceSelections == null ? void 0 : choiceSelections.pendingLocks) ?? {};
  const competences = Array.isArray((_o = props.character) == null ? void 0 : _o.competences) ? props.character.competences : [];
  const expertises = Array.isArray((_p = props.character) == null ? void 0 : _p.expertises) ? props.character.expertises : [];
  reactExports.useEffect(() => {
    var _a2;
    if (skillsMode !== "normal") return;
    const adaptableSkill = (_a2 = choiceSelections == null ? void 0 : choiceSelections.race) == null ? void 0 : _a2.adaptableSkill;
    if (!adaptableSkill) return;
    if (competences.includes(adaptableSkill)) return;
    const nextSkills = Array.from(/* @__PURE__ */ new Set([...competences ?? [], adaptableSkill]));
    props.onChangeCharacter({ ...props.character, competences: nextSkills });
  }, [skillsMode, choiceSelections, competences, props.character, props.onChangeCharacter]);
  const profs = ((_q = props.character) == null ? void 0 : _q.proficiencies) ?? {};
  const rawWeaponEntries = Array.isArray(profs.weapons) ? profs.weapons : [];
  const weaponProficiencyIdSet = new Set(WEAPON_PROFICIENCY_OPTIONS.map((option) => option.id));
  const weaponMasteryOptionMap = new Map(
    WEAPON_MASTERY_OPTIONS.map((option) => [option.id, option.label])
  );
  const weaponMasteryIdSet = new Set(WEAPON_MASTERY_OPTIONS.map((option) => option.id));
  const weaponProficiencies = rawWeaponEntries.filter((id2) => weaponProficiencyIdSet.has(id2));
  const explicitWeaponMasteries = Array.isArray((_r = props.character) == null ? void 0 : _r.weaponMasteries) ? ((_s = props.character) == null ? void 0 : _s.weaponMasteries).map((id2) => String(id2)).filter(Boolean) : [];
  const legacyWeaponMasteries = rawWeaponEntries.filter((id2) => weaponMasteryIdSet.has(id2));
  const activeWeaponMasteryIds = explicitWeaponMasteries.length > 0 ? Array.from(new Set(explicitWeaponMasteries)) : Array.from(new Set(legacyWeaponMasteries));
  const unlockedWeaponMasteries = activeWeaponMasteryIds.map((id2) => ({ id: id2, label: weaponMasteryOptionMap.get(id2) ?? id2 }));
  const armorMasteries = Array.isArray(profs.armors) ? profs.armors : [];
  const toolMasteries = Array.isArray(profs.tools) ? profs.tools : [];
  const getClassEquipment = (cls) => {
    const list = Array.isArray(cls == null ? void 0 : cls.equipment) ? cls == null ? void 0 : cls.equipment : [];
    return list.filter(Boolean);
  };
  const arraysEqual = (left, right) => {
    if (left.length !== right.length) return false;
    for (let i2 = 0; i2 < left.length; i2 += 1) {
      if (left[i2] !== right[i2]) return false;
    }
    return true;
  };
  const DEFAULT_MATERIEL_SLOTS = {
    corps: null,
    tete: null,
    gants: null,
    bottes: null,
    ceinture_gauche: null,
    ceinture_droite: null,
    dos_gauche: null,
    dos_droit: null,
    anneau_1: null,
    anneau_2: null,
    collier: null,
    bijou_1: null,
    bijou_2: null,
    paquetage: null,
    ceinture_bourse_1: null,
    ceinture_bourse_2: null
  };
  const materielSlots = reactExports.useMemo(() => {
    var _a2;
    const current = ((_a2 = props.character) == null ? void 0 : _a2.materielSlots) ?? {};
    return { ...DEFAULT_MATERIEL_SLOTS, ...current };
  }, [(_t = props.character) == null ? void 0 : _t.materielSlots]);
  const EQUIPMENT_SLOTS = [
    { id: "corps", label: "Corps (armure ou vetement)", accepts: ["armor_body", "clothing_body"] },
    {
      id: "tete",
      label: "Tete (vetement)",
      accepts: ["clothing_head"],
      requiresClothingBody: true
    },
    {
      id: "gants",
      label: "Gants (vetement)",
      accepts: ["clothing_gloves"],
      requiresClothingBody: true
    },
    {
      id: "bottes",
      label: "Bottes (vetement)",
      accepts: ["clothing_boots"],
      requiresClothingBody: true
    },
    {
      id: "ceinture_gauche",
      label: "Ceinture gauche",
      accepts: ["weapon_short", "weapon_long", "weapon_ranged", "shield"]
    },
    {
      id: "ceinture_droite",
      label: "Ceinture droite",
      accepts: ["weapon_short", "weapon_long", "weapon_ranged", "shield"]
    },
    {
      id: "dos_gauche",
      label: "Dos gauche",
      accepts: ["weapon_long", "weapon_ranged", "shield"]
    },
    {
      id: "dos_droit",
      label: "Dos droit",
      accepts: ["weapon_long", "weapon_ranged", "shield"]
    },
    { id: "anneau_1", label: "Anneau 1", accepts: ["ring"] },
    { id: "anneau_2", label: "Anneau 2", accepts: ["ring"] },
    { id: "collier", label: "Collier", accepts: ["necklace"] },
    { id: "bijou_1", label: "Bijou 1", accepts: ["jewel"] },
    { id: "bijou_2", label: "Bijou 2", accepts: ["jewel"] },
    { id: "paquetage", label: "Paquetage (sac)", accepts: ["pack"] },
    { id: "ceinture_bourse_1", label: "Ceinture - bourse 1", accepts: ["pack"] },
    { id: "ceinture_bourse_2", label: "Ceinture - bourse 2", accepts: ["pack"] }
  ];
  const weaponCarrySlots = reactExports.useMemo(
    () => /* @__PURE__ */ new Set(["ceinture_gauche", "ceinture_droite", "dos_gauche", "dos_droit"]),
    []
  );
  const clothingSubSlots = reactExports.useMemo(() => /* @__PURE__ */ new Set(["tete", "gants", "bottes"]), []);
  const packSlots = reactExports.useMemo(
    () => /* @__PURE__ */ new Set(["paquetage", "ceinture_bourse_1", "ceinture_bourse_2"]),
    []
  );
  const packSlotMaxWeight = {
    paquetage: null,
    ceinture_bourse_1: 5.2,
    ceinture_bourse_2: 5.2
  };
  const humanizeId = (value2) => {
    const cleaned = value2.replace(/^obj_/, "").replace(/^weapon_/, "").replace(/^armor_/, "").replace(/^tool_/, "").replace(/[_-]+/g, " ").trim();
    return cleaned.length > 0 ? cleaned.charAt(0).toUpperCase() + cleaned.slice(1) : value2;
  };
  const getItemLabel = (item) => {
    var _a2, _b2, _c2, _d2;
    const fallback = humanizeId((item == null ? void 0 : item.id) ?? "item");
    if ((item == null ? void 0 : item.type) === "object") return ((_a2 = objectItemMap.get(item.id)) == null ? void 0 : _a2.label) ?? fallback;
    if ((item == null ? void 0 : item.type) === "armor") return ((_b2 = armorItemMap.get(item.id)) == null ? void 0 : _b2.label) ?? fallback;
    if ((item == null ? void 0 : item.type) === "tool") return ((_c2 = toolItemMap.get(item.id)) == null ? void 0 : _c2.label) ?? fallback;
    if ((item == null ? void 0 : item.type) === "weapon") return ((_d2 = weaponItemMap.get(item.id)) == null ? void 0 : _d2.name) ?? fallback;
    return fallback;
  };
  const getWeaponCategories = (weapon) => {
    if (!weapon) return [];
    const categories = /* @__PURE__ */ new Set();
    const props2 = weapon.properties ?? {};
    if (props2.twoHanded || props2.heavy) {
      categories.add("weapon_long");
    } else if (props2.light) {
      categories.add("weapon_short");
    } else {
      categories.add("weapon_long");
    }
    if (weapon.category === "distance" || props2.ammunition) {
      categories.add("weapon_ranged");
    }
    return Array.from(categories);
  };
  const getItemCategories = (item) => {
    if (!item) return [];
    if (item.type === "object") {
      const def = objectItemMap.get(item.id);
      return (def == null ? void 0 : def.category) ? [def.category] : [];
    }
    if (item.type === "armor") {
      const def = armorItemMap.get(item.id);
      return (def == null ? void 0 : def.category) ? [def.category] : [];
    }
    if (item.type === "weapon") {
      const def = weaponItemMap.get(item.id);
      return getWeaponCategories(def);
    }
    if (item.type === "tool") {
      return ["tool"];
    }
    return [];
  };
  const getItemWeight = (item) => {
    var _a2, _b2, _c2, _d2;
    if (!item) return 0;
    if (item.type === "object") return ((_a2 = objectItemMap.get(item.id)) == null ? void 0 : _a2.weight) ?? 0;
    if (item.type === "armor") return ((_b2 = armorItemMap.get(item.id)) == null ? void 0 : _b2.weight) ?? 0;
    if (item.type === "weapon") return ((_c2 = weaponItemMap.get(item.id)) == null ? void 0 : _c2.weight) ?? 0;
    if (item.type === "tool") return ((_d2 = toolItemMap.get(item.id)) == null ? void 0 : _d2.weight) ?? 0;
    return 0;
  };
  const isItemHarmonisable = (item) => {
    var _a2, _b2, _c2;
    if (!item) return false;
    if (item.type === "weapon") return Boolean((_a2 = weaponItemMap.get(item.id)) == null ? void 0 : _a2.harmonisable);
    if (item.type === "armor") return Boolean((_b2 = armorItemMap.get(item.id)) == null ? void 0 : _b2.harmonisable);
    if (item.type === "object") return Boolean((_c2 = objectItemMap.get(item.id)) == null ? void 0 : _c2.harmonisable);
    return false;
  };
  const isInventoryItemHarmonized2 = (item) => {
    var _a2, _b2;
    if (!item) return false;
    if (item.harmonized === true || item.isHarmonized === true || item.attuned === true) return true;
    if (((_a2 = item == null ? void 0 : item.attunement) == null ? void 0 : _a2.state) === "harmonized") return true;
    if (typeof ((_b2 = item == null ? void 0 : item.attunement) == null ? void 0 : _b2.harmonizedAt) === "string" && item.attunement.harmonizedAt.length > 0) {
      return true;
    }
    return false;
  };
  const createInstanceId = (prefix) => {
    const next = instanceCounterRef.current + 1;
    instanceCounterRef.current = next;
    return `${prefix}-${instanceSeedRef.current}-${next}`;
  };
  const getPackSlotItemId = (slotId) => (materielSlots == null ? void 0 : materielSlots[slotId]) ?? null;
  const getPackCapacity = (slotId) => {
    const bagId = getPackSlotItemId(slotId);
    if (!bagId) return 0;
    const bag = objectItemMap.get(bagId);
    return (bag == null ? void 0 : bag.capacityWeight) ?? 0;
  };
  const getStoredWeightForSlot = (slotId) => {
    const bagId = getPackSlotItemId(slotId);
    return inventoryItems.reduce((sum, item) => {
      const isStoredInSlot = (item == null ? void 0 : item.storedIn) === slotId || slotId === "paquetage" && bagId && (item == null ? void 0 : item.storedIn) === bagId;
      if (!isStoredInSlot) return sum;
      return sum + getItemWeight(item) * (Number((item == null ? void 0 : item.qty) ?? 1) || 1);
    }, 0);
  };
  const getPackTotalWeightForItem = (item) => {
    if (!item) return 0;
    const base = getItemWeight(item);
    const slotId = (item == null ? void 0 : item.equippedSlot) && packSlots.has(item.equippedSlot) ? item.equippedSlot : null;
    const contents = slotId ? getStoredWeightForSlot(slotId) : 0;
    return base + contents;
  };
  const getPackTotalWeightForSlot = (slotId) => {
    const bagId = getPackSlotItemId(slotId);
    if (!bagId) return 0;
    const bagItem = inventoryItems.find(
      (item) => (item == null ? void 0 : item.equippedSlot) === slotId && (item == null ? void 0 : item.id) === bagId
    );
    if (!bagItem) return 0;
    return getItemWeight(bagItem) + getStoredWeightForSlot(slotId);
  };
  const getBodyCategory = () => {
    const bodyId = materielSlots == null ? void 0 : materielSlots.corps;
    if (!bodyId) return null;
    const item = inventoryItems.find((entry) => entry.id === bodyId && entry.equippedSlot === "corps");
    const categories = getItemCategories(item);
    return categories.length > 0 ? categories[0] : null;
  };
  const canUseClothingPieces = getBodyCategory() === "clothing_body";
  const slotGroups = reactExports.useMemo(
    () => ({
      body: ["corps", "tete", "gants", "bottes"],
      weapons: ["ceinture_gauche", "ceinture_droite", "dos_gauche", "dos_droit"],
      jewelry: ["anneau_1", "anneau_2", "collier", "bijou_1", "bijou_2"],
      bag: ["paquetage"],
      beltPacks: ["ceinture_bourse_1", "ceinture_bourse_2"]
    }),
    []
  );
  const getEligibleItemsForSlot = (slotId) => {
    const slotDef = EQUIPMENT_SLOTS.find((s2) => s2.id === slotId);
    if (!slotDef) return [];
    if (slotDef.requiresClothingBody && !canUseClothingPieces) return [];
    return inventoryItems.map((item, idx) => ({ item, idx })).filter(({ item }) => {
      const categories = getItemCategories(item);
      if (!categories.some((cat) => slotDef.accepts.includes(cat))) return false;
      if (packSlots.has(slotId)) {
        const limit = packSlotMaxWeight[slotId];
        if (typeof limit === "number") {
          const totalWeight = getPackTotalWeightForItem(item);
          if (totalWeight > limit) return false;
        }
      }
      return true;
    });
  };
  const packSlotStatus = (slotId) => {
    const bagId = getPackSlotItemId(slotId);
    const capacity = getPackCapacity(slotId);
    const storedWeight = getStoredWeightForSlot(slotId);
    const totalWeight = getPackTotalWeightForSlot(slotId);
    const maxTotal = packSlotMaxWeight[slotId];
    return { bagId, capacity, storedWeight, totalWeight, maxTotal };
  };
  const getSlotLabel = (slotId) => {
    var _a2;
    return ((_a2 = EQUIPMENT_SLOTS.find((slot) => slot.id === slotId)) == null ? void 0 : _a2.label) ?? slotId;
  };
  const resolveStoredSlotId = (item) => {
    if (!(item == null ? void 0 : item.storedIn)) return null;
    if (packSlots.has(item.storedIn)) return item.storedIn;
    const mainBagId = getPackSlotItemId("paquetage");
    if (mainBagId && item.storedIn === mainBagId) return "paquetage";
    return null;
  };
  const slotItemIndexMap = reactExports.useMemo(() => {
    const map = /* @__PURE__ */ new Map();
    inventoryItems.forEach((item, idx) => {
      if (item == null ? void 0 : item.equippedSlot) map.set(item.equippedSlot, idx);
    });
    return map;
  }, [inventoryItems]);
  const renderSlotGroup = (slotIds, title, note) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      style: {
        borderRadius: 8,
        border: "1px solid rgba(255,255,255,0.12)",
        background: "rgba(12,12,18,0.75)",
        padding: 10,
        display: "flex",
        flexDirection: "column",
        gap: 8
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, fontWeight: 700 }, children: title }),
        note && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 11, color: "rgba(255,255,255,0.6)" }, children: note }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            style: {
              display: "grid",
              gridTemplateColumns: "repeat(auto-fit, minmax(200px, 1fr))",
              gap: 8
            },
            children: slotIds.map((slotId) => {
              const slot = EQUIPMENT_SLOTS.find((entry) => entry.id === slotId);
              if (!slot) return null;
              const currentIndex = slotItemIndexMap.get(slot.id);
              const eligible = getEligibleItemsForSlot(slot.id);
              const disabled = isSectionLocked("equip") || slot.requiresClothingBody && !canUseClothingPieces;
              return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "label",
                {
                  style: { fontSize: 12, display: "flex", flexDirection: "column", gap: 6 },
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { color: disabled ? "rgba(255,255,255,0.4)" : "#f5f5f5" }, children: slot.label }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      "select",
                      {
                        value: typeof currentIndex === "number" ? String(currentIndex) : "",
                        onChange: (event) => {
                          const value2 = event.target.value;
                          if (!value2) {
                            if (typeof currentIndex === "number") {
                              updateItemSlot(currentIndex, null);
                            }
                            return;
                          }
                          updateItemSlot(Number(value2), slot.id);
                        },
                        disabled,
                        style: {
                          background: "#0f0f19",
                          color: "#f5f5f5",
                          border: "1px solid #333",
                          borderRadius: 6,
                          padding: "6px 8px",
                          fontSize: 12,
                          opacity: disabled ? 0.6 : 1
                        },
                        children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "", children: "Vide" }),
                          eligible.map(({ item, idx }) => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: String(idx), children: getItemLabel(item) }, `slot-${slot.id}-${idx}`))
                        ]
                      }
                    ),
                    slot.requiresClothingBody && !canUseClothingPieces && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: 10, color: "rgba(255,255,255,0.45)" }, children: "Requiert un vetement au corps" })
                  ]
                },
                slot.id
              );
            })
          }
        )
      ]
    }
  );
  const setNameField = (key2, value2) => {
    const nextNom = {
      ...props.character.nom ?? {},
      [key2]: value2
    };
    props.onChangeCharacter({ ...props.character, nom: nextNom });
  };
  const setProfileDetail = (key2, value2) => {
    const nextProfileDetails = { ...profileDetails, [key2]: value2 };
    props.onChangeCharacter({ ...props.character, profileDetails: nextProfileDetails });
  };
  const setPhysiqueDetail = (value2) => {
    const nextDesc = {
      ...props.character.descriptionPersonnage ?? {},
      physique: value2
    };
    props.onChangeCharacter({ ...props.character, descriptionPersonnage: nextDesc });
  };
  const toggleListValue = (list, value2) => {
    if (list.includes(value2)) return list.filter((item) => item !== value2);
    return [...list, value2];
  };
  const toggleCompetence = (value2) => {
    const next = toggleListValue(competences, value2);
    const nextExpertises = next.includes(value2) ? expertises : expertises.filter((item) => item !== value2);
    props.onChangeCharacter({
      ...props.character,
      competences: next,
      expertises: nextExpertises
    });
  };
  const toggleExpertise = (value2) => {
    if (!competences.includes(value2)) return;
    const next = toggleListValue(expertises, value2);
    props.onChangeCharacter({ ...props.character, expertises: next });
  };
  const toggleMastery = (kind2, value2) => {
    const next = {
      weapons: kind2 === "weapons" ? toggleListValue(weaponProficiencies, value2) : weaponProficiencies,
      armors: kind2 === "armors" ? toggleListValue(armorMasteries, value2) : armorMasteries,
      tools: kind2 === "tools" ? toggleListValue(toolMasteries, value2) : toolMasteries
    };
    props.onChangeCharacter({ ...props.character, proficiencies: next });
  };
  const resolveLevel = () => {
    var _a2, _b2, _c2, _d2, _e2, _f2;
    const combatLevel = Number((_b2 = (_a2 = props.character) == null ? void 0 : _a2.combatStats) == null ? void 0 : _b2.level);
    if (Number.isFinite(combatLevel) && combatLevel > 0) return combatLevel;
    const globalLevel = Number((_c2 = props.character) == null ? void 0 : _c2.niveauGlobal);
    if (Number.isFinite(globalLevel) && globalLevel > 0) return globalLevel;
    const classLevel = Number((_f2 = (_e2 = (_d2 = props.character) == null ? void 0 : _d2.classe) == null ? void 0 : _e2[1]) == null ? void 0 : _f2.niveau);
    if (Number.isFinite(classLevel) && classLevel > 0) return classLevel;
    return 1;
  };
  const resolvedClassTab = resolveLevel() > 2 ? activeClassTab : "primary";
  const activeClassSlot = resolvedClassTab === "secondary" ? 2 : 1;
  const isActiveClassLocked = activeClassSlot === 2 ? isSecondaryClassLocked : isPrimaryClassLocked;
  const setLevel = (nextLevelRaw) => {
    var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i2;
    const nextLevel = Math.max(1, Math.min(20, Math.floor(nextLevelRaw || 1)));
    const nextCombatStats = {
      ...props.character.combatStats ?? {},
      level: nextLevel
    };
    const currentClasse = ((_a2 = props.character) == null ? void 0 : _a2.classe) && typeof props.character.classe === "object" ? props.character.classe : {};
    const prevPrimaryLevel = Number((_b2 = currentClasse == null ? void 0 : currentClasse[1]) == null ? void 0 : _b2.niveau) || 0;
    const prevSecondaryLevel = Number((_c2 = currentClasse == null ? void 0 : currentClasse[2]) == null ? void 0 : _c2.niveau) || 0;
    const hasSecondary = Boolean(currentClasse == null ? void 0 : currentClasse[2]);
    let nextClasse = { ...currentClasse };
    if (hasSecondary && nextLevel > 2) {
      const primaryLevel = Number((_d2 = currentClasse == null ? void 0 : currentClasse[1]) == null ? void 0 : _d2.niveau) || 1;
      const clampedPrimary = Math.max(1, Math.min(nextLevel - 1, primaryLevel));
      const secondaryLevel = Math.max(1, nextLevel - clampedPrimary);
      nextClasse = {
        ...nextClasse,
        1: { ...(nextClasse == null ? void 0 : nextClasse[1]) ?? {}, niveau: clampedPrimary },
        2: { ...(nextClasse == null ? void 0 : nextClasse[2]) ?? {}, niveau: secondaryLevel }
      };
    } else {
      nextClasse = {
        ...nextClasse,
        1: { ...(nextClasse == null ? void 0 : nextClasse[1]) ?? {}, niveau: nextLevel }
      };
      if (nextClasse == null ? void 0 : nextClasse[2]) {
        delete nextClasse[2];
      }
    }
    let nextChoiceSelections = choiceSelections;
    let nextClassLocks = classLocks;
    if (((_e2 = nextClasse == null ? void 0 : nextClasse[1]) == null ? void 0 : _e2.classeId) && ((_f2 = nextClasse == null ? void 0 : nextClasse[1]) == null ? void 0 : _f2.niveau) < prevPrimaryLevel) {
      const classId2 = (_g2 = nextClasse == null ? void 0 : nextClasse[1]) == null ? void 0 : _g2.classeId;
      const allowed = new Set(getAsiKeysForClassLevel(classId2, ((_h2 = nextClasse == null ? void 0 : nextClasse[1]) == null ? void 0 : _h2.niveau) || 0));
      const nextAsi = { ...asiSelections };
      Object.keys(nextAsi).forEach((key2) => {
        if (!key2.startsWith(`${classId2}:`)) return;
        if (!allowed.has(key2)) {
          delete nextAsi[key2];
        }
      });
      nextChoiceSelections = {
        ...nextChoiceSelections,
        asi: nextAsi,
        pendingLocks: (() => {
          const nextPending = { ...pendingLocks };
          delete nextPending.classes;
          delete nextPending.classesSlot;
          return nextPending;
        })()
      };
      nextClassLocks = { ...nextClassLocks, primary: false };
      const threshold = getSubclassThresholdForClassId(classId2);
      if (threshold !== null && (((_i2 = nextClasse == null ? void 0 : nextClasse[1]) == null ? void 0 : _i2.niveau) ?? 0) < threshold) {
        nextClasse = {
          ...nextClasse,
          1: { ...(nextClasse == null ? void 0 : nextClasse[1]) ?? {}, subclasseId: null }
        };
      }
    }
    if (!(nextClasse == null ? void 0 : nextClasse[2]) && prevSecondaryLevel > 0) {
      nextClassLocks = { ...nextClassLocks, secondary: false };
      const nextPending = { ...pendingLocks };
      delete nextPending.classes;
      delete nextPending.classesSlot;
      nextChoiceSelections = { ...nextChoiceSelections, pendingLocks: nextPending };
    }
    props.onChangeCharacter({
      ...props.character,
      niveauGlobal: nextLevel,
      classe: nextClasse,
      combatStats: nextCombatStats,
      classLocks: nextLevel <= 2 ? { ...nextClassLocks, secondary: false } : { ...nextClassLocks },
      choiceSelections: nextChoiceSelections
    });
    if (nextLevel <= 2) {
      setActiveClassTab("primary");
    }
  };
  const setClassSelection = (cls, slot) => {
    var _a2, _b2, _c2, _d2, _e2, _f2, _g2;
    const current = ((_a2 = props.character) == null ? void 0 : _a2.classe) ?? {};
    const previousId = ((_b2 = current == null ? void 0 : current[slot]) == null ? void 0 : _b2.classeId) ?? null;
    let nextAsi = asiSelections;
    let nextPendingLocks = pendingLocks;
    if (previousId && previousId !== cls.id) {
      nextAsi = { ...asiSelections };
      Object.keys(nextAsi).forEach((key2) => {
        if (key2.startsWith(`${previousId}:`)) {
          delete nextAsi[key2];
        }
      });
      nextPendingLocks = { ...pendingLocks };
      delete nextPendingLocks.classes;
      delete nextPendingLocks.classesSlot;
    }
    const existingLevel = Number((_c2 = current == null ? void 0 : current[slot]) == null ? void 0 : _c2.niveau);
    const fallbackLevel = slot === 1 ? resolveLevel() : 1;
    const nextLevel = Number.isFinite(existingLevel) && existingLevel > 0 ? existingLevel : fallbackLevel;
    const currentProfs = ((_d2 = props.character) == null ? void 0 : _d2.proficiencies) ?? {};
    const nextProfs = {
      weapons: Array.from(
        /* @__PURE__ */ new Set([...currentProfs.weapons ?? [], ...((_e2 = cls.proficiencies) == null ? void 0 : _e2.weapons) ?? []])
      ),
      armors: Array.from(
        /* @__PURE__ */ new Set([...currentProfs.armors ?? [], ...((_f2 = cls.proficiencies) == null ? void 0 : _f2.armors) ?? []])
      ),
      tools: Array.from(
        /* @__PURE__ */ new Set([...currentProfs.tools ?? [], ...((_g2 = cls.proficiencies) == null ? void 0 : _g2.tools) ?? []])
      )
    };
    const nextEntry = {
      ...(current == null ? void 0 : current[slot]) ?? {},
      classeId: cls.id,
      subclasseId: null,
      niveau: nextLevel
    };
    const nextClasse = { ...current, [slot]: nextEntry };
    const nextChoiceSelections = {
      ...choiceSelections,
      asi: nextAsi,
      pendingLocks: nextPendingLocks
    };
    props.onChangeCharacter({
      ...props.character,
      classe: nextClasse,
      proficiencies: nextProfs,
      choiceSelections: nextChoiceSelections
    });
  };
  const setSubclassSelection = (subclassId, slot) => {
    var _a2, _b2;
    const current = ((_a2 = props.character) == null ? void 0 : _a2.classe) ?? {};
    const nextEntry = {
      ...(current == null ? void 0 : current[slot]) ?? {},
      subclasseId: subclassId,
      niveau: slot === 1 ? resolveLevel() : Math.max(1, Number((_b2 = current == null ? void 0 : current[slot]) == null ? void 0 : _b2.niveau) || 1)
    };
    const nextClasse = { ...current, [slot]: nextEntry };
    props.onChangeCharacter({ ...props.character, classe: nextClasse });
  };
  const setClassLevel = (slot, nextLevelRaw) => {
    var _a2, _b2, _c2;
    const globalLevel = resolveLevel();
    const current = ((_a2 = props.character) == null ? void 0 : _a2.classe) ?? {};
    if (slot === 1 && !(current == null ? void 0 : current[1])) return;
    if (slot === 2 && !(current == null ? void 0 : current[2])) return;
    if (slot === 2 && globalLevel <= 2) return;
    const otherSlot = slot === 1 ? 2 : 1;
    const hasSecondary = Boolean(current == null ? void 0 : current[2]);
    if (!hasSecondary) {
      const nextClasse2 = {
        ...current,
        1: { ...(current == null ? void 0 : current[1]) ?? {}, niveau: globalLevel }
      };
      props.onChangeCharacter({ ...props.character, classe: nextClasse2 });
      return;
    }
    const prevLevel = Number((_b2 = current == null ? void 0 : current[slot]) == null ? void 0 : _b2.niveau) || 0;
    const nextLevel = Math.max(1, Math.min(globalLevel - 1, Math.floor(nextLevelRaw || 1)));
    const otherLevel = Math.max(1, globalLevel - nextLevel);
    const classId2 = ((_c2 = current == null ? void 0 : current[slot]) == null ? void 0 : _c2.classeId) ?? null;
    const nextClasse = {
      ...current,
      [slot]: { ...(current == null ? void 0 : current[slot]) ?? {}, niveau: nextLevel },
      [otherSlot]: { ...(current == null ? void 0 : current[otherSlot]) ?? {}, niveau: otherLevel }
    };
    let nextChoiceSelections = choiceSelections;
    let nextClassLocks = classLocks;
    if (classId2 && nextLevel < prevLevel) {
      const allowed = new Set(getAsiKeysForClassLevel(classId2, nextLevel));
      const nextAsi = { ...asiSelections };
      Object.keys(nextAsi).forEach((key2) => {
        if (!key2.startsWith(`${classId2}:`)) return;
        if (!allowed.has(key2)) {
          delete nextAsi[key2];
        }
      });
      const sourcesToDrop = slot === 1 ? ["classPrimary", "subclassPrimary"] : ["classSecondary", "subclassSecondary"];
      const nextStatBonuses = pruneStatBonusesBySource(sourcesToDrop);
      nextChoiceSelections = {
        ...choiceSelections,
        asi: nextAsi,
        ...nextStatBonuses ? { statBonuses: nextStatBonuses } : null,
        pendingLocks: (() => {
          const nextPending = { ...pendingLocks };
          delete nextPending.classes;
          delete nextPending.classesSlot;
          return nextPending;
        })()
      };
      nextClassLocks = {
        ...classLocks,
        primary: slot === 1 ? false : classLocks.primary,
        secondary: slot === 2 ? false : classLocks.secondary
      };
      const threshold = getSubclassThresholdForClassId(classId2);
      if (threshold !== null && nextLevel < threshold) {
        nextClasse[slot] = { ...nextClasse[slot] ?? {}, subclasseId: null };
      }
    }
    props.onChangeCharacter({
      ...props.character,
      classe: nextClasse,
      choiceSelections: nextChoiceSelections,
      classLocks: nextClassLocks
    });
  };
  const enableSecondaryClass = () => {
    var _a2, _b2, _c2;
    const current = ((_a2 = props.character) == null ? void 0 : _a2.classe) ?? {};
    const globalLevel = resolveLevel();
    if (globalLevel <= 2) return;
    const prevPrimaryLevel = Number(((_b2 = current == null ? void 0 : current[1]) == null ? void 0 : _b2.niveau) ?? 0);
    const primaryLevel = Math.max(1, globalLevel - 1);
    const secondaryLevel = Math.max(1, globalLevel - primaryLevel);
    const nextClasse = {
      ...current,
      1: { ...(current == null ? void 0 : current[1]) ?? {}, niveau: primaryLevel },
      2: { classeId: "", subclasseId: null, niveau: secondaryLevel }
    };
    let nextChoiceSelections = choiceSelections;
    let nextClassLocks = { ...classLocks, secondary: false };
    if (prevPrimaryLevel > 0 && primaryLevel < prevPrimaryLevel) {
      const classId2 = ((_c2 = current == null ? void 0 : current[1]) == null ? void 0 : _c2.classeId) ?? null;
      if (classId2) {
        const allowed = new Set(getAsiKeysForClassLevel(classId2, primaryLevel));
        const nextAsi = { ...asiSelections };
        Object.keys(nextAsi).forEach((key2) => {
          if (!key2.startsWith(`${classId2}:`)) return;
          if (!allowed.has(key2)) {
            delete nextAsi[key2];
          }
        });
        const sourcesToDrop = ["classPrimary", "subclassPrimary"];
        const nextStatBonuses = pruneStatBonusesBySource(sourcesToDrop);
        nextChoiceSelections = {
          ...choiceSelections,
          asi: nextAsi,
          ...nextStatBonuses ? { statBonuses: nextStatBonuses } : null,
          pendingLocks: (() => {
            const nextPending = { ...pendingLocks };
            delete nextPending.classes;
            delete nextPending.classesSlot;
            return nextPending;
          })()
        };
        const threshold = getSubclassThresholdForClassId(classId2);
        if (threshold !== null && primaryLevel < threshold) {
          nextClasse[1] = { ...nextClasse[1] ?? {}, subclasseId: null };
        }
        nextClassLocks = { ...nextClassLocks, primary: false };
      }
    }
    props.onChangeCharacter({
      ...props.character,
      classe: nextClasse,
      classLocks: nextClassLocks,
      choiceSelections: nextChoiceSelections
    });
    setActiveClassTab("secondary");
  };
  const removeSecondaryClass = () => {
    var _a2;
    const current = ((_a2 = props.character) == null ? void 0 : _a2.classe) ?? {};
    const globalLevel = resolveLevel();
    const nextClasse = {
      ...current,
      1: { ...(current == null ? void 0 : current[1]) ?? {}, niveau: globalLevel }
    };
    if (nextClasse == null ? void 0 : nextClasse[2]) delete nextClasse[2];
    props.onChangeCharacter({
      ...props.character,
      classe: nextClasse,
      classLocks: { ...classLocks, secondary: false }
    });
    setActiveClassTab("primary");
  };
  const buildClassLockCharacter = (slot, baseChoiceSelections, pendingOverride) => {
    const wasLocked = slot === 1 ? Boolean(classLocks.primary) : Boolean(classLocks.secondary);
    const nextLocks = {
      ...classLocks,
      primary: slot === 1 ? true : classLocks.primary,
      secondary: slot === 2 ? true : classLocks.secondary
    };
    const nextChoiceSelections = pendingOverride ? { ...baseChoiceSelections, pendingLocks: pendingOverride } : baseChoiceSelections;
    const nextCharacter = {
      ...props.character,
      classLocks: nextLocks,
      choiceSelections: nextChoiceSelections
    };
    if (slot === 1) {
      nextCharacter.classLock = true;
    }
    if (!wasLocked) {
      const cls = slot === 1 ? classPrimary : classSecondary;
      const classEquip = getClassEquipment(cls);
      const autoResult = addAutoItemsToState(
        equipmentAuto,
        inventoryItems,
        classEquip,
        { kind: "class", id: (cls == null ? void 0 : cls.id) ?? "" }
      );
      const baseSpellcasting = (nextChoiceSelections == null ? void 0 : nextChoiceSelections.spellcasting) ?? {};
      const nextSpellcasting = { ...baseSpellcasting };
      const grantedBySource = buildSpellGrantsForClassSlot(slot);
      Object.entries(grantedBySource).forEach(([key2, grants2]) => {
        nextSpellcasting[key2] = {
          ...nextSpellcasting[key2] ?? {},
          grantedSpells: grants2
        };
      });
      nextCharacter.equipmentAuto = autoResult.nextAuto;
      nextCharacter.inventoryItems = autoResult.nextInventory;
      nextCharacter.choiceSelections = {
        ...nextChoiceSelections,
        spellcasting: nextSpellcasting
      };
    }
    return nextCharacter;
  };
  const setClassLockForSlot = (slot, value2) => {
    const wasLocked = slot === 1 ? Boolean(classLocks.primary) : Boolean(classLocks.secondary);
    const nextLocks = {
      ...classLocks,
      primary: slot === 1 ? value2 : classLocks.primary,
      secondary: slot === 2 ? value2 : classLocks.secondary
    };
    if (value2 && !wasLocked) {
      const nextCharacter2 = applySkillsAndMasteriesReset(
        buildClassLockCharacter(slot, choiceSelections)
      );
      props.onChangeCharacter(nextCharacter2);
      return;
    }
    const nextCharacter = {
      ...props.character,
      classLocks: nextLocks
    };
    if (slot === 1) nextCharacter.classLock = value2;
    props.onChangeCharacter(nextCharacter);
  };
  const clearPendingLocks = (keys) => {
    const nextPending = { ...pendingLocks };
    let changed = false;
    for (const key2 of keys) {
      if (key2 in nextPending) {
        delete nextPending[key2];
        changed = true;
      }
    }
    if (!changed) return;
    props.onChangeCharacter({
      ...props.character,
      choiceSelections: { ...choiceSelections, pendingLocks: nextPending }
    });
  };
  const resetClassImpactsForSlot = (slot) => {
    var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i2, _j2;
    const current = ((_a2 = props.character) == null ? void 0 : _a2.classe) ?? {};
    const nextClasse = { ...current };
    const affectedClassIds = [];
    const affectedSubclassIds = [];
    const affectedSources = [];
    const globalLevel = resolveLevel();
    if (slot === 1) {
      if (nextClasse == null ? void 0 : nextClasse[1]) {
        const entry = nextClasse[1];
        affectedClassIds.push((entry == null ? void 0 : entry.classeId) ?? "");
        affectedSubclassIds.push((entry == null ? void 0 : entry.subclasseId) ?? "");
        affectedSources.push("classPrimary", "subclassPrimary");
        nextClasse[1] = { ...entry, subclasseId: null };
      }
      if (nextClasse == null ? void 0 : nextClasse[2]) {
        const entry = nextClasse[2];
        affectedClassIds.push((entry == null ? void 0 : entry.classeId) ?? "");
        affectedSubclassIds.push((entry == null ? void 0 : entry.subclasseId) ?? "");
        affectedSources.push("classSecondary", "subclassSecondary");
        delete nextClasse[2];
        nextClasse[1] = { ...(nextClasse == null ? void 0 : nextClasse[1]) ?? {}, niveau: globalLevel };
      }
    } else {
      if (nextClasse == null ? void 0 : nextClasse[2]) {
        const entry = nextClasse[2];
        affectedClassIds.push((entry == null ? void 0 : entry.classeId) ?? "");
        affectedSubclassIds.push((entry == null ? void 0 : entry.subclasseId) ?? "");
        affectedSources.push("classSecondary", "subclassSecondary");
        delete nextClasse[2];
        nextClasse[1] = { ...(nextClasse == null ? void 0 : nextClasse[1]) ?? {}, niveau: globalLevel };
      }
    }
    const nextAsi = { ...asiSelections };
    affectedClassIds.filter(Boolean).forEach((classId2) => {
      Object.keys(nextAsi).forEach((key2) => {
        if (key2.startsWith(`${classId2}:`)) {
          delete nextAsi[key2];
        }
      });
    });
    const nextPending = { ...pendingLocks };
    delete nextPending.classes;
    delete nextPending.classesSlot;
    const nextStatBonuses = pruneStatBonusesBySource(affectedSources);
    const classFeatureSelectionsCurrent = (choiceSelections == null ? void 0 : choiceSelections.classFeatures) ?? {};
    const blockedPrefixes = [
      ...affectedClassIds.filter(Boolean).map((id2) => `class:${id2}:`),
      ...affectedSubclassIds.filter(Boolean).map((id2) => `subclass:${id2}:`)
    ];
    const nextClassFeatures = Object.fromEntries(
      Object.entries(classFeatureSelectionsCurrent).filter(
        ([choiceId]) => !blockedPrefixes.some((prefix) => choiceId.startsWith(prefix))
      )
    );
    const nextChoiceSelections = {
      ...choiceSelections,
      asi: nextAsi,
      classFeatures: nextClassFeatures,
      ...nextStatBonuses ? { statBonuses: nextStatBonuses } : null,
      pendingLocks: nextPending
    };
    const primaryId = ((_b2 = nextClasse == null ? void 0 : nextClasse[1]) == null ? void 0 : _b2.classeId) ?? "";
    const secondaryId = ((_c2 = nextClasse == null ? void 0 : nextClasse[2]) == null ? void 0 : _c2.classeId) ?? "";
    const primaryCls = classOptions.find((cls) => cls.id === primaryId) ?? null;
    const secondaryCls = classOptions.find((cls) => cls.id === secondaryId) ?? null;
    const backgroundTools = [
      ...getBackgroundToolProficiencies(activeBackground),
      ...((_d2 = choiceSelections == null ? void 0 : choiceSelections.background) == null ? void 0 : _d2.tools) ?? []
    ];
    const nextProfs = {
      weapons: Array.from(
        /* @__PURE__ */ new Set([...((_e2 = primaryCls == null ? void 0 : primaryCls.proficiencies) == null ? void 0 : _e2.weapons) ?? [], ...((_f2 = secondaryCls == null ? void 0 : secondaryCls.proficiencies) == null ? void 0 : _f2.weapons) ?? []])
      ),
      armors: Array.from(
        /* @__PURE__ */ new Set([...((_g2 = primaryCls == null ? void 0 : primaryCls.proficiencies) == null ? void 0 : _g2.armors) ?? [], ...((_h2 = secondaryCls == null ? void 0 : secondaryCls.proficiencies) == null ? void 0 : _h2.armors) ?? []])
      ),
      tools: Array.from(
        /* @__PURE__ */ new Set([
          ...((_i2 = primaryCls == null ? void 0 : primaryCls.proficiencies) == null ? void 0 : _i2.tools) ?? [],
          ...((_j2 = secondaryCls == null ? void 0 : secondaryCls.proficiencies) == null ? void 0 : _j2.tools) ?? [],
          ...backgroundTools
        ])
      )
    };
    const baseSkills = getBackgroundSkillProficiencies(activeBackground);
    const nextCompetences = [...baseSkills];
    const nextExpertises = [];
    const nextClassLocks = {
      ...classLocks,
      primary: slot === 1 ? false : classLocks.primary,
      secondary: false
    };
    const nextCharacter = {
      ...props.character,
      classe: nextClasse,
      classLocks: nextClassLocks,
      choiceSelections: nextChoiceSelections,
      weaponMasteries: [],
      proficiencies: nextProfs,
      competences: nextCompetences,
      expertises: nextExpertises,
      materielSlots: { ...DEFAULT_MATERIEL_SLOTS },
      armesDefaut: { main_droite: null, main_gauche: null, mains: null },
      equipmentAuto: [],
      equipmentManual: [],
      inventoryItems: []
    };
    if (slot === 1) {
      nextCharacter.classLock = false;
    }
    props.onChangeCharacter(nextCharacter);
  };
  const resetSpeciesImpacts = () => {
    var _a2;
    const adaptableSkill = (_a2 = choiceSelections == null ? void 0 : choiceSelections.race) == null ? void 0 : _a2.adaptableSkill;
    const nextCompetences = adaptableSkill ? competences.filter((skill) => skill !== adaptableSkill) : competences;
    const nextChoiceSelections = {
      ...choiceSelections,
      race: { ...choiceSelections.race }
    };
    if (adaptableSkill) {
      delete nextChoiceSelections.race.adaptableSkill;
    }
    props.onChangeCharacter({
      ...props.character,
      creationLocks: { ...creationLocks, species: false },
      choiceSelections: nextChoiceSelections,
      competences: nextCompetences
    });
    clearPendingLocks(["species"]);
  };
  const resetBackgroundImpacts = () => {
    var _a2, _b2, _c2, _d2, _e2;
    const backgroundChoices = (choiceSelections == null ? void 0 : choiceSelections.background) ?? {};
    const bonusApplied = Boolean(backgroundChoices.statBonusApplied);
    const toolChoices = Array.isArray(backgroundChoices.tools) ? backgroundChoices.tools : [];
    const languageChoices = Array.isArray(backgroundChoices.languages) ? backgroundChoices.languages : [];
    const currentLangues = (_a2 = props.character) == null ? void 0 : _a2.langues;
    const currentList = Array.isArray(currentLangues) ? currentLangues : typeof currentLangues === "string" ? currentLangues.split(",").map((item) => item.trim()).filter(Boolean) : [];
    const nextLangues = currentList.filter((lang) => !languageChoices.includes(lang));
    const currentProfs = ((_b2 = props.character) == null ? void 0 : _b2.proficiencies) ?? {};
    const nextTools = Array.isArray(currentProfs.tools) ? currentProfs.tools.filter((tool) => !toolChoices.includes(tool)) : [];
    let nextCaracs = props.character.caracs;
    const nextChoiceSelections = {
      ...choiceSelections,
      background: {}
    };
    if (bonusApplied) {
      const current = ((_d2 = (_c2 = props.character.caracs) == null ? void 0 : _c2.force) == null ? void 0 : _d2.FOR) ?? 10;
      nextCaracs = {
        ...props.character.caracs,
        force: { ...((_e2 = props.character.caracs) == null ? void 0 : _e2.force) ?? {}, FOR: current - 1 }
      };
      nextChoiceSelections.statsBase = {
        ...statsBase,
        FOR: Number.isFinite(statsBase.FOR) ? statsBase.FOR : current - 1
      };
    }
    props.onChangeCharacter({
      ...props.character,
      creationLocks: { ...creationLocks, backgrounds: false },
      choiceSelections: nextChoiceSelections,
      langues: nextLangues,
      proficiencies: { ...currentProfs, tools: nextTools },
      caracs: nextCaracs,
      materielSlots: { ...DEFAULT_MATERIEL_SLOTS },
      armesDefaut: { main_droite: null, main_gauche: null, mains: null },
      equipmentAuto: [],
      equipmentManual: [],
      inventoryItems: []
    });
    clearPendingLocks(["backgrounds"]);
  };
  const STAT_KEYS = ["FOR", "DEX", "CON", "INT", "SAG", "CHA"];
  const parseStatBonusId = (id2) => {
    const trimmed = String(id2 ?? "").trim();
    const match = trimmed.match(/^(?:stat|carac)[:.](FOR|DEX|CON|INT|SAG|CHA)[:.]([+-]?\d+)$/i);
    if (!match) return null;
    const stat = match[1].toUpperCase();
    const value2 = Number.parseInt(match[2], 10);
    if (!Number.isFinite(value2) || value2 === 0) return null;
    return { stat, value: value2 };
  };
  const collectProgressionBonuses = (definition, level2, source2) => {
    const bonuses2 = [];
    if (!definition || !definition.progression) return bonuses2;
    Object.keys(definition.progression).map((key2) => Number(key2)).filter((lvl) => Number.isFinite(lvl) && lvl > 0 && lvl <= level2).forEach((lvl) => {
      var _a2, _b2;
      const grants2 = ((_b2 = (_a2 = definition.progression) == null ? void 0 : _a2[String(lvl)]) == null ? void 0 : _b2.grants) ?? [];
      for (const grant of grants2) {
        if ((grant == null ? void 0 : grant.kind) !== "bonus") continue;
        const ids = Array.isArray(grant.ids) ? grant.ids : [];
        for (const id2 of ids) {
          if (id2 === "asi-or-feat") continue;
          const parsed = parseStatBonusId(id2);
          if (!parsed) continue;
          bonuses2.push({ ...parsed, source: source2 });
        }
      }
    });
    return bonuses2;
  };
  const getStatBonuses = () => {
    var _a2;
    const bonuses2 = [];
    if ((_a2 = choiceSelections == null ? void 0 : choiceSelections.background) == null ? void 0 : _a2.statBonusApplied) {
      bonuses2.push({ stat: "FOR", value: 1, source: "background" });
    }
    if (activeRace && (activeRace == null ? void 0 : activeRace.statBonuses)) {
      const statBonuses2 = activeRace.statBonuses;
      Object.entries(statBonuses2).forEach(([stat, value2]) => {
        const key2 = String(stat).toUpperCase();
        if (!STAT_KEYS.includes(key2)) return;
        const amount = Number(value2) || 0;
        if (amount === 0) return;
        bonuses2.push({ stat: key2, value: amount, source: "race" });
      });
    }
    const primaryLevel = Number((classEntry == null ? void 0 : classEntry.niveau) ?? 0);
    if (primaryLevel > 0 && classPrimary) {
      bonuses2.push(...collectProgressionBonuses(classPrimary, primaryLevel, "classPrimary"));
    }
    if (primaryLevel > 0 && selectedSubclassId) {
      const sub = subclassOptions.find((item) => item.id === selectedSubclassId) ?? null;
      bonuses2.push(...collectProgressionBonuses(sub, primaryLevel, "subclassPrimary"));
    }
    const secondaryLevel = Number((secondaryClassEntry == null ? void 0 : secondaryClassEntry.niveau) ?? 0);
    if (secondaryLevel > 0 && classSecondary) {
      bonuses2.push(...collectProgressionBonuses(classSecondary, secondaryLevel, "classSecondary"));
    }
    if (secondaryLevel > 0 && selectedSecondarySubclassId) {
      const sub = subclassOptions.find((item) => item.id === selectedSecondarySubclassId) ?? null;
      bonuses2.push(...collectProgressionBonuses(sub, secondaryLevel, "subclassSecondary"));
    }
    const globalLevel = resolveLevel();
    if (globalLevel > 0 && activeRace) {
      bonuses2.push(...collectProgressionBonuses(activeRace, globalLevel, "race"));
    }
    if (globalLevel > 0 && activeBackground) {
      bonuses2.push(...collectProgressionBonuses(activeBackground, globalLevel, "background"));
    }
    const extraBonuses = (choiceSelections == null ? void 0 : choiceSelections.statBonuses) ?? [];
    if (Array.isArray(extraBonuses)) {
      extraBonuses.forEach((entry) => {
        const key2 = String(entry.stat ?? "").toUpperCase();
        if (!STAT_KEYS.includes(key2)) return;
        const amount = Number(entry.value) || 0;
        if (amount === 0) return;
        bonuses2.push({
          stat: key2,
          value: amount,
          source: entry.source ?? "bonus"
        });
      });
    }
    return bonuses2;
  };
  const statBonuses = reactExports.useMemo(() => getStatBonuses(), [
    choiceSelections,
    activeRace,
    activeBackground,
    classPrimary,
    classSecondary,
    selectedSubclassId,
    selectedSecondarySubclassId,
    classEntry == null ? void 0 : classEntry.niveau,
    secondaryClassEntry == null ? void 0 : secondaryClassEntry.niveau,
    (_u = props.character) == null ? void 0 : _u.niveauGlobal,
    subclassOptions
  ]);
  const asiSelections = (choiceSelections == null ? void 0 : choiceSelections.asi) ?? {};
  const statsBase = (choiceSelections == null ? void 0 : choiceSelections.statsBase) ?? {};
  const getNonAsiBonusSumForStat = (key2) => statBonuses.reduce((sum, bonus) => bonus.stat === key2 ? sum + bonus.value : sum, 0);
  const getScore = (key2) => {
    var _a2, _b2;
    const mapping = {
      FOR: "force",
      DEX: "dexterite",
      CON: "constitution",
      INT: "intelligence",
      SAG: "sagesse",
      CHA: "charisme"
    };
    const caracKey = mapping[key2];
    const score = (_b2 = (_a2 = props.character.caracs) == null ? void 0 : _a2[caracKey]) == null ? void 0 : _b2[key2];
    return Number.isFinite(score) ? Number(score) : 10;
  };
  const carryWeight = reactExports.useMemo(
    () => inventoryItems.reduce(
      (sum, item) => sum + getItemWeight(item) * (Number((item == null ? void 0 : item.qty) ?? 1) || 1),
      0
    ),
    [inventoryItems, objectItemMap, armorItemMap, weaponItemMap, toolItemMap]
  );
  const carryCapacityMax = getScore("FOR") * 7.5;
  const getRequestedAsiBonus = (key2) => {
    let total = 0;
    Object.values(asiSelections).forEach((entry) => {
      if (!entry || entry.type !== "asi" || !entry.stats) return;
      const raw = entry.stats[key2];
      const value2 = Number(raw) || 0;
      if (value2 > 0) total += value2;
    });
    return total;
  };
  const getBaseScore = (key2) => {
    const stored = statsBase[key2];
    if (Number.isFinite(stored)) return Number(stored);
    const current = getScore(key2);
    const nonAsi = getNonAsiBonusSumForStat(key2);
    const requestedAsi = getRequestedAsiBonus(key2);
    return Math.max(1, current - nonAsi - requestedAsi);
  };
  const getAsiBonusMap = () => {
    const requested = {};
    Object.values(asiSelections).forEach((entry) => {
      if (!entry || entry.type !== "asi" || !entry.stats) return;
      Object.entries(entry.stats).forEach(([stat, value2]) => {
        const amount = Number(value2) || 0;
        if (amount <= 0) return;
        requested[stat] = (requested[stat] ?? 0) + amount;
      });
    });
    const capped = {};
    STAT_KEYS.forEach((stat) => {
      const base = getBaseScore(stat);
      const other = getNonAsiBonusSumForStat(stat);
      const cap = 20 - (base + other);
      const available = cap > 0 ? cap : 0;
      const want = requested[stat] ?? 0;
      capped[stat] = Math.max(0, Math.min(want, available));
    });
    return capped;
  };
  const asiBonusMap = reactExports.useMemo(() => getAsiBonusMap(), [
    asiSelections,
    statBonuses,
    statsBase,
    (_v = props.character) == null ? void 0 : _v.caracs
  ]);
  const getBonusSumForStat = (key2) => getNonAsiBonusSumForStat(key2) + (asiBonusMap[key2] ?? 0);
  reactExports.useEffect(() => {
    if (!(classPrimary == null ? void 0 : classPrimary.id)) return;
    const legacyKeys = Object.keys(asiSelections).filter((key2) => /^\d+$/.test(key2));
    if (legacyKeys.length === 0) return;
    const nextAsi = { ...asiSelections };
    let changed = false;
    for (const levelKey of legacyKeys) {
      const newKey = `${classPrimary.id}:${levelKey}`;
      if (!nextAsi[newKey]) {
        nextAsi[newKey] = nextAsi[levelKey];
        changed = true;
      }
      delete nextAsi[levelKey];
      changed = true;
    }
    if (!changed) return;
    props.onChangeCharacter({
      ...props.character,
      choiceSelections: { ...choiceSelections, asi: nextAsi }
    });
  }, [asiSelections, classPrimary == null ? void 0 : classPrimary.id, props.character, props.onChangeCharacter, choiceSelections]);
  const getStatSources = (key2) => {
    const sources2 = [
      ...statBonuses.filter((bonus) => bonus.stat === key2).map((bonus) => bonus.source),
      ...asiBonusMap[key2] ? ["asi"] : []
    ];
    return Array.from(new Set(sources2.filter(Boolean)));
  };
  const buildCaracsFromTotals = (scores) => {
    const mapping = {
      FOR: "force",
      DEX: "dexterite",
      CON: "constitution",
      INT: "intelligence",
      SAG: "sagesse",
      CHA: "charisme"
    };
    const nextCaracs = { ...props.character.caracs ?? {} };
    const nextMods = {
      modFOR: 0,
      modDEX: 0,
      modCON: 0,
      modINT: 0,
      modSAG: 0,
      modCHA: 0
    };
    Object.keys(mapping).forEach((key2) => {
      var _a2;
      const nextScore = Math.max(1, Math.min(30, Math.floor(scores[key2] || 1)));
      const caracKey = mapping[key2];
      const modValue = computeMod(nextScore);
      nextCaracs[caracKey] = {
        ...((_a2 = props.character.caracs) == null ? void 0 : _a2[caracKey]) ?? {},
        [key2]: nextScore,
        [`mod${key2}`]: modValue
      };
      nextMods[`mod${key2}`] = modValue;
    });
    const nextCombatStats = {
      ...props.character.combatStats ?? {},
      mods: nextMods
    };
    return { nextCaracs, nextCombatStats };
  };
  const setBaseScores = (scores) => {
    const totals = {};
    STAT_KEYS.forEach((key2) => {
      const bonus = getBonusSumForStat(key2);
      const base = Math.max(1, Math.min(30, Math.floor(scores[key2] || 1)));
      let total = base + bonus;
      if (total > 30) total = 30;
      totals[key2] = total;
    });
    const { nextCaracs, nextCombatStats } = buildCaracsFromTotals(totals);
    const nextChoiceSelections = {
      ...choiceSelections,
      statsBase: { ...statsBase, ...scores }
    };
    props.onChangeCharacter({
      ...props.character,
      choiceSelections: nextChoiceSelections,
      caracs: nextCaracs,
      combatStats: nextCombatStats
    });
  };
  reactExports.useEffect(() => {
    const baseScores = getBaseScoresSnapshot();
    const totals = {};
    let changed = false;
    STAT_KEYS.forEach((key2) => {
      const bonus = getBonusSumForStat(key2);
      const base = Math.max(1, Math.min(30, Math.floor(baseScores[key2] || 1)));
      const total = Math.max(1, Math.min(30, Math.floor(base + bonus)));
      totals[key2] = total;
      if (getScore(key2) !== total) changed = true;
    });
    if (!changed) return;
    const { nextCaracs, nextCombatStats } = buildCaracsFromTotals(totals);
    props.onChangeCharacter({
      ...props.character,
      caracs: nextCaracs,
      combatStats: nextCombatStats
    });
  }, [statBonuses, asiBonusMap, statsBase, (_w = props.character) == null ? void 0 : _w.caracs, (_x = props.character) == null ? void 0 : _x.id]);
  const resetStats = () => {
    if (!initialStatsRef.current) return;
    setBaseScores(initialStatsRef.current);
  };
  const resetStatsFromBase = () => {
    const snapshot = getBaseScoresSnapshot();
    setBaseScores(snapshot);
  };
  const resetSkills = () => {
    const baseSkills = getBackgroundSkillProficiencies(activeBackground);
    props.onChangeCharacter({
      ...props.character,
      competences: [...baseSkills],
      expertises: []
    });
  };
  const resetMasteries = () => {
    var _a2;
    const primaryProfs = (classPrimary == null ? void 0 : classPrimary.proficiencies) ?? {};
    const secondaryProfs = (classSecondary == null ? void 0 : classSecondary.proficiencies) ?? {};
    const backgroundTools = [
      ...getBackgroundToolProficiencies(activeBackground),
      ...((_a2 = choiceSelections == null ? void 0 : choiceSelections.background) == null ? void 0 : _a2.tools) ?? []
    ];
    const nextProfs = {
      weapons: Array.from(
        /* @__PURE__ */ new Set([...primaryProfs.weapons ?? [], ...secondaryProfs.weapons ?? []])
      ),
      armors: Array.from(
        /* @__PURE__ */ new Set([...primaryProfs.armors ?? [], ...secondaryProfs.armors ?? []])
      ),
      tools: Array.from(
        /* @__PURE__ */ new Set([
          ...primaryProfs.tools ?? [],
          ...secondaryProfs.tools ?? [],
          ...backgroundTools
        ])
      )
    };
    props.onChangeCharacter({ ...props.character, proficiencies: nextProfs });
  };
  const applySkillsAndMasteriesReset = (base) => {
    var _a2;
    const baseSkills = getBackgroundSkillProficiencies(activeBackground);
    const primaryProfs = (classPrimary == null ? void 0 : classPrimary.proficiencies) ?? {};
    const secondaryProfs = (classSecondary == null ? void 0 : classSecondary.proficiencies) ?? {};
    const backgroundTools = [
      ...getBackgroundToolProficiencies(activeBackground),
      ...((_a2 = choiceSelections == null ? void 0 : choiceSelections.background) == null ? void 0 : _a2.tools) ?? []
    ];
    const nextProfs = {
      weapons: Array.from(
        /* @__PURE__ */ new Set([...primaryProfs.weapons ?? [], ...secondaryProfs.weapons ?? []])
      ),
      armors: Array.from(
        /* @__PURE__ */ new Set([...primaryProfs.armors ?? [], ...secondaryProfs.armors ?? []])
      ),
      tools: Array.from(
        /* @__PURE__ */ new Set([
          ...primaryProfs.tools ?? [],
          ...secondaryProfs.tools ?? [],
          ...backgroundTools
        ])
      )
    };
    return {
      ...base,
      competences: [...baseSkills],
      expertises: [],
      proficiencies: nextProfs
    };
  };
  const pruneStatBonusesBySource = (sources2) => {
    const existing = (choiceSelections == null ? void 0 : choiceSelections.statBonuses) ?? [];
    if (!Array.isArray(existing) || existing.length === 0) return null;
    const next = existing.filter((entry) => !sources2.includes(String(entry.source ?? "")));
    if (next.length === existing.length) return null;
    return next;
  };
  const applyBackgroundSelection = (bg) => {
    var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2;
    const nextSkills = Array.from(
      /* @__PURE__ */ new Set([...competences ?? [], ...getBackgroundSkillProficiencies(bg)])
    );
    const currentProfs = ((_a2 = props.character) == null ? void 0 : _a2.proficiencies) ?? {};
    const nextProfs = {
      ...currentProfs,
      tools: Array.from(
        /* @__PURE__ */ new Set([...currentProfs.tools ?? [], ...getBackgroundToolProficiencies(bg)])
      )
    };
    const nextChoiceSelections = {
      ...choiceSelections,
      background: { ...choiceSelections.background }
    };
    let nextCaracs = props.character.caracs;
    const bonusApplied = Boolean((_b2 = choiceSelections == null ? void 0 : choiceSelections.background) == null ? void 0 : _b2.statBonusApplied);
    if (bonusApplied && bg.id !== "veteran-de-guerre") {
      const current = ((_d2 = (_c2 = props.character.caracs) == null ? void 0 : _c2.force) == null ? void 0 : _d2.FOR) ?? 10;
      nextCaracs = {
        ...props.character.caracs,
        force: { ...((_e2 = props.character.caracs) == null ? void 0 : _e2.force) ?? {}, FOR: current - 1 }
      };
      nextChoiceSelections.background.statBonusApplied = false;
      nextChoiceSelections.statsBase = {
        ...statsBase,
        FOR: Number.isFinite(statsBase.FOR) ? statsBase.FOR : current - 1
      };
    }
    if (!bonusApplied && bg.id === "veteran-de-guerre") {
      const needsImmediateBonus = !getBackgroundToolChoice(bg) && !getBackgroundLanguageChoice(bg);
      if (needsImmediateBonus) {
        const current = ((_g2 = (_f2 = props.character.caracs) == null ? void 0 : _f2.force) == null ? void 0 : _g2.FOR) ?? 10;
        nextCaracs = {
          ...props.character.caracs,
          force: { ...((_h2 = props.character.caracs) == null ? void 0 : _h2.force) ?? {}, FOR: current + 1 }
        };
        nextChoiceSelections.background.statBonusApplied = true;
        nextChoiceSelections.statsBase = {
          ...statsBase,
          FOR: Number.isFinite(statsBase.FOR) ? statsBase.FOR : current
        };
      }
    }
    props.onChangeCharacter({
      ...props.character,
      backgroundId: bg.id,
      competences: nextSkills,
      proficiencies: nextProfs,
      choiceSelections: nextChoiceSelections,
      caracs: nextCaracs
    });
  };
  const lockBackgroundAndCreateEquipment = () => {
    var _a2, _b2, _c2, _d2;
    if (!activeBackground) return;
    const bonusApplied = Boolean((_a2 = choiceSelections == null ? void 0 : choiceSelections.background) == null ? void 0 : _a2.statBonusApplied);
    let nextCaracs = props.character.caracs;
    const nextChoiceSelections = {
      ...choiceSelections,
      background: { ...choiceSelections.background }
    };
    if (!bonusApplied && selectedBackgroundId === "veteran-de-guerre") {
      const current = ((_c2 = (_b2 = props.character.caracs) == null ? void 0 : _b2.force) == null ? void 0 : _c2.FOR) ?? 10;
      nextCaracs = {
        ...props.character.caracs,
        force: { ...((_d2 = props.character.caracs) == null ? void 0 : _d2.force) ?? {}, FOR: current + 1 }
      };
      nextChoiceSelections.background.statBonusApplied = true;
      nextChoiceSelections.statsBase = {
        ...statsBase,
        FOR: Number.isFinite(statsBase.FOR) ? statsBase.FOR : current
      };
    }
    const backgroundEquip = Array.isArray(activeBackground.equipment) ? activeBackground.equipment : [];
    const { nextAuto, nextInventory } = addAutoItemsToState(
      equipmentAuto,
      inventoryItems,
      backgroundEquip,
      { kind: "background", id: activeBackground.id }
    );
    const nextCharacter = applySkillsAndMasteriesReset({
      ...props.character,
      creationLocks: { ...creationLocks, backgrounds: true },
      choiceSelections: nextChoiceSelections,
      caracs: nextCaracs,
      equipmentAuto: nextAuto,
      inventoryItems: nextInventory
    });
    props.onChangeCharacter(nextCharacter);
  };
  const sourceColors = {
    race: "#2ecc71",
    background: "#f1c40f",
    classPrimary: "#4f7df2",
    subclassPrimary: "#6e8cff",
    classSecondary: "#7dc7ff",
    subclassSecondary: "#9ad4ff",
    asi: "#9b59b6",
    feat: "#e67e22",
    equipment: "#16a085"
  };
  const tabAccentColors = {
    species: sourceColors.race,
    backgrounds: sourceColors.background,
    classes: sourceColors.classPrimary,
    profile: "#e67e22",
    stats: "#f39c12",
    magic: "#8e44ad",
    equip: sourceColors.equipment,
    skills: "#3498db",
    masteries: "#1abc9c"
  };
  const toRgba = (hex, alpha) => {
    if (!hex || typeof hex !== "string") return `rgba(255,255,255,${alpha})`;
    const normalized = hex.replace("#", "");
    if (normalized.length !== 6) return `rgba(255,255,255,${alpha})`;
    const r2 = parseInt(normalized.slice(0, 2), 16);
    const g2 = parseInt(normalized.slice(2, 4), 16);
    const b2 = parseInt(normalized.slice(4, 6), 16);
    if (!Number.isFinite(r2) || !Number.isFinite(g2) || !Number.isFinite(b2)) {
      return `rgba(255,255,255,${alpha})`;
    }
    return `rgba(${r2}, ${g2}, ${b2}, ${alpha})`;
  };
  const renderSourceDots = (sources2) => {
    if (sources2.length === 0) return null;
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", gap: 4 }, children: sources2.map((source2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "span",
      {
        title: source2,
        style: {
          width: 8,
          height: 8,
          borderRadius: 999,
          background: sourceColors[source2] ?? "#999",
          display: "inline-block"
        }
      },
      source2
    )) });
  };
  const renderSourceDotsWithLabels = (sources2) => {
    if (sources2.length === 0) return null;
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", gap: 4 }, children: sources2.map((source2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "span",
      {
        title: source2.label,
        style: {
          width: 8,
          height: 8,
          borderRadius: 999,
          background: sourceColors[source2.key] ?? "#999",
          display: "inline-block"
        }
      },
      source2.key
    )) });
  };
  const getSkillSources = (skillId) => {
    var _a2, _b2, _c2, _d2, _e2;
    const sources2 = [];
    if (((_a2 = choiceSelections == null ? void 0 : choiceSelections.race) == null ? void 0 : _a2.adaptableSkill) === skillId) sources2.push("race");
    if (getBackgroundSkillProficiencies(activeBackground).includes(skillId)) sources2.push("background");
    if ((_c2 = (_b2 = classPrimary == null ? void 0 : classPrimary.proficiencies) == null ? void 0 : _b2.skills) == null ? void 0 : _c2.includes(skillId)) sources2.push("classPrimary");
    if ((_e2 = (_d2 = classSecondary == null ? void 0 : classSecondary.proficiencies) == null ? void 0 : _d2.skills) == null ? void 0 : _e2.includes(skillId)) sources2.push("classSecondary");
    return sources2;
  };
  const getMasterySources = (kind2, id2) => {
    var _a2, _b2, _c2, _d2, _e2;
    const sources2 = [];
    if ((_b2 = (_a2 = classPrimary == null ? void 0 : classPrimary.proficiencies) == null ? void 0 : _a2[kind2]) == null ? void 0 : _b2.includes(id2)) sources2.push("classPrimary");
    if ((_d2 = (_c2 = classSecondary == null ? void 0 : classSecondary.proficiencies) == null ? void 0 : _c2[kind2]) == null ? void 0 : _d2.includes(id2)) sources2.push("classSecondary");
    if (kind2 === "tools" && (getBackgroundToolProficiencies(activeBackground).includes(id2) || (((_e2 = choiceSelections == null ? void 0 : choiceSelections.background) == null ? void 0 : _e2.tools) ?? []).includes(id2))) {
      sources2.push("background");
    }
    return sources2;
  };
  const [choiceModal, setChoiceModal] = reactExports.useState({
    open: false,
    title: "",
    options: [],
    selected: [],
    count: 1,
    multi: false,
    onConfirm: () => void 0
  });
  const [confirmModal, setConfirmModal] = reactExports.useState({
    open: false,
    title: "",
    message: "",
    onConfirm: () => void 0
  });
  const [asiModal, setAsiModal] = reactExports.useState({
    open: false,
    entry: null,
    step: "type",
    type: "asi",
    stats: {},
    originalStats: {}
  });
  const getSectionValidated = (id2) => {
    if (id2 === "classes") {
      const hasSecondary = Boolean(secondaryClassEntry == null ? void 0 : secondaryClassEntry.classeId);
      return Boolean(classLocks.primary) && (!hasSecondary || Boolean(classLocks.secondary));
    }
    return isSectionLocked(id2);
  };
  const renderValidatedBadge = (validated) => {
    if (!validated) return null;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "span",
      {
        style: {
          marginLeft: "auto",
          padding: "2px 6px",
          borderRadius: 999,
          border: "1px solid rgba(46, 204, 113, 0.6)",
          background: "rgba(46, 204, 113, 0.16)",
          color: "#e8fff2",
          fontSize: 10,
          fontWeight: 800,
          letterSpacing: 0.2
        },
        children: "Valide"
      }
    );
  };
  const openChoiceModal = (config) => {
    setChoiceModal({ open: true, ...config });
  };
  const closeChoiceModal = () => {
    setChoiceModal((prev) => ({ ...prev, open: false }));
  };
  const closeConfirmModal = () => {
    setConfirmModal((prev) => ({ ...prev, open: false }));
  };
  const handleChoiceToggle = (id2) => {
    setChoiceModal((prev) => {
      const already = prev.selected.includes(id2);
      let next = prev.selected;
      if (prev.multi) {
        next = already ? next.filter((item) => item !== id2) : [...next, id2];
      } else {
        next = already ? [] : [id2];
      }
      return { ...prev, selected: next };
    });
  };
  const handleChoiceConfirm = () => {
    if (choiceModal.selected.length < choiceModal.count) return;
    choiceModal.onConfirm(choiceModal.selected.slice(0, choiceModal.count));
    closeChoiceModal();
  };
  const applyHumanAdaptableSkill = (skillId) => {
    const nextChoiceSelections = {
      ...choiceSelections,
      race: { ...choiceSelections.race, adaptableSkill: skillId }
    };
    const nextSkills = Array.from(/* @__PURE__ */ new Set([...competences ?? [], skillId]));
    const nextPending = { ...pendingLocks };
    if (pendingLocks.species) delete nextPending.species;
    props.onChangeCharacter({
      ...props.character,
      choiceSelections: { ...nextChoiceSelections, pendingLocks: nextPending },
      competences: nextSkills,
      creationLocks: pendingLocks.species ? { ...creationLocks, species: true } : creationLocks
    });
  };
  const applyBackgroundToolChoices = (selected) => {
    var _a2, _b2, _c2, _d2, _e2;
    const nextChoiceSelections = {
      ...choiceSelections,
      background: { ...choiceSelections.background, tools: selected }
    };
    const currentProfs = ((_a2 = props.character) == null ? void 0 : _a2.proficiencies) ?? {};
    const nextProfs = {
      ...currentProfs,
      tools: Array.from(/* @__PURE__ */ new Set([...currentProfs.tools ?? [], ...selected]))
    };
    const nextPending = { ...pendingLocks };
    let nextCaracs = props.character.caracs;
    let nextLocks = creationLocks;
    const remainingChoicesAfter = getPendingBackgroundChoiceCount(
      nextChoiceSelections.background ?? {}
    );
    if (pendingLocks.backgrounds && remainingChoicesAfter <= 0) {
      delete nextPending.backgrounds;
      nextLocks = { ...creationLocks, backgrounds: true };
      const bonusApplied = Boolean((_b2 = choiceSelections == null ? void 0 : choiceSelections.background) == null ? void 0 : _b2.statBonusApplied);
      if (!bonusApplied && selectedBackgroundId === "veteran-de-guerre") {
        const current = ((_d2 = (_c2 = props.character.caracs) == null ? void 0 : _c2.force) == null ? void 0 : _d2.FOR) ?? 10;
        nextCaracs = {
          ...props.character.caracs,
          force: { ...((_e2 = props.character.caracs) == null ? void 0 : _e2.force) ?? {}, FOR: current + 1 }
        };
        nextChoiceSelections.background.statBonusApplied = true;
        nextChoiceSelections.statsBase = {
          ...statsBase,
          FOR: Number.isFinite(statsBase.FOR) ? statsBase.FOR : current
        };
      }
    }
    props.onChangeCharacter({
      ...props.character,
      choiceSelections: { ...nextChoiceSelections, pendingLocks: nextPending },
      proficiencies: nextProfs,
      creationLocks: nextLocks,
      caracs: nextCaracs
    });
    if (pendingLocks.backgrounds) {
      requireBackgroundChoices();
    }
  };
  const applyBackgroundLanguageChoices = (selected) => {
    var _a2, _b2, _c2, _d2, _e2;
    const nextChoiceSelections = {
      ...choiceSelections,
      background: { ...choiceSelections.background, languages: selected }
    };
    const currentLangues = (_a2 = props.character) == null ? void 0 : _a2.langues;
    const currentList = Array.isArray(currentLangues) ? currentLangues : typeof currentLangues === "string" ? currentLangues.split(",").map((item) => item.trim()).filter(Boolean) : [];
    const nextLangues = Array.from(/* @__PURE__ */ new Set([...currentList, ...selected]));
    const nextPending = { ...pendingLocks };
    let nextCaracs = props.character.caracs;
    let nextLocks = creationLocks;
    const remainingChoicesAfter = getPendingBackgroundChoiceCount(
      nextChoiceSelections.background ?? {}
    );
    if (pendingLocks.backgrounds && remainingChoicesAfter <= 0) {
      delete nextPending.backgrounds;
      nextLocks = { ...creationLocks, backgrounds: true };
      const bonusApplied = Boolean((_b2 = choiceSelections == null ? void 0 : choiceSelections.background) == null ? void 0 : _b2.statBonusApplied);
      if (!bonusApplied && selectedBackgroundId === "veteran-de-guerre") {
        const current = ((_d2 = (_c2 = props.character.caracs) == null ? void 0 : _c2.force) == null ? void 0 : _d2.FOR) ?? 10;
        nextCaracs = {
          ...props.character.caracs,
          force: { ...((_e2 = props.character.caracs) == null ? void 0 : _e2.force) ?? {}, FOR: current + 1 }
        };
        nextChoiceSelections.background.statBonusApplied = true;
        nextChoiceSelections.statsBase = {
          ...statsBase,
          FOR: Number.isFinite(statsBase.FOR) ? statsBase.FOR : current
        };
      }
    }
    props.onChangeCharacter({
      ...props.character,
      choiceSelections: { ...nextChoiceSelections, pendingLocks: nextPending },
      langues: nextLangues,
      creationLocks: nextLocks,
      caracs: nextCaracs
    });
    if (pendingLocks.backgrounds) {
      requireBackgroundChoices();
    }
  };
  const requireRaceChoices = () => {
    var _a2;
    if (!hasRaceTrait("adaptable")) return false;
    const adaptableSkill = (_a2 = choiceSelections == null ? void 0 : choiceSelections.race) == null ? void 0 : _a2.adaptableSkill;
    if (!adaptableSkill) {
      openChoiceModal({
        title: `${(activeRace == null ? void 0 : activeRace.label) ?? "Espece"} - Choisir une competence`,
        options: competenceOptions.map((skill) => ({ id: skill.id, label: skill.label })),
        selected: [],
        count: 1,
        multi: false,
        onConfirm: (selected) => applyHumanAdaptableSkill(selected[0])
      });
      return true;
    }
    return false;
  };
  const requireBackgroundChoices = () => {
    if (!activeBackground) return false;
    const backgroundChoices = (choiceSelections == null ? void 0 : choiceSelections.background) ?? {};
    const toolChoices = getBackgroundToolChoice(activeBackground);
    if (toolChoices && toolChoices.count > 0) {
      const existing = Array.isArray(backgroundChoices.tools) ? backgroundChoices.tools : [];
      if (existing.length < toolChoices.count) {
        openChoiceModal({
          title: "Historique - Choisir un outil",
          options: (toolChoices.options ?? []).map((id2) => {
            var _a2;
            return {
              id: id2,
              label: ((_a2 = toolMasteryOptions.find((opt) => opt.id === id2)) == null ? void 0 : _a2.label) ?? id2
            };
          }),
          selected: existing,
          count: toolChoices.count,
          multi: toolChoices.count > 1,
          onConfirm: (selected) => applyBackgroundToolChoices(selected)
        });
        return true;
      }
    }
    const languageChoices = getBackgroundLanguageChoice(activeBackground);
    if (languageChoices && languageChoices.count > 0) {
      const existing = Array.isArray(backgroundChoices.languages) ? backgroundChoices.languages : [];
      if (existing.length < languageChoices.count) {
        openChoiceModal({
          title: "Historique - Choisir des langues",
          options: languageOptions.map((lang) => ({ id: lang.id, label: lang.label })),
          selected: existing,
          count: languageChoices.count,
          multi: languageChoices.count > 1,
          onConfirm: (selected) => applyBackgroundLanguageChoices(selected)
        });
        return true;
      }
    }
    return false;
  };
  const resetMateriel = () => {
    var _a2;
    const nextMaterielSlots = { ...DEFAULT_MATERIEL_SLOTS };
    const nextArmesDefaut = {
      main_droite: null,
      main_gauche: null,
      mains: null
    };
    props.onChangeCharacter({
      ...props.character,
      materielSlots: nextMaterielSlots,
      armesDefaut: nextArmesDefaut,
      equipmentManual: [],
      inventoryItems: Array.isArray((_a2 = props.character) == null ? void 0 : _a2.inventoryItems) ? props.character.inventoryItems.map((item) => ({
        ...item,
        equippedSlot: null,
        storedIn: null,
        isPrimaryWeapon: false
      })) : []
    });
  };
  const parseItemSpec = (rawId) => {
    const parts = rawId.split(":");
    if (parts.length >= 2) {
      const [prefix, id2, qtyRaw] = parts;
      if (prefix === "weapon" || prefix === "armor" || prefix === "tool" || prefix === "object") {
        const qty = Math.max(1, Math.floor(Number(qtyRaw || 1)));
        return { type: prefix, id: id2, qty };
      }
    }
    return { type: null, id: rawId, qty: 1 };
  };
  const buildItemSpec = (type2, id2, qty) => {
    const safeQty = Math.max(1, Math.floor(Number(qty || 1)));
    if (type2 === "object" && (safeQty > 1 || isCoinId(id2))) {
      return `object:${id2}:${safeQty}`;
    }
    return safeQty > 1 ? `${type2}:${id2}:${safeQty}` : id2;
  };
  const resolveItemType = (rawId) => {
    const parsed = parseItemSpec(rawId);
    if (parsed.type === "weapon") return { type: "weapon", id: parsed.id, qty: parsed.qty };
    if (parsed.type === "armor") return { type: "armor", id: parsed.id, qty: parsed.qty };
    if (parsed.type === "tool") return { type: "tool", id: parsed.id, qty: parsed.qty };
    if (parsed.type === "object") return { type: "object", id: parsed.id, qty: parsed.qty };
    if (objectItemMap.has(parsed.id)) return { type: "object", id: parsed.id, qty: parsed.qty };
    if (armorItemMap.has(parsed.id)) return { type: "armor", id: parsed.id, qty: parsed.qty };
    if (toolItemMap.has(parsed.id)) return { type: "tool", id: parsed.id, qty: parsed.qty };
    if (weaponItemMap.has(parsed.id)) return { type: "weapon", id: parsed.id, qty: parsed.qty };
    return { type: "object", id: parsed.id, qty: parsed.qty };
  };
  const formatEquipmentLabel = (rawId) => {
    var _a2, _b2, _c2, _d2;
    const resolved = resolveItemType(rawId);
    const fallback = humanizeId(resolved.id);
    if (resolved.type === "object") return ((_a2 = objectItemMap.get(resolved.id)) == null ? void 0 : _a2.label) ?? fallback;
    if (resolved.type === "armor") return ((_b2 = armorItemMap.get(resolved.id)) == null ? void 0 : _b2.label) ?? fallback;
    if (resolved.type === "tool") return ((_c2 = toolItemMap.get(resolved.id)) == null ? void 0 : _c2.label) ?? fallback;
    if (resolved.type === "weapon") return ((_d2 = weaponItemMap.get(resolved.id)) == null ? void 0 : _d2.name) ?? fallback;
    return fallback;
  };
  const addAutoItemsToState = (baseAuto, baseInventory, specIds, origin) => {
    if (!specIds || specIds.length === 0) {
      return { nextAuto: baseAuto, nextInventory: baseInventory };
    }
    const resolvedSpecs = specIds.map((raw) => resolveItemType(raw));
    const entries = buildInventoryEntries(
      resolvedSpecs.map((spec) => ({ type: spec.type, id: spec.id, qty: spec.qty ?? 1 })),
      "auto",
      origin,
      createInstanceId
    );
    return {
      nextAuto: [...baseAuto, ...specIds],
      nextInventory: appendInventoryEntries(baseInventory, entries)
    };
  };
  const addManualItem = (id2) => {
    const nextManual = [...equipmentManual, id2];
    const resolved = resolveItemType(id2);
    const entries = buildInventoryEntries(
      [{ type: resolved.type, id: resolved.id, qty: resolved.qty ?? 1 }],
      "manual",
      { kind: "manual" },
      createInstanceId
    );
    const nextInventory = appendInventoryEntries(inventoryItems, entries);
    props.onChangeCharacter({
      ...props.character,
      equipmentManual: nextManual,
      inventoryItems: nextInventory
    });
  };
  const removeManualItem = (inventoryIndex) => {
    const target = inventoryItems[inventoryIndex];
    if (!target) return;
    if ((target.qty ?? 1) > 1) {
      const nextManual2 = updateEquipmentListQty(
        equipmentManual,
        resolveItemType,
        buildItemSpec,
        target.type,
        target.id,
        -1
      );
      const nextInventory2 = inventoryItems.map(
        (item, idx) => idx === inventoryIndex ? { ...item, qty: (item.qty ?? 1) - 1 } : item
      );
      props.onChangeCharacter({
        ...props.character,
        equipmentManual: nextManual2,
        inventoryItems: nextInventory2
      });
      return;
    }
    const nextManual = updateEquipmentListQty(
      equipmentManual,
      resolveItemType,
      buildItemSpec,
      target.type,
      target.id,
      -1
    );
    const slots = { ...materielSlots };
    if (target.equippedSlot && slots[target.equippedSlot]) {
      slots[target.equippedSlot] = null;
    }
    const nextInventory = inventoryItems.filter((_, idx) => idx !== inventoryIndex);
    props.onChangeCharacter({
      ...props.character,
      equipmentManual: nextManual,
      materielSlots: slots,
      inventoryItems: nextInventory
    });
  };
  const isCurrencyItem = (item) => (item == null ? void 0 : item.type) === "object" && isCoinId((item == null ? void 0 : item.id) ?? "");
  const getItemUnitValue = (item) => {
    if (!item) return null;
    if (item.type === "weapon") {
      const def = weaponItemMap.get(item.id);
      const value2 = def == null ? void 0 : def.value;
      if (!value2) return null;
      return {
        po: Number(value2.gold ?? 0) || 0,
        pa: Number(value2.silver ?? 0) || 0,
        pc: Number(value2.copper ?? 0) || 0
      };
    }
    if (item.type === "armor") {
      const def = armorItemMap.get(item.id);
      if (def == null ? void 0 : def.value) return def.value;
      if (Number.isFinite(def == null ? void 0 : def.priceGp)) {
        return { po: Number((def == null ? void 0 : def.priceGp) ?? 0) || 0 };
      }
      return null;
    }
    if (item.type === "object") {
      const def = objectItemMap.get(item.id);
      if (def == null ? void 0 : def.value) return def.value;
      if (Number.isFinite(def == null ? void 0 : def.priceGp)) {
        return { po: Number((def == null ? void 0 : def.priceGp) ?? 0) || 0 };
      }
      return null;
    }
    return null;
  };
  const addMoneyToInventory = (money, baseManual, baseInventory) => {
    const stacks = moneyToCoinStacks(money);
    if (stacks.length === 0) return { nextManual: baseManual, nextInventory: baseInventory };
    const entries = buildInventoryEntries(
      stacks.map((stack) => ({ type: "object", id: stack.id, qty: stack.qty })),
      "loot",
      void 0,
      createInstanceId
    );
    const nextInventory = appendInventoryEntries(baseInventory, entries);
    return { nextManual: baseManual, nextInventory };
  };
  const sellInventoryItem = (inventoryIndex) => {
    const target = inventoryItems[inventoryIndex];
    if (!target || isSectionLocked("equip")) return;
    if (isCurrencyItem(target)) return;
    const unitValue = getItemUnitValue(target);
    if (!unitValue || moneyToCopper(unitValue) <= 0) return;
    const soldValue = scaleMoney(unitValue, 1);
    const nextAuto = target.source === "auto" ? updateEquipmentListQty(
      equipmentAuto,
      resolveItemType,
      buildItemSpec,
      target.type,
      target.id,
      -1
    ) : equipmentAuto;
    const nextManual = target.source === "manual" ? updateEquipmentListQty(
      equipmentManual,
      resolveItemType,
      buildItemSpec,
      target.type,
      target.id,
      -1
    ) : equipmentManual;
    const slots = { ...materielSlots };
    let nextInventory = [...inventoryItems];
    if ((target.qty ?? 1) > 1) {
      nextInventory = nextInventory.map(
        (item, idx) => idx === inventoryIndex ? { ...item, qty: (item.qty ?? 1) - 1 } : item
      );
    } else {
      if (target.equippedSlot && slots[target.equippedSlot]) {
        slots[target.equippedSlot] = null;
      }
      nextInventory = nextInventory.filter((_, idx) => idx !== inventoryIndex);
    }
    const moneyResult = addMoneyToInventory(soldValue, nextManual, nextInventory);
    props.onChangeCharacter({
      ...props.character,
      equipmentAuto: nextAuto,
      equipmentManual: moneyResult.nextManual,
      materielSlots: slots,
      inventoryItems: moneyResult.nextInventory
    });
  };
  const handleSellRequest = (index, item, itemValue) => {
    const label2 = getItemLabel(item);
    const valueLabel = itemValue ? formatMoneyValue(itemValue) : "0";
    setConfirmModal({
      open: true,
      title: "Avertissement",
      message: `Vendre ${label2} ? Gains: ${valueLabel}. L'objet sera supprime de l'inventaire.`,
      onConfirm: () => {
        sellInventoryItem(index);
        closeConfirmModal();
      }
    });
  };
  const updateItemSlot = (index, slot) => {
    var _a2;
    const targetItem = inventoryItems[index];
    if (!targetItem) return;
    if (slot && !EQUIPMENT_SLOTS.find((s2) => s2.id === slot)) return;
    const categories = getItemCategories(targetItem);
    if (slot) {
      const slotDef = EQUIPMENT_SLOTS.find((s2) => s2.id === slot);
      if (!slotDef) return;
      if (slotDef.requiresClothingBody && !canUseClothingPieces) return;
      if (!categories.some((cat) => slotDef.accepts.includes(cat))) return;
      if (packSlots.has(slot)) {
        const limit = packSlotMaxWeight[slot];
        if (typeof limit === "number") {
          const totalWeight = getPackTotalWeightForItem(targetItem);
          if (totalWeight > limit) {
            setEquipMessage("Ce sac depasse la limite de 5.2kg pour la ceinture.");
            return;
          }
        }
      }
    }
    const previousSlots = { ...materielSlots };
    const slots = { ...materielSlots };
    let nextInventory = inventoryItems.map((item, idx) => {
      if (idx === index) return item;
      if (slot && item.equippedSlot === slot) {
        return { ...item, equippedSlot: null };
      }
      return item;
    });
    const keepPrimary = targetItem.type === "weapon" && slot && weaponCarrySlots.has(slot) ? Boolean(targetItem.isPrimaryWeapon) : false;
    const nextForTarget = {
      ...targetItem,
      equippedSlot: slot,
      storedIn: null,
      isPrimaryWeapon: keepPrimary
    };
    nextInventory[index] = nextForTarget;
    if (targetItem.equippedSlot && slots[targetItem.equippedSlot]) {
      slots[targetItem.equippedSlot] = null;
    }
    if (slot) {
      slots[slot] = targetItem.id ?? null;
    }
    if (slot === "corps") {
      const isArmor = categories.includes("armor_body");
      if (isArmor) {
        for (const subSlot of clothingSubSlots) {
          const subId = slots[subSlot];
          if (subId) {
            slots[subSlot] = null;
            for (let i2 = 0; i2 < nextInventory.length; i2 += 1) {
              if (((_a2 = nextInventory[i2]) == null ? void 0 : _a2.equippedSlot) === subSlot) {
                nextInventory[i2] = { ...nextInventory[i2], equippedSlot: null };
              }
            }
          }
        }
      }
    }
    const wasPackSlot = targetItem.equippedSlot && packSlots.has(targetItem.equippedSlot);
    const isPackSlot = slot && packSlots.has(slot);
    if (isPackSlot) {
      const destPrevBagId = previousSlots[slot] ?? null;
      if (destPrevBagId && slot !== targetItem.equippedSlot) {
        nextInventory = nextInventory.map((item) => {
          const inDest = (item == null ? void 0 : item.storedIn) === slot || slot === "paquetage" && (item == null ? void 0 : item.storedIn) === destPrevBagId;
          if (!inDest) return item;
          return { ...item, storedIn: null };
        });
      }
      if (wasPackSlot && targetItem.equippedSlot && targetItem.equippedSlot !== slot) {
        const fromSlot = targetItem.equippedSlot;
        const fromBagId = previousSlots[fromSlot] ?? null;
        nextInventory = nextInventory.map((item) => {
          const inFrom = (item == null ? void 0 : item.storedIn) === fromSlot || fromSlot === "paquetage" && fromBagId && (item == null ? void 0 : item.storedIn) === fromBagId;
          if (!inFrom) return item;
          return { ...item, storedIn: slot };
        });
      }
    }
    if (!slot && wasPackSlot && targetItem.equippedSlot) {
      const fromSlot = targetItem.equippedSlot;
      const fromBagId = previousSlots[fromSlot] ?? null;
      nextInventory = nextInventory.map((item) => {
        const inFrom = (item == null ? void 0 : item.storedIn) === fromSlot || fromSlot === "paquetage" && fromBagId && (item == null ? void 0 : item.storedIn) === fromBagId;
        if (!inFrom) return item;
        return { ...item, storedIn: null };
      });
    }
    props.onChangeCharacter({
      ...props.character,
      materielSlots: slots,
      inventoryItems: nextInventory
    });
  };
  const storeItemInPack = (index, slotId) => {
    if (!packSlots.has(slotId)) return;
    const previousSlots = { ...materielSlots };
    const bagId = getPackSlotItemId(slotId);
    const bagCapacity = getPackCapacity(slotId);
    if (!bagId || bagCapacity <= 0) return;
    const item = inventoryItems[index];
    if (!item) return;
    const containerItem = inventoryItems.find(
      (entry) => (entry == null ? void 0 : entry.equippedSlot) === slotId && (entry == null ? void 0 : entry.id) === bagId
    );
    if (containerItem && containerItem === item) {
      setEquipMessage("Impossible de ranger un sac dans lui-meme.");
      return;
    }
    const itemWeight = getItemWeight(item) * (Number((item == null ? void 0 : item.qty) ?? 1) || 1);
    const storedWeight = getStoredWeightForSlot(slotId);
    const slotLimit = packSlotMaxWeight[slotId];
    const bagWeight = containerItem ? getItemWeight(containerItem) : 0;
    if (item.storedIn !== slotId && storedWeight + itemWeight > bagCapacity) {
      setEquipMessage("Capacite du sac depassee.");
      return;
    }
    if (typeof slotLimit === "number" && item.storedIn !== slotId && bagWeight + storedWeight + itemWeight > slotLimit) {
      setEquipMessage("Ce sac depasse la limite de 5.2kg pour la ceinture.");
      return;
    }
    const slots = { ...materielSlots };
    let nextInventory = inventoryItems.map((entry, idx) => {
      if (idx !== index) return entry;
      return { ...entry, equippedSlot: null, storedIn: slotId, isPrimaryWeapon: false };
    });
    if (item.equippedSlot && slots[item.equippedSlot]) {
      const fromSlot = item.equippedSlot;
      slots[fromSlot] = null;
      if (packSlots.has(fromSlot)) {
        const fromBagId = previousSlots[fromSlot] ?? null;
        nextInventory = nextInventory.map((entry) => {
          const inFrom = (entry == null ? void 0 : entry.storedIn) === fromSlot || fromSlot === "paquetage" && fromBagId && (entry == null ? void 0 : entry.storedIn) === fromBagId;
          if (!inFrom) return entry;
          return { ...entry, storedIn: null };
        });
      }
    }
    props.onChangeCharacter({
      ...props.character,
      materielSlots: slots,
      inventoryItems: nextInventory
    });
  };
  const setPrimaryWeapon = (index) => {
    const item = inventoryItems[index];
    if (!item || item.type !== "weapon") return;
    if (!item.equippedSlot || !weaponCarrySlots.has(item.equippedSlot)) {
      setEquipMessage("L'arme principale doit etre equipee a la ceinture ou au dos.");
      return;
    }
    const weapon = weaponItemMap.get(item.id);
    const creatorConstraintAction = {
      id: "creator:set-primary-weapon",
      name: "Set Primary Weapon",
      category: "attack",
      actionCost: { actionType: "free", movementCost: 0 },
      targeting: {
        target: "enemy",
        range: { min: 0, max: 1.5, shape: "single" },
        maxTargets: 1,
        requiresLos: false
      },
      usage: { perTurn: null, perEncounter: null },
      conditions: [],
      components: { verbal: false, somatic: false, material: false }
    };
    const issues = getEquipmentConstraintIssues({
      action: creatorConstraintAction,
      inventoryItems,
      weaponById: weaponItemMap,
      armorById: armorItemMap,
      selectedWeapon: weapon ?? null,
      features: activeFeatureDefs
    });
    if (issues.length > 0) {
      setEquipMessage(issues[0]);
      return;
    }
    const nextInventory = inventoryItems.map((entry, idx) => ({
      ...entry,
      isPrimaryWeapon: idx === index
    }));
    props.onChangeCharacter({ ...props.character, inventoryItems: nextInventory });
  };
  const toggleItemHarmonization = (index) => {
    var _a2;
    const item = inventoryItems[index];
    if (!item) return;
    if (!isItemHarmonisable(item)) return;
    const nextState = !isInventoryItemHarmonized2(item);
    const nextInventory = inventoryItems.map((entry, idx) => {
      var _a3;
      if (idx !== index) return entry;
      const nextAttunement = nextState ? {
        ...(entry == null ? void 0 : entry.attunement) ?? {},
        state: "harmonized",
        harmonizedAt: typeof ((_a3 = entry == null ? void 0 : entry.attunement) == null ? void 0 : _a3.harmonizedAt) === "string" && entry.attunement.harmonizedAt.length > 0 ? entry.attunement.harmonizedAt : (/* @__PURE__ */ new Date()).toISOString()
      } : null;
      return {
        ...entry,
        harmonized: nextState,
        isHarmonized: nextState,
        attuned: nextState,
        attunement: nextAttunement
      };
    });
    const prevAttunements = ((_a2 = props.character) == null ? void 0 : _a2.attunements) ?? {};
    const nextAttunements = { ...prevAttunements };
    const keys = [];
    if (typeof (item == null ? void 0 : item.instanceId) === "string" && item.instanceId.length > 0) {
      keys.push(item.instanceId, `instance:${item.instanceId}`);
    }
    if (typeof (item == null ? void 0 : item.id) === "string" && item.id.length > 0) {
      keys.push(item.id, `item:${item.id}`);
    }
    keys.forEach((key2) => {
      if (!key2) return;
      if (nextState) nextAttunements[key2] = true;
      else delete nextAttunements[key2];
    });
    props.onChangeCharacter({
      ...props.character,
      inventoryItems: nextInventory,
      attunements: nextAttunements
    });
  };
  reactExports.useEffect(() => {
    if (inventoryInitRef.current) return;
    inventoryInitRef.current = true;
  }, []);
  const handleSpeciesSelect = (raceId) => {
    var _a2, _b2, _c2, _d2;
    const race = raceOptions.find((entry) => entry.id === raceId) ?? null;
    const baseActionIds = Array.isArray(race == null ? void 0 : race.actionIds) ? race == null ? void 0 : race.actionIds.filter(Boolean) : ["melee-strike", "dash"];
    const nextActionIds = Array.from(new Set(baseActionIds));
    const currentVision = ((_a2 = props.character) == null ? void 0 : _a2.visionProfile) ?? {};
    const raceVisionMode = String(((_b2 = race == null ? void 0 : race.vision) == null ? void 0 : _b2.mode) ?? "").toLowerCase();
    const raceVisionLight = raceVisionMode === "darkvision" ? "darkvision" : raceVisionMode === "lowlight" ? "lowlight" : "normal";
    const nextVisionProfile = {
      shape: currentVision.shape ?? "cone",
      range: typeof currentVision.range === "number" ? currentVision.range : Number(((_c2 = race == null ? void 0 : race.vision) == null ? void 0 : _c2.range) ?? 100) || 100,
      apertureDeg: currentVision.apertureDeg ?? 180,
      lightVision: raceVisionLight
    };
    const currentMovementModes = ((_d2 = props.character) == null ? void 0 : _d2.movementModes) ?? {};
    const nextMovementModes = {
      ...currentMovementModes,
      walk: typeof (race == null ? void 0 : race.speed) === "number" ? race.speed : Number(currentMovementModes.walk ?? 6) || 6
    };
    if (!isSectionLocked("species")) {
      props.onChangeCharacter({
        ...props.character,
        raceId,
        actionIds: nextActionIds,
        reactionIds: [],
        movementModes: nextMovementModes,
        visionProfile: nextVisionProfile
      });
      return;
    }
    setConfirmModal({
      open: true,
      title: "Changer l'espece",
      message: "Changer l'espece va deverouiller les onglets dependants et reinitialiser le materiel. Continuer ?",
      onConfirm: () => {
        var _a3;
        const nextLocks = { ...creationLocks };
        [
          "species",
          "backgrounds",
          "classes",
          "stats",
          "skills",
          "masteries",
          "equip",
          "profile"
        ].forEach((key2) => {
          delete nextLocks[key2];
        });
        const nextChoiceSelections = {
          ...choiceSelections,
          race: { ...choiceSelections.race }
        };
        const adaptableSkill = (_a3 = choiceSelections == null ? void 0 : choiceSelections.race) == null ? void 0 : _a3.adaptableSkill;
        if (adaptableSkill) {
          delete nextChoiceSelections.race.adaptableSkill;
        }
        const nextCompetences = adaptableSkill ? competences.filter((skill) => skill !== adaptableSkill) : competences;
        props.onChangeCharacter({
          ...props.character,
          raceId,
          actionIds: nextActionIds,
          reactionIds: [],
          movementModes: nextMovementModes,
          visionProfile: nextVisionProfile,
          creationLocks: nextLocks,
          classLock: false,
          classLocks: { primary: false, secondary: false },
          choiceSelections: nextChoiceSelections,
          competences: nextCompetences
        });
        resetMateriel();
        closeConfirmModal();
      }
    });
  };
  const handleBackgroundSelect = (bg) => {
    if (!isSectionLocked("backgrounds")) {
      applyBackgroundSelection(bg);
      return;
    }
    setConfirmModal({
      open: true,
      title: "Changer l'historique",
      message: "Changer l'historique va deverouiller les onglets dependants et reinitialiser le materiel. Continuer ?",
      onConfirm: () => {
        var _a2, _b2, _c2, _d2;
        const nextLocks = { ...creationLocks };
        ["backgrounds", "skills", "masteries", "equip"].forEach((key2) => {
          delete nextLocks[key2];
        });
        const prevBackground = activeBackground;
        const prevSkills = getBackgroundSkillProficiencies(prevBackground);
        const nextCompetences = prevSkills.length ? competences.filter((skill) => !prevSkills.includes(skill)) : competences;
        const nextChoiceSelections = {
          ...choiceSelections,
          background: {}
        };
        let nextCaracs = props.character.caracs;
        const bonusApplied = Boolean((_a2 = choiceSelections == null ? void 0 : choiceSelections.background) == null ? void 0 : _a2.statBonusApplied);
        if (bonusApplied) {
          const current = ((_c2 = (_b2 = props.character.caracs) == null ? void 0 : _b2.force) == null ? void 0 : _c2.FOR) ?? 10;
          nextCaracs = {
            ...props.character.caracs,
            force: { ...((_d2 = props.character.caracs) == null ? void 0 : _d2.force) ?? {}, FOR: current - 1 }
          };
          nextChoiceSelections.statsBase = {
            ...statsBase,
            FOR: Number.isFinite(statsBase.FOR) ? statsBase.FOR : current - 1
          };
        }
        props.onChangeCharacter({
          ...props.character,
          creationLocks: nextLocks,
          choiceSelections: nextChoiceSelections,
          competences: nextCompetences,
          classLock: false,
          classLocks: { primary: false, secondary: false },
          caracs: nextCaracs
        });
        applyBackgroundSelection(bg);
        resetMateriel();
        closeConfirmModal();
      }
    });
  };
  const handleClassSelect = (cls, slot) => {
    if (!isSectionLocked("classes")) {
      setClassSelection(cls, slot);
      return;
    }
    setConfirmModal({
      open: true,
      title: "Changer la classe",
      message: "Changer la classe va deverouiller les onglets dependants et reinitialiser le materiel. Continuer ?",
      onConfirm: () => {
        const nextLocks = { ...creationLocks };
        ["classes", "masteries", "skills", "equip"].forEach((key2) => {
          delete nextLocks[key2];
        });
        const nextChoiceSelections = {
          ...choiceSelections,
          classes: {}
        };
        props.onChangeCharacter({
          ...props.character,
          creationLocks: nextLocks,
          classLock: false,
          classLocks: { primary: false, secondary: false },
          choiceSelections: nextChoiceSelections
        });
        setClassSelection(cls, slot);
        resetMasteries();
        resetMateriel();
        closeConfirmModal();
      }
    });
  };
  const hasSubclassChoicePending = (slot) => {
    const clsId = slot === 1 ? selectedClassId : selectedSecondaryClassId;
    const entry = slot === 1 ? classEntry : secondaryClassEntry;
    const cls = classOptions.find((c2) => c2.id === clsId);
    if (!cls || !entry) return false;
    const threshold = cls.subclassLevel ?? 1;
    const level2 = Number(entry == null ? void 0 : entry.niveau) || 0;
    if (level2 < threshold) return false;
    const selectedSub = slot === 1 ? selectedSubclassId : selectedSecondarySubclassId;
    if (selectedSub) return false;
    const allowedIds = Array.isArray(cls.subclassIds) ? cls.subclassIds : [];
    const options = subclassOptions.filter((sub) => sub.classId === cls.id).filter((sub) => allowedIds.length === 0 || allowedIds.includes(sub.id)).map((sub) => ({ id: sub.id, label: sub.label }));
    return options.length > 0;
  };
  const promptSubclassChoiceForSlot = (slot, onDone) => {
    const clsId = slot === 1 ? selectedClassId : selectedSecondaryClassId;
    const entry = slot === 1 ? classEntry : secondaryClassEntry;
    const cls = classOptions.find((c2) => c2.id === clsId);
    if (!cls || !entry) return false;
    const threshold = cls.subclassLevel ?? 1;
    const level2 = Number(entry == null ? void 0 : entry.niveau) || 0;
    if (level2 < threshold) return false;
    const selectedSub = slot === 1 ? selectedSubclassId : selectedSecondarySubclassId;
    if (selectedSub) return false;
    const allowedIds = Array.isArray(cls.subclassIds) ? cls.subclassIds : [];
    const options = subclassOptions.filter((sub) => sub.classId === cls.id).filter((sub) => allowedIds.length === 0 || allowedIds.includes(sub.id)).map((sub) => ({ id: sub.id, label: sub.label }));
    if (options.length === 0) return false;
    openChoiceModal({
      title: "Choisir une sous-classe",
      options,
      selected: [],
      count: 1,
      multi: false,
      onConfirm: (selected) => {
        setSubclassSelection(selected[0], slot);
        if (onDone) onDone();
      }
    });
    return true;
  };
  const getOtherAsiSumForStat = (stat, entryKey, overrides) => {
    let total = 0;
    Object.entries(asiSelections).forEach(([key2, entry]) => {
      if (key2 === entryKey) return;
      const override = (overrides == null ? void 0 : overrides[key2]) ?? null;
      const effective = override ?? entry;
      if (!effective || effective.type !== "asi" || !effective.stats) return;
      total += Number(effective.stats[stat] ?? 0) || 0;
    });
    return total;
  };
  const canAllocateMoreAsi = (entryKey, stats, overrides) => {
    const spent = Object.values(stats).reduce((sum, value2) => sum + (Number(value2) || 0), 0);
    const remaining = Math.max(0, 2 - spent);
    if (remaining <= 0) return false;
    return STAT_KEYS.some((stat) => {
      const current = Number(stats[stat] ?? 0) || 0;
      if (current >= 2) return false;
      const base = getBaseScore(stat);
      const nonAsi = getNonAsiBonusSumForStat(stat);
      const otherAsi = getOtherAsiSumForStat(stat, entryKey, overrides);
      const total = base + nonAsi + otherAsi + current;
      return total < 20;
    });
  };
  const isAsiEntryComplete = (entry, entryKey, overrides) => {
    if (!entry) return false;
    if (entry.type === "feat") return true;
    const stats = entry.stats ?? {};
    const total = Object.values(stats).reduce(
      (sum, value2) => sum + (Number(value2) || 0),
      0
    );
    if (total >= 2) return true;
    if (!entryKey) return false;
    return !canAllocateMoreAsi(entryKey, stats, overrides);
  };
  const getMissingAsiEntries = (overrides) => {
    const entries = getClassAsiLevels();
    return entries.filter((entryInfo) => {
      const override = (overrides == null ? void 0 : overrides[entryInfo.key]) ?? null;
      const entry = override ?? getAsiEntryForLevel(entryInfo);
      return !isAsiEntryComplete(entry, entryInfo.key, overrides);
    });
  };
  const hasMissingAsiForSlot = (slot) => {
    const classId2 = slot === 1 ? classPrimary == null ? void 0 : classPrimary.id : classSecondary == null ? void 0 : classSecondary.id;
    if (!classId2) return false;
    return getMissingAsiEntries().some((entry) => entry.classId === classId2);
  };
  const getMissingAsiEntryForSlot = (slot) => {
    const classId2 = slot === 1 ? classPrimary == null ? void 0 : classPrimary.id : classSecondary == null ? void 0 : classSecondary.id;
    if (!classId2) return null;
    return getMissingAsiEntries().find((entry) => entry.classId === classId2) ?? null;
  };
  const getClassFeatureChoicesFromFeature = (featureId) => {
    const feature = featureById.get(String(featureId));
    const rules2 = (feature == null ? void 0 : feature.rules) ?? {};
    const rawChoices = Array.isArray(rules2 == null ? void 0 : rules2.choices) ? rules2.choices : [];
    return rawChoices.map((rawChoice, index) => {
      const keyRaw = String((rawChoice == null ? void 0 : rawChoice.key) ?? (rawChoice == null ? void 0 : rawChoice.id) ?? "").trim();
      const key2 = keyRaw || `choice-${index + 1}`;
      const count2 = Math.max(1, Math.floor(Number((rawChoice == null ? void 0 : rawChoice.count) ?? 1)));
      const titleRaw = String((rawChoice == null ? void 0 : rawChoice.title) ?? (rawChoice == null ? void 0 : rawChoice.label) ?? "").trim();
      const title = titleRaw || (feature == null ? void 0 : feature.label) || humanizeId(featureId);
      const optionsRaw = Array.isArray(rawChoice == null ? void 0 : rawChoice.options) ? rawChoice.options : [];
      const options = optionsRaw.map((rawOption) => {
        if (typeof rawOption === "string") {
          const id22 = rawOption.trim();
          if (!id22) return null;
          return {
            id: id22,
            label: humanizeId(id22),
            summary: "",
            grants: []
          };
        }
        const id2 = String((rawOption == null ? void 0 : rawOption.id) ?? "").trim();
        if (!id2) return null;
        const grantsRaw = Array.isArray(rawOption == null ? void 0 : rawOption.grants) ? rawOption.grants : [];
        const grants2 = grantsRaw.map((grant) => {
          const kind2 = String((grant == null ? void 0 : grant.kind) ?? "").trim();
          const ids = Array.isArray(grant == null ? void 0 : grant.ids) ? grant.ids.map((entry) => String(entry)).filter(Boolean) : [];
          if (!kind2 || ids.length === 0) return null;
          return { kind: kind2, ids };
        }).filter(Boolean);
        return {
          id: id2,
          label: String((rawOption == null ? void 0 : rawOption.label) ?? "").trim() || humanizeId(id2),
          summary: String((rawOption == null ? void 0 : rawOption.summary) ?? "").trim(),
          grants: grants2
        };
      }).filter(Boolean);
      if (options.length === 0) return null;
      return { key: key2, title, count: count2, options, featureId };
    }).filter(Boolean);
  };
  const getClassFeatureChoicesForSlot = (slot) => {
    const cls = slot === 1 ? classPrimary : classSecondary;
    const entry = slot === 1 ? classEntry : secondaryClassEntry;
    if (!cls) return [];
    const classLevel = Number((entry == null ? void 0 : entry.niveau) ?? 0);
    if (!Number.isFinite(classLevel) || classLevel <= 0) return [];
    const sources2 = [
      { source: `class:${cls.id}`, progression: cls.progression }
    ];
    const subclassId = slot === 1 ? selectedSubclassId : selectedSecondarySubclassId;
    if (subclassId) {
      const sub = subclassOptions.find((item) => item.id === subclassId) ?? null;
      if (sub) {
        sources2.push({ source: `subclass:${sub.id}`, progression: sub.progression });
      }
    }
    const byId = /* @__PURE__ */ new Map();
    sources2.forEach((source2) => {
      if (!source2.progression) return;
      Object.keys(source2.progression).map((key2) => Number(key2)).filter((lvl) => Number.isFinite(lvl) && lvl > 0 && lvl <= classLevel).sort((a2, b2) => a2 - b2).forEach((lvl) => {
        var _a2, _b2;
        const grants2 = Array.isArray((_b2 = (_a2 = source2.progression) == null ? void 0 : _a2[String(lvl)]) == null ? void 0 : _b2.grants) ? source2.progression[String(lvl)].grants : [];
        grants2.forEach((grant) => {
          if (String((grant == null ? void 0 : grant.kind) ?? "").toLowerCase() !== "feature") return;
          const ids = Array.isArray(grant == null ? void 0 : grant.ids) ? grant.ids : [];
          ids.forEach((featureId) => {
            getClassFeatureChoicesFromFeature(String(featureId)).forEach((choice) => {
              const id2 = `${source2.source}:${choice.featureId}:${choice.key}`;
              if (!byId.has(id2)) {
                byId.set(id2, {
                  id: id2,
                  key: choice.key,
                  title: choice.title,
                  count: choice.count,
                  options: choice.options
                });
              }
            });
          });
        });
      });
    });
    return Array.from(byId.values());
  };
  const getSelectedClassFeatureOptions = (choiceId, overrides) => {
    var _a2;
    const source2 = overrides ?? classFeatureSelections;
    const selected = (_a2 = source2 == null ? void 0 : source2[choiceId]) == null ? void 0 : _a2.selected;
    return Array.isArray(selected) ? selected.map((value2) => String(value2)).filter(Boolean) : [];
  };
  const getMissingClassFeatureChoicesForSlot = (slot, overrides) => getClassFeatureChoicesForSlot(slot).filter((choice) => {
    const selected = getSelectedClassFeatureOptions(choice.id, overrides);
    return selected.length < choice.count;
  });
  const getMissingClassFeatureChoiceForSlot = (slot, overrides) => getMissingClassFeatureChoicesForSlot(slot, overrides)[0] ?? null;
  const hasMissingClassFeatureChoiceForSlot = (slot) => getMissingClassFeatureChoiceForSlot(slot) !== null;
  const extractWeaponMasteryIdsFromGrant = (grant) => {
    const kind2 = String(grant.kind ?? "").trim().toLowerCase();
    const ids = Array.isArray(grant.ids) ? grant.ids.map((id2) => String(id2)).filter(Boolean) : [];
    if (ids.length === 0) return [];
    if (kind2 === "weaponmastery" || kind2 === "weapon-mastery" || kind2 === "weapon_mastery" || kind2 === "wm") {
      return ids;
    }
    if (kind2 === "feature") {
      return ids.map((id2) => id2.startsWith("wm-") ? id2.slice(3) : id2).filter((id2) => weaponMasteryIdSet.has(id2));
    }
    return [];
  };
  const selectedWeaponMasteries = reactExports.useMemo(() => {
    const byId = /* @__PURE__ */ new Set();
    let hasChoicePool = false;
    [1, 2].forEach((slot) => {
      const choices = getClassFeatureChoicesForSlot(slot);
      choices.forEach((choice) => {
        const selectedOptionIds = new Set(getSelectedClassFeatureOptions(choice.id));
        choice.options.forEach((option) => {
          const grantedMasteries = option.grants.flatMap(extractWeaponMasteryIdsFromGrant);
          if (grantedMasteries.length > 0) hasChoicePool = true;
          if (!selectedOptionIds.has(option.id)) return;
          grantedMasteries.forEach((id2) => byId.add(id2));
        });
      });
    });
    return { ids: Array.from(byId), hasChoicePool };
  }, [
    classFeatureSelections,
    classPrimary == null ? void 0 : classPrimary.id,
    classSecondary == null ? void 0 : classSecondary.id,
    classEntry == null ? void 0 : classEntry.niveau,
    secondaryClassEntry == null ? void 0 : secondaryClassEntry.niveau,
    selectedSubclassId,
    selectedSecondarySubclassId,
    subclassOptions
  ]);
  const selectedCombatStyles = reactExports.useMemo(() => {
    const byId = /* @__PURE__ */ new Map();
    [1, 2].forEach((slot) => {
      const choices = getClassFeatureChoicesForSlot(slot);
      choices.forEach((choice) => {
        const selectedOptionIds = new Set(getSelectedClassFeatureOptions(choice.id));
        choice.options.forEach((option) => {
          if (!selectedOptionIds.has(option.id)) return;
          option.grants.forEach((grant) => {
            if (String(grant.kind).toLowerCase() !== "feature") return;
            grant.ids.map((id2) => String(id2)).filter((id2) => id2.startsWith("fighting-style-")).forEach((featureId) => {
              var _a2;
              const label2 = ((_a2 = featureById.get(featureId)) == null ? void 0 : _a2.label) ?? option.label ?? featureId;
              byId.set(featureId, label2);
            });
          });
        });
      });
    });
    return Array.from(byId.entries()).map(([id2, label2]) => ({ id: id2, label: label2 }));
  }, [
    classFeatureSelections,
    classPrimary == null ? void 0 : classPrimary.id,
    classSecondary == null ? void 0 : classSecondary.id,
    classEntry == null ? void 0 : classEntry.niveau,
    secondaryClassEntry == null ? void 0 : secondaryClassEntry.niveau,
    selectedSubclassId,
    selectedSecondarySubclassId,
    featureById,
    subclassOptions
  ]);
  reactExports.useEffect(() => {
    var _a2, _b2;
    if (!selectedWeaponMasteries.hasChoicePool) return;
    const current = Array.isArray((_a2 = props.character) == null ? void 0 : _a2.weaponMasteries) ? ((_b2 = props.character) == null ? void 0 : _b2.weaponMasteries).map((id2) => String(id2)).filter(Boolean) : [];
    const next = selectedWeaponMasteries.ids;
    if (arraysEqual(current, next)) return;
    props.onChangeCharacter({ ...props.character, weaponMasteries: next });
  }, [
    selectedWeaponMasteries,
    props.character,
    props.onChangeCharacter
  ]);
  const hasPendingClassChoicesForSlot = (slot) => hasSubclassChoicePending(slot) || hasMissingClassFeatureChoiceForSlot(slot) || hasMissingAsiForSlot(slot);
  const hasPendingRaceChoices = () => {
    var _a2;
    if (!hasRaceTrait("adaptable")) return false;
    const adaptableSkill = (_a2 = choiceSelections == null ? void 0 : choiceSelections.race) == null ? void 0 : _a2.adaptableSkill;
    return !adaptableSkill;
  };
  const getPendingBackgroundChoiceCount = (overrides) => {
    if (!activeBackground) return 0;
    const backgroundChoices = overrides ?? (choiceSelections == null ? void 0 : choiceSelections.background) ?? {};
    let count2 = 0;
    const toolChoices = getBackgroundToolChoice(activeBackground);
    if (toolChoices && toolChoices.count > 0) {
      const existing = Array.isArray(backgroundChoices.tools) ? backgroundChoices.tools : [];
      if (existing.length < toolChoices.count) {
        count2 += toolChoices.count - existing.length;
      }
    }
    const languageChoices = getBackgroundLanguageChoice(activeBackground);
    if (languageChoices && languageChoices.count > 0) {
      const existing = Array.isArray(backgroundChoices.languages) ? backgroundChoices.languages : [];
      if (existing.length < languageChoices.count) {
        count2 += languageChoices.count - existing.length;
      }
    }
    return count2;
  };
  const hasPendingBackgroundChoices = () => getPendingBackgroundChoiceCount() > 0;
  const getPendingRaceChoiceCount = () => hasPendingRaceChoices() ? 1 : 0;
  const getPendingClassChoiceCount = (slot) => {
    let count2 = 0;
    if (hasSubclassChoicePending(slot)) count2 += 1;
    getMissingClassFeatureChoicesForSlot(slot).forEach((choice) => {
      const selected = getSelectedClassFeatureOptions(choice.id);
      count2 += Math.max(0, choice.count - selected.length);
    });
    const classId2 = slot === 1 ? classPrimary == null ? void 0 : classPrimary.id : classSecondary == null ? void 0 : classSecondary.id;
    if (classId2) {
      count2 += getMissingAsiEntries().filter((entry) => entry.classId === classId2).length;
    }
    return count2;
  };
  const getLockButtonState = (id2) => {
    const locked = isSectionLocked(id2);
    let needsDefine = false;
    if (!locked) {
      if (id2 === "species") needsDefine = hasPendingRaceChoices();
      if (id2 === "backgrounds") needsDefine = hasPendingBackgroundChoices();
      if (id2 === "stats") needsDefine = !canLockStats();
    }
    return {
      locked,
      needsDefine,
      label: locked ? "Deverouiller" : needsDefine ? "Definir" : "Verouiller",
      background: locked ? "rgba(46, 204, 113, 0.22)" : needsDefine ? "rgba(243, 156, 18, 0.24)" : "rgba(231, 76, 60, 0.22)"
    };
  };
  const getClassLockButtonState = () => {
    const locked = isActiveClassLocked;
    const needsDefine = !locked && hasPendingClassChoicesForSlot(activeClassSlot);
    return {
      locked,
      needsDefine,
      label: locked ? "Deverouiller" : needsDefine ? "Definir" : "Verouiller",
      background: locked ? "rgba(46, 204, 113, 0.22)" : needsDefine ? "rgba(243, 156, 18, 0.24)" : "rgba(231, 76, 60, 0.22)"
    };
  };
  const getPendingCountForSection = (id2) => {
    if (id2 === "species") return getPendingRaceChoiceCount();
    if (id2 === "backgrounds") return getPendingBackgroundChoiceCount();
    if (id2 === "classes") return getPendingClassChoiceCount(activeClassSlot);
    return 0;
  };
  const lockButtonBaseStyle = {
    padding: "0 10px",
    borderRadius: 8,
    border: "1px solid rgba(255,255,255,0.15)",
    color: "#f5f5f5",
    cursor: "pointer",
    fontSize: 11,
    fontWeight: 700,
    width: 120,
    minWidth: 120,
    maxWidth: 120,
    height: 26,
    minHeight: 26,
    textAlign: "center",
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    gap: 6,
    whiteSpace: "nowrap"
  };
  const renderPendingBadge = (count2) => {
    if (count2 <= 0) return null;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "span",
      {
        style: {
          marginLeft: 6,
          flex: "0 0 auto",
          minWidth: 16,
          height: 16,
          padding: "0 4px",
          borderRadius: 999,
          background: "#f39c12",
          color: "#0b0b12",
          fontSize: 10,
          fontWeight: 800,
          lineHeight: "16px",
          textAlign: "center",
          display: "inline-flex",
          alignItems: "center",
          justifyContent: "center",
          verticalAlign: "middle"
        },
        children: count2 > 9 ? "9+" : count2
      }
    );
  };
  const startBackgroundDefine = () => {
    if (!activeBackground) return;
    props.onChangeCharacter({
      ...props.character,
      choiceSelections: {
        ...choiceSelections,
        pendingLocks: { ...pendingLocks, backgrounds: true }
      }
    });
    requireBackgroundChoices();
  };
  const startClassDefine = (slot) => {
    const pendingForClass = {
      ...pendingLocks,
      classes: true,
      classesSlot: slot
    };
    const withPendingSelections = {
      ...choiceSelections,
      pendingLocks: pendingForClass
    };
    props.onChangeCharacter({
      ...props.character,
      choiceSelections: withPendingSelections
    });
    const finalizeClassDefine = (baseChoiceSelections) => {
      const nextPending = { ...(baseChoiceSelections == null ? void 0 : baseChoiceSelections.pendingLocks) ?? pendingForClass };
      delete nextPending.classes;
      delete nextPending.classesSlot;
      const nextCharacter = buildClassLockCharacter(slot, baseChoiceSelections, nextPending);
      props.onChangeCharacter(nextCharacter);
    };
    const openNextAsi = () => {
      const nextEntry = getMissingAsiEntryForSlot(slot);
      if (nextEntry) {
        openAsiModal(nextEntry);
        return true;
      }
      return false;
    };
    const openNextClassFeatureChoice = (overrides) => {
      const nextChoice = getMissingClassFeatureChoiceForSlot(slot, overrides);
      if (!nextChoice) return false;
      const selected = getSelectedClassFeatureOptions(nextChoice.id, overrides);
      openChoiceModal({
        title: nextChoice.title,
        options: nextChoice.options.map((option) => ({
          id: option.id,
          label: option.summary ? `${option.label} - ${option.summary}` : option.label
        })),
        selected,
        count: nextChoice.count,
        multi: nextChoice.count > 1,
        onConfirm: (picked) => {
          const nextClassFeatures = {
            ...overrides ?? classFeatureSelections,
            [nextChoice.id]: {
              selected: picked.slice(0, nextChoice.count)
            }
          };
          const nextChoiceSelections = {
            ...withPendingSelections,
            classFeatures: nextClassFeatures
          };
          props.onChangeCharacter({
            ...props.character,
            choiceSelections: nextChoiceSelections
          });
          if (openNextClassFeatureChoice(nextClassFeatures)) return;
          if (!openNextAsi()) {
            finalizeClassDefine(nextChoiceSelections);
          }
        }
      });
      return true;
    };
    if (hasSubclassChoicePending(slot)) {
      promptSubclassChoiceForSlot(slot, () => {
        if (openNextClassFeatureChoice()) return;
        if (openNextAsi()) return;
        finalizeClassDefine(withPendingSelections);
      });
      return;
    }
    if (openNextClassFeatureChoice()) return;
    if (openNextAsi()) return;
    finalizeClassDefine(withPendingSelections);
  };
  const LockIcon = ({ color }) => /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "12", height: "12", viewBox: "0 0 24 24", "aria-hidden": "true", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    "path",
    {
      fill: color,
      d: "M6 10V8a6 6 0 0 1 12 0v2h1a1 1 0 0 1 1 1v9a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1v-9a1 1 0 0 1 1-1h1zm2 0h8V8a4 4 0 1 0-8 0v2z"
    }
  ) });
  const initialStatsRef = reactExports.useRef(null);
  if (!initialStatsRef.current) {
    initialStatsRef.current = {
      FOR: getBaseScore("FOR"),
      DEX: getBaseScore("DEX"),
      CON: getBaseScore("CON"),
      INT: getBaseScore("INT"),
      SAG: getBaseScore("SAG"),
      CHA: getBaseScore("CHA")
    };
  }
  reactExports.useEffect(() => {
    initialStatsRef.current = {
      FOR: getBaseScore("FOR"),
      DEX: getBaseScore("DEX"),
      CON: getBaseScore("CON"),
      INT: getBaseScore("INT"),
      SAG: getBaseScore("SAG"),
      CHA: getBaseScore("CHA")
    };
  }, [(_y = props.character) == null ? void 0 : _y.id]);
  const prevClassStateRef = reactExports.useRef(null);
  reactExports.useEffect(() => {
    const current = {
      primaryLevel: Number((classEntry == null ? void 0 : classEntry.niveau) ?? 0),
      secondaryLevel: Number((secondaryClassEntry == null ? void 0 : secondaryClassEntry.niveau) ?? 0),
      primarySubclassId: selectedSubclassId ?? "",
      secondarySubclassId: selectedSecondarySubclassId ?? ""
    };
    const prev = prevClassStateRef.current;
    if (prev) {
      const primaryDropped = current.primaryLevel < prev.primaryLevel;
      const secondaryDropped = current.secondaryLevel < prev.secondaryLevel;
      const primarySubclassLost = Boolean(prev.primarySubclassId) && !current.primarySubclassId;
      const secondarySubclassLost = Boolean(prev.secondarySubclassId) && !current.secondarySubclassId;
      if (primaryDropped || secondaryDropped || primarySubclassLost || secondarySubclassLost) {
        resetStatsFromBase();
      }
    }
    prevClassStateRef.current = current;
  }, [
    classEntry == null ? void 0 : classEntry.niveau,
    secondaryClassEntry == null ? void 0 : secondaryClassEntry.niveau,
    selectedSubclassId,
    selectedSecondarySubclassId
  ]);
  const computeMod = (score) => Math.floor((score - 10) / 2);
  const computeProficiencyBonusForLevel = (level2) => {
    if (level2 <= 4) return 2;
    if (level2 <= 8) return 3;
    if (level2 <= 12) return 4;
    if (level2 <= 16) return 5;
    return 6;
  };
  const averageHitDie = (die) => {
    switch (die) {
      case 6:
        return 4;
      case 8:
        return 5;
      case 10:
        return 6;
      case 12:
        return 7;
      default:
        return 0;
    }
  };
  const computeArmorClassFromEquipment2 = () => {
    const dexMod = computeMod(getScore("DEX"));
    const base = 10 + dexMod;
    let armorBase = base;
    let shieldBonus = 0;
    const equippedArmor = inventoryItems.filter(
      (item) => (item == null ? void 0 : item.type) === "armor" && (item == null ? void 0 : item.equippedSlot)
    );
    for (const item of equippedArmor) {
      const def = armorItemMap.get(item.id);
      if (!def) continue;
      if (def.armorCategory === "shield") {
        shieldBonus = Math.max(shieldBonus, Number(def.baseAC ?? 2) || 2);
        continue;
      }
      const baseAC2 = typeof def.baseAC === "number" ? def.baseAC : 10;
      const dexCap2 = def.dexCap === null || typeof def.dexCap === "undefined" ? dexMod : Math.max(0, Math.min(dexMod, Number(def.dexCap) || 0));
      armorBase = Math.max(armorBase, baseAC2 + dexCap2);
    }
    return Math.max(1, armorBase + shieldBonus);
  };
  const computeMaxHp = () => {
    const conMod = computeMod(getScore("CON"));
    const primaryLevel = Number(classEntry == null ? void 0 : classEntry.niveau) || 0;
    const secondaryLevel = Number(secondaryClassEntry == null ? void 0 : secondaryClassEntry.niveau) || 0;
    const primaryDie = (classPrimary == null ? void 0 : classPrimary.hitDie) ?? null;
    const secondaryDie = (classSecondary == null ? void 0 : classSecondary.hitDie) ?? null;
    if (!primaryLevel || !primaryDie) return Math.max(1, conMod + 1);
    let total = Math.max(1, primaryDie + conMod);
    if (primaryLevel > 1) {
      const avg = averageHitDie(primaryDie);
      const perLevel = Math.max(1, avg + conMod);
      total += perLevel * (primaryLevel - 1);
    }
    if (secondaryLevel > 0 && secondaryDie) {
      const avg = averageHitDie(secondaryDie);
      const perLevel = Math.max(1, avg + conMod);
      total += perLevel * secondaryLevel;
    }
    return Math.max(1, Math.floor(total));
  };
  const computePassivePerception = (proficiencyBonus) => {
    var _a2, _b2;
    const wisMod = computeMod(getScore("SAG"));
    const skills = Array.isArray((_a2 = props.character) == null ? void 0 : _a2.competences) ? props.character.competences.map((id2) => String(id2).toLowerCase()) : [];
    const expertises2 = Array.isArray((_b2 = props.character) == null ? void 0 : _b2.expertises) ? props.character.expertises.map((id2) => String(id2).toLowerCase()) : [];
    const isProficient = skills.includes("perception");
    const isExpert = expertises2.includes("perception");
    const profContribution = isExpert ? proficiencyBonus * 2 : isProficient ? proficiencyBonus : 0;
    return 10 + wisMod + profContribution;
  };
  const resolvePrimaryHitDie = () => {
    var _a2;
    if (classPrimary == null ? void 0 : classPrimary.hitDie) return Number(classPrimary.hitDie);
    const rawDv = Number((_a2 = props.character) == null ? void 0 : _a2.dv);
    if (Number.isFinite(rawDv) && rawDv > 0) return rawDv;
    return 6;
  };
  const spellcastingSelections = (choiceSelections == null ? void 0 : choiceSelections.spellcasting) ?? {};
  const updateSpellcastingSelection = (key2, patch) => {
    const next = { ...spellcastingSelections, [key2]: { ...spellcastingSelections[key2] ?? {}, ...patch } };
    props.onChangeCharacter({
      ...props.character,
      choiceSelections: { ...choiceSelections, spellcasting: next }
    });
  };
  const getCasterContribution = (progression2, level2) => {
    if (progression2 === "full") return level2;
    if (progression2 === "half") return Math.floor(level2 / 2);
    if (progression2 === "third") return Math.floor(level2 / 3);
    return 0;
  };
  const collectSpellGrants = (progression2, level2) => {
    if (!progression2) return [];
    const max = Number(level2) || 0;
    const ids = [];
    Object.keys(progression2).map((key2) => Number(key2)).filter((lvl) => Number.isFinite(lvl) && lvl > 0 && lvl <= max).forEach((lvl) => {
      var _a2;
      const grants2 = ((_a2 = progression2[String(lvl)]) == null ? void 0 : _a2.grants) ?? [];
      grants2.forEach((grant) => {
        if ((grant == null ? void 0 : grant.kind) !== "spell") return;
        const list = Array.isArray(grant == null ? void 0 : grant.ids) ? grant.ids : [];
        list.forEach((id2) => ids.push(id2));
      });
    });
    return Array.from(new Set(ids));
  };
  const getSpellId = (entry) => typeof entry === "string" ? entry : entry.id;
  const makeSpellEntry = (id2, origin) => ({
    id: id2,
    instanceId: createInstanceId("spell"),
    origin
  });
  const buildSpellGrantsForClassSlot = (slot) => {
    const grants2 = {};
    const cls = slot === 1 ? classPrimary : classSecondary;
    const entry = slot === 1 ? classEntry : secondaryClassEntry;
    const subclassId = slot === 1 ? selectedSubclassId : selectedSecondarySubclassId;
    const subclass = subclassId ? subclassOptions.find((sub) => sub.id === subclassId) ?? null : null;
    const classLevel = Number(entry == null ? void 0 : entry.niveau) || 0;
    if ((cls == null ? void 0 : cls.spellcasting) && cls.id) {
      const classSpells = collectSpellGrants(cls.progression, classLevel);
      const subclassSpells = subclass && !subclass.spellcasting ? collectSpellGrants(subclass.progression, classLevel) : [];
      const spellIds = Array.from(/* @__PURE__ */ new Set([...classSpells, ...subclassSpells]));
      if (spellIds.length > 0) {
        const sourceKey = `class:${cls.id}`;
        grants2[sourceKey] = spellIds.map(
          (id2) => makeSpellEntry(id2, { kind: "class", id: cls.id, sourceKey })
        );
      }
    }
    if ((subclass == null ? void 0 : subclass.spellcasting) && subclass.id) {
      const spellIds = collectSpellGrants(subclass.progression, classLevel);
      if (spellIds.length > 0) {
        const sourceKey = `subclass:${subclass.id}`;
        grants2[sourceKey] = spellIds.map(
          (id2) => makeSpellEntry(id2, { kind: "subclass", id: subclass.id, sourceKey })
        );
      }
    }
    return grants2;
  };
  const getItemSources = (item) => {
    if (!item || isCurrencyItem(item)) return [];
    const origin = item.origin;
    if (!origin || !origin.kind) return [];
    if (origin.kind === "background") {
      const label2 = `Historique${origin.id ? `: ${origin.id}` : ""}`;
      return [{ key: "background", label: label2 }];
    }
    if (origin.kind === "class") {
      const label2 = `Classe${origin.id ? `: ${origin.id}` : ""}`;
      return [{ key: "classPrimary", label: label2 }];
    }
    if (origin.kind === "manual") {
      return [{ key: "equipment", label: "Ajoute manuellement" }];
    }
    return [];
  };
  const getItemTags = (item) => {
    if (!item) return [];
    const tags2 = item.tags;
    return Array.isArray(tags2) ? tags2.map((tag) => String(tag)) : [];
  };
  const resolveItemTags = (itemId) => {
    const resolved = resolveItemType(itemId);
    if (resolved.type === "weapon") {
      return getItemTags(weaponItemMap.get(resolved.id));
    }
    if (resolved.type === "armor") {
      return getItemTags(armorItemMap.get(resolved.id));
    }
    if (resolved.type === "tool") {
      return getItemTags(toolItemMap.get(resolved.id));
    }
    return getItemTags(objectItemMap.get(resolved.id));
  };
  const magicSources = (() => {
    const sources2 = [];
    const primarySub = selectedSubclassId ? subclassOptions.find((sub) => sub.id === selectedSubclassId) ?? null : null;
    const secondarySub = selectedSecondarySubclassId ? subclassOptions.find((sub) => sub.id === selectedSecondarySubclassId) ?? null : null;
    if (classLocks.primary && (classPrimary == null ? void 0 : classPrimary.spellcasting)) {
      const classLevel = Number(classEntry == null ? void 0 : classEntry.niveau) || 0;
      const classSpells = collectSpellGrants(classPrimary.progression, classLevel);
      const subclassSpells = primarySub && !primarySub.spellcasting ? collectSpellGrants(primarySub.progression, classLevel) : [];
      sources2.push({
        key: `class:${classPrimary.id}`,
        label: classPrimary.label,
        ability: classPrimary.spellcasting.ability,
        preparation: classPrimary.spellcasting.preparation,
        storage: classPrimary.spellcasting.storage,
        focusTypes: classPrimary.spellcasting.focusTypes,
        spellFilterTags: classPrimary.spellcasting.spellFilterTags,
        freePreparedFromGrants: classPrimary.spellcasting.freePreparedFromGrants,
        casterProgression: classPrimary.spellcasting.casterProgression,
        slotsByLevel: classPrimary.spellcasting.slotsByLevel,
        classLevel,
        spellIds: Array.from(/* @__PURE__ */ new Set([...classSpells, ...subclassSpells]))
      });
    }
    if (classLocks.primary && (primarySub == null ? void 0 : primarySub.spellcasting)) {
      sources2.push({
        key: `subclass:${primarySub.id}`,
        label: `${(classPrimary == null ? void 0 : classPrimary.label) ?? "Classe"}  ${primarySub.label}`,
        ability: primarySub.spellcasting.ability,
        preparation: primarySub.spellcasting.preparation,
        storage: primarySub.spellcasting.storage,
        focusTypes: primarySub.spellcasting.focusTypes,
        spellFilterTags: primarySub.spellcasting.spellFilterTags,
        freePreparedFromGrants: primarySub.spellcasting.freePreparedFromGrants,
        casterProgression: primarySub.spellcasting.casterProgression,
        slotsByLevel: primarySub.spellcasting.slotsByLevel,
        classLevel: Number(classEntry == null ? void 0 : classEntry.niveau) || 0,
        spellIds: collectSpellGrants(primarySub.progression, Number(classEntry == null ? void 0 : classEntry.niveau) || 0)
      });
    }
    if (classLocks.secondary && (classSecondary == null ? void 0 : classSecondary.spellcasting)) {
      const classLevel = Number(secondaryClassEntry == null ? void 0 : secondaryClassEntry.niveau) || 0;
      const classSpells = collectSpellGrants(classSecondary.progression, classLevel);
      const subclassSpells = secondarySub && !secondarySub.spellcasting ? collectSpellGrants(secondarySub.progression, classLevel) : [];
      sources2.push({
        key: `class:${classSecondary.id}`,
        label: classSecondary.label,
        ability: classSecondary.spellcasting.ability,
        preparation: classSecondary.spellcasting.preparation,
        storage: classSecondary.spellcasting.storage,
        focusTypes: classSecondary.spellcasting.focusTypes,
        spellFilterTags: classSecondary.spellcasting.spellFilterTags,
        freePreparedFromGrants: classSecondary.spellcasting.freePreparedFromGrants,
        casterProgression: classSecondary.spellcasting.casterProgression,
        slotsByLevel: classSecondary.spellcasting.slotsByLevel,
        classLevel,
        spellIds: Array.from(/* @__PURE__ */ new Set([...classSpells, ...subclassSpells]))
      });
    }
    if (classLocks.secondary && (secondarySub == null ? void 0 : secondarySub.spellcasting)) {
      sources2.push({
        key: `subclass:${secondarySub.id}`,
        label: `${(classSecondary == null ? void 0 : classSecondary.label) ?? "Classe"}  ${secondarySub.label}`,
        ability: secondarySub.spellcasting.ability,
        preparation: secondarySub.spellcasting.preparation,
        storage: secondarySub.spellcasting.storage,
        focusTypes: secondarySub.spellcasting.focusTypes,
        spellFilterTags: secondarySub.spellcasting.spellFilterTags,
        freePreparedFromGrants: secondarySub.spellcasting.freePreparedFromGrants,
        casterProgression: secondarySub.spellcasting.casterProgression,
        slotsByLevel: secondarySub.spellcasting.slotsByLevel,
        classLevel: Number(secondaryClassEntry == null ? void 0 : secondaryClassEntry.niveau) || 0,
        spellIds: collectSpellGrants(secondarySub.progression, Number(secondaryClassEntry == null ? void 0 : secondaryClassEntry.niveau) || 0)
      });
    }
    return sources2;
  })();
  const [activeMagicTab, setActiveMagicTab] = reactExports.useState(0);
  reactExports.useEffect(() => {
    if (activeMagicTab >= magicSources.length) {
      setActiveMagicTab(0);
    }
  }, [magicSources.length, activeMagicTab]);
  const canEditSkills = !isSectionLocked("skills") && skillsMode !== "normal";
  const canEditMasteries = !isSectionLocked("masteries") && masteriesMode !== "normal";
  const normalizeLanguages = (value2) => {
    const rawList = Array.isArray(value2) ? value2 : typeof value2 === "string" ? value2.split(",").map((item) => item.trim()).filter(Boolean) : [];
    const byId = /* @__PURE__ */ new Map();
    const byLabel = /* @__PURE__ */ new Map();
    languageOptions.forEach((lang) => {
      if (!(lang == null ? void 0 : lang.id)) return;
      byId.set(String(lang.id).toLowerCase(), String(lang.id));
      byLabel.set(String(lang.label ?? "").toLowerCase(), String(lang.id));
    });
    const normalized = [];
    rawList.forEach((entry) => {
      const key2 = String(entry ?? "").trim();
      if (!key2) return;
      const lower = key2.toLowerCase();
      const resolved = byId.get(lower) ?? byLabel.get(lower) ?? key2;
      normalized.push(resolved);
    });
    return Array.from(new Set(normalized));
  };
  const collectProgressionGrantEntries = (progression2, level2, source2) => {
    if (!progression2 || level2 <= 0) return [];
    const entries = [];
    Object.keys(progression2).map((key2) => Number(key2)).filter((lvl) => Number.isFinite(lvl) && lvl > 0 && lvl <= level2).sort((a2, b2) => a2 - b2).forEach((lvl) => {
      var _a2;
      const grants2 = Array.isArray((_a2 = progression2[String(lvl)]) == null ? void 0 : _a2.grants) ? progression2[String(lvl)].grants : [];
      grants2.forEach((grant) => {
        if (!(grant == null ? void 0 : grant.kind)) return;
        const ids = Array.isArray(grant.ids) ? grant.ids.filter(Boolean) : [];
        if (ids.length === 0) return;
        entries.push({ source: source2, level: lvl, kind: String(grant.kind), ids });
      });
    });
    return entries;
  };
  const collectProgressionSources = () => {
    const globalLevel = resolveLevel();
    const primaryLevel = Number(classEntry == null ? void 0 : classEntry.niveau) || 0;
    const secondaryLevel = Number(secondaryClassEntry == null ? void 0 : secondaryClassEntry.niveau) || 0;
    const sources2 = [];
    if (activeRace == null ? void 0 : activeRace.id) {
      sources2.push({
        source: `race:${activeRace.id}`,
        level: globalLevel,
        progression: activeRace == null ? void 0 : activeRace.progression
      });
    }
    if (activeBackground == null ? void 0 : activeBackground.id) {
      sources2.push({
        source: `background:${activeBackground.id}`,
        level: globalLevel,
        progression: activeBackground == null ? void 0 : activeBackground.progression
      });
    }
    if (classPrimary == null ? void 0 : classPrimary.id) {
      sources2.push({
        source: `class:${classPrimary.id}`,
        level: primaryLevel,
        progression: classPrimary.progression
      });
    }
    if (selectedSubclassId) {
      const sub = subclassOptions.find((item) => item.id === selectedSubclassId) ?? null;
      if (sub == null ? void 0 : sub.id) {
        sources2.push({
          source: `subclass:${sub.id}`,
          level: primaryLevel,
          progression: sub.progression
        });
      }
    }
    if (classSecondary == null ? void 0 : classSecondary.id) {
      sources2.push({
        source: `class:${classSecondary.id}`,
        level: secondaryLevel,
        progression: classSecondary.progression
      });
    }
    if (selectedSecondarySubclassId) {
      const sub = subclassOptions.find((item) => item.id === selectedSecondarySubclassId) ?? null;
      if (sub == null ? void 0 : sub.id) {
        sources2.push({
          source: `subclass:${sub.id}`,
          level: secondaryLevel,
          progression: sub.progression
        });
      }
    }
    return sources2.filter((item) => item.level > 0 && Boolean(item.progression));
  };
  const buildProgressionHistory = () => {
    var _a2, _b2, _c2;
    const history = [];
    const raceId = ((_a2 = props.character) == null ? void 0 : _a2.raceId) ?? "";
    const backgroundId = ((_b2 = props.character) == null ? void 0 : _b2.backgroundId) ?? "";
    const adaptableSkill = (_c2 = choiceSelections == null ? void 0 : choiceSelections.race) == null ? void 0 : _c2.adaptableSkill;
    if (adaptableSkill) {
      history.push({
        source: `race:${raceId || "unknown"}`,
        level: 1,
        type: "choice",
        payload: { kind: "skill", id: adaptableSkill }
      });
    }
    const backgroundChoices = (choiceSelections == null ? void 0 : choiceSelections.background) ?? {};
    const backgroundTools = Array.isArray(backgroundChoices.tools) ? backgroundChoices.tools : [];
    const backgroundLanguages = Array.isArray(backgroundChoices.languages) ? backgroundChoices.languages : [];
    backgroundTools.forEach((toolId) => {
      history.push({
        source: `background:${backgroundId || "unknown"}`,
        level: 1,
        type: "choice",
        payload: { kind: "tool", id: toolId }
      });
    });
    backgroundLanguages.forEach((langId) => {
      history.push({
        source: `background:${backgroundId || "unknown"}`,
        level: 1,
        type: "choice",
        payload: { kind: "language", id: langId }
      });
    });
    const sourceLevels = /* @__PURE__ */ new Map();
    if (classPrimary == null ? void 0 : classPrimary.id) {
      sourceLevels.set(`class:${classPrimary.id}`, Number((classEntry == null ? void 0 : classEntry.niveau) ?? 0) || 0);
    }
    if (classSecondary == null ? void 0 : classSecondary.id) {
      sourceLevels.set(`class:${classSecondary.id}`, Number((secondaryClassEntry == null ? void 0 : secondaryClassEntry.niveau) ?? 0) || 0);
    }
    if (selectedSubclassId) {
      sourceLevels.set(`subclass:${selectedSubclassId}`, Number((classEntry == null ? void 0 : classEntry.niveau) ?? 0) || 0);
    }
    if (selectedSecondarySubclassId) {
      sourceLevels.set(
        `subclass:${selectedSecondarySubclassId}`,
        Number((secondaryClassEntry == null ? void 0 : secondaryClassEntry.niveau) ?? 0) || 0
      );
    }
    if (activeRace == null ? void 0 : activeRace.id) sourceLevels.set(`race:${activeRace.id}`, 1);
    if (activeBackground == null ? void 0 : activeBackground.id) sourceLevels.set(`background:${activeBackground.id}`, 1);
    const featureUnlockBySourceAndId = /* @__PURE__ */ new Map();
    collectProgressionSources().forEach((item) => {
      const grants2 = collectProgressionGrantEntries(item.progression, item.level, item.source);
      grants2.forEach((grant) => {
        if (String(grant.kind).toLowerCase() !== "feature") return;
        grant.ids.forEach((featureId) => {
          const key2 = `${grant.source}|${String(featureId)}`;
          const previous = featureUnlockBySourceAndId.get(key2);
          if (typeof previous === "number") {
            featureUnlockBySourceAndId.set(key2, Math.min(previous, grant.level));
          } else {
            featureUnlockBySourceAndId.set(key2, grant.level);
          }
        });
      });
    });
    const classFeatureChoiceSelections = (choiceSelections == null ? void 0 : choiceSelections.classFeatures) ?? {};
    Object.entries(classFeatureChoiceSelections).forEach(([choiceId, entry]) => {
      const match = choiceId.match(/^(class|subclass):([^:]+):([^:]+):(.+)$/);
      if (!match) return;
      const source2 = `${match[1]}:${match[2]}`;
      const featureId = match[3];
      const choiceKey = match[4];
      const selected = Array.isArray(entry == null ? void 0 : entry.selected) ? entry.selected : [];
      const unlockLevel = featureUnlockBySourceAndId.get(`${source2}|${featureId}`) ?? sourceLevels.get(source2) ?? 0;
      selected.forEach((optionId) => {
        history.push({
          source: source2,
          level: unlockLevel,
          type: "choice",
          payload: {
            kind: "class-feature-option",
            featureId,
            choiceKey,
            optionId: String(optionId)
          }
        });
      });
    });
    Object.entries(asiSelections).forEach(([key2, entry]) => {
      const match = key2.match(/^(.+):(\d+)$/);
      const level2 = match ? Number(match[2]) : null;
      const classId2 = match ? match[1] : null;
      if (!level2 || !classId2) return;
      history.push({
        source: `class:${classId2}`,
        level: level2,
        type: (entry == null ? void 0 : entry.type) === "feat" ? "feat" : "asi",
        payload: (entry == null ? void 0 : entry.type) === "asi" ? { stats: entry.stats ?? {} } : {}
      });
    });
    collectProgressionSources().forEach((item) => {
      collectProgressionGrantEntries(item.progression, item.level, item.source).forEach((entry) => {
        history.push({ source: entry.source, level: entry.level, type: "grant", payload: entry });
      });
    });
    return history;
  };
  const buildDerivedGrants = () => {
    var _a2;
    const grants2 = {
      traits: [],
      features: [],
      feats: [],
      skills: [],
      weaponMasteries: [],
      tools: [],
      languages: [],
      spells: [],
      actions: [],
      reactions: [],
      resources: [],
      passifs: []
    };
    const resolveGrantKey = (rawKind) => {
      const kind2 = String(rawKind ?? "").trim().toLowerCase();
      if (!kind2) return "";
      if (kind2 === "trait" || kind2 === "traits") return "traits";
      if (kind2 === "feature" || kind2 === "features") return "features";
      if (kind2 === "feat" || kind2 === "feats") return "feats";
      if (kind2 === "skill" || kind2 === "skills" || kind2 === "competence" || kind2 === "competences") return "skills";
      if (kind2 === "weaponmastery" || kind2 === "weapon-mastery" || kind2 === "weapon_mastery" || kind2 === "wm") return "weaponMasteries";
      if (kind2 === "tool" || kind2 === "tools") return "tools";
      if (kind2 === "language" || kind2 === "languages" || kind2 === "langue" || kind2 === "langues") return "languages";
      if (kind2 === "spell" || kind2 === "spells") return "spells";
      if (kind2 === "action" || kind2 === "actions") return "actions";
      if (kind2 === "reaction" || kind2 === "reactions") return "reactions";
      if (kind2 === "resource" || kind2 === "resources") return "resources";
      if (kind2 === "passif" || kind2 === "passifs" || kind2 === "passive" || kind2 === "passives" || kind2 === "status" || kind2 === "statuses") return "passifs";
      return "";
    };
    const add = (kind2, ids) => {
      if (!Array.isArray(ids) || ids.length === 0) return;
      const key2 = resolveGrantKey(kind2);
      if (!key2) return;
      const normalizedIds = ids.map((id2) => String(id2)).filter(Boolean);
      if (normalizedIds.length === 0) return;
      grants2[key2] = Array.from(/* @__PURE__ */ new Set([...grants2[key2] ?? [], ...normalizedIds]));
    };
    const raceGrants = Array.isArray(activeRace == null ? void 0 : activeRace.grants) ? activeRace == null ? void 0 : activeRace.grants : [];
    raceGrants.forEach((grant) => add(String((grant == null ? void 0 : grant.kind) ?? ""), (grant == null ? void 0 : grant.ids) ?? []));
    const backgroundGrants = Array.isArray(activeBackground == null ? void 0 : activeBackground.grants) ? activeBackground == null ? void 0 : activeBackground.grants : [];
    backgroundGrants.forEach((grant) => add(String((grant == null ? void 0 : grant.kind) ?? ""), (grant == null ? void 0 : grant.ids) ?? []));
    const adaptableSkill = (_a2 = choiceSelections == null ? void 0 : choiceSelections.race) == null ? void 0 : _a2.adaptableSkill;
    if (adaptableSkill) add("skill", [String(adaptableSkill)]);
    const backgroundChoices = (choiceSelections == null ? void 0 : choiceSelections.background) ?? {};
    const backgroundTools = Array.isArray(backgroundChoices.tools) ? backgroundChoices.tools : [];
    const backgroundLanguages = Array.isArray(backgroundChoices.languages) ? backgroundChoices.languages : [];
    if (backgroundTools.length > 0) add("tool", backgroundTools.map((id2) => String(id2)));
    if (backgroundLanguages.length > 0) add("language", backgroundLanguages.map((id2) => String(id2)));
    const classFeatureChoicesById = /* @__PURE__ */ new Map();
    getClassFeatureChoicesForSlot(1).forEach((choice) => classFeatureChoicesById.set(choice.id, choice));
    getClassFeatureChoicesForSlot(2).forEach((choice) => classFeatureChoicesById.set(choice.id, choice));
    Object.entries(classFeatureSelections).forEach(([choiceId, entry]) => {
      const choice = classFeatureChoicesById.get(choiceId);
      if (!choice) return;
      const selectedIds = Array.isArray(entry == null ? void 0 : entry.selected) ? entry.selected.map((id2) => String(id2)).filter(Boolean) : [];
      selectedIds.forEach((optionId) => {
        const option = choice.options.find((item) => item.id === optionId);
        if (!option) return;
        option.grants.forEach((grant) => add(grant.kind, grant.ids));
      });
    });
    collectProgressionSources().forEach((item) => {
      collectProgressionGrantEntries(item.progression, item.level, item.source).forEach(
        (entry) => add(entry.kind, entry.ids)
      );
    });
    return { grants: grants2 };
  };
  const buildSpellcastingState = (derivedGrants) => {
    var _a2, _b2;
    const parseSourceFromKey = (sourceKey) => {
      const [kindRaw, ...rest] = String(sourceKey ?? "").split(":");
      const kind2 = String(kindRaw ?? "").trim().toLowerCase();
      const sourceId = rest.join(":") || void 0;
      const allowed = /* @__PURE__ */ new Set([
        "class",
        "subclass",
        "race",
        "background",
        "feat",
        "feature",
        "item",
        "manual",
        "system"
      ]);
      const sourceType = allowed.has(kind2) ? kind2 : "manual";
      return { sourceType, sourceId };
    };
    const getDefaultSpellUsage = (spellId, preferSlot) => {
      var _a3;
      const level2 = Number(((_a3 = spellCatalog.byId.get(spellId)) == null ? void 0 : _a3.level) ?? 0);
      if (level2 <= 0) {
        return { type: "at-will", consumesSlot: false };
      }
      if (preferSlot) {
        return { type: "slot", consumesSlot: true };
      }
      return { type: "at-will", consumesSlot: false };
    };
    const resolveUsage = (spellId, rawMeta, preferSlot) => {
      const meta = rawMeta;
      const usageMeta = meta && typeof meta === "object" && meta.usage && typeof meta.usage === "object" ? meta.usage : meta && typeof meta === "object" ? meta : null;
      if (!usageMeta) {
        return getDefaultSpellUsage(spellId, preferSlot);
      }
      const typeRaw = usageMeta.type;
      const type2 = typeof typeRaw === "string" && typeRaw.trim() ? typeRaw.trim() : getDefaultSpellUsage(spellId, preferSlot).type;
      const consumesSlot = typeof usageMeta.consumesSlot === "boolean" ? usageMeta.consumesSlot : type2 === "slot";
      const maxUses = typeof usageMeta.maxUses === "number" && Number.isFinite(usageMeta.maxUses) ? usageMeta.maxUses : void 0;
      const remainingUses = typeof usageMeta.remainingUses === "number" && Number.isFinite(usageMeta.remainingUses) ? usageMeta.remainingUses : maxUses;
      const resetOn = typeof usageMeta.resetOn === "string" ? usageMeta.resetOn : void 0;
      const fixedSlotLevel = typeof usageMeta.fixedSlotLevel === "number" && Number.isFinite(usageMeta.fixedSlotLevel) ? usageMeta.fixedSlotLevel : void 0;
      const poolId = typeof usageMeta.poolId === "string" ? usageMeta.poolId : void 0;
      return {
        type: type2,
        consumesSlot,
        maxUses,
        remainingUses,
        resetOn,
        fixedSlotLevel,
        poolId
      };
    };
    const totalCasterLevel = magicSources.reduce(
      (sum, item) => sum + getCasterContribution(item.casterProgression, item.classLevel),
      0
    );
    const slotsTable = ((_a2 = magicSources.find((item) => item.slotsByLevel)) == null ? void 0 : _a2.slotsByLevel) ?? null;
    const slotsRow = slotsTable ? slotsTable[String(Math.max(0, totalCasterLevel))] ?? [] : [];
    const maxSpellLevel = slotsRow.reduce(
      (max, count2, idx) => count2 > 0 ? idx + 1 : max,
      0
    );
    const slots = {};
    slotsRow.forEach((count2, idx) => {
      if (count2 > 0) {
        slots[String(idx + 1)] = { max: count2, remaining: count2, sources: ["caster-total"] };
      }
    });
    const sources2 = {};
    const spellGrantsBySource = /* @__PURE__ */ new Map();
    const slotJustifications = [];
    const upsertSpellGrant = (sourceKey, spellId, patch) => {
      if (!sourceKey || !spellId) return;
      const bySpell = spellGrantsBySource.get(sourceKey) ?? /* @__PURE__ */ new Map();
      const existing = bySpell.get(spellId);
      if (!existing) {
        bySpell.set(spellId, {
          entryId: `${sourceKey}:${spellId}`,
          spellId,
          sourceType: patch.sourceType,
          sourceId: patch.sourceId,
          sourceKey,
          sourceInstanceId: patch.sourceInstanceId,
          grantedAtLevel: patch.grantedAtLevel,
          usage: patch.usage,
          prepared: patch.prepared,
          alwaysPrepared: patch.alwaysPrepared,
          countsAgainstPreparation: patch.countsAgainstPreparation,
          tags: Array.from(new Set((patch.tags ?? []).map((value2) => String(value2)).filter(Boolean)))
        });
        spellGrantsBySource.set(sourceKey, bySpell);
        return;
      }
      if (patch.sourceInstanceId && !existing.sourceInstanceId) existing.sourceInstanceId = patch.sourceInstanceId;
      if (typeof patch.grantedAtLevel === "number" && typeof existing.grantedAtLevel !== "number") {
        existing.grantedAtLevel = patch.grantedAtLevel;
      }
      if (patch.usage && !existing.usage) existing.usage = patch.usage;
      if (patch.prepared === true) existing.prepared = true;
      if (patch.alwaysPrepared === true) existing.alwaysPrepared = true;
      if (patch.countsAgainstPreparation === false) {
        existing.countsAgainstPreparation = false;
      } else if (patch.countsAgainstPreparation === true && typeof existing.countsAgainstPreparation !== "boolean") {
        existing.countsAgainstPreparation = true;
      }
      if (Array.isArray(patch.tags) && patch.tags.length > 0) {
        existing.tags = Array.from(
          new Set([...existing.tags ?? [], ...patch.tags.map((value2) => String(value2))].filter(Boolean))
        );
      }
    };
    const addSpellEntriesFromSelection = (sourceKey, list, listType, fallback) => {
      list.forEach((rawEntry) => {
        const entryObject = typeof rawEntry === "string" ? null : rawEntry;
        const spellId = getSpellId(rawEntry);
        if (!spellId) return;
        const origin = entryObject == null ? void 0 : entryObject.origin;
        const originKind = typeof (origin == null ? void 0 : origin.kind) === "string" ? origin.kind : null;
        const originSourceKey = typeof (origin == null ? void 0 : origin.sourceKey) === "string" ? origin.sourceKey : null;
        const targetSourceKey = originSourceKey ?? sourceKey;
        const parsed = parseSourceFromKey(targetSourceKey);
        const sourceType = originKind ?? parsed.sourceType ?? fallback.sourceType;
        const sourceId = (typeof (origin == null ? void 0 : origin.id) === "string" ? origin.id : void 0) ?? parsed.sourceId ?? fallback.sourceId;
        const sourceInstanceId = (typeof (origin == null ? void 0 : origin.sourceInstanceId) === "string" ? origin.sourceInstanceId : void 0) ?? (typeof fallback.sourceInstanceId === "string" ? fallback.sourceInstanceId : void 0);
        const preferSlot = fallback.preferSlot ?? true;
        const usage2 = resolveUsage(
          spellId,
          (entryObject == null ? void 0 : entryObject.usage) ?? (origin == null ? void 0 : origin.usage),
          preferSlot
        );
        const alwaysPrepared = listType === "granted" && Boolean(fallback.freePreparedFromGrants);
        const prepared = listType === "prepared" || alwaysPrepared;
        const countsAgainstPreparation = listType === "prepared" ? true : alwaysPrepared ? false : void 0;
        upsertSpellGrant(targetSourceKey, spellId, {
          sourceType,
          sourceId,
          sourceInstanceId,
          grantedAtLevel: fallback.classLevel,
          usage: usage2,
          prepared,
          alwaysPrepared,
          countsAgainstPreparation,
          tags: [listType]
        });
      });
    };
    magicSources.forEach((source2) => {
      var _a3;
      const selection = spellcastingSelections[source2.key] ?? {};
      const knownSpellsRaw = Array.isArray(selection.knownSpells) ? selection.knownSpells : [];
      const preparedSpellsRaw = Array.isArray(selection.preparedSpells) ? selection.preparedSpells : [];
      const grantedSpells = Array.isArray(selection.grantedSpells) ? selection.grantedSpells : [];
      const filterByMaxLevel = (entry) => {
        const id2 = getSpellId(entry);
        const def = spellCatalog.byId.get(id2);
        if (!def || typeof def.level !== "number") return true;
        if (def.level === 0) return true;
        return def.level <= maxSpellLevel;
      };
      const knownSpells = knownSpellsRaw.filter(filterByMaxLevel);
      const preparedSpells = preparedSpellsRaw.filter(filterByMaxLevel);
      const resolvedFocusInstanceId = selection.focusInstanceId ?? (selection.focusItemId ? ((_a3 = inventoryItems.find((item) => (item == null ? void 0 : item.id) === selection.focusItemId)) == null ? void 0 : _a3.instanceId) ?? null : null);
      sources2[source2.key] = {
        ability: source2.ability,
        preparation: source2.preparation,
        storage: source2.storage,
        casterProgression: source2.casterProgression,
        classLevel: source2.classLevel,
        focusInstanceId: resolvedFocusInstanceId ?? null,
        preparedSpellIds: preparedSpells.map((entry) => getSpellId(entry)),
        knownSpellIds: knownSpells.map((entry) => getSpellId(entry)),
        grantedSpellIds: grantedSpells.map((entry) => getSpellId(entry))
      };
      const parsedSource = parseSourceFromKey(source2.key);
      addSpellEntriesFromSelection(source2.key, knownSpells, "known", {
        sourceType: parsedSource.sourceType,
        sourceId: parsedSource.sourceId,
        classLevel: source2.classLevel,
        freePreparedFromGrants: source2.freePreparedFromGrants,
        preferSlot: true,
        sourceInstanceId: resolvedFocusInstanceId
      });
      addSpellEntriesFromSelection(source2.key, preparedSpells, "prepared", {
        sourceType: parsedSource.sourceType,
        sourceId: parsedSource.sourceId,
        classLevel: source2.classLevel,
        freePreparedFromGrants: source2.freePreparedFromGrants,
        preferSlot: true,
        sourceInstanceId: resolvedFocusInstanceId
      });
      addSpellEntriesFromSelection(source2.key, grantedSpells, "granted", {
        sourceType: parsedSource.sourceType,
        sourceId: parsedSource.sourceId,
        classLevel: source2.classLevel,
        freePreparedFromGrants: source2.freePreparedFromGrants,
        preferSlot: true,
        sourceInstanceId: resolvedFocusInstanceId
      });
      if (source2.slotsByLevel) {
        const row = source2.slotsByLevel[String(Math.max(0, totalCasterLevel))] ?? [];
        slotJustifications.push({
          source: source2.key,
          classLevel: source2.classLevel,
          casterProgression: source2.casterProgression,
          slotsByLevel: row
        });
      }
    });
    Object.entries(spellcastingSelections).forEach(([sourceKey, selection]) => {
      if (sources2[sourceKey]) return;
      const knownSpells = Array.isArray(selection == null ? void 0 : selection.knownSpells) ? selection.knownSpells : [];
      const preparedSpells = Array.isArray(selection == null ? void 0 : selection.preparedSpells) ? selection.preparedSpells : [];
      const grantedSpells = Array.isArray(selection == null ? void 0 : selection.grantedSpells) ? selection.grantedSpells : [];
      if (knownSpells.length + preparedSpells.length + grantedSpells.length === 0) return;
      const parsedSource = parseSourceFromKey(sourceKey);
      addSpellEntriesFromSelection(sourceKey, knownSpells, "known", {
        sourceType: parsedSource.sourceType,
        sourceId: parsedSource.sourceId,
        preferSlot: parsedSource.sourceType !== "item"
      });
      addSpellEntriesFromSelection(sourceKey, preparedSpells, "prepared", {
        sourceType: parsedSource.sourceType,
        sourceId: parsedSource.sourceId,
        preferSlot: parsedSource.sourceType !== "item"
      });
      addSpellEntriesFromSelection(sourceKey, grantedSpells, "granted", {
        sourceType: parsedSource.sourceType,
        sourceId: parsedSource.sourceId,
        preferSlot: parsedSource.sourceType !== "item"
      });
    });
    const getInventoryDefinitionGrants = (item) => {
      var _a3, _b3, _c2, _d2, _e2, _f2, _g2, _h2;
      if (!item) return [];
      const type2 = String(item.type ?? "").toLowerCase();
      const id2 = String(item.id ?? "");
      if (!id2) return [];
      if (type2 === "object") {
        return Array.isArray((_a3 = objectItemMap.get(id2)) == null ? void 0 : _a3.grants) ? ((_b3 = objectItemMap.get(id2)) == null ? void 0 : _b3.grants) ?? [] : [];
      }
      if (type2 === "armor") {
        return Array.isArray((_c2 = armorItemMap.get(id2)) == null ? void 0 : _c2.grants) ? ((_d2 = armorItemMap.get(id2)) == null ? void 0 : _d2.grants) ?? [] : [];
      }
      if (type2 === "tool") {
        return Array.isArray((_e2 = toolItemMap.get(id2)) == null ? void 0 : _e2.grants) ? ((_f2 = toolItemMap.get(id2)) == null ? void 0 : _f2.grants) ?? [] : [];
      }
      if (type2 === "weapon") {
        return Array.isArray((_g2 = weaponItemMap.get(id2)) == null ? void 0 : _g2.grants) ? ((_h2 = weaponItemMap.get(id2)) == null ? void 0 : _h2.grants) ?? [] : [];
      }
      return [];
    };
    inventoryItems.forEach((item) => {
      if (!(item == null ? void 0 : item.id)) return;
      if (!(item == null ? void 0 : item.equippedSlot)) return;
      const grants2 = getInventoryDefinitionGrants(item);
      if (grants2.length === 0) return;
      const sourceKey = `item:${item.instanceId ?? item.id}`;
      grants2.forEach((grant) => {
        if (String((grant == null ? void 0 : grant.kind) ?? "") !== "spell") return;
        const ids = Array.isArray(grant == null ? void 0 : grant.ids) ? grant.ids.map((id2) => String(id2)).filter(Boolean) : [];
        ids.forEach((spellId) => {
          upsertSpellGrant(sourceKey, spellId, {
            sourceType: "item",
            sourceId: String(item.id),
            sourceInstanceId: typeof item.instanceId === "string" ? item.instanceId : void 0,
            usage: resolveUsage(spellId, grant == null ? void 0 : grant.meta, false),
            tags: ["granted", "item"]
          });
        });
      });
    });
    const activeFeatureIds = Array.isArray(derivedGrants == null ? void 0 : derivedGrants.features) ? (_b2 = derivedGrants == null ? void 0 : derivedGrants.features) == null ? void 0 : _b2.map((id2) => String(id2)).filter(Boolean) : [];
    activeFeatureIds.forEach((featureId) => {
      const feature = featureById.get(featureId);
      const grants2 = Array.isArray(feature == null ? void 0 : feature.grants) ? feature.grants : [];
      grants2.forEach((grant) => {
        if (String((grant == null ? void 0 : grant.kind) ?? "") !== "spell") return;
        const ids = Array.isArray(grant == null ? void 0 : grant.ids) ? grant.ids.map((id2) => String(id2)).filter(Boolean) : [];
        ids.forEach((spellId) => {
          upsertSpellGrant(`feature:${featureId}`, spellId, {
            sourceType: "feature",
            sourceId: featureId,
            usage: resolveUsage(spellId, grant == null ? void 0 : grant.meta, true),
            tags: ["granted", "feature"]
          });
        });
      });
    });
    const spellGrants = {};
    spellGrantsBySource.forEach((entryMap, sourceKey) => {
      const list = Array.from(entryMap.values());
      if (list.length > 0) spellGrants[sourceKey] = list;
    });
    return {
      totalCasterLevel,
      slots,
      sources: sources2,
      spellGrants,
      slotJustifications
    };
  };
  const buildInventorySnapshot = () => {
    const items = inventoryItems.map((item) => ({
      ...item,
      instanceId: typeof (item == null ? void 0 : item.instanceId) === "string" && item.instanceId.length > 0 ? item.instanceId : createInstanceId("item")
    }));
    const containerIds = /* @__PURE__ */ new Set();
    items.forEach((item) => {
      const def = objectItemMap.get(item == null ? void 0 : item.id);
      const tags2 = Array.isArray(def == null ? void 0 : def.tags) ? def == null ? void 0 : def.tags.map((tag) => String(tag)) : [];
      if ((item == null ? void 0 : item.instanceId) && tags2.includes("sac")) {
        item.contenu = [];
        containerIds.add(item.instanceId);
      }
    });
    const getContainerInstanceIdForSlot = (slotId) => {
      const bag = items.find((entry) => (entry == null ? void 0 : entry.equippedSlot) === slotId && (entry == null ? void 0 : entry.instanceId));
      if ((bag == null ? void 0 : bag.instanceId) && containerIds.has(bag.instanceId)) return bag.instanceId;
      return null;
    };
    items.forEach((item) => {
      const storedIn = item == null ? void 0 : item.storedIn;
      if (!storedIn || !(item == null ? void 0 : item.instanceId)) return;
      let containerId = null;
      if (containerIds.has(storedIn)) {
        containerId = storedIn;
      } else if (packSlots.has(storedIn)) {
        containerId = getContainerInstanceIdForSlot(storedIn);
      }
      if (!containerId) return;
      const container = items.find((entry) => (entry == null ? void 0 : entry.instanceId) === containerId);
      if (!container) return;
      if (!Array.isArray(container.contenu)) container.contenu = [];
      container.contenu = Array.from(/* @__PURE__ */ new Set([...container.contenu, item.instanceId]));
    });
    return items;
  };
  const buildCharacterSave = () => {
    var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i2, _j2, _k2, _l2, _m2, _n2, _o2, _p2, _q2, _r2, _s2, _t2, _u2, _v2, _w2, _x2, _y2, _z2, _A2, _B2, _C, _D, _E, _F, _G, _H, _I, _J, _K, _L, _M, _N;
    const normalizedLanguages = normalizeLanguages((_a2 = props.character) == null ? void 0 : _a2.langues);
    const derived = buildDerivedGrants();
    const spellcastingState2 = buildSpellcastingState(derived == null ? void 0 : derived.grants);
    const resolvedLevel = Math.max(1, Math.min(20, Math.floor(resolveLevel() || 1)));
    const proficiencyBonus = computeProficiencyBonusForLevel(resolvedLevel);
    const computedMaxHp = computeMaxHp();
    const computedArmorClass = computeArmorClassFromEquipment2();
    const mods = {
      modFOR: computeMod(getScore("FOR")),
      modDEX: computeMod(getScore("DEX")),
      modCON: computeMod(getScore("CON")),
      modINT: computeMod(getScore("INT")),
      modSAG: computeMod(getScore("SAG")),
      modCHA: computeMod(getScore("CHA"))
    };
    const computedAttackBonus = mods.modFOR + proficiencyBonus;
    const computedPassivePerception = computePassivePerception(proficiencyBonus);
    const progressionHistory = buildProgressionHistory();
    if ((_b2 = spellcastingState2.slotJustifications) == null ? void 0 : _b2.length) {
      progressionHistory.push({
        source: "spellcasting",
        level: resolveLevel(),
        type: "spell-slots",
        payload: {
          totalCasterLevel: spellcastingState2.totalCasterLevel,
          slots: spellcastingState2.slots,
          slotJustifications: spellcastingState2.slotJustifications
        }
      });
    }
    const inventorySnapshot = buildInventorySnapshot();
    const rawCombatStats = ((_c2 = props.character) == null ? void 0 : _c2.combatStats) ?? null;
    const normalizedCombatStats = {
      ...rawCombatStats ?? {},
      level: resolvedLevel,
      mods,
      maxHp: Math.max(1, Math.floor(computedMaxHp)),
      armorClass: Math.max(1, Math.floor(computedArmorClass)),
      attackBonus: computedAttackBonus,
      maxAttacksPerTurn: Math.max(1, Number((rawCombatStats == null ? void 0 : rawCombatStats.maxAttacksPerTurn) ?? 1) || 1),
      actionsPerTurn: Math.max(1, Number((rawCombatStats == null ? void 0 : rawCombatStats.actionsPerTurn) ?? 1) || 1),
      bonusActionsPerTurn: Math.max(1, Number((rawCombatStats == null ? void 0 : rawCombatStats.bonusActionsPerTurn) ?? 1) || 1),
      actionRules: (rawCombatStats == null ? void 0 : rawCombatStats.actionRules) ?? { forbidSecondAttack: true },
      resources: (rawCombatStats == null ? void 0 : rawCombatStats.resources) && typeof rawCombatStats.resources === "object" ? rawCombatStats.resources : {}
    };
    const raceVisionMode = String(((_d2 = activeRace == null ? void 0 : activeRace.vision) == null ? void 0 : _d2.mode) ?? "").toLowerCase();
    const raceLightVision = raceVisionMode === "darkvision" ? "darkvision" : raceVisionMode === "lowlight" ? "lowlight" : "normal";
    const currentVision = ((_e2 = props.character) == null ? void 0 : _e2.visionProfile) ?? {};
    const normalizedVisionProfile = {
      shape: currentVision.shape ?? "cone",
      range: typeof currentVision.range === "number" ? currentVision.range : Number(((_f2 = activeRace == null ? void 0 : activeRace.vision) == null ? void 0 : _f2.range) ?? 100) || 100,
      apertureDeg: currentVision.apertureDeg ?? 180,
      lightVision: raceLightVision === "darkvision" ? "darkvision" : currentVision.lightVision ?? raceLightVision ?? "normal"
    };
    const currentMovementModes = ((_g2 = props.character) == null ? void 0 : _g2.movementModes) ?? {};
    const normalizedMovementModes = {
      ...currentMovementModes,
      walk: typeof (activeRace == null ? void 0 : activeRace.speed) === "number" ? activeRace.speed : Number(currentMovementModes.walk ?? 6) || 6
    };
    const rawCurrentHp = Number((_h2 = props.character) == null ? void 0 : _h2.pvActuels);
    const normalizedCurrentHp = Number.isFinite(rawCurrentHp) ? Math.max(0, Math.min(rawCurrentHp, normalizedCombatStats.maxHp)) : normalizedCombatStats.maxHp;
    return {
      id: props.character.id,
      nom: props.character.nom,
      age: (_i2 = props.character) == null ? void 0 : _i2.age,
      sexe: (_j2 = props.character) == null ? void 0 : _j2.sexe,
      taille: (_k2 = props.character) == null ? void 0 : _k2.taille,
      poids: (_l2 = props.character) == null ? void 0 : _l2.poids,
      langues: normalizedLanguages,
      alignement: (_m2 = props.character) == null ? void 0 : _m2.alignement,
      raceId: (_n2 = props.character) == null ? void 0 : _n2.raceId,
      backgroundId: (_o2 = props.character) == null ? void 0 : _o2.backgroundId,
      classe: ((_p2 = props.character) == null ? void 0 : _p2.classe) ?? {},
      niveauGlobal: resolvedLevel,
      xp: ((_q2 = props.character) == null ? void 0 : _q2.xp) ?? 0,
      dv: resolvePrimaryHitDie(),
      maitriseBonus: proficiencyBonus,
      pvActuels: normalizedCurrentHp,
      pvTmp: (_r2 = props.character) == null ? void 0 : _r2.pvTmp,
      nivFatigueActuel: (_s2 = props.character) == null ? void 0 : _s2.nivFatigueActuel,
      nivFatigueMax: (_t2 = props.character) == null ? void 0 : _t2.nivFatigueMax,
      actionIds: ((_u2 = props.character) == null ? void 0 : _u2.actionIds) ?? [],
      reactionIds: ((_v2 = props.character) == null ? void 0 : _v2.reactionIds) ?? [],
      combatStats: normalizedCombatStats,
      caracs: props.character.caracs,
      movementModes: normalizedMovementModes,
      visionProfile: normalizedVisionProfile,
      appearance: (_w2 = props.character) == null ? void 0 : _w2.appearance,
      competences: ((_x2 = props.character) == null ? void 0 : _x2.competences) ?? [],
      expertises: ((_y2 = props.character) == null ? void 0 : _y2.expertises) ?? [],
      initiative: (_z2 = props.character) == null ? void 0 : _z2.initiative,
      besoin: ((_A2 = props.character) == null ? void 0 : _A2.besoin) ?? [],
      percPassive: computedPassivePerception,
      proficiencies: ((_B2 = props.character) == null ? void 0 : _B2.proficiencies) ?? {},
      weaponMasteries: ((_C = props.character) == null ? void 0 : _C.weaponMasteries) ?? (((_D = derived == null ? void 0 : derived.grants) == null ? void 0 : _D.weaponMasteries) ?? []),
      savingThrows: ((_E = props.character) == null ? void 0 : _E.savingThrows) ?? [],
      inspiration: ((_F = props.character) == null ? void 0 : _F.inspiration) ?? false,
      notes: ((_G = props.character) == null ? void 0 : _G.notes) ?? "",
      argent: ((_H = props.character) == null ? void 0 : _H.argent) ?? {},
      materielSlots: ((_I = props.character) == null ? void 0 : _I.materielSlots) ?? {},
      inventoryItems: inventorySnapshot,
      descriptionPersonnage: (_J = props.character) == null ? void 0 : _J.descriptionPersonnage,
      profileDetails: (_K = props.character) == null ? void 0 : _K.profileDetails,
      choiceSelections: ((_L = props.character) == null ? void 0 : _L.choiceSelections) ?? {},
      creationLocks: ((_M = props.character) == null ? void 0 : _M.creationLocks) ?? {},
      classLocks: ((_N = props.character) == null ? void 0 : _N.classLocks) ?? {},
      progressionHistory,
      spellcastingState: spellcastingState2,
      derived
    };
  };
  const SAVED_SHEETS_KEY = "jdr5e_saved_sheets";
  const ACTIVE_SHEET_KEY = "jdr5e_active_sheet";
  const [savedSheets, setSavedSheets] = reactExports.useState(() => {
    if (typeof window === "undefined") return [];
    try {
      const raw = window.localStorage.getItem(SAVED_SHEETS_KEY);
      if (!raw) return [];
      const parsed = JSON.parse(raw);
      return Array.isArray(parsed) ? parsed : [];
    } catch {
      return [];
    }
  });
  const [activeSheetId, setActiveSheetId] = reactExports.useState(() => {
    if (typeof window === "undefined") return "";
    return window.localStorage.getItem(ACTIVE_SHEET_KEY) ?? "";
  });
  const [sheetNameInput, setSheetNameInput] = reactExports.useState("");
  const persistSheets = (next) => {
    setSavedSheets(next);
    if (typeof window === "undefined") return;
    try {
      window.localStorage.setItem(SAVED_SHEETS_KEY, JSON.stringify(next));
    } catch {
    }
  };
  const persistActiveSheetId = (id2) => {
    setActiveSheetId(id2);
    if (typeof window === "undefined") return;
    try {
      if (!id2) {
        window.localStorage.removeItem(ACTIVE_SHEET_KEY);
      } else {
        window.localStorage.setItem(ACTIVE_SHEET_KEY, id2);
      }
    } catch {
    }
  };
  const saveCurrentSheet = () => {
    const nameRaw = sheetNameInput.trim();
    const name2 = nameRaw || `Fiche ${(/* @__PURE__ */ new Date()).toLocaleString("fr-FR", {
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit"
    })}`;
    const entry = {
      id: createInstanceId("sheet"),
      name: name2,
      updatedAt: (/* @__PURE__ */ new Date()).toISOString(),
      character: JSON.parse(JSON.stringify(buildCharacterSave()))
    };
    const next = [entry, ...savedSheets];
    persistSheets(next);
    setSheetNameInput("");
    persistActiveSheetId(entry.id);
  };
  const deleteSheet = (id2) => {
    const next = savedSheets.filter((sheet) => sheet.id !== id2);
    persistSheets(next);
    if (activeSheetId === id2) {
      persistActiveSheetId("");
    }
  };
  const getClassAsiLevels = () => {
    const entries = [];
    const collect = (cls, level2) => {
      if (!cls || !cls.id) return;
      const progression2 = (cls == null ? void 0 : cls.progression) ?? {};
      Object.keys(progression2).map((key2) => Number(key2)).filter((lvl) => Number.isFinite(lvl) && lvl > 0 && lvl <= level2).filter((lvl) => {
        var _a2;
        const grants2 = ((_a2 = progression2[String(lvl)]) == null ? void 0 : _a2.grants) ?? [];
        return grants2.some(
          (grant) => (grant == null ? void 0 : grant.kind) === "bonus" && ((grant == null ? void 0 : grant.ids) ?? []).includes("asi-or-feat")
        );
      }).forEach((lvl) => {
        const key2 = `${cls.id}:${lvl}`;
        entries.push({
          key: key2,
          level: lvl,
          classId: cls.id,
          classLabel: cls.label ?? cls.id
        });
      });
    };
    const primaryLevel = Number((classEntry == null ? void 0 : classEntry.niveau) ?? 0);
    if (primaryLevel > 0) collect(classPrimary, primaryLevel);
    const secondaryLevel = Number((secondaryClassEntry == null ? void 0 : secondaryClassEntry.niveau) ?? 0);
    if (secondaryLevel > 0) collect(classSecondary, secondaryLevel);
    return entries.sort(
      (a2, b2) => a2.level === b2.level ? a2.classLabel.localeCompare(b2.classLabel) : a2.level - b2.level
    );
  };
  const getAsiKeysForClassLevel = (classId2, level2) => {
    const cls = classOptions.find((item) => item.id === classId2);
    if (!cls || !cls.progression) return [];
    return Object.keys(cls.progression).map((key2) => Number(key2)).filter((lvl) => Number.isFinite(lvl) && lvl > 0 && lvl <= level2).filter((lvl) => {
      var _a2, _b2;
      const grants2 = ((_b2 = (_a2 = cls.progression) == null ? void 0 : _a2[String(lvl)]) == null ? void 0 : _b2.grants) ?? [];
      return grants2.some(
        (grant) => (grant == null ? void 0 : grant.kind) === "bonus" && ((grant == null ? void 0 : grant.ids) ?? []).includes("asi-or-feat")
      );
    }).map((lvl) => `${classId2}:${lvl}`);
  };
  const getSubclassThresholdForClassId = (classId2) => {
    if (!classId2) return null;
    const cls = classOptions.find((item) => item.id === classId2);
    if (!cls) return null;
    return typeof cls.subclassLevel === "number" ? cls.subclassLevel : 1;
  };
  const getAsiEntryForLevel = (entryInfo) => {
    return asiSelections[entryInfo.key] ?? (entryInfo.classId === (classPrimary == null ? void 0 : classPrimary.id) ? asiSelections[String(entryInfo.level)] : null) ?? null;
  };
  const openAsiModal = (entryInfo) => {
    const entry = getAsiEntryForLevel(entryInfo);
    const type2 = (entry == null ? void 0 : entry.type) === "feat" ? "feat" : "asi";
    const stats = type2 === "asi" && (entry == null ? void 0 : entry.stats) ? { ...entry.stats } : {};
    setAsiModal({
      open: true,
      entry: entryInfo,
      step: "type",
      type: type2,
      stats,
      originalStats: { ...stats }
    });
  };
  const closeAsiModal = () => {
    setAsiModal((prev) => ({ ...prev, open: false }));
  };
  const setAsiModalStep = (step) => {
    setAsiModal((prev) => ({ ...prev, step }));
  };
  const setAsiModalType = (type2) => {
    setAsiModal((prev) => ({ ...prev, type: type2 }));
  };
  const updateAsiModalStat = (stat, delta) => {
    setAsiModal((prev) => {
      if (!prev.entry) return prev;
      const current = Number(prev.stats[stat] ?? 0);
      const nextValue = Math.max(0, Math.min(2, current + delta));
      const nextStats = { ...prev.stats };
      if (nextValue <= 0) {
        delete nextStats[stat];
      } else {
        nextStats[stat] = nextValue;
      }
      return { ...prev, stats: nextStats };
    });
  };
  const confirmAsiModalType = () => {
    if (!asiModal.entry) return;
    const slot = asiModal.entry.classId === (classPrimary == null ? void 0 : classPrimary.id) ? 1 : 2;
    if (asiModal.type === "feat") {
      const nextEntry = { type: "feat" };
      const overrides = { [asiModal.entry.key]: nextEntry };
      let otherMissing = [];
      const nextAsi = { ...asiSelections, [asiModal.entry.key]: nextEntry };
      const nextChoiceSelections = { ...choiceSelections, asi: nextAsi };
      if (pendingLocks.classes) {
        otherMissing = getMissingAsiEntries(overrides).filter(
          (entry) => {
            var _a2, _b2;
            return entry.classId === ((_a2 = asiModal.entry) == null ? void 0 : _a2.classId) && entry.key !== ((_b2 = asiModal.entry) == null ? void 0 : _b2.key);
          }
        );
        if (!hasSubclassChoicePending(slot) && !hasMissingClassFeatureChoiceForSlot(slot) && otherMissing.length === 0) {
          const nextPending = { ...pendingLocks };
          delete nextPending.classes;
          delete nextPending.classesSlot;
          const nextCharacter = buildClassLockCharacter(
            slot,
            nextChoiceSelections,
            nextPending
          );
          props.onChangeCharacter(nextCharacter);
        } else {
          props.onChangeCharacter({
            ...props.character,
            choiceSelections: nextChoiceSelections
          });
        }
      } else {
        props.onChangeCharacter({
          ...props.character,
          choiceSelections: nextChoiceSelections
        });
      }
      setAsiModal((prev) => ({ ...prev, step: "feat" }));
      if (pendingLocks.classes) {
        if (otherMissing.length > 0) {
          setTimeout(() => openAsiModal(otherMissing[0]), 0);
        } else if (hasMissingClassFeatureChoiceForSlot(slot)) {
          setTimeout(() => startClassDefine(slot), 0);
        }
      }
      return;
    }
    setAsiModal((prev) => ({ ...prev, step: "asi" }));
  };
  const confirmAsiModalStats = () => {
    if (!asiModal.entry) return;
    const slot = asiModal.entry.classId === (classPrimary == null ? void 0 : classPrimary.id) ? 1 : 2;
    const nextEntry = { type: "asi", stats: { ...asiModal.stats } };
    const overrides = { [asiModal.entry.key]: nextEntry };
    const nextAsi = { ...asiSelections, [asiModal.entry.key]: nextEntry };
    const nextChoiceSelections = { ...choiceSelections, asi: nextAsi };
    if (pendingLocks.classes) {
      const otherMissing = getMissingAsiEntries(overrides).filter(
        (entry) => {
          var _a2, _b2;
          return entry.classId === ((_a2 = asiModal.entry) == null ? void 0 : _a2.classId) && entry.key !== ((_b2 = asiModal.entry) == null ? void 0 : _b2.key);
        }
      );
      if (isAsiEntryComplete(nextEntry, asiModal.entry.key, overrides) && !hasSubclassChoicePending(slot) && !hasMissingClassFeatureChoiceForSlot(slot) && otherMissing.length === 0) {
        const nextPending = { ...pendingLocks };
        delete nextPending.classes;
        delete nextPending.classesSlot;
        const nextCharacter = buildClassLockCharacter(
          slot,
          nextChoiceSelections,
          nextPending
        );
        props.onChangeCharacter(nextCharacter);
      } else {
        props.onChangeCharacter({
          ...props.character,
          choiceSelections: nextChoiceSelections
        });
      }
    } else {
      props.onChangeCharacter({
        ...props.character,
        choiceSelections: nextChoiceSelections
      });
    }
    closeAsiModal();
    if (pendingLocks.classes) {
      const remaining = getMissingAsiEntries(overrides).filter(
        (entry) => {
          var _a2, _b2;
          return entry.classId === ((_a2 = asiModal.entry) == null ? void 0 : _a2.classId) && entry.key !== ((_b2 = asiModal.entry) == null ? void 0 : _b2.key);
        }
      );
      if (remaining.length > 0) {
        setTimeout(() => openAsiModal(remaining[0]), 0);
      } else if (hasMissingClassFeatureChoiceForSlot(slot)) {
        setTimeout(() => startClassDefine(slot), 0);
      }
    }
  };
  const POINT_BUY_COSTS = {
    8: 0,
    9: 1,
    10: 2,
    11: 3,
    12: 4,
    13: 5,
    14: 7,
    15: 9
  };
  const getPointBuyCost = (score) => {
    const cost = POINT_BUY_COSTS[score];
    return Number.isFinite(cost) ? cost : null;
  };
  const getBaseScoresSnapshot = () => {
    const snapshot = {};
    STAT_KEYS.forEach((key2) => {
      snapshot[key2] = getBaseScore(key2);
    });
    return snapshot;
  };
  const DEFAULT_POINT_BUY_BASE = {
    FOR: 15,
    DEX: 14,
    CON: 13,
    INT: 12,
    SAG: 10,
    CHA: 8
  };
  const isPointBuyStateValid = (bases) => {
    const summary2 = getPointBuySummary(bases);
    if (summary2.invalid) return false;
    return summary2.remaining !== null && summary2.remaining >= 0;
  };
  const getPointBuySummary = (overrides) => {
    let total = 0;
    let invalid = false;
    STAT_KEYS.forEach((key2) => {
      const base = (overrides == null ? void 0 : overrides[key2]) ?? getBaseScore(key2);
      const cost = getPointBuyCost(base);
      if (cost === null) {
        invalid = true;
        return;
      }
      total += cost;
    });
    const remaining = invalid ? null : 27 - total;
    return { total, remaining, invalid };
  };
  const canLockStats = () => {
    if (statsMode !== "normal") return true;
    const summary2 = getPointBuySummary();
    return !summary2.invalid && summary2.remaining === 0;
  };
  const canAdjustPointBuy = (key2, delta) => {
    const currentBases = getBaseScoresSnapshot();
    const current = currentBases[key2];
    const next = current + delta;
    if (next < 8 || next > 15) return false;
    const nextBases = { ...currentBases, [key2]: next };
    const summary2 = getPointBuySummary(nextBases);
    if (summary2.invalid) return false;
    return summary2.remaining !== null && summary2.remaining >= 0;
  };
  const setScore = (key2, value2) => {
    const desiredTotal = Math.max(1, Math.min(30, Math.floor(value2 || 1)));
    const bonus = getBonusSumForStat(key2);
    if (statsMode === "normal") {
      let base2 = desiredTotal - bonus;
      if (base2 < 8) base2 = 8;
      if (base2 > 15) base2 = 15;
      const currentBases = getBaseScoresSnapshot();
      const nextBase2 = { ...currentBases, [key2]: base2 };
      const summary2 = getPointBuySummary(nextBase2);
      if (summary2.invalid || summary2.remaining !== null && summary2.remaining < 0) {
        return;
      }
      setBaseScores(nextBase2);
      return;
    }
    let base = desiredTotal - bonus;
    if (base < 1) base = 1;
    if (base > 30) base = 30;
    const nextBase = { ...statsBase, [key2]: base };
    setBaseScores(nextBase);
  };
  reactExports.useEffect(() => {
    if (statsMode !== "normal") return;
    const snapshot = getBaseScoresSnapshot();
    const hasAll = STAT_KEYS.every((key2) => Number.isFinite(snapshot[key2]));
    if (!hasAll || !isPointBuyStateValid(snapshot)) {
      setBaseScores(DEFAULT_POINT_BUY_BASE);
    }
  }, [statsMode, (_z = props.character) == null ? void 0 : _z.id]);
  const competenceOptions = [
    { id: "athletisme", label: "Athletisme" },
    { id: "acrobaties", label: "Acrobaties" },
    { id: "escamotage", label: "Escamotage" },
    { id: "discretion", label: "Discretion" },
    { id: "arcanes", label: "Arcanes" },
    { id: "histoire", label: "Histoire" },
    { id: "investigation", label: "Investigation" },
    { id: "nature", label: "Nature" },
    { id: "religion", label: "Religion" },
    { id: "intuition", label: "Intuition" },
    { id: "medecine", label: "Medecine" },
    { id: "perception", label: "Perception" },
    { id: "survie", label: "Survie" },
    { id: "dressage", label: "Dressage" },
    { id: "intimidation", label: "Intimidation" },
    { id: "persuasion", label: "Persuasion" },
    { id: "tromperie", label: "Tromperie" },
    { id: "representation", label: "Representation" }
  ];
  const skillAbilityMap = {
    athletisme: "STR",
    acrobaties: "DEX",
    escamotage: "DEX",
    discretion: "DEX",
    arcanes: "INT",
    histoire: "INT",
    investigation: "INT",
    nature: "INT",
    religion: "INT",
    intuition: "WIS",
    medecine: "WIS",
    perception: "WIS",
    survie: "WIS",
    dressage: "WIS",
    intimidation: "CHA",
    persuasion: "CHA",
    tromperie: "CHA",
    representation: "CHA"
  };
  const armorMasteryOptions = [
    { id: "legere", label: "Legere" },
    { id: "intermediaire", label: "Intermediaire" },
    { id: "lourde", label: "Lourde" },
    { id: "bouclier", label: "Bouclier" }
  ];
  const toolMasteryOptions = [
    { id: "outils_artisan", label: "Outils d'artisan" },
    { id: "outils_jeux", label: "Boite de jeux" },
    { id: "outils_instruments", label: "Instruments de musique" },
    { id: "outils_autres", label: "Autres outils" },
    { id: "outils_vehicules", label: "Vehicules" }
  ];
  const activeClassEntry = activeClassSlot === 1 ? classEntry : secondaryClassEntry;
  const activeClassId = activeClassSlot === 1 ? selectedClassId : selectedSecondaryClassId;
  const activeSubclassId = activeClassSlot === 1 ? selectedSubclassId : selectedSecondarySubclassId;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      style: {
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        justifyContent: "center",
        height: "100vh",
        background: "#0b0b12",
        color: "#f5f5f5",
        fontFamily: "system-ui, sans-serif",
        padding: 16,
        boxSizing: "border-box"
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { style: { marginBottom: 8 }, children: "Preparation du combat" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { marginBottom: 16, fontSize: 13, maxWidth: 480, textAlign: "center" }, children: "Configurez le combat avant de lancer la grille : nombre d'ennemis, puis demarrez pour effectuer les jets d'initiative et entrer en mode tour par tour." }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            style: {
              padding: 16,
              borderRadius: 8,
              background: "#141421",
              border: "1px solid #333",
              minWidth: 320,
              width: "min(680px, 92vw)",
              display: "flex",
              flexDirection: "column",
              gap: 12
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "div",
                {
                  style: {
                    borderRadius: 8,
                    border: "1px solid rgba(255,255,255,0.12)",
                    background: "rgba(10,10,16,0.7)",
                    padding: 10,
                    display: "flex",
                    flexDirection: "column",
                    gap: 8
                  },
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, fontWeight: 800 }, children: "Fiches sauvegardees" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: 8, flexWrap: "wrap" }, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "input",
                        {
                          type: "text",
                          placeholder: "Nom de la fiche",
                          value: sheetNameInput,
                          onChange: (e2) => setSheetNameInput(e2.target.value),
                          style: {
                            flex: "1 1 220px",
                            background: "#0f0f19",
                            color: "#f5f5f5",
                            border: "1px solid #333",
                            borderRadius: 6,
                            padding: "6px 8px",
                            fontSize: 12
                          }
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "button",
                        {
                          type: "button",
                          onClick: saveCurrentSheet,
                          style: {
                            padding: "6px 10px",
                            borderRadius: 6,
                            border: "1px solid rgba(255,255,255,0.15)",
                            background: "rgba(46, 204, 113, 0.16)",
                            color: "#f5f5f5",
                            cursor: "pointer",
                            fontSize: 12,
                            fontWeight: 700
                          },
                          children: "Sauvegarder"
                        }
                      ),
                      activeSheetId && /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "button",
                        {
                          type: "button",
                          onClick: () => persistActiveSheetId(""),
                          style: {
                            padding: "6px 10px",
                            borderRadius: 6,
                            border: "1px solid rgba(255,255,255,0.15)",
                            background: "rgba(231, 76, 60, 0.18)",
                            color: "#f5f5f5",
                            cursor: "pointer",
                            fontSize: 12,
                            fontWeight: 700
                          },
                          children: "Desactiver"
                        }
                      )
                    ] }),
                    savedSheets.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.6)" }, children: "Aucune fiche sauvegardee." }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "grid", gap: 6 }, children: savedSheets.map((sheet) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      "div",
                      {
                        style: {
                          display: "flex",
                          alignItems: "center",
                          justifyContent: "space-between",
                          gap: 8,
                          padding: "6px 8px",
                          borderRadius: 6,
                          border: "1px solid rgba(255,255,255,0.12)",
                          background: sheet.id === activeSheetId ? "rgba(79,125,242,0.18)" : "rgba(12,12,18,0.6)"
                        },
                        children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { minWidth: 0 }, children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, fontWeight: 700 }, children: sheet.name }),
                            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 10, color: "rgba(255,255,255,0.6)" }, children: new Date(sheet.updatedAt).toLocaleString("fr-FR") })
                          ] }),
                          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: 6 }, children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsx(
                              "button",
                              {
                                type: "button",
                                onClick: () => persistActiveSheetId(sheet.id),
                                style: {
                                  padding: "4px 8px",
                                  borderRadius: 6,
                                  border: "1px solid rgba(255,255,255,0.15)",
                                  background: sheet.id === activeSheetId ? "rgba(46, 204, 113, 0.18)" : "rgba(255,255,255,0.08)",
                                  color: "#f5f5f5",
                                  cursor: "pointer",
                                  fontSize: 11,
                                  fontWeight: 700
                                },
                                children: sheet.id === activeSheetId ? "Active" : "Activer"
                              }
                            ),
                            /* @__PURE__ */ jsxRuntimeExports.jsx(
                              "button",
                              {
                                type: "button",
                                onClick: () => deleteSheet(sheet.id),
                                style: {
                                  padding: "4px 8px",
                                  borderRadius: 6,
                                  border: "1px solid rgba(255,255,255,0.15)",
                                  background: "rgba(255,255,255,0.08)",
                                  color: "#f5f5f5",
                                  cursor: "pointer",
                                  fontSize: 11,
                                  fontWeight: 700
                                },
                                children: "Supprimer"
                              }
                            )
                          ] })
                        ]
                      },
                      sheet.id
                    )) })
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", gap: 8, flexWrap: "wrap" }, children: [{ id: "map", label: "Carte" }, { id: "player", label: "Joueur" }].map(
                (tab) => {
                  const isActive = activeMainTab === tab.id;
                  return /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "button",
                    {
                      type: "button",
                      onClick: () => setActiveMainTab(tab.id),
                      style: {
                        padding: "6px 10px",
                        borderRadius: 6,
                        border: `1px solid ${isActive ? "#4f7df2" : "#333"}`,
                        background: isActive ? "rgba(79,125,242,0.2)" : "#0f0f19",
                        color: isActive ? "#dfe8ff" : "#c9cfdd",
                        cursor: "pointer",
                        fontSize: 12,
                        fontWeight: 700
                      },
                      children: tab.label
                    },
                    tab.id
                  );
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  style: {
                    display: "flex",
                    gap: 8,
                    flexWrap: "wrap",
                    minHeight: 36,
                    alignItems: "center"
                  },
                  children: activeMainTab === "player" && [
                    { id: "species", label: "Espece" },
                    { id: "backgrounds", label: "Historique" },
                    { id: "profile", label: "Profil" },
                    { id: "stats", label: "Stats" },
                    { id: "classes", label: "Classes" },
                    ...magicSources.length > 0 ? [{ id: "magic", label: "Magie" }] : [],
                    { id: "equip", label: "Equipement" },
                    { id: "skills", label: "Competences" },
                    { id: "masteries", label: "Maitrises" },
                    { id: "sheet", label: "Fiche complete" }
                  ].map((tab) => {
                    const isActive = activePlayerTab === tab.id;
                    const tabAccent = tabAccentColors[tab.id] ?? "#6fd3a8";
                    const borderColor = toRgba(tabAccent, isActive ? 0.9 : 0.55);
                    const lockedBackground = isSectionLocked(tab.id) ? toRgba(tabAccent, isActive ? 0.22 : 0.12) : null;
                    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      "button",
                      {
                        type: "button",
                        onClick: () => setActivePlayerTab(tab.id),
                        style: {
                          padding: "6px 10px",
                          borderRadius: 6,
                          border: `1px solid ${borderColor}`,
                          background: lockedBackground ?? (isActive ? toRgba(tabAccent, 0.18) : "#0f0f19"),
                          color: isActive ? "#f0f7ff" : "#c9cfdd",
                          cursor: "pointer",
                          fontSize: 12,
                          fontWeight: 700,
                          minWidth: 120,
                          justifyContent: "center",
                          display: "inline-flex",
                          alignItems: "center",
                          gap: 6
                        },
                        children: [
                          tab.label,
                          isSectionLocked(tab.id) && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { display: "inline-flex" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(LockIcon, { color: tabAccent }) })
                        ]
                      },
                      tab.id
                    );
                  })
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "div",
                {
                  style: {
                    border: "1px solid rgba(255,255,255,0.08)",
                    borderRadius: 8,
                    padding: 12,
                    background: "rgba(10,10,18,0.6)",
                    height: "52vh",
                    overflowY: "auto",
                    display: "flex",
                    flexDirection: "column",
                    gap: 12
                  },
                  children: [
                    activeMainTab === "map" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { style: { fontSize: 13, display: "flex", flexDirection: "column", gap: 6 }, children: [
                        "Contexte de la battle map :",
                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                          "textarea",
                          {
                            value: props.mapPrompt,
                            onChange: (e2) => props.onChangeMapPrompt(e2.target.value),
                            placeholder: "Ex: Un donjon humide: une salle, un couloir, une porte verrouillee, des piliers. Ennemis en embuscade au fond.",
                            rows: 4,
                            style: {
                              resize: "vertical",
                              minHeight: 84,
                              background: "#0f0f19",
                              color: "#f5f5f5",
                              border: "1px solid #333",
                              borderRadius: 6,
                              padding: "8px 10px",
                              fontSize: 12,
                              lineHeight: 1.35
                            }
                          }
                        )
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 13, display: "flex", alignItems: "center", gap: 10 }, children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Nombre d'ennemis :" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsxs(
                          "div",
                          {
                            style: {
                              display: "flex",
                              alignItems: "center",
                              gap: 6,
                              padding: "4px 6px",
                              borderRadius: 8,
                              border: "1px solid #2a2a3a",
                              background: "#0f0f19"
                            },
                            children: [
                              /* @__PURE__ */ jsxRuntimeExports.jsx(
                                "button",
                                {
                                  type: "button",
                                  onClick: () => props.onChangeEnemyCount(Math.max(1, props.configEnemyCount - 1)),
                                  style: {
                                    width: 30,
                                    height: 30,
                                    borderRadius: 6,
                                    border: "1px solid #333",
                                    background: "#141421",
                                    color: "#f5f5f5",
                                    cursor: "pointer",
                                    display: "grid",
                                    placeItems: "center"
                                  },
                                  "aria-label": "Diminuer le nombre d'ennemis",
                                  children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { width: "12", height: "12", viewBox: "0 0 12 12", "aria-hidden": "true", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "2", y: "5.25", width: "8", height: "1.5", fill: "currentColor" }) })
                                }
                              ),
                              /* @__PURE__ */ jsxRuntimeExports.jsx(
                                "input",
                                {
                                  type: "number",
                                  min: 1,
                                  max: 8,
                                  value: props.configEnemyCount,
                                  onChange: (e2) => props.onChangeEnemyCount(Math.max(1, Math.min(8, Number(e2.target.value) || 1))),
                                  style: {
                                    width: 60,
                                    background: "#0f0f19",
                                    color: "#f5f5f5",
                                    border: "1px solid #333",
                                    borderRadius: 6,
                                    padding: "4px 6px",
                                    textAlign: "center",
                                    appearance: "textfield",
                                    WebkitAppearance: "textfield",
                                    MozAppearance: "textfield"
                                  }
                                }
                              ),
                              /* @__PURE__ */ jsxRuntimeExports.jsx(
                                "button",
                                {
                                  type: "button",
                                  onClick: () => props.onChangeEnemyCount(Math.min(8, props.configEnemyCount + 1)),
                                  style: {
                                    width: 30,
                                    height: 30,
                                    borderRadius: 6,
                                    border: "1px solid #333",
                                    background: "#141421",
                                    color: "#f5f5f5",
                                    cursor: "pointer",
                                    display: "grid",
                                    placeItems: "center"
                                  },
                                  "aria-label": "Augmenter le nombre d'ennemis",
                                  children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: "12", height: "12", viewBox: "0 0 12 12", "aria-hidden": "true", children: [
                                    /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "2", y: "5.25", width: "8", height: "1.5", fill: "currentColor" }),
                                    /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "5.25", y: "2", width: "1.5", height: "8", fill: "currentColor" })
                                  ] })
                                }
                              )
                            ]
                          }
                        )
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { style: { fontSize: 11, color: "#b0b8c4", margin: 0 }, children: [
                        "Taille de la carte : mode texte utilise (",
                        props.gridCols,
                        " x ",
                        props.gridRows,
                        ")."
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "button",
                        {
                          type: "button",
                          onClick: () => {
                            if (props.enemyTypeCount === 0) {
                              props.onNoEnemyTypes();
                              return;
                            }
                            props.onStartCombat();
                          },
                          style: {
                            marginTop: 8,
                            padding: "6px 12px",
                            background: "#2ecc71",
                            color: "#0b0b12",
                            border: "none",
                            borderRadius: 4,
                            cursor: "pointer",
                            fontWeight: 600,
                            fontSize: 13
                          },
                          children: "Lancer le combat"
                        }
                      )
                    ] }),
                    activeMainTab === "player" && activePlayerTab === "equip" && /* @__PURE__ */ jsxRuntimeExports.jsx(
                      EquipmentTab,
                      {
                        toggleSectionLock,
                        getLockButtonState,
                        renderPendingBadge,
                        getPendingCountForSection,
                        lockButtonBaseStyle,
                        equipSubTab,
                        setEquipSubTab,
                        equipMessage,
                        setEquipMessage,
                        slotGroups,
                        renderSlotGroup,
                        packSlotStatus,
                        inventoryItems,
                        getItemLabel,
                        getItemCategories,
                        canUseClothingPieces,
                        equipmentSlots: EQUIPMENT_SLOTS,
                        resolveStoredSlotId,
                        packSlots,
                        getSlotLabel,
                        getItemWeight,
                        storeItemInPack,
                        updateItemSlot,
                        isSectionLocked,
                        getItemUnitValue,
                        isCurrencyItem,
                        moneyToCopper,
                        formatMoneyValue,
                        onSellRequest: handleSellRequest,
                        setPrimaryWeapon,
                        isItemHarmonisable,
                        isItemHarmonized: isInventoryItemHarmonized2,
                        toggleItemHarmonization,
                        removeManualItem,
                        renderSourceDotsWithLabels,
                        getItemSources,
                        carryWeight,
                        carryCapacityMax,
                        weaponOptions,
                        toolItems,
                        armorItems,
                        objectItems,
                        addManualItem
                      }
                    ),
                    activeMainTab === "player" && activePlayerTab === "stats" && /* @__PURE__ */ jsxRuntimeExports.jsx(
                      StatsTab,
                      {
                        statsMode,
                        setStatsMode,
                        canLockStats,
                        toggleSectionLock,
                        resetStats,
                        isSectionLocked,
                        lockButtonBaseStyle,
                        getLockButtonState,
                        renderPendingBadge,
                        getPendingCountForSection,
                        getPointBuySummary,
                        statKeys: STAT_KEYS,
                        getBaseScore,
                        getBonusSumForStat,
                        computeMod,
                        getStatSources,
                        renderSourceDots,
                        setScore,
                        canAdjustPointBuy
                      }
                    ),
                    activeMainTab === "player" && activePlayerTab === "skills" && /* @__PURE__ */ jsxRuntimeExports.jsx(
                      SkillsTab,
                      {
                        skillsMode,
                        setSkillsMode,
                        resetSkills,
                        isSectionLocked,
                        toggleSectionLock,
                        lockButtonBaseStyle,
                        getLockButtonState,
                        renderPendingBadge,
                        getPendingCountForSection,
                        competenceOptions,
                        expertises,
                        competences,
                        resolveLevel,
                        computeMod,
                        getScore,
                        skillAbilityMap,
                        renderSourceDots,
                        getSkillSources,
                        canEditSkills,
                        toggleCompetence,
                        toggleExpertise
                      }
                    ),
                    activeMainTab === "player" && activePlayerTab === "masteries" && /* @__PURE__ */ jsxRuntimeExports.jsx(
                      MasteriesTab,
                      {
                        masteriesMode,
                        setMasteriesMode,
                        resetMasteries,
                        isSectionLocked,
                        toggleSectionLock,
                        lockButtonBaseStyle,
                        getLockButtonState,
                        renderPendingBadge,
                        getPendingCountForSection,
                        weaponProficiencyOptions: WEAPON_PROFICIENCY_OPTIONS,
                        unlockedWeaponMasteries,
                        unlockedFightingStyles: selectedCombatStyles,
                        armorMasteryOptions,
                        toolMasteryOptions,
                        weaponMasteries: weaponProficiencies,
                        armorMasteries,
                        toolMasteries,
                        toggleWeaponMastery: (value2) => canEditMasteries && toggleMastery("weapons", value2),
                        toggleArmorMastery: (value2) => canEditMasteries && toggleMastery("armors", value2),
                        toggleToolMastery: (value2) => canEditMasteries && toggleMastery("tools", value2),
                        canEditMasteries,
                        renderSourceDots,
                        getMasterySources
                      }
                    ),
                    activeMainTab === "player" && activePlayerTab === "species" && /* @__PURE__ */ jsxRuntimeExports.jsx(
                      SpeciesTab,
                      {
                        isSectionLocked,
                        lockButtonBaseStyle,
                        getLockButtonState,
                        renderPendingBadge,
                        getPendingCountForSection,
                        onLockClick: () => {
                          if (isSectionLocked("species")) {
                            resetSpeciesImpacts();
                            return;
                          }
                          if (hasPendingRaceChoices()) {
                            props.onChangeCharacter({
                              ...props.character,
                              choiceSelections: {
                                ...choiceSelections,
                                pendingLocks: { ...pendingLocks, species: true }
                              }
                            });
                            requireRaceChoices();
                            return;
                          }
                          setSectionLock("species", true);
                        },
                        raceOptions,
                        selectedRaceId,
                        handleSpeciesSelect,
                        activeRace,
                        getRaceTraits
                      }
                    ),
                    activeMainTab === "player" && activePlayerTab === "classes" && /* @__PURE__ */ jsxRuntimeExports.jsx(
                      ClassesTab,
                      {
                        activeClassTab,
                        resolvedClassTab,
                        setActiveClassTab,
                        isSectionLocked,
                        lockButtonBaseStyle,
                        getClassLockButtonState,
                        renderPendingBadge,
                        getPendingCountForSection,
                        resetClassImpactsForSlot,
                        hasPendingClassChoicesForSlot,
                        startClassDefine,
                        setClassLockForSlot,
                        resolveLevel,
                        setLevel,
                        classOptions,
                        subclassOptions,
                        isActiveClassLocked,
                        activeClassSlot,
                        activeClassId,
                        activeSubclassId,
                        activeClassEntry,
                        handleClassSelect,
                        setSubclassSelection,
                        setClassLevel,
                        isSecondaryEnabled,
                        enableSecondaryClass,
                        removeSecondaryClass
                      }
                    ),
                    activeMainTab === "player" && activePlayerTab === "backgrounds" && /* @__PURE__ */ jsxRuntimeExports.jsx(
                      BackgroundsTab,
                      {
                        isSectionLocked,
                        lockButtonBaseStyle,
                        getLockButtonState,
                        renderPendingBadge,
                        getPendingCountForSection,
                        backgroundOptions,
                        selectedBackgroundId,
                        handleBackgroundSelect,
                        onLockClick: () => {
                          if (isSectionLocked("backgrounds")) {
                            resetBackgroundImpacts();
                            return;
                          }
                          if (hasPendingBackgroundChoices()) {
                            startBackgroundDefine();
                            return;
                          }
                          lockBackgroundAndCreateEquipment();
                        },
                        activeBackground,
                        getBackgroundFeatureInfo,
                        getBackgroundToolChoice,
                        getBackgroundLanguageChoice,
                        getBackgroundSkillProficiencies,
                        getBackgroundToolProficiencies,
                        formatEquipmentLabel,
                        toolMasteryOptions,
                        competenceOptions
                      }
                    ),
                    activeMainTab === "player" && activePlayerTab === "profile" && /* @__PURE__ */ jsxRuntimeExports.jsx(
                      ProfileTab,
                      {
                        character: props.character,
                        profileDetails,
                        setNameField,
                        setPhysiqueDetail,
                        setProfileDetail,
                        isSectionLocked,
                        toggleSectionLock,
                        lockButtonBaseStyle,
                        getLockButtonState,
                        renderPendingBadge,
                        getPendingCountForSection
                      }
                    ),
                    activeMainTab === "player" && activePlayerTab === "magic" && magicSources.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
                      MagicPanel,
                      {
                        magicSources,
                        activeMagicTab,
                        setActiveMagicTab,
                        isSectionLocked,
                        toggleSectionLock,
                        lockButtonBaseStyle,
                        getLockButtonState,
                        spellcastingSelections,
                        spellGrantsBySource: ((_B = (_A = props.character) == null ? void 0 : _A.spellcastingState) == null ? void 0 : _B.spellGrants) ?? {},
                        updateSpellcastingSelection,
                        computeMod,
                        getScore,
                        resolveLevel,
                        getCasterContribution,
                        resolveItemTags,
                        inventoryItems,
                        formatEquipmentLabel,
                        getSpellId,
                        makeSpellEntry
                      }
                    ),
                    activeMainTab === "player" && activePlayerTab === "sheet" && /* @__PURE__ */ jsxRuntimeExports.jsx(
                      SheetTab,
                      {
                        character: props.character,
                        onChangeCharacter: props.onChangeCharacter,
                        choiceSelections,
                        magicSources,
                        spellcastingSelections,
                        renderValidatedBadge,
                        getSectionValidated,
                        activeRace,
                        getRaceTraits,
                        activeBackground,
                        getBackgroundFeatureInfo,
                        getBackgroundSkillProficiencies,
                        getBackgroundToolProficiencies,
                        competenceOptions,
                        toolMasteryOptions,
                        classPrimary,
                        classSecondary,
                        classEntry,
                        secondaryClassEntry,
                        selectedSubclassId,
                        selectedSecondarySubclassId,
                        subclassOptions,
                        asiSelections,
                        getScore,
                        computeMod,
                        resolveLevel,
                        computeArmorClassFromEquipment: computeArmorClassFromEquipment2,
                        computeMaxHp,
                        competences,
                        expertises,
                        skillAbilityMap,
                        weaponMasteries: weaponProficiencies,
                        unlockedWeaponMasteries,
                        unlockedFightingStyles: selectedCombatStyles,
                        armorMasteries,
                        toolMasteries,
                        EQUIPMENT_SLOTS,
                        materielSlots,
                        packSlots,
                        packSlotStatus,
                        inventoryItems,
                        getSlotLabel,
                        formatEquipmentLabel
                      }
                    )
                  ]
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          AsiModal,
          {
            open: asiModal.open,
            entry: asiModal.entry,
            step: asiModal.step,
            type: asiModal.type,
            stats: asiModal.stats,
            originalStats: asiModal.originalStats,
            statKeys: STAT_KEYS,
            asiBonusMap,
            getBaseScore,
            getNonAsiBonusSumForStat,
            setType: setAsiModalType,
            setStep: setAsiModalStep,
            onClose: closeAsiModal,
            onConfirmType: confirmAsiModalType,
            onConfirmStats: confirmAsiModalStats,
            updateStat: updateAsiModalStat,
            canAllocateMoreAsi
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          ChoiceModal,
          {
            open: choiceModal.open,
            title: choiceModal.title,
            options: choiceModal.options,
            selected: choiceModal.selected,
            count: choiceModal.count,
            multi: choiceModal.multi,
            onToggle: handleChoiceToggle,
            onClose: closeChoiceModal,
            onConfirm: handleChoiceConfirm
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          ConfirmModal,
          {
            open: confirmModal.open,
            title: confirmModal.title,
            message: confirmModal.message,
            onCancel: closeConfirmModal,
            onConfirm: confirmModal.onConfirm
          }
        )
      ]
    }
  );
}
function GameOverOverlay(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      style: {
        position: "fixed",
        inset: 0,
        background: "rgba(0, 0, 0, 0.75)",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        zIndex: 1e3
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          style: {
            background: "#141421",
            borderRadius: 12,
            border: "1px solid #f1c40f",
            padding: "24px 32px",
            maxWidth: 360,
            textAlign: "center",
            boxShadow: "0 0 24px rgba(0,0,0,0.6)"
          },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { style: { margin: "0 0 8px" }, children: "Game Over" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { fontSize: 13, margin: "0 0 16px" }, children: "Le hros est tomb et aucun alli n'est en mesure de continuer." }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "button",
                onClick: props.onRestart,
                style: {
                  padding: "6px 12px",
                  background: "#e67e22",
                  color: "#fff",
                  border: "none",
                  borderRadius: 6,
                  cursor: "pointer",
                  fontSize: 13,
                  fontWeight: 600
                },
                children: "Recommencer le combat"
              }
            )
          ]
        }
      )
    }
  );
}
function InitiativePanel(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      style: {
        marginBottom: 8,
        padding: "6px 10px",
        background: "#111322",
        borderRadius: 8,
        border: "1px solid #333",
        display: "flex",
        flexDirection: "column",
        gap: 4,
        maxWidth: "100%"
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            style: {
              display: "flex",
              justifyContent: "space-between",
              alignItems: "center",
              marginBottom: 4
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { style: { fontSize: 12, color: "#b0b8c4" }, children: [
                "Ordre d'initiative (round ",
                props.round,
                ")"
              ] }),
              props.activeEntry && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { style: { fontSize: 11, color: "#f1c40f" }, children: [
                "Tour actuel :",
                " ",
                props.activeEntry.kind === "player" ? "Joueur" : props.activeEntry.kind === "summon" ? `Summon (${props.activeEntry.id})` : props.activeEntry.id
              ] })
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            style: {
              display: "flex",
              gap: 8,
              alignItems: "center",
              overflowX: "auto",
              paddingBottom: 2
            },
            children: props.timelineEntries.map((entry) => {
              const isActive = props.activeEntry && entry.id === props.activeEntry.id && entry.kind === props.activeEntry.kind;
              const isPlayer = entry.kind === "player";
              const isSummon = entry.kind === "summon";
              const tokenState = entry.kind === "player" ? props.player : props.enemies.find((e2) => e2.id === entry.id) || null;
              const isDead = tokenState ? isTokenDead(tokenState) : false;
              const token = isPlayer ? { label: "PJ", color: "#7dc4ff" } : isSummon ? {
                label: `SUM`,
                color: entry.ownerType === "player" ? "#7dc4ff" : "#ff6b6b"
              } : { label: entry.id, color: "#ff6b6b" };
              return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "div",
                {
                  style: {
                    display: "flex",
                    flexDirection: "column",
                    alignItems: "center",
                    padding: 4,
                    borderRadius: 6,
                    border: isActive ? "2px solid #f1c40f" : "1px solid #333",
                    background: isDead ? "#111118" : isActive ? "#1b1b30" : "#101020",
                    minWidth: 48
                  },
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "div",
                      {
                        "aria-hidden": "true",
                        style: {
                          width: 32,
                          height: 32,
                          borderRadius: "50%",
                          background: isDead ? "#2b2b38" : token.color,
                          border: "1px solid rgba(255,255,255,0.18)",
                          display: "flex",
                          alignItems: "center",
                          justifyContent: "center",
                          fontSize: 12,
                          fontWeight: 700,
                          color: "#0b0b12",
                          textTransform: "uppercase",
                          filter: isDead ? "grayscale(1)" : "none"
                        },
                        children: token.label.slice(0, 2)
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "span",
                      {
                        style: {
                          fontSize: 10,
                          marginTop: 2,
                          color: isDead ? "#777a8a" : "#d0d6e0",
                          whiteSpace: "nowrap",
                          textDecoration: isDead ? "line-through" : "none"
                        },
                        children: isSummon ? `${token.label} ${entry.id}` : token.label
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(
                      "span",
                      {
                        style: {
                          fontSize: 9,
                          color: "#9aa0b5"
                        },
                        children: [
                          "Init ",
                          entry.initiative
                        ]
                      }
                    )
                  ]
                },
                `${entry.kind}-${entry.id}`
              );
            })
          }
        )
      ]
    }
  );
}
function EffectsPanel(props) {
  var _a;
  const [mode, setMode] = reactExports.useState("zones");
  const sortedAnimations = reactExports.useMemo(() => {
    return [...props.fxAnimations].sort((a2, b2) => a2.key.localeCompare(b2.key));
  }, [props.fxAnimations]);
  const [selectedKey, setSelectedKey] = reactExports.useState(
    ((_a = sortedAnimations[0]) == null ? void 0 : _a.key) ?? ""
  );
  const [frameIndex, setFrameIndex] = reactExports.useState(0);
  const [isPlaying, setIsPlaying] = reactExports.useState(false);
  const [fps, setFps] = reactExports.useState(12);
  const selected = sortedAnimations.find((a2) => a2.key === selectedKey) ?? null;
  const frames = (selected == null ? void 0 : selected.frames) ?? [];
  const safeIndex = frames.length > 0 ? Math.max(0, Math.min(frameIndex, frames.length - 1)) : 0;
  const currentFrame = frames[safeIndex] ?? null;
  reactExports.useEffect(() => {
    if (!selected) return;
    setFrameIndex(0);
    setIsPlaying(false);
  }, [selectedKey]);
  reactExports.useEffect(() => {
    if (!isPlaying || frames.length === 0) return;
    const interval = Math.max(40, Math.round(1e3 / Math.max(1, fps)));
    const timer = window.setInterval(() => {
      setFrameIndex((prev) => (prev + 1) % frames.length);
    }, interval);
    return () => window.clearInterval(timer);
  }, [isPlaying, frames.length, fps]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "section",
    {
      style: {
        padding: "8px 12px",
        background: "#141421",
        borderRadius: 8,
        border: "1px solid #333",
        display: "flex",
        flexDirection: "column",
        gap: 8,
        maxHeight: "100%",
        overflowY: "auto"
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: 8, flexWrap: "wrap" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              type: "button",
              onClick: () => setMode("zones"),
              style: {
                padding: "4px 8px",
                background: mode === "zones" ? "#2ecc71" : "#555",
                color: mode === "zones" ? "#0b0b12" : "#fff",
                border: "none",
                borderRadius: 6,
                cursor: "pointer",
                fontSize: 12,
                fontWeight: 800
              },
              children: "Zones"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              type: "button",
              onClick: () => setMode("animations"),
              style: {
                padding: "4px 8px",
                background: mode === "animations" ? "#f1c40f" : "#555",
                color: mode === "animations" ? "#0b0b12" : "#fff",
                border: "none",
                borderRadius: 6,
                cursor: "pointer",
                fontSize: 12,
                fontWeight: 800
              },
              children: "Animations"
            }
          )
        ] }),
        mode === "zones" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { style: { margin: "6px 0 4px" }, children: "Zones d'effet (demo)" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { style: { margin: 0, fontSize: 12 }, children: [
            "Ces boutons utilisent les helpers de ",
            /* @__PURE__ */ jsxRuntimeExports.jsx("code", { children: "boardEffects.ts" }),
            " pour dessiner des zones en coordonnes de grille autour du joueur."
          ] }),
          props.visionLegend ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { margin: 0, fontSize: 12, color: "#bfc6d2" }, children: props.visionLegend }) : null,
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", flexWrap: "wrap", gap: 8, marginTop: 8 }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "button",
                onClick: props.onShowCircle,
                style: {
                  padding: "4px 8px",
                  background: "#2980b9",
                  color: "#fff",
                  border: "none",
                  borderRadius: 4,
                  cursor: "pointer",
                  fontSize: 12
                },
                children: "Cercle R=2"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "button",
                onClick: props.onShowRectangle,
                style: {
                  padding: "4px 8px",
                  background: "#27ae60",
                  color: "#fff",
                  border: "none",
                  borderRadius: 4,
                  cursor: "pointer",
                  fontSize: 12
                },
                children: "Rectangle 3x3"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "button",
                onClick: props.onShowCone,
                style: {
                  padding: "4px 8px",
                  background: "#c0392b",
                  color: "#fff",
                  border: "none",
                  borderRadius: 4,
                  cursor: "pointer",
                  fontSize: 12
                },
                children: "Cne porte 4"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "button",
                onClick: props.onToggleVisionDebug,
                style: {
                  padding: "4px 8px",
                  background: props.showVisionDebug ? "#f1c40f" : "#555",
                  color: "#0b0b12",
                  border: "none",
                  borderRadius: 4,
                  cursor: "pointer",
                  fontSize: 12
                },
                children: props.showVisionDebug ? "Masquer vision" : "Afficher vision"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "button",
                onClick: props.onToggleLightOverlay,
                style: {
                  padding: "4px 8px",
                  background: props.showLightOverlay ? "#f39c12" : "#555",
                  color: "#0b0b12",
                  border: "none",
                  borderRadius: 4,
                  cursor: "pointer",
                  fontSize: 12
                },
                children: props.showLightOverlay ? "Masquer lumiere" : "Afficher lumiere"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "button",
                onClick: props.onToggleFogSegments,
                style: {
                  padding: "4px 8px",
                  background: props.showFogSegments ? "#ecf0f1" : "#555",
                  color: props.showFogSegments ? "#111" : "#fff",
                  border: "none",
                  borderRadius: 4,
                  cursor: "pointer",
                  fontSize: 12
                },
                children: props.showFogSegments ? "Masquer segments fog" : "Tracer segments fog"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "button",
                onClick: props.onToggleCellIds,
                style: {
                  padding: "4px 8px",
                  background: props.showCellIds ? "#8e44ad" : "#555",
                  color: "#fff",
                  border: "none",
                  borderRadius: 4,
                  cursor: "pointer",
                  fontSize: 12
                },
                children: props.showCellIds ? "Masquer IDs" : "Afficher IDs"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "button",
                onClick: props.onToggleShowAllLevels,
                style: {
                  padding: "4px 8px",
                  background: props.showAllLevels ? "#e67e22" : "#555",
                  color: "#fff",
                  border: "none",
                  borderRadius: 4,
                  cursor: "pointer",
                  fontSize: 12
                },
                children: props.showAllLevels ? "Masquer tout" : "Voir tout"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "button",
                onClick: props.onToggleTerrainIds,
                style: {
                  padding: "4px 8px",
                  background: props.showTerrainIds ? "#16a085" : "#555",
                  color: "#fff",
                  border: "none",
                  borderRadius: 4,
                  cursor: "pointer",
                  fontSize: 12
                },
                children: props.showTerrainIds ? "Masquer sol IDs" : "Afficher sol IDs"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "button",
                onClick: props.onToggleTerrainContours,
                style: {
                  padding: "4px 8px",
                  background: props.showTerrainContours ? "#1abc9c" : "#555",
                  color: "#0b0b12",
                  border: "none",
                  borderRadius: 4,
                  cursor: "pointer",
                  fontSize: 12
                },
                children: props.showTerrainContours ? "Masquer contours sol" : "Afficher contours sol"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "button",
                onClick: props.onToggleGridLines,
                style: {
                  padding: "4px 8px",
                  background: props.showGridLines ? "#3498db" : "#555",
                  color: props.showGridLines ? "#0b0b12" : "#fff",
                  border: "none",
                  borderRadius: 4,
                  cursor: "pointer",
                  fontSize: 12
                },
                children: props.showGridLines ? "Masquer grille" : "Afficher grille"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "button",
                onClick: props.onToggleBumpDebug,
                style: {
                  padding: "4px 8px",
                  background: props.bumpDebug ? "#f1c40f" : "#555",
                  color: "#0b0b12",
                  border: "none",
                  borderRadius: 4,
                  cursor: "pointer",
                  fontSize: 12
                },
                children: props.bumpDebug ? "Masquer bump debug" : "Afficher bump debug"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", flexDirection: "column", gap: 4, minWidth: 180 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { style: { fontSize: 11, color: "#bfc6d2" }, children: [
                "Lumiere angle: ",
                Math.round(props.shadowLightAngleDeg),
                ""
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "range",
                  min: "0",
                  max: "360",
                  step: "1",
                  value: props.shadowLightAngleDeg,
                  onChange: (event) => props.onChangeShadowLightAngleDeg(Number(event.target.value))
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", flexDirection: "column", gap: 4, minWidth: 180 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { style: { fontSize: 11, color: "#bfc6d2" }, children: [
                "Bump: ",
                props.bumpIntensity.toFixed(2)
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "range",
                  min: "0",
                  max: "1",
                  step: "0.01",
                  value: props.bumpIntensity,
                  onChange: (event) => props.onChangeBumpIntensity(Number(event.target.value))
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", flexDirection: "column", gap: 4, minWidth: 180 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { style: { fontSize: 11, color: "#bfc6d2" }, children: [
                "Vent vitesse: ",
                props.windSpeed.toFixed(2)
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "range",
                  min: "0",
                  max: "0.2",
                  step: "0.01",
                  value: props.windSpeed,
                  onChange: (event) => props.onChangeWindSpeed(Number(event.target.value))
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", flexDirection: "column", gap: 4, minWidth: 180 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { style: { fontSize: 11, color: "#bfc6d2" }, children: [
                "Vent force: ",
                props.windStrength.toFixed(2)
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "range",
                  min: "0",
                  max: "2",
                  step: "0.05",
                  value: props.windStrength,
                  onChange: (event) => props.onChangeWindStrength(Number(event.target.value))
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "button",
                onClick: props.onClear,
                style: {
                  padding: "4px 8px",
                  background: "#7f8c8d",
                  color: "#fff",
                  border: "none",
                  borderRadius: 4,
                  cursor: "pointer",
                  fontSize: 12
                },
                children: "Effacer zones"
              }
            )
          ] }),
          props.usageDebug && props.usageDebug.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              style: {
                marginTop: 12,
                paddingTop: 10,
                borderTop: "1px solid rgba(255,255,255,0.08)"
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { style: { margin: "0 0 6px", fontSize: 13 }, children: "Usage actions (debug)" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexDirection: "column", gap: 8 }, children: props.usageDebug.map((actor) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12 }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: actor.actorLabel }),
                  actor.actions.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { color: "#9aa0b5" }, children: "Aucun usage" }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexDirection: "column", gap: 4 }, children: actor.actions.map((action2) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("code", { children: action2.label }),
                    " ",
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { style: { color: "#9aa0b5" }, children: [
                      "(turn: ",
                      action2.turn,
                      ", combat: ",
                      action2.combat,
                      ")"
                    ] })
                  ] }, `${actor.actorId}-${action2.id}`)) })
                ] }, actor.actorId)) })
              ]
            }
          )
        ] }),
        mode === "animations" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { style: { margin: "6px 0 4px" }, children: "Animations (FX)" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { margin: 0, fontSize: 12 }, children: "Liste des animations charges. Lecture ou frame par frame." }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", flexDirection: "column", gap: 8, marginTop: 8 }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { style: { fontSize: 11, color: "#bfc6d2" }, children: [
              "Animation",
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "select",
                {
                  value: selectedKey,
                  onChange: (event) => setSelectedKey(event.target.value),
                  style: { marginLeft: 8, padding: "4px 6px", fontSize: 12 },
                  children: [
                    sortedAnimations.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "", children: "Aucune animation" }),
                    sortedAnimations.map((anim) => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: anim.key, children: anim.key }, anim.key))
                  ]
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: 8, flexWrap: "wrap" }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  type: "button",
                  onClick: () => setIsPlaying((prev) => !prev),
                  disabled: frames.length === 0,
                  style: {
                    padding: "4px 8px",
                    background: isPlaying ? "#e67e22" : "#2ecc71",
                    color: "#0b0b12",
                    border: "none",
                    borderRadius: 4,
                    cursor: frames.length === 0 ? "not-allowed" : "pointer",
                    fontSize: 12,
                    fontWeight: 800
                  },
                  children: isPlaying ? "Pause" : "Lecture"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  type: "button",
                  onClick: () => setFrameIndex((prev) => Math.max(0, prev - 1)),
                  disabled: frames.length === 0,
                  style: {
                    padding: "4px 8px",
                    background: "#555",
                    color: "#fff",
                    border: "none",
                    borderRadius: 4,
                    cursor: frames.length === 0 ? "not-allowed" : "pointer",
                    fontSize: 12
                  },
                  children: "Frame -"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  type: "button",
                  onClick: () => setFrameIndex((prev) => Math.min(frames.length - 1, prev + 1)),
                  disabled: frames.length === 0,
                  style: {
                    padding: "4px 8px",
                    background: "#555",
                    color: "#fff",
                    border: "none",
                    borderRadius: 4,
                    cursor: frames.length === 0 ? "not-allowed" : "pointer",
                    fontSize: 12
                  },
                  children: "Frame +"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", flexDirection: "column", gap: 4, minWidth: 140 }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { style: { fontSize: 11, color: "#bfc6d2" }, children: [
                  "FPS: ",
                  fps
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "input",
                  {
                    type: "range",
                    min: "1",
                    max: "30",
                    step: "1",
                    value: fps,
                    onChange: (event) => setFps(Number(event.target.value))
                  }
                )
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, color: "#bfc6d2" }, children: frames.length > 0 ? `Frame ${safeIndex + 1} / ${frames.length}` : "Aucune frame" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                style: {
                  width: "100%",
                  minHeight: 180,
                  display: "flex",
                  alignItems: "center",
                  justifyContent: "center",
                  background: "rgba(255,255,255,0.04)",
                  border: "1px solid rgba(255,255,255,0.12)",
                  borderRadius: 8,
                  padding: 8
                },
                children: currentFrame ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "img",
                  {
                    src: currentFrame,
                    alt: selectedKey,
                    style: { maxWidth: "100%", maxHeight: 240, imageRendering: "pixelated" }
                  }
                ) : /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: 12, color: "#bfc6d2" }, children: "Slectionnez une animation" })
              }
            )
          ] })
        ] })
      ]
    }
  );
}
function LogPanel(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "section",
    {
      style: {
        padding: "8px 12px",
        background: "#141421",
        borderRadius: 8,
        border: "1px solid #333",
        flex: "1 1 auto",
        display: "flex",
        flexDirection: "column",
        height: "100%",
        maxHeight: "100%",
        minHeight: 0
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { style: { margin: "0 0 8px" }, children: "Log" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            style: {
              flex: "1 1 auto",
              overflowY: "auto",
              fontSize: 12,
              lineHeight: 1.4,
              minHeight: 0
            },
            children: props.log.map((line, idx) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              "- ",
              line
            ] }, idx))
          }
        )
      ]
    }
  );
}
function NarrationPanel(props) {
  const rounds = reactExports.useMemo(() => {
    var _a;
    const seen2 = /* @__PURE__ */ new Map();
    const ordered = [];
    for (const entry of props.entries) {
      if (!seen2.has(entry.round)) {
        seen2.set(entry.round, []);
        ordered.push(entry.round);
      }
      (_a = seen2.get(entry.round)) == null ? void 0 : _a.push(entry);
    }
    return ordered.map((round2) => ({
      round: round2,
      entries: seen2.get(round2) ?? []
    }));
  }, [props.entries]);
  const [expandedRounds, setExpandedRounds] = reactExports.useState(() => /* @__PURE__ */ new Set());
  reactExports.useEffect(() => {
    var _a;
    const latest = (_a = props.entries[0]) == null ? void 0 : _a.round;
    if (latest == null) return;
    setExpandedRounds((prev) => {
      if (prev.has(latest)) return prev;
      const next = new Set(prev);
      next.add(latest);
      return next;
    });
  }, [props.entries]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      style: {
        padding: "10px 12px",
        background: "linear-gradient(180deg, rgba(38, 28, 16, 0.92), rgba(16, 12, 8, 0.92))",
        borderRadius: 14,
        border: "1px solid rgba(255,255,255,0.10)",
        boxShadow: "0 16px 50px rgba(0,0,0,0.45)",
        display: "flex",
        flexDirection: "column",
        gap: 4,
        maxWidth: "100%",
        height: 240,
        fontFamily: '"Iowan Old Style", "Palatino Linotype", Palatino, Garamond, "Times New Roman", serif'
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            style: {
              display: "flex",
              justifyContent: "space-between",
              alignItems: "center",
              marginBottom: 4
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: 13, color: "rgba(255,255,255,0.82)", fontWeight: 700 }, children: "Chronique" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { style: { fontSize: 12, color: "rgba(255,255,255,0.65)" }, children: [
                "Tours ",
                rounds.length
              ] })
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            style: {
              display: "flex",
              flexDirection: "column",
              gap: 2,
              flex: "1 1 auto",
              minHeight: 0,
              overflowY: "auto",
              paddingRight: 4
            },
            children: [
              props.entries.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: 12, color: "rgba(255,255,255,0.65)" }, children: "En attente d'actions pour raconter le tour..." }),
              rounds.map((group) => {
                const isExpanded = expandedRounds.has(group.round);
                return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "div",
                  {
                    style: {
                      borderRadius: 10,
                      border: "1px solid rgba(255,255,255,0.08)",
                      background: "rgba(8,8,12,0.55)",
                      overflow: "hidden"
                    },
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs(
                        "button",
                        {
                          type: "button",
                          onClick: () => setExpandedRounds((prev) => {
                            const next = new Set(prev);
                            if (next.has(group.round)) {
                              next.delete(group.round);
                            } else {
                              next.add(group.round);
                            }
                            return next;
                          }),
                          style: {
                            width: "100%",
                            display: "flex",
                            alignItems: "center",
                            justifyContent: "space-between",
                            gap: 8,
                            padding: "6px 10px",
                            background: "transparent",
                            border: "none",
                            color: "rgba(255,255,255,0.9)",
                            cursor: "pointer",
                            fontSize: 12,
                            fontWeight: 800,
                            letterSpacing: 0.3
                          },
                          children: [
                            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                              "Tour ",
                              group.round
                            ] }),
                            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { style: { fontSize: 11, color: "rgba(255,255,255,0.6)" }, children: [
                              isExpanded ? "replier" : "deplier",
                              " (",
                              group.entries.length,
                              ")"
                            ] })
                          ]
                        }
                      ),
                      isExpanded && /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "div",
                        {
                          style: {
                            display: "flex",
                            flexDirection: "column",
                            gap: 6,
                            padding: "6px 10px 10px",
                            fontSize: 13,
                            color: "rgba(255,255,255,0.88)",
                            maxHeight: 220,
                            overflowY: "auto",
                            paddingRight: 6
                          },
                          children: group.entries.map((entry) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                            "div",
                            {
                              style: {
                                padding: "6px 8px",
                                borderRadius: 8,
                                border: "1px solid rgba(255,255,255,0.06)",
                                background: "rgba(20,14,10,0.7)",
                                maxHeight: 140,
                                overflowY: "auto",
                                lineHeight: 1.35,
                                whiteSpace: "pre-wrap"
                              },
                              children: entry.text
                            },
                            entry.id
                          ))
                        }
                      )
                    ]
                  },
                  group.round
                );
              })
            ]
          }
        )
      ]
    }
  );
}
function polarToCartesian(radius, angleRad) {
  return { x: Math.cos(angleRad) * radius, y: Math.sin(angleRad) * radius };
}
function normalizeAngle(angleRad) {
  const twoPi = Math.PI * 2;
  let a2 = angleRad % twoPi;
  if (a2 < 0) a2 += twoPi;
  return a2;
}
function arcPath(radius, startAngleRad, endAngleRad, largeArcFlag, sweepFlag) {
  const end = polarToCartesian(radius, endAngleRad);
  return `A ${radius} ${radius} 0 ${largeArcFlag} ${sweepFlag} ${end.x} ${end.y}`;
}
function donutSlicePath(innerRadius, outerRadius, startAngleRad, endAngleRad) {
  const fullCircle = Math.abs(endAngleRad - startAngleRad) >= Math.PI * 2 - 1e-6;
  const delta = endAngleRad - startAngleRad;
  const largeArcFlag = fullCircle || Math.abs(delta) > Math.PI ? 1 : 0;
  const sweepFlag = delta >= 0 ? 1 : 0;
  const sweepFlagReverse = sweepFlag === 1 ? 0 : 1;
  const outerStart = polarToCartesian(outerRadius, startAngleRad);
  const innerEnd = polarToCartesian(innerRadius, endAngleRad);
  const innerStart = polarToCartesian(innerRadius, startAngleRad);
  return [
    `M ${outerStart.x} ${outerStart.y}`,
    arcPath(outerRadius, startAngleRad, endAngleRad, largeArcFlag, sweepFlag),
    `L ${innerEnd.x} ${innerEnd.y}`,
    arcPath(innerRadius, endAngleRad, startAngleRad, largeArcFlag, sweepFlagReverse),
    `L ${innerStart.x} ${innerStart.y}`,
    "Z"
  ].join(" ");
}
function fullDonutPath(outerRadius, innerRadius) {
  const outerTop = polarToCartesian(outerRadius, -Math.PI / 2);
  const outerBottom = polarToCartesian(outerRadius, Math.PI / 2);
  const innerTop = polarToCartesian(innerRadius, -Math.PI / 2);
  const innerBottom = polarToCartesian(innerRadius, Math.PI / 2);
  return [
    `M ${outerTop.x} ${outerTop.y}`,
    `A ${outerRadius} ${outerRadius} 0 1 1 ${outerBottom.x} ${outerBottom.y}`,
    `A ${outerRadius} ${outerRadius} 0 1 1 ${outerTop.x} ${outerTop.y}`,
    `M ${innerTop.x} ${innerTop.y}`,
    `A ${innerRadius} ${innerRadius} 0 1 0 ${innerBottom.x} ${innerBottom.y}`,
    `A ${innerRadius} ${innerRadius} 0 1 0 ${innerTop.x} ${innerTop.y}`
  ].join(" ");
}
function RadialWheelMenu(props) {
  if (!props.open) return null;
  const size2 = props.size ?? 240;
  const half = size2 / 2;
  const outerRadius = half;
  const innerRadius = Math.max(44, Math.floor(outerRadius * 0.42));
  const centerRadius = innerRadius - 6;
  const labelRadius = Math.max(innerRadius + 12, outerRadius - 18);
  const itemCount = Math.max(1, props.items.length);
  const isSingleItem2 = itemCount === 1;
  const useArcLabels = itemCount > 1;
  const angleStep = Math.PI * 2 / itemCount;
  const startAngle = -Math.PI / 2;
  const centerLabel = props.centerLabel ?? "Annuler";
  const onCenterClick = props.onCenterClick ?? props.onClose;
  const sliceOpacity = typeof props.sliceOpacity === "number" ? props.sliceOpacity : 1;
  const centerOpacity = typeof props.centerOpacity === "number" ? props.centerOpacity : 1;
  const zIndex = typeof props.zIndex === "number" ? props.zIndex : 50;
  const arcId = reactExports.useId();
  const arcRadius = outerRadius - 6;
  const arcStart = -Math.PI * 0.95;
  const arcEnd = -Math.PI * 0.05;
  const arcPathId = `wheel-arc-${arcId}`;
  const arcStartPos = polarToCartesian(arcRadius, arcStart);
  const arcEndPos = polarToCartesian(arcRadius, arcEnd);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      style: {
        position: "absolute",
        left: props.anchorX,
        top: props.anchorY,
        width: size2,
        height: size2,
        transform: "translate(-50%, -50%)",
        zIndex,
        pointerEvents: "auto",
        userSelect: "none"
      },
      onMouseDown: (event) => {
        event.preventDefault();
        event.stopPropagation();
      },
      onClick: (event) => {
        event.preventDefault();
        event.stopPropagation();
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { width: size2, height: size2, viewBox: `${-half} ${-half} ${size2} ${size2}`, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("defs", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("filter", { id: "wheelShadow", x: "-30%", y: "-30%", width: "160%", height: "160%", children: /* @__PURE__ */ jsxRuntimeExports.jsx("feDropShadow", { dx: "0", dy: "10", stdDeviation: "14", floodOpacity: "0.35" }) }),
          props.arcLabel ? /* @__PURE__ */ jsxRuntimeExports.jsx(
            "path",
            {
              id: arcPathId,
              d: [
                `M ${arcStartPos.x} ${arcStartPos.y}`,
                `A ${arcRadius} ${arcRadius} 0 0 1 ${arcEndPos.x} ${arcEndPos.y}`
              ].join(" ")
            }
          ) : null
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { filter: "url(#wheelShadow)", children: [
          props.arcLabel ? /* @__PURE__ */ jsxRuntimeExports.jsx(
            "text",
            {
              style: {
                fill: "rgba(255,255,255,0.85)",
                fontSize: 11,
                fontWeight: 700,
                letterSpacing: 0.3,
                pointerEvents: "none"
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("textPath", { href: `#${arcPathId}`, startOffset: "50%", textAnchor: "middle", children: props.arcLabel })
            }
          ) : null,
          props.items.map((item, index) => {
            const a0 = startAngle + index * angleStep;
            const a1 = startAngle + (index + 1) * angleStep;
            const mid = (a0 + a1) / 2;
            const midNorm = normalizeAngle(mid);
            const isBottom = midNorm > 0 && midNorm < Math.PI;
            const labelStart = isBottom ? a1 : a0;
            const labelEnd = isBottom ? a0 : a1;
            const labelPos = polarToCartesian((innerRadius + outerRadius) / 2, mid);
            const pathD = isSingleItem2 ? fullDonutPath(outerRadius, innerRadius) : donutSlicePath(innerRadius, outerRadius, a0, a1);
            const labelStartPos = polarToCartesian(labelRadius, labelStart);
            const labelEndPos = polarToCartesian(labelRadius, labelEnd);
            const delta = labelEnd - labelStart;
            const largeArcFlag = Math.abs(delta) > Math.PI ? 1 : 0;
            const sweepFlag = delta >= 0 ? 1 : 0;
            const labelPathId = `wheel-label-${index}-${item.id}`;
            const labelPath = [
              `M ${labelStartPos.x} ${labelStartPos.y}`,
              `A ${labelRadius} ${labelRadius} 0 ${largeArcFlag} ${sweepFlag} ${labelEndPos.x} ${labelEndPos.y}`
            ].join(" ");
            const isDisabled = Boolean(item.disabled);
            const title = isDisabled && item.disabledReason ? item.disabledReason : isDisabled ? "Indisponible" : void 0;
            return /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { id: labelPathId, d: labelPath }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "path",
                {
                  d: pathD,
                  fill: isDisabled ? "rgba(90, 90, 100, 0.75)" : item.color,
                  fillRule: isSingleItem2 ? "evenodd" : void 0,
                  stroke: isSingleItem2 ? "none" : "rgba(255,255,255,0.22)",
                  strokeWidth: isSingleItem2 ? 0 : 1,
                  style: {
                    cursor: isDisabled ? "not-allowed" : "pointer",
                    transition: "filter 120ms ease, opacity 120ms ease"
                  },
                  opacity: (isDisabled ? 0.55 : 0.95) * Math.max(0, Math.min(1, sliceOpacity)),
                  onClick: (event) => {
                    var _a;
                    event.preventDefault();
                    event.stopPropagation();
                    if (isDisabled) return;
                    (_a = item.onSelect) == null ? void 0 : _a.call(item);
                  },
                  children: title ? /* @__PURE__ */ jsxRuntimeExports.jsx("title", { children: title }) : null
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "text",
                {
                  x: useArcLabels ? void 0 : labelPos.x,
                  y: useArcLabels ? void 0 : labelPos.y,
                  textAnchor: useArcLabels ? void 0 : "middle",
                  dominantBaseline: useArcLabels ? void 0 : "middle",
                  style: {
                    fill: isDisabled ? "rgba(255,255,255,0.6)" : "rgba(255,255,255,0.92)",
                    fontSize: 11,
                    fontWeight: 700,
                    letterSpacing: 0.2,
                    pointerEvents: "none"
                  },
                  children: useArcLabels ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "textPath",
                    {
                      href: `#${labelPathId}`,
                      startOffset: "50%",
                      textAnchor: "middle",
                      children: item.label
                    }
                  ) : item.label
                }
              )
            ] }, item.id);
          }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "circle",
            {
              cx: 0,
              cy: 0,
              r: centerRadius,
              fill: "rgba(10,10,16,0.92)",
              stroke: "rgba(255,255,255,0.18)",
              strokeWidth: 1,
              opacity: Math.max(0, Math.min(1, centerOpacity)),
              style: { cursor: "pointer" },
              onClick: (event) => {
                event.preventDefault();
                event.stopPropagation();
                onCenterClick();
              }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "text",
            {
              x: 0,
              y: 0,
              textAnchor: "middle",
              dominantBaseline: "middle",
              style: {
                fill: "rgba(255,255,255,0.9)",
                fontSize: 12,
                fontWeight: 800,
                pointerEvents: "none"
              },
              children: centerLabel
            }
          )
        ] })
      ] })
    }
  );
}
function categoryLabel(category2) {
  const c2 = category2.toLowerCase();
  if (c2 === "attack") return "Attaque";
  if (c2 === "movement") return "Mouvement";
  if (c2 === "support") return "Support";
  if (c2 === "defense") return "Defense";
  if (c2 === "item") return "Objet";
  if (c2 === "reaction") return "Reaction";
  return category2;
}
function categoryColor(category2) {
  const c2 = category2.toLowerCase();
  if (c2 === "attack") return "#e74c3c";
  if (c2 === "movement") return "#2ecc71";
  if (c2 === "support") return "#3498db";
  if (c2 === "defense") return "#9b59b6";
  if (c2 === "item") return "#f1c40f";
  if (c2 === "reaction") return "#e67e22";
  return "#7f8c8d";
}
function ActionWheelMenu(props) {
  const [view, setView] = reactExports.useState("root");
  const [selectedCategory, setSelectedCategory] = reactExports.useState(null);
  const categoryThreshold = typeof props.categoryThreshold === "number" ? props.categoryThreshold : 7;
  const shouldFilterByCategory = props.actions.length > categoryThreshold;
  const categories = reactExports.useMemo(() => {
    const set = /* @__PURE__ */ new Set();
    for (const action2 of props.actions) set.add(action2.category);
    return Array.from(set).sort((a2, b2) => a2.localeCompare(b2));
  }, [props.actions]);
  reactExports.useEffect(() => {
    if (!props.open) {
      setView("root");
      setSelectedCategory(null);
    }
  }, [props.open]);
  reactExports.useEffect(() => {
    if (props.interactionState === "select") {
      setView("interaction-select");
      return;
    }
    if (props.interactionState === "menu") {
      setView("interaction-actions");
      return;
    }
    if (view === "interaction-select" || view === "interaction-actions") {
      setView("root");
    }
  }, [props.interactionState, view]);
  const items = reactExports.useMemo(() => {
    if (props.blockWheel) {
      return [
        {
          id: "action-in-progress",
          label: "Action en cours",
          color: "#7f8c8d",
          disabled: true,
          disabledReason: "Terminez ou reprenez l'action."
        }
      ];
    }
    if (view === "interaction-select") {
      return [
        {
          id: "interaction-select",
          label: "Selection",
          color: "#34495e",
          disabled: true,
          disabledReason: "Selection en cours"
        }
      ];
    }
    if (view === "interaction-actions") {
      return props.interactionItems;
    }
    if (view === "categories") {
      const catItems = [
        {
          id: "all",
          label: "Toutes",
          color: "#34495e",
          onSelect: () => {
            setSelectedCategory(null);
            setView("actions");
          }
        },
        ...categories.map((cat) => ({
          id: `cat-${cat}`,
          label: categoryLabel(cat),
          color: categoryColor(cat),
          onSelect: () => {
            setSelectedCategory(cat);
            setView("actions");
          }
        }))
      ];
      return catItems;
    }
    if (view === "actions") {
      if (props.actions.length === 0) {
        props.onNoActions();
        setView("root");
        return [];
      }
      const filtered = selectedCategory ? props.actions.filter((a2) => a2.category === selectedCategory) : props.actions;
      return filtered.map((action2) => {
        const availability = props.computeActionAvailability(action2);
        const enabled = availability.enabled;
        return {
          id: `action-${action2.id}`,
          label: action2.name,
          color: enabled ? "#2ecc71" : "#e74c3c",
          onSelect: () => {
            props.onPickAction(action2);
            setView("root");
            setSelectedCategory(null);
          }
        };
      });
    }
    if (view === "inspect") {
      const enabled = props.canInteractWithBoard && props.hasCell;
      const disabledReason = !props.canInteractWithBoard ? "Tour joueur requis" : !props.hasCell ? "Aucune case" : "Indisponible";
      return [
        {
          id: "inspect-cell",
          label: "Inspecter",
          color: "#3498db",
          disabled: !enabled,
          disabledReason,
          onSelect: () => {
            props.onInspectCell();
            setView("root");
          }
        },
        {
          id: "look",
          label: "Tourner regard",
          color: "#1abc9c",
          disabled: !enabled,
          disabledReason,
          onSelect: () => {
            props.onLook();
            setView("root");
          }
        }
      ];
    }
    if (view === "movement") {
      if (props.moveTypes.length === 0) {
        props.onNoMoveTypes();
        setView("root");
        return [];
      }
      return props.moveTypes.map((moveType) => {
        const availability = props.computeActionAvailability(moveType);
        const enabled = availability.enabled;
        return {
          id: `move-type-${moveType.id}`,
          label: moveType.name,
          color: enabled ? "#2ecc71" : "#e74c3c",
          onSelect: () => {
            props.onPickAction(moveType);
            setView("root");
          }
        };
      });
    }
    const isMoveAvailable = props.canInteractWithBoard;
    return [
      {
        id: "move",
        label: "Deplacer",
        color: "#2ecc71",
        disabled: !isMoveAvailable,
        disabledReason: "Tour joueur requis",
        onSelect: () => {
          setView("movement");
        }
      },
      {
        id: "action",
        label: "Action",
        color: "#e74c3c",
        disabled: !props.canInteractWithBoard,
        disabledReason: "Tour joueur requis",
        onSelect: () => {
          if (props.actions.length === 0) {
            props.onNoActions();
            return;
          }
          if (shouldFilterByCategory) {
            setView("categories");
            return;
          }
          setView("actions");
        }
      },
      {
        id: "inspect",
        label: "Inspecter",
        color: "#3498db",
        disabled: !props.hasCell || !props.canInteractWithBoard,
        disabledReason: !props.canInteractWithBoard ? "Tour joueur requis" : "Aucune case",
        onSelect: () => setView("inspect")
      },
      {
        id: "interact",
        label: "Interagir",
        color: "#9b59b6",
        disabled: !props.canInteractWithBoard,
        disabledReason: "Tour joueur requis",
        onSelect: props.onInteract
      },
      {
        id: "hide",
        label: "Fiche personnage",
        color: "#34495e",
        disabled: !props.canInteractWithBoard,
        disabledReason: "Tour joueur requis",
        onSelect: props.onOpenSheet
      },
      {
        id: "end-turn",
        label: "Fin tour",
        color: "#ff7f50",
        disabled: !props.canInteractWithBoard || props.isResolvingEnemies || props.blockEndTurn,
        disabledReason: props.isResolvingEnemies ? "Tour des ennemis en cours" : props.blockEndTurn ? "Action en cours" : "Tour joueur requis",
        onSelect: props.onEndTurn
      }
    ];
  }, [
    categories,
    props,
    selectedCategory,
    shouldFilterByCategory,
    view
  ]);
  const { centerLabel, onCenterClick } = reactExports.useMemo(() => {
    if (view === "root") {
      return { centerLabel: "Annuler", onCenterClick: props.onClose };
    }
    if (view === "categories") {
      return { centerLabel: "Annuler", onCenterClick: () => setView("root") };
    }
    if (view === "inspect") {
      return { centerLabel: "Annuler", onCenterClick: () => setView("root") };
    }
    if (view === "movement") {
      return {
        centerLabel: "Annuler",
        onCenterClick: () => {
          props.onCancelMove();
          setView("root");
        }
      };
    }
    if (view === "interaction-select" || view === "interaction-actions") {
      return {
        centerLabel: "Annuler",
        onCenterClick: () => {
          props.onCancelInteract();
          setView("root");
        }
      };
    }
    if (view === "actions" && shouldFilterByCategory) {
      return { centerLabel: "Annuler", onCenterClick: () => setView("root") };
    }
    return { centerLabel: "Annuler", onCenterClick: () => setView("root") };
  }, [props.blockWheel, props.onCancelInteract, props.onCancelMove, props.onClose, shouldFilterByCategory, view]);
  const sliceOpacity = typeof props.sliceOpacity === "number" ? props.sliceOpacity : props.isMoving ? 0.28 : 0.65;
  const centerOpacity = typeof props.centerOpacity === "number" ? props.centerOpacity : props.isMoving ? 0.35 : 0.6;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    RadialWheelMenu,
    {
      open: props.open,
      anchorX: props.anchorX,
      anchorY: props.anchorY,
      items,
      onClose: props.onClose,
      size: props.size,
      centerLabel,
      onCenterClick,
      sliceOpacity,
      centerOpacity,
      arcLabel: view === "interaction-select" ? props.interactionPrompt : void 0
    }
  );
}
function clamp$2(value2, min, max) {
  return Math.max(min, Math.min(max, value2));
}
function badgeColorForActionType(actionType) {
  if (actionType === "action") return "#8e44ad";
  if (actionType === "bonus") return "#27ae60";
  if (actionType === "reaction") return "#e67e22";
  return "#2980b9";
}
function ActionContextWindow(props) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i;
  const containerRef = reactExports.useRef(null);
  const [pos, setPos] = reactExports.useState({ left: 16, top: 16 });
  const dragRef = reactExports.useRef(null);
  const hasUserMovedRef = reactExports.useRef(false);
  const [isDragging, setIsDragging] = reactExports.useState(false);
  const [finishReady, setFinishReady] = reactExports.useState(false);
  const [hazardFinishReady, setHazardFinishReady] = reactExports.useState(false);
  const action2 = props.action;
  const availability = props.availability;
  const isBlocked = availability ? !availability.enabled : false;
  const hasHazard = Boolean(props.pendingHazard);
  const isMovementAction = Boolean((_a = action2 == null ? void 0 : action2.tags) == null ? void 0 : _a.includes("move-type"));
  const movement2 = props.movement ?? null;
  const canValidateMove = Boolean(
    movement2 && movement2.canInteract && movement2.hasPath && props.stage === "active" && movement2.costMax > 0
  );
  const showCancelAction = Boolean(action2 && props.stage === "active");
  reactExports.useLayoutEffect(() => {
    if (!props.open) return;
    if (hasUserMovedRef.current) return;
    const el = containerRef.current;
    if (!el) return;
    const parent = el.parentElement;
    if (!parent) return;
    setPos({ left: 8, top: 8 });
  }, [props.anchorX, props.anchorY, props.open, action2 == null ? void 0 : action2.id]);
  reactExports.useEffect(() => {
    if (!props.open) return;
    hasUserMovedRef.current = false;
  }, [props.open, action2 == null ? void 0 : action2.id]);
  reactExports.useEffect(() => {
    if (!props.isComplete) {
      setFinishReady(false);
      return;
    }
    const timer = window.setTimeout(() => {
      setFinishReady(true);
    }, 2e3);
    return () => {
      window.clearTimeout(timer);
    };
  }, [props.isComplete, action2 == null ? void 0 : action2.id]);
  reactExports.useEffect(() => {
    if (!props.hazardResolution) {
      setHazardFinishReady(false);
      return;
    }
    const timer = window.setTimeout(() => {
      setHazardFinishReady(true);
    }, 2e3);
    return () => {
      window.clearTimeout(timer);
    };
  }, [(_b = props.hazardResolution) == null ? void 0 : _b.damageTotal, (_c = props.hazardResolution) == null ? void 0 : _c.statusTriggered]);
  reactExports.useEffect(() => {
    if (!isDragging) return;
    const onMove = (event) => {
      const el = containerRef.current;
      const drag = dragRef.current;
      if (!el || !drag) return;
      const parent = el.parentElement;
      if (!parent) return;
      const parentRect = parent.getBoundingClientRect();
      const rect = el.getBoundingClientRect();
      const dx = event.clientX - drag.startClientX;
      const dy = event.clientY - drag.startClientY;
      const nextLeft = drag.startLeft + dx;
      const nextTop = drag.startTop + dy;
      const left = clamp$2(nextLeft, 8, Math.max(8, parentRect.width - rect.width - 8));
      const top = clamp$2(nextTop, 8, Math.max(8, parentRect.height - rect.height - 8));
      hasUserMovedRef.current = true;
      setPos({ left, top });
    };
    const onUp = () => {
      setIsDragging(false);
      dragRef.current = null;
    };
    window.addEventListener("pointermove", onMove);
    window.addEventListener("pointerup", onUp, { once: true });
    return () => {
      window.removeEventListener("pointermove", onMove);
    };
  }, [isDragging]);
  const steps = ((_d = props.plan) == null ? void 0 : _d.steps) ?? [];
  const stepByType = reactExports.useMemo(() => {
    const map = /* @__PURE__ */ new Map();
    for (const step of steps) {
      map.set(step.type, step);
    }
    return map;
  }, [steps]);
  const getStep = (type2) => stepByType.get(type2) ?? null;
  const validateStep = getStep("validate");
  const resourceStep = getStep("resource");
  const ammoInfo = props.ammoInfo ?? null;
  const spellSourceOptions = Array.isArray(props.spellSourceOptions) ? props.spellSourceOptions : [];
  const targetStep = getStep("target");
  const attackStep = getStep("attack-roll");
  const damageStep = getStep("damage-roll");
  const isImpossible = steps.some((step) => step.status === "blocked");
  const statusLabel = isImpossible ? "Action impossible" : props.stage === "active" ? "Action en cours" : "Action possible";
  const statusColor = isImpossible ? "#c0392b" : props.stage === "active" ? "#f39c12" : "#2ecc71";
  const totalSteps = Math.max(1, steps.length);
  const completedSteps = props.isComplete ? totalSteps : steps.filter((step) => step.status === "done").length;
  const progress = completedSteps / totalSteps;
  if (!props.open) return null;
  if (!action2 && !hasHazard) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      ref: containerRef,
      onMouseDown: (event) => event.stopPropagation(),
      onClick: (event) => event.stopPropagation(),
      style: {
        position: "absolute",
        left: pos.left,
        top: pos.top,
        zIndex: 60,
        width: 360,
        maxWidth: "min(92vw, 420px)",
        background: "rgba(10, 10, 16, 0.92)",
        border: "1px solid rgba(255,255,255,0.14)",
        borderRadius: 12,
        padding: 12,
        boxShadow: "0 18px 60px rgba(0,0,0,0.55)",
        backdropFilter: "blur(8px)"
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            style: {
              display: "flex",
              justifyContent: "space-between",
              gap: 10,
              alignItems: "flex-start"
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "div",
                {
                  onPointerDown: (event) => {
                    if (event.button !== 0) return;
                    const el = containerRef.current;
                    if (!el) return;
                    event.preventDefault();
                    event.stopPropagation();
                    dragRef.current = {
                      startClientX: event.clientX,
                      startClientY: event.clientY,
                      startLeft: pos.left,
                      startTop: pos.top
                    };
                    setIsDragging(true);
                  },
                  style: {
                    minWidth: 0,
                    flex: "1 1 auto",
                    cursor: isDragging ? "grabbing" : "grab",
                    userSelect: "none"
                  },
                  title: "Glisser pour deplacer",
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 13, fontWeight: 900, color: "#fff" }, children: action2 ? action2.name : "Danger environnement" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: 8, flexWrap: "wrap", marginTop: 6 }, children: [
                      action2 && /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "span",
                        {
                          style: {
                            fontSize: 11,
                            padding: "2px 6px",
                            borderRadius: 6,
                            background: badgeColorForActionType(action2.actionCost.actionType),
                            color: "#fff",
                            fontWeight: 800
                          },
                          children: action2.actionCost.actionType
                        }
                      ),
                      action2 && /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "span",
                        {
                          style: {
                            fontSize: 11,
                            padding: "2px 6px",
                            borderRadius: 6,
                            background: "rgba(255,255,255,0.08)",
                            border: "1px solid rgba(255,255,255,0.12)",
                            color: "rgba(255,255,255,0.85)",
                            fontWeight: 700
                          },
                          children: action2.category
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "span",
                        {
                          style: {
                            fontSize: 11,
                            padding: "2px 6px",
                            borderRadius: 6,
                            background: action2 ? isBlocked ? "rgba(231,76,60,0.25)" : "rgba(46,204,113,0.18)" : "rgba(255,255,255,0.08)",
                            border: action2 ? `1px solid ${isBlocked ? "rgba(231,76,60,0.55)" : "rgba(46,204,113,0.45)"}` : "1px solid rgba(255,255,255,0.12)",
                            color: action2 ? isBlocked ? "#ffb2aa" : "#bdf6d2" : "rgba(255,255,255,0.85)",
                            fontWeight: 800
                          },
                          children: action2 ? availability ? availability.enabled ? "Disponible" : "Bloquee" : "Etat inconnu" : "Hazard"
                        }
                      )
                    ] })
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  type: "button",
                  onClick: () => {
                    props.onClose();
                  },
                  style: {
                    width: 32,
                    height: 32,
                    borderRadius: 10,
                    border: "1px solid rgba(255,255,255,0.14)",
                    background: "rgba(255,255,255,0.06)",
                    color: "rgba(255,255,255,0.85)",
                    cursor: "pointer",
                    fontWeight: 900,
                    flex: "0 0 auto"
                  },
                  title: "Fermer",
                  children: ""
                }
              )
            ]
          }
        ),
        action2 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginTop: 10, fontSize: 12, color: "rgba(255,255,255,0.82)" }, children: action2.summary || "Aucun resume." }),
        showCancelAction && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginTop: 10 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            type: "button",
            onClick: props.onCancelAction,
            style: {
              padding: "6px 10px",
              borderRadius: 10,
              border: "1px solid rgba(255,255,255,0.12)",
              background: "rgba(231,76,60,0.18)",
              color: "#ffb2aa",
              cursor: "pointer",
              fontSize: 12,
              fontWeight: 900
            },
            children: "Annuler action"
          }
        ) }),
        action2 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginTop: 10 }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            style: {
              height: 18,
              borderRadius: 9,
              background: "rgba(255,255,255,0.08)",
              border: "1px solid rgba(255,255,255,0.15)",
              overflow: "hidden",
              position: "relative"
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  style: {
                    position: "absolute",
                    inset: 0,
                    width: `${Math.max(0, Math.min(1, progress)) * 100}%`,
                    background: statusColor,
                    opacity: 0.85
                  }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  style: {
                    position: "relative",
                    zIndex: 1,
                    fontSize: 11,
                    fontWeight: 900,
                    color: "#0b0b12",
                    textAlign: "center",
                    lineHeight: "18px"
                  },
                  children: statusLabel
                }
              )
            ]
          }
        ) }),
        action2 && availability && !availability.enabled && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginTop: 10 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, fontWeight: 800, color: "#ffb2aa" }, children: "Pourquoi c'est bloque" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { style: { margin: "6px 0 0", paddingLeft: 18, color: "rgba(255,255,255,0.85)", fontSize: 12 }, children: availability.reasons.map((r2, idx) => /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: r2 }, idx)) })
        ] }),
        action2 && isMovementAction && movement2 && /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            style: {
              marginTop: 12,
              padding: 8,
              borderRadius: 10,
              border: "1px solid rgba(255,255,255,0.12)",
              background: "rgba(255,255,255,0.04)"
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, fontWeight: 900, color: "#fff" }, children: "Deplacement" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginTop: 6, fontSize: 12, color: "rgba(255,255,255,0.85)" }, children: [
                "Trajet: ",
                movement2.costUsed,
                "/",
                movement2.costMax
              ] }),
              props.stage === "active" ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginTop: 6, fontSize: 12, color: "rgba(255,255,255,0.7)" }, children: "Cliquez sur la grille pour tracer le trajet, puis validez." }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginTop: 6, fontSize: 12, color: "rgba(255,255,255,0.7)" }, children: "Validez l'action pour commencer le trajet." }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginTop: 10, display: "flex", gap: 8, flexWrap: "wrap" }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    type: "button",
                    onClick: movement2.onSelectPath,
                    disabled: !movement2.canInteract || props.stage !== "active",
                    style: {
                      padding: "6px 10px",
                      borderRadius: 10,
                      border: "1px solid rgba(255,255,255,0.12)",
                      background: movement2.canInteract && props.stage === "active" ? "rgba(255,255,255,0.08)" : "rgba(90, 90, 100, 0.55)",
                      color: movement2.canInteract && props.stage === "active" ? "rgba(255,255,255,0.9)" : "rgba(255,255,255,0.75)",
                      cursor: movement2.canInteract && props.stage === "active" ? "pointer" : "not-allowed",
                      fontSize: 12,
                      fontWeight: 900
                    },
                    children: "Selectionner trajet"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    type: "button",
                    onClick: movement2.onValidateMove,
                    disabled: !canValidateMove,
                    style: {
                      padding: "6px 10px",
                      borderRadius: 10,
                      border: "1px solid rgba(255,255,255,0.12)",
                      background: canValidateMove ? "#f1c40f" : "rgba(90, 90, 100, 0.55)",
                      color: canValidateMove ? "#0b0b12" : "rgba(255,255,255,0.75)",
                      cursor: canValidateMove ? "pointer" : "not-allowed",
                      fontSize: 12,
                      fontWeight: 900
                    },
                    children: "Valider deplacement"
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    type: "button",
                    onClick: movement2.onCancelMove,
                    disabled: !movement2.isMoving && !movement2.hasPath,
                    style: {
                      padding: "6px 10px",
                      borderRadius: 10,
                      border: "1px solid rgba(255,255,255,0.12)",
                      background: movement2.isMoving || movement2.hasPath ? "rgba(255,255,255,0.08)" : "rgba(90, 90, 100, 0.35)",
                      color: "rgba(255,255,255,0.85)",
                      cursor: movement2.isMoving || movement2.hasPath ? "pointer" : "not-allowed",
                      fontSize: 12,
                      fontWeight: 900
                    },
                    children: "Annuler trajet"
                  }
                )
              ] })
            ]
          }
        ),
        action2 && validateStep && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginTop: 12, display: "flex", gap: 8, flexWrap: "wrap" }, children: [
          props.stage === "draft" && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              type: "button",
              onClick: () => {
                props.onValidateAction(action2);
              },
              disabled: validateStep.status !== "available",
              style: {
                padding: "6px 10px",
                borderRadius: 10,
                border: "1px solid rgba(255,255,255,0.12)",
                background: validateStep.status === "available" ? "#2ecc71" : "rgba(90, 90, 100, 0.55)",
                color: validateStep.status === "available" ? "#0b0b12" : "rgba(255,255,255,0.75)",
                cursor: validateStep.status === "available" ? "pointer" : "not-allowed",
                fontSize: 12,
                fontWeight: 900
              },
              title: !(availability == null ? void 0 : availability.enabled) ? "Action indisponible" : "Valider l'action",
              children: "Valider"
            }
          ),
          props.stage === "active" && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: 12, color: "rgba(255,255,255,0.70)" }, children: "Action validee: suivez les etapes ci-dessous." })
        ] }),
        action2 && targetStep && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginTop: 12 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", justifyContent: "space-between", gap: 8, alignItems: "center" }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, fontWeight: 900, color: "#fff" }, children: "Cible" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "button",
                onClick: () => {
                  if (props.stage !== "active") return;
                  props.onSetTargetMode("selecting");
                },
                disabled: targetStep.status === "locked" || targetStep.status === "blocked",
                style: {
                  padding: "4px 8px",
                  borderRadius: 10,
                  border: "1px solid rgba(255,255,255,0.12)",
                  background: targetStep.status === "locked" || targetStep.status === "blocked" ? "rgba(90, 90, 100, 0.35)" : "rgba(255,255,255,0.06)",
                  color: "#fff",
                  cursor: targetStep.status === "locked" || targetStep.status === "blocked" ? "not-allowed" : "pointer",
                  fontSize: 12,
                  fontWeight: 800
                },
                children: "Selectionner cible"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginTop: 6, fontSize: 12, color: "rgba(255,255,255,0.80)" }, children: [
            "Cibles selectionnees:",
            " ",
            /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: props.selectedTargetLabels.length > 0 ? "" : "aucune" }),
            typeof props.maxTargets === "number" && props.maxTargets > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { style: { marginLeft: 6, color: "rgba(255,255,255,0.6)" }, children: [
              "(",
              props.selectedTargetIds.length,
              "/",
              props.maxTargets,
              ")"
            ] }),
            props.targetMode === "selecting" && props.stage === "active" && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { marginLeft: 8, color: "#cfd3ff" }, children: "(clique pour ajouter/retirer)" })
          ] }),
          props.selectedTargetLabels.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginTop: 6, display: "flex", flexWrap: "wrap", gap: 6 }, children: props.selectedTargetLabels.map((label2, idx) => {
            const hasId = idx < props.selectedTargetIds.length;
            const id2 = hasId ? props.selectedTargetIds[idx] : label2;
            return /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "div",
              {
                style: {
                  display: "flex",
                  alignItems: "center",
                  gap: 6,
                  padding: "2px 8px",
                  borderRadius: 999,
                  background: "rgba(255,255,255,0.08)",
                  border: "1px solid rgba(255,255,255,0.12)",
                  fontSize: 11,
                  fontWeight: 800,
                  color: "rgba(255,255,255,0.85)"
                },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: label2 }),
                  props.onToggleTargetId && hasId && /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "button",
                    {
                      type: "button",
                      onClick: () => {
                        var _a2;
                        return (_a2 = props.onToggleTargetId) == null ? void 0 : _a2.call(props, id2);
                      },
                      style: {
                        width: 18,
                        height: 18,
                        borderRadius: 9,
                        border: "1px solid rgba(255,255,255,0.2)",
                        background: "rgba(255,255,255,0.08)",
                        color: "rgba(255,255,255,0.9)",
                        cursor: "pointer",
                        fontSize: 10,
                        lineHeight: "16px",
                        padding: 0
                      },
                      title: "Retirer",
                      children: ""
                    }
                  )
                ]
              },
              `${id2}-${idx}`
            );
          }) }),
          props.stage !== "active" && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginTop: 6, fontSize: 12, color: "rgba(255,255,255,0.70)" }, children: "Validez l'action pour pouvoir selectionner une cible sur la grille." }),
          props.stage === "active" && props.targetMode === "selecting" && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginTop: 8 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              type: "button",
              onClick: () => props.onSetTargetMode("none"),
              style: {
                padding: "4px 8px",
                borderRadius: 10,
                border: "1px solid rgba(255,255,255,0.12)",
                background: "rgba(255,255,255,0.06)",
                color: "#fff",
                cursor: "pointer",
                fontSize: 11,
                fontWeight: 800
              },
              children: "Terminer selection"
            }
          ) }),
          props.targetStatuses && props.targetStatuses.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              style: {
                marginTop: 8,
                padding: 8,
                borderRadius: 10,
                border: "1px solid rgba(255,255,255,0.12)",
                background: "rgba(255,255,255,0.04)"
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 11, fontWeight: 900, color: "#fff" }, children: "Etats actifs sur la cible" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginTop: 6, display: "grid", gap: 6 }, children: props.targetStatuses.map((status) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "div",
                  {
                    style: {
                      display: "flex",
                      justifyContent: "space-between",
                      alignItems: "center",
                      gap: 8,
                      fontSize: 11,
                      color: "rgba(255,255,255,0.82)"
                    },
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontWeight: 700 }, children: status.label }),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { style: { color: "rgba(255,255,255,0.65)" }, children: [
                        status.sourceId ? `posee par ${status.sourceId}` : "source inconnue",
                        " |",
                        " ",
                        status.isPersistent ? "jusqua la mort" : `${status.remainingTurns} tour(s)`
                      ] })
                    ]
                  },
                  status.id
                )) })
              ]
            }
          )
        ] }),
        resourceStep && /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            style: {
              marginTop: 12,
              padding: 8,
              borderRadius: 10,
              border: "1px solid rgba(255,255,255,0.12)",
              background: "rgba(255,255,255,0.04)"
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, fontWeight: 900, color: "#fff" }, children: "Ressource" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginTop: 6, fontSize: 12, color: "rgba(255,255,255,0.85)" }, children: resourceStep.title }),
              resourceStep.detail && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginTop: 4, fontSize: 11, color: "#ffb2aa" }, children: resourceStep.detail })
            ]
          }
        ),
        ammoInfo && /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            style: {
              marginTop: 12,
              padding: 8,
              borderRadius: 10,
              border: "1px solid rgba(255,255,255,0.12)",
              background: "rgba(255,255,255,0.04)"
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, fontWeight: 900, color: "#fff" }, children: "Munitions" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginTop: 6, fontSize: 12, color: "rgba(255,255,255,0.85)" }, children: [
                ammoInfo.label,
                " : ",
                ammoInfo.available,
                " / ",
                ammoInfo.required
              ] }),
              ammoInfo.unknown && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginTop: 4, fontSize: 11, color: "#ffb2aa" }, children: "Type de munition non reference dans le catalogue." }),
              ammoInfo.insufficient && !ammoInfo.unknown && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginTop: 4, fontSize: 11, color: "#ffb2aa" }, children: "Munitions insuffisantes pour cette action." })
            ]
          }
        ),
        action2 && spellSourceOptions.length > 1 && /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            style: {
              marginTop: 12,
              padding: 8,
              borderRadius: 10,
              border: "1px solid rgba(255,255,255,0.12)",
              background: "rgba(255,255,255,0.04)"
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, fontWeight: 900, color: "#fff" }, children: "Source du sort" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "select",
                {
                  value: props.selectedSpellSourceEntryId ?? "",
                  onChange: (event) => {
                    var _a2;
                    const value2 = event.target.value;
                    if (!value2) return;
                    (_a2 = props.onSelectSpellSourceEntryId) == null ? void 0 : _a2.call(props, value2);
                  },
                  style: {
                    width: "100%",
                    marginTop: 6,
                    background: "#0f0f19",
                    color: "#f5f5f5",
                    border: "1px solid #333",
                    borderRadius: 6,
                    padding: "6px 8px",
                    fontSize: 12
                  },
                  children: spellSourceOptions.map((option) => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: option.entryId, disabled: Boolean(option.disabled), children: option.label }, option.entryId))
                }
              ),
              (() => {
                const selected = spellSourceOptions.find((option) => option.entryId === (props.selectedSpellSourceEntryId ?? "")) ?? spellSourceOptions[0];
                if (!(selected == null ? void 0 : selected.detail)) return null;
                return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginTop: 6, fontSize: 11, color: "rgba(255,255,255,0.75)" }, children: selected.detail });
              })()
            ]
          }
        ),
        hasHazard && /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            style: {
              marginTop: 12,
              padding: 8,
              borderRadius: 10,
              border: "1px solid rgba(255,255,255,0.12)",
              background: "rgba(255,255,255,0.04)"
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, fontWeight: 900, color: "#fff" }, children: [
                "Danger: ",
                (_e = props.pendingHazard) == null ? void 0 : _e.label
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginTop: 6, fontSize: 12, color: "rgba(255,255,255,0.85)" }, children: [
                "Cases traversees: ",
                (_f = props.pendingHazard) == null ? void 0 : _f.cells,
                " | Jet requis: ",
                (_g = props.pendingHazard) == null ? void 0 : _g.formula
              ] }),
              ((_h = props.pendingHazard) == null ? void 0 : _h.statusRoll) && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginTop: 4, fontSize: 11, color: "rgba(255,255,255,0.7)" }, children: [
                "Etat: d",
                props.pendingHazard.statusRoll.die,
                " == ",
                props.pendingHazard.statusRoll.trigger
              ] }),
              props.hazardResolution && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginTop: 8, fontSize: 12, color: "rgba(255,255,255,0.85)" }, children: [
                "Resultat: ",
                props.hazardResolution.damageTotal,
                " degats",
                props.hazardResolution.diceText ? ` (${props.hazardResolution.diceText})` : ""
              ] }),
              ((_i = props.hazardResolution) == null ? void 0 : _i.statusId) && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginTop: 4, fontSize: 11, color: "rgba(255,255,255,0.75)" }, children: [
                "Etat ",
                props.hazardResolution.statusId,
                ": ",
                props.hazardResolution.statusTriggered ? "declenche" : "non declenche"
              ] }),
              props.onRollHazardDamage && !props.hazardResolution && /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  type: "button",
                  onClick: props.onRollHazardDamage,
                  style: {
                    marginTop: 8,
                    padding: "6px 10px",
                    background: "#c0392b",
                    color: "#fff",
                    border: "1px solid rgba(255,255,255,0.12)",
                    borderRadius: 10,
                    cursor: "pointer",
                    fontSize: 12,
                    fontWeight: 900
                  },
                  children: "Lancer degats environnement"
                }
              ),
              hazardFinishReady && props.onFinishHazard && /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  type: "button",
                  onClick: props.onFinishHazard,
                  style: {
                    marginTop: 10,
                    padding: "6px 10px",
                    background: "#2ecc71",
                    color: "#0b0b12",
                    border: "1px solid rgba(255,255,255,0.12)",
                    borderRadius: 10,
                    cursor: "pointer",
                    fontSize: 12,
                    fontWeight: 900
                  },
                  children: "Terminer"
                }
              )
            ]
          }
        ),
        action2 && props.stage === "active" && (attackStep || damageStep) && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginTop: 12 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, fontWeight: 900, color: "#fff", marginBottom: 6 }, children: "Jets" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginTop: 8, display: "flex", gap: 8, flexWrap: "wrap" }, children: [
            attackStep && /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "button",
                onClick: props.onRollAttack,
                disabled: attackStep.status !== "available",
                style: {
                  padding: "6px 10px",
                  background: attackStep.status === "available" ? "#2980b9" : "rgba(90, 90, 100, 0.55)",
                  color: "#fff",
                  border: "1px solid rgba(255,255,255,0.12)",
                  borderRadius: 10,
                  cursor: attackStep.status === "available" ? "pointer" : "not-allowed",
                  fontSize: 12,
                  fontWeight: 900
                },
                children: "Jet de touche"
              }
            ),
            damageStep && /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "button",
                onClick: props.onRollDamage,
                disabled: damageStep.status !== "available",
                style: {
                  padding: "6px 10px",
                  background: damageStep.status === "available" ? "#27ae60" : "rgba(90, 90, 100, 0.55)",
                  color: "#fff",
                  border: "1px solid rgba(255,255,255,0.12)",
                  borderRadius: 10,
                  cursor: damageStep.status === "available" ? "pointer" : "not-allowed",
                  fontSize: 12,
                  fontWeight: 900
                },
                children: "Degats"
              }
            )
          ] }),
          attackStep && props.effectiveAdvantageMode && props.effectiveAdvantageMode !== "normal" && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginTop: 6, fontSize: 11, color: "rgba(255,255,255,0.75)" }, children: props.effectiveAdvantageMode === "advantage" ? "Avantage: lancer 2d20, garder le meilleur." : "Desavantage: lancer 2d20, garder le pire." }),
          attackStep && props.attackRoll && /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              style: {
                marginTop: 10,
                padding: 8,
                borderRadius: 10,
                border: "1px solid rgba(255,255,255,0.12)",
                background: "rgba(255,255,255,0.04)"
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 11, fontWeight: 900, color: "rgba(255,255,255,0.85)" }, children: "Jet de touche" }),
                props.effectiveAdvantageMode && props.effectiveAdvantageMode !== "normal" && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginTop: 4, fontSize: 11, color: "rgba(255,255,255,0.7)" }, children: props.effectiveAdvantageMode === "advantage" ? "Avantage: 2d20, garder le meilleur." : "Desavantage: 2d20, garder le pire." }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginTop: 4, fontSize: 12, color: "rgba(255,255,255,0.85)" }, children: [
                  props.attackRoll.total,
                  props.attackRoll.isCrit ? " (crit)" : ""
                ] }),
                damageStep && damageStep.status === "blocked" && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginTop: 6, fontSize: 12, fontWeight: 900, color: "#ffb2aa" }, children: "RATE" }),
                damageStep && damageStep.status !== "blocked" && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginTop: 6, fontSize: 12, fontWeight: 900, color: "#bdf6d2" }, children: "REUSSI" })
              ]
            }
          ),
          damageStep && props.damageRoll && /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              style: {
                marginTop: 10,
                padding: 8,
                borderRadius: 10,
                border: "1px solid rgba(255,255,255,0.12)",
                background: "rgba(255,255,255,0.04)"
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 11, fontWeight: 900, color: "rgba(255,255,255,0.85)" }, children: "Degats" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginTop: 4, fontSize: 12, color: "rgba(255,255,255,0.85)" }, children: [
                  props.damageRoll.total,
                  props.damageRoll.isCrit ? " (crit)" : ""
                ] })
              ]
            }
          ),
          finishReady && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              type: "button",
              onClick: props.onFinishAction,
              style: {
                marginTop: 12,
                padding: "6px 10px",
                background: "#2ecc71",
                color: "#0b0b12",
                border: "1px solid rgba(255,255,255,0.12)",
                borderRadius: 10,
                cursor: "pointer",
                fontSize: 12,
                fontWeight: 900
              },
              children: "Terminer"
            }
          )
        ] })
      ]
    }
  );
}
function JsonInfoPanel(props) {
  if (!props.open) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      style: {
        position: "absolute",
        inset: 12,
        zIndex: 80,
        background: "rgba(7, 9, 12, 0.96)",
        border: "1px solid rgba(255,255,255,0.14)",
        borderRadius: 12,
        padding: 12,
        display: "flex",
        flexDirection: "column",
        gap: 10,
        boxShadow: "0 20px 60px rgba(0,0,0,0.65)",
        backdropFilter: "blur(8px)"
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", justifyContent: "space-between", gap: 10 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { minWidth: 0 }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 13, fontWeight: 900, color: "#fff" }, children: props.title }),
            props.subtitle && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginTop: 4, fontSize: 11, color: "rgba(255,255,255,0.65)" }, children: props.subtitle })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              type: "button",
              onClick: props.onClose,
              style: {
                width: 32,
                height: 32,
                borderRadius: 10,
                border: "1px solid rgba(255,255,255,0.14)",
                background: "rgba(255,255,255,0.06)",
                color: "rgba(255,255,255,0.85)",
                cursor: "pointer",
                fontWeight: 900
              },
              children: "X"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "pre",
          {
            style: {
              margin: 0,
              flex: "1 1 auto",
              overflow: "auto",
              whiteSpace: "pre-wrap",
              wordBreak: "break-word",
              fontSize: 11,
              color: "rgba(255,255,255,0.8)",
              background: "#0f0f19",
              border: "1px solid rgba(255,255,255,0.12)",
              borderRadius: 8,
              padding: 8
            },
            children: JSON.stringify(props.data, null, 2)
          }
        )
      ]
    }
  );
}
function clamp$1(value2, min, max) {
  return Math.max(min, Math.min(max, value2));
}
function formatMod(value2) {
  if (typeof value2 !== "number") return "-";
  return value2 >= 0 ? `+${value2}` : `${value2}`;
}
function formatList(list, fallback = "-") {
  if (!list || list.length === 0) return fallback;
  return list.join(", ");
}
function formatMovementModes(modes) {
  if (!modes) return null;
  if (Array.isArray(modes)) {
    if (modes.length === 0) return null;
    return modes.map((id2) => `${id2.charAt(0).toUpperCase()}${id2.slice(1)}`).join(", ");
  }
  const entries = Object.entries(modes);
  if (entries.length === 0) return null;
  return entries.map(([key2, value2]) => {
    const label2 = key2 ? `${key2.charAt(0).toUpperCase()}${key2.slice(1)}` : "Mode";
    return `${label2} ${value2}`;
  }).join(", ");
}
function Section(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      style: {
        background: "rgba(255,255,255,0.03)",
        border: "1px solid rgba(255,255,255,0.08)",
        borderRadius: 12,
        padding: 10,
        display: "flex",
        flexDirection: "column",
        gap: 8
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, fontWeight: 900, color: "#fff", letterSpacing: 0.4 }, children: props.title }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexDirection: "column", gap: 6 }, children: props.children })
      ]
    }
  );
}
function StatRow(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", justifyContent: "space-between", gap: 12 }, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { color: props.dim ? "rgba(255,255,255,0.55)" : "rgba(255,255,255,0.75)" }, children: props.label }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { color: "#fff", fontWeight: 800, textAlign: "right" }, children: props.value })
  ] });
}
function Chip(props) {
  const bg = props.tone === "accent" ? "rgba(88, 205, 255, 0.18)" : "rgba(255,255,255,0.08)";
  const color = props.tone === "accent" ? "#e9fbff" : "rgba(255,255,255,0.8)";
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "span",
    {
      style: {
        padding: "4px 8px",
        borderRadius: 999,
        fontSize: 11,
        fontWeight: 700,
        background: bg,
        color,
        border: "1px solid rgba(255,255,255,0.08)",
        textTransform: "none"
      },
      children: props.label
    }
  );
}
function ChipList(props) {
  if (!props.items || props.items.length === 0) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.6)" }, children: props.emptyLabel });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexWrap: "wrap", gap: 6 }, children: props.items.map((item) => /* @__PURE__ */ jsxRuntimeExports.jsx(Chip, { label: item, tone: props.accent ? "accent" : "muted" }, item)) });
}
function ChipButton(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "button",
    {
      type: "button",
      onClick: props.onClick,
      title: props.title,
      style: {
        padding: "4px 8px",
        borderRadius: 999,
        fontSize: 11,
        fontWeight: 700,
        background: "rgba(255,255,255,0.08)",
        color: "rgba(255,255,255,0.85)",
        border: "1px solid rgba(255,255,255,0.12)",
        cursor: "pointer"
      },
      children: props.label
    }
  );
}
function ChipButtonList(props) {
  if (!props.items || props.items.length === 0) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.6)" }, children: props.emptyLabel });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", flexWrap: "wrap", gap: 6 }, children: props.items.map((item) => /* @__PURE__ */ jsxRuntimeExports.jsx(ChipButton, { label: item, onClick: () => props.onSelect(item) }, item)) });
}
function formatCoins(coins) {
  if (!coins) return "-";
  const entries = Object.entries(coins).filter(([, value2]) => typeof value2 === "number" && value2 !== 0);
  if (entries.length === 0) return "0";
  return entries.map(([key2, value2]) => `${value2} ${key2}`).join(" | ");
}
function formatSlots(slots) {
  if (!slots) return [];
  const entries = Object.entries(slots).map(([level2, data]) => {
    if (!data || typeof data !== "object") return null;
    const max = data.max;
    const remaining = data.remaining;
    if (typeof max !== "number" && typeof remaining !== "number") return null;
    const safeMax = typeof max === "number" ? max : "-";
    const safeRemaining = typeof remaining === "number" ? remaining : "-";
    return { label: `Niv ${level2}`, text: `${safeRemaining} / ${safeMax}` };
  }).filter(Boolean);
  return entries.sort((a2, b2) => Number(a2.label.replace("Niv ", "")) - Number(b2.label.replace("Niv ", "")));
}
function formatWeaponRangeLabel(weapon) {
  const properties2 = (weapon == null ? void 0 : weapon.properties) ?? {};
  const thrown = properties2 == null ? void 0 : properties2.thrown;
  const range = properties2 == null ? void 0 : properties2.range;
  if (thrown && typeof thrown.normal === "number" && typeof thrown.long === "number") {
    return `jet ${thrown.normal}/${thrown.long} m`;
  }
  if (range && typeof range.normal === "number") {
    if (typeof range.long === "number" && range.long > range.normal) {
      return `portee ${range.normal}/${range.long} m`;
    }
    return `portee ${range.normal} m`;
  }
  if (typeof (properties2 == null ? void 0 : properties2.reach) === "number" && properties2.reach > 0) {
    return `allonge ${properties2.reach} m`;
  }
  return "portee -";
}
function formatWeaponDamageLabel(weapon) {
  var _a, _b;
  const baseDice = ((_a = weapon.damage) == null ? void 0 : _a.dice) ?? "?";
  const baseType = ((_b = weapon.damage) == null ? void 0 : _b.damageType) ?? "?";
  const base = `${baseDice} ${baseType}`;
  const extras = Array.isArray(weapon.extraDamage) ? weapon.extraDamage : [];
  const extraText = extras.map((entry) => {
    const dice = String((entry == null ? void 0 : entry.dice) ?? "").trim();
    const type2 = String((entry == null ? void 0 : entry.damageType) ?? "").trim();
    if (!dice || !type2) return null;
    const when = String((entry == null ? void 0 : entry.when) ?? "onHit");
    return when === "onHit" ? `+${dice} ${type2}` : `+${dice} ${type2} (${when})`;
  }).filter(Boolean).join(" + ");
  return extraText ? `${base} + ${extraText}` : base;
}
function isInventoryItemHarmonized(item) {
  var _a, _b;
  if (!item) return false;
  if (item.harmonized === true || item.isHarmonized === true || item.attuned === true) return true;
  if (((_a = item == null ? void 0 : item.attunement) == null ? void 0 : _a.state) === "harmonized") return true;
  if (typeof ((_b = item == null ? void 0 : item.attunement) == null ? void 0 : _b.harmonizedAt) === "string" && item.attunement.harmonizedAt.length > 0) {
    return true;
  }
  return false;
}
function CharacterSheetWindow(props) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B, _C, _D, _E, _F, _G, _H, _I;
  const containerRef = reactExports.useRef(null);
  const [pos, setPos] = reactExports.useState({ left: 8, top: 8 });
  const [isDragging, setIsDragging] = reactExports.useState(false);
  const [showCharacterJson, setShowCharacterJson] = reactExports.useState(false);
  const [infoPanel, setInfoPanel] = reactExports.useState(null);
  const dragRef = reactExports.useRef(null);
  reactExports.useLayoutEffect(() => {
    if (!props.open) return;
    const el = containerRef.current;
    if (!el) return;
    const parent = el.parentElement;
    if (!parent) return;
    const parentRect = parent.getBoundingClientRect();
    const rect = el.getBoundingClientRect();
    const left = clamp$1(8, 8, Math.max(8, parentRect.width - rect.width - 8));
    const top = clamp$1(8, 8, Math.max(8, parentRect.height - rect.height - 8));
    setPos({ left, top });
  }, [props.open]);
  reactExports.useEffect(() => {
    if (!isDragging) return;
    const onMove = (event) => {
      const el = containerRef.current;
      const drag = dragRef.current;
      if (!el || !drag) return;
      const parent = el.parentElement;
      if (!parent) return;
      const parentRect = parent.getBoundingClientRect();
      const rect = el.getBoundingClientRect();
      const dx = event.clientX - drag.startClientX;
      const dy = event.clientY - drag.startClientY;
      const nextLeft = drag.startLeft + dx;
      const nextTop = drag.startTop + dy;
      const left = clamp$1(nextLeft, 8, Math.max(8, parentRect.width - rect.width - 8));
      const top = clamp$1(nextTop, 8, Math.max(8, parentRect.height - rect.height - 8));
      setPos({ left, top });
    };
    const onUp = () => {
      setIsDragging(false);
      dragRef.current = null;
    };
    window.addEventListener("pointermove", onMove);
    window.addEventListener("pointerup", onUp, { once: true });
    return () => {
      window.removeEventListener("pointermove", onMove);
    };
  }, [isDragging]);
  if (!props.open) return null;
  const stats = props.player.combatStats ?? props.character.combatStats;
  const charName = ((_b = (_a = props.character) == null ? void 0 : _a.nom) == null ? void 0 : _b.nomcomplet) ?? "Personnage";
  const nickName = ((_d = (_c = props.character) == null ? void 0 : _c.nom) == null ? void 0 : _d.surnom) ? `"${props.character.nom.surnom}"` : "";
  const subtitleParts = [(_f = (_e = props.character) == null ? void 0 : _e.nom) == null ? void 0 : _f.prenom, nickName].filter(Boolean).join(" ");
  const movementSummary = formatMovementModes(props.character.movementModes) ?? (typeof (stats == null ? void 0 : stats.moveRange) === "number" || typeof props.player.moveRange === "number" ? `Standard ${(stats == null ? void 0 : stats.moveRange) ?? props.player.moveRange ?? 0}` : "Inconnu");
  const equippedWeapons = props.equippedWeapons ?? [];
  const weaponById = props.weaponById ?? /* @__PURE__ */ new Map();
  const equipmentAppliedBonuses = Array.isArray(props.equipmentAppliedBonuses) ? props.equipmentAppliedBonuses : [];
  const attackRange = equippedWeapons.length === 0 ? 1.5 : Math.max(
    1.5,
    ...equippedWeapons.map((weapon) => {
      var _a2, _b2, _c2;
      const reach = (_a2 = weapon.properties) == null ? void 0 : _a2.reach;
      if (typeof reach === "number" && reach > 0) return reach;
      const range = (_c2 = (_b2 = weapon.properties) == null ? void 0 : _b2.range) == null ? void 0 : _c2.normal;
      if (typeof range === "number" && range > 0) return range;
      return 1.5;
    })
  );
  const classEntries = Object.entries(((_g = props.character) == null ? void 0 : _g.classe) ?? {}).map(([key2, value2]) => {
    const name2 = (value2 == null ? void 0 : value2.classeId) ?? key2;
    const level2 = (value2 == null ? void 0 : value2.niveau) ?? "-";
    const sub = (value2 == null ? void 0 : value2.subclasseId) ? ` (${value2.subclasseId})` : "";
    return `${name2}${sub} L${level2}`;
  });
  const abilities = [
    { key: "FOR", label: "FOR", score: (_i = (_h = props.character.caracs) == null ? void 0 : _h.force) == null ? void 0 : _i.FOR, mod: (_k = (_j = props.character.caracs) == null ? void 0 : _j.force) == null ? void 0 : _k.modFOR },
    { key: "DEX", label: "DEX", score: (_m = (_l = props.character.caracs) == null ? void 0 : _l.dexterite) == null ? void 0 : _m.DEX, mod: (_o = (_n = props.character.caracs) == null ? void 0 : _n.dexterite) == null ? void 0 : _o.modDEX },
    { key: "CON", label: "CON", score: (_q = (_p = props.character.caracs) == null ? void 0 : _p.constitution) == null ? void 0 : _q.CON, mod: (_s = (_r = props.character.caracs) == null ? void 0 : _r.constitution) == null ? void 0 : _s.modCON },
    { key: "INT", label: "INT", score: (_u = (_t = props.character.caracs) == null ? void 0 : _t.intelligence) == null ? void 0 : _u.INT, mod: (_w = (_v = props.character.caracs) == null ? void 0 : _v.intelligence) == null ? void 0 : _w.modINT },
    { key: "SAG", label: "SAG", score: (_y = (_x = props.character.caracs) == null ? void 0 : _x.sagesse) == null ? void 0 : _y.SAG, mod: (_A = (_z = props.character.caracs) == null ? void 0 : _z.sagesse) == null ? void 0 : _A.modSAG },
    { key: "CHA", label: "CHA", score: (_C = (_B = props.character.caracs) == null ? void 0 : _B.charisme) == null ? void 0 : _C.CHA, mod: (_E = (_D = props.character.caracs) == null ? void 0 : _D.charisme) == null ? void 0 : _E.modCHA }
  ];
  const profs = props.character.proficiencies ?? {};
  const inventoryItems = props.character.inventoryItems ?? [];
  const harmonizedByWeaponId = (() => {
    const map = /* @__PURE__ */ new Map();
    inventoryItems.filter(
      (item) => (item == null ? void 0 : item.type) === "weapon" && (item == null ? void 0 : item.equippedSlot) && (/* @__PURE__ */ new Set(["ceinture_gauche", "ceinture_droite", "dos_gauche", "dos_droit"])).has(item.equippedSlot)
    ).forEach((item) => {
      const weapon = weaponById.get(String(item.id));
      if (!weapon) return;
      const current = map.get(String(item.id)) ?? { harmonisable: Boolean(weapon.harmonisable), harmonized: false };
      const next = {
        harmonisable: current.harmonisable || Boolean(weapon.harmonisable),
        harmonized: current.harmonized || isInventoryItemHarmonized(item)
      };
      map.set(String(item.id), next);
    });
    return map;
  })();
  const equipmentSlots = props.character.materielSlots ?? {};
  const spellSlots = formatSlots((_F = props.character.spellcastingState) == null ? void 0 : _F.slots);
  const spellSources = ((_G = props.character.spellcastingState) == null ? void 0 : _G.sources) ? Object.values(props.character.spellcastingState.sources) : [];
  const spellIdsFromState = (() => {
    const prepared = /* @__PURE__ */ new Set();
    const granted = /* @__PURE__ */ new Set();
    const known = /* @__PURE__ */ new Set();
    spellSources.forEach((source2) => {
      const preparedIds = Array.isArray(source2 == null ? void 0 : source2.preparedSpellIds) ? source2.preparedSpellIds : [];
      const grantedIds = Array.isArray(source2 == null ? void 0 : source2.grantedSpellIds) ? source2.grantedSpellIds : [];
      const knownIds = Array.isArray(source2 == null ? void 0 : source2.knownSpellIds) ? source2.knownSpellIds : [];
      preparedIds.forEach((id2) => id2 && prepared.add(String(id2)));
      grantedIds.forEach((id2) => id2 && granted.add(String(id2)));
      knownIds.forEach((id2) => id2 && known.add(String(id2)));
    });
    return {
      prepared: Array.from(prepared),
      granted: Array.from(granted),
      known: Array.from(known)
    };
  })();
  const spellIdsFromSelections = (() => {
    var _a2, _b2;
    const prepared = /* @__PURE__ */ new Set();
    const granted = /* @__PURE__ */ new Set();
    const known = /* @__PURE__ */ new Set();
    const selections = (_b2 = (_a2 = props.character) == null ? void 0 : _a2.choiceSelections) == null ? void 0 : _b2.spellcasting;
    if (!selections || typeof selections !== "object") {
      return { prepared: [], granted: [], known: [] };
    }
    Object.values(selections).forEach((entry) => {
      const preparedList = Array.isArray(entry == null ? void 0 : entry.preparedSpells) ? entry.preparedSpells : [];
      const grantedList = Array.isArray(entry == null ? void 0 : entry.grantedSpells) ? entry.grantedSpells : [];
      const knownList = Array.isArray(entry == null ? void 0 : entry.knownSpells) ? entry.knownSpells : [];
      preparedList.forEach((spell) => {
        const id2 = typeof spell === "string" ? spell : spell == null ? void 0 : spell.id;
        if (id2) prepared.add(String(id2));
      });
      grantedList.forEach((spell) => {
        const id2 = typeof spell === "string" ? spell : spell == null ? void 0 : spell.id;
        if (id2) granted.add(String(id2));
      });
      knownList.forEach((spell) => {
        const id2 = typeof spell === "string" ? spell : spell == null ? void 0 : spell.id;
        if (id2) known.add(String(id2));
      });
    });
    return {
      prepared: Array.from(prepared),
      granted: Array.from(granted),
      known: Array.from(known)
    };
  })();
  const displayedPreparedSpellIds = spellIdsFromState.prepared.length > 0 ? spellIdsFromState.prepared : spellIdsFromSelections.prepared;
  const displayedGrantedSpellIds = spellIdsFromState.granted.length > 0 ? spellIdsFromState.granted : spellIdsFromSelections.granted;
  const displayedKnownSpellIds = spellIdsFromState.known.length > 0 ? spellIdsFromState.known : spellIdsFromSelections.known;
  const resolveItemLabel = (value2) => {
    var _a2;
    if (!value2) return "-";
    return ((_a2 = props.itemLabels) == null ? void 0 : _a2[value2]) ?? value2;
  };
  const actionInfoById = props.actionInfoById ?? /* @__PURE__ */ new Map();
  const spellInfoById = props.spellInfoById ?? /* @__PURE__ */ new Map();
  const resourceEntries = Object.entries(props.resources ?? {}).map(([key2, value2]) => {
    const [poolRaw, nameRaw] = key2.includes(":") ? key2.split(":", 2) : ["default", key2];
    const pool = poolRaw || "default";
    const name2 = nameRaw || key2;
    const label2 = pool === "default" ? name2 : `${pool}:${name2}`;
    return { key: key2, label: label2, value: value2 };
  }).filter((entry) => Number.isFinite(entry.value)).sort((a2, b2) => a2.label.localeCompare(b2.label));
  const openActionInfo = (id2) => {
    const def = actionInfoById.get(id2);
    if (!def) {
      setInfoPanel({ title: `Action ${id2}`, subtitle: "Non trouvee", data: { id: id2 } });
      return;
    }
    setInfoPanel({ title: def.name ?? def.id, subtitle: `Action ${def.id}`, data: def });
  };
  const openSpellInfo = (id2) => {
    const def = spellInfoById.get(id2);
    if (!def) {
      setInfoPanel({ title: `Sort ${id2}`, subtitle: "Non trouve", data: { id: id2 } });
      return;
    }
    setInfoPanel({ title: def.name ?? def.id, subtitle: `Sort ${def.id}`, data: def });
  };
  const initiativeValue = (() => {
    const total = props.initiativeTotal;
    if (typeof total === "number") {
      const roll = props.initiativeRoll;
      const mod = props.initiativeMod;
      if (typeof roll === "number" && typeof mod === "number") {
        const modText = mod >= 0 ? `+${mod}` : `${mod}`;
        return `${total} (d20=${roll} ${modText})`;
      }
      return total;
    }
    return "-";
  })();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      ref: containerRef,
      onWheelCapture: (event) => {
        event.preventDefault();
        event.stopPropagation();
      },
      onWheel: (event) => {
        event.preventDefault();
        event.stopPropagation();
      },
      onMouseDown: (event) => event.stopPropagation(),
      style: {
        position: "absolute",
        right: 8,
        top: 8,
        bottom: 8,
        zIndex: 65,
        width: 560,
        maxWidth: "min(92vw, 720px)",
        background: "rgba(8, 10, 14, 0.95)",
        border: "1px solid rgba(255,255,255,0.14)",
        borderRadius: 14,
        padding: 12,
        boxShadow: "0 24px 70px rgba(0,0,0,0.6)",
        backdropFilter: "blur(8px)",
        overflow: "hidden",
        display: "flex",
        flexDirection: "column",
        gap: 10
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", justifyContent: "space-between", gap: 10 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              onPointerDown: (event) => {
                if (event.button !== 0) return;
                const el = containerRef.current;
                if (!el) return;
                event.preventDefault();
                event.stopPropagation();
                dragRef.current = {
                  startClientX: event.clientX,
                  startClientY: event.clientY,
                  startLeft: pos.left,
                  startTop: pos.top
                };
                setIsDragging(true);
              },
              style: {
                minWidth: 0,
                flex: "1 1 auto",
                cursor: isDragging ? "grabbing" : "grab",
                userSelect: "none"
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 14, fontWeight: 900, color: "#fff" }, children: "Fiche personnage" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginTop: 4, fontSize: 12, color: "rgba(255,255,255,0.75)" }, children: charName }),
                subtitleParts && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginTop: 2, fontSize: 11, color: "rgba(255,255,255,0.6)" }, children: subtitleParts })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              type: "button",
              onClick: props.onClose,
              style: {
                width: 32,
                height: 32,
                borderRadius: 10,
                border: "1px solid rgba(255,255,255,0.14)",
                background: "rgba(255,255,255,0.06)",
                color: "rgba(255,255,255,0.85)",
                cursor: "pointer",
                fontWeight: 900
              },
              children: "X"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginTop: 4, display: "flex", justifyContent: "flex-end" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            type: "button",
            onClick: () => setShowCharacterJson((prev) => !prev),
            style: {
              padding: "6px 10px",
              borderRadius: 8,
              border: "1px solid rgba(255,255,255,0.15)",
              background: "rgba(255,255,255,0.08)",
              color: "#f5f5f5",
              cursor: "pointer",
              fontSize: 12,
              fontWeight: 700
            },
            children: showCharacterJson ? "Masquer le JSON" : "Afficher le JSON"
          }
        ) }),
        showCharacterJson && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "pre",
          {
            style: {
              marginTop: 6,
              maxHeight: 200,
              overflow: "auto",
              whiteSpace: "pre-wrap",
              wordBreak: "break-word",
              fontSize: 11,
              color: "rgba(255,255,255,0.8)",
              background: "#0f0f19",
              border: "1px solid rgba(255,255,255,0.12)",
              borderRadius: 8,
              padding: 8
            },
            children: JSON.stringify(props.character, null, 2)
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { flex: "1 1 auto", minHeight: 0, overflow: "auto", paddingRight: 4, display: "grid", gap: 10 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "grid", gridTemplateColumns: "repeat(auto-fit, minmax(230px, 1fr))", gap: 10 }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Section, { title: "Etat", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(StatRow, { label: "PV", value: `${props.player.hp} / ${props.player.maxHp}` }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(StatRow, { label: "PV temporaires", value: props.player.tempHp ?? props.character.pvTmp ?? 0 }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                StatRow,
                {
                  label: "Fatigue",
                  value: `${props.character.nivFatigueActuel ?? 0} / ${props.character.nivFatigueMax ?? 0}`
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(StatRow, { label: "Actions", value: props.actionsRemaining }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(StatRow, { label: "Bonus", value: props.bonusRemaining }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(StatRow, { label: "Inspiration", value: props.character.inspiration ? "Oui" : "Non" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Section, { title: "Combat", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(StatRow, { label: "CA", value: (stats == null ? void 0 : stats.armorClass) ?? props.player.armorClass ?? 10 }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(StatRow, { label: "Portee", value: attackRange }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(StatRow, { label: "Deplacements", value: movementSummary }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(StatRow, { label: "Initiative", value: initiativeValue }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(StatRow, { label: "Perception passive", value: props.character.percPassive ?? "-" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(StatRow, { label: "Vision", value: ((_H = props.character.visionProfile) == null ? void 0 : _H.lightVision) ?? "-" })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Section, { title: "Classe", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(StatRow, { label: "Classes", value: formatList(classEntries, "-") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(StatRow, { label: "Maitrise", value: props.character.maitriseBonus ?? "-" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(StatRow, { label: "XP", value: props.character.xp ?? "-" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(StatRow, { label: "DV", value: props.character.dv ?? "-" })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Section, { title: "Caracteristiques", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "grid", gridTemplateColumns: "repeat(auto-fit, minmax(160px, 1fr))", gap: 8 }, children: abilities.map((ability) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              style: {
                background: "rgba(255,255,255,0.04)",
                borderRadius: 10,
                border: "1px solid rgba(255,255,255,0.08)",
                padding: 8,
                display: "flex",
                flexDirection: "column",
                gap: 4
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, fontWeight: 800, color: "#fff" }, children: ability.label }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", justifyContent: "space-between", fontSize: 12 }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { color: "rgba(255,255,255,0.65)" }, children: "Score" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { color: "#fff", fontWeight: 800 }, children: ability.score ?? "-" })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", justifyContent: "space-between", fontSize: 12 }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { color: "rgba(255,255,255,0.65)" }, children: "Mod" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { color: "#fff", fontWeight: 800 }, children: formatMod(ability.mod) })
                ] })
              ]
            },
            ability.key
          )) }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "grid", gridTemplateColumns: "repeat(auto-fit, minmax(230px, 1fr))", gap: 10 }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Section, { title: "Competences", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChipList, { items: props.character.competences ?? [], emptyLabel: "Aucune competence." }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Section, { title: "Expertises", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChipList, { items: props.character.expertises ?? [], emptyLabel: "Aucune expertise." }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Section, { title: "Jets de sauvegarde", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChipList, { items: props.character.savingThrows ?? [], emptyLabel: "Aucun jet.", accent: true }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Section, { title: "Langues", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChipList, { items: props.character.langues ?? [], emptyLabel: "Aucune langue." }) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "grid", gridTemplateColumns: "repeat(auto-fit, minmax(230px, 1fr))", gap: 10 }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Section, { title: "Maitrises", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(StatRow, { label: "Armes", value: formatList(profs.weapons) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(StatRow, { label: "Bottes d'armes", value: formatList((_I = props.character) == null ? void 0 : _I.weaponMasteries) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(StatRow, { label: "Armures", value: formatList(profs.armors) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(StatRow, { label: "Outils", value: formatList(profs.tools) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Section, { title: "Actions", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                ChipButtonList,
                {
                  items: props.character.actionIds ?? props.player.actionIds ?? [],
                  emptyLabel: "Aucune action.",
                  onSelect: openActionInfo
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginTop: 6 }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 11, color: "rgba(255,255,255,0.6)", marginBottom: 4 }, children: "Reactions" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  ChipButtonList,
                  {
                    items: props.character.reactionIds ?? props.player.reactionIds ?? [],
                    emptyLabel: "Aucune reaction.",
                    onSelect: openActionInfo
                  }
                )
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Section, { title: "Ressources", children: [
              resourceEntries.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.65)" }, children: "Aucune ressource suivie." }),
              resourceEntries.map((entry) => /* @__PURE__ */ jsxRuntimeExports.jsx(StatRow, { label: entry.label, value: entry.value }, entry.key))
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Section, { title: "Bonus equipement actifs", children: [
              equipmentAppliedBonuses.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.65)" }, children: "Aucun bonus actif." }),
              equipmentAppliedBonuses.map((entry, idx) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12 }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { color: "#fff", fontWeight: 700 }, children: entry.bonusId }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { style: { color: "rgba(255,255,255,0.62)" }, children: [
                  " (source: ",
                  resolveItemLabel(entry.sourceItemId),
                  ")"
                ] })
              ] }, `${entry.bonusId}-${entry.sourceItemId}-${idx}`))
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "grid", gridTemplateColumns: "repeat(auto-fit, minmax(230px, 1fr))", gap: 10 }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Section, { title: "Equipement", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "grid", gridTemplateColumns: "repeat(auto-fit, minmax(160px, 1fr))", gap: 6 }, children: [
              Object.entries(equipmentSlots).filter(([, item]) => item).length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.65)" }, children: "Aucun slot." }),
              Object.entries(equipmentSlots).filter(([, item]) => item).map(([slot, item]) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.75)" }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontWeight: 800, color: "#fff" }, children: slot }),
                ":",
                " ",
                resolveItemLabel(String(item))
              ] }, slot))
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Section, { title: "Inventaire", children: [
              inventoryItems.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.65)" }, children: "Inventaire vide." }),
              inventoryItems.map((item) => {
                const weapon = (item == null ? void 0 : item.type) === "weapon" ? weaponById.get(String(item.id)) ?? null : null;
                const weaponSummary = weapon ? `${String(weapon.category ?? "?")} | ${formatWeaponDamageLabel(weapon)} | ${formatWeaponRangeLabel(weapon)}${weapon.harmonisable ? ` | harm:${isInventoryItemHarmonized(item) ? "active" : "inactive"}` : ""}` : null;
                return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "div",
                  {
                    style: { fontSize: 12, display: "flex", flexDirection: "column", gap: 2 },
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { style: { color: "#fff", fontWeight: 700 }, children: [
                          item.qty,
                          "x"
                        ] }),
                        " ",
                        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { color: "rgba(255,255,255,0.8)" }, title: weaponSummary ?? void 0, children: resolveItemLabel(String(item.id)) }),
                        item.equippedSlot && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { style: { color: "rgba(255,255,255,0.55)" }, children: [
                          " (eq: ",
                          item.equippedSlot,
                          ")"
                        ] }),
                        item.storedIn && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { style: { color: "rgba(255,255,255,0.55)" }, children: [
                          " (dans ",
                          item.storedIn,
                          ")"
                        ] })
                      ] }),
                      weaponSummary && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 10, color: "rgba(255,255,255,0.62)" }, children: weaponSummary })
                    ]
                  },
                  item.instanceId ?? `${item.id}-${item.qty}`
                );
              }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginTop: 6, fontSize: 12, color: "rgba(255,255,255,0.75)" }, children: [
                "Argent: ",
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { color: "#fff", fontWeight: 800 }, children: formatCoins(props.character.argent) })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Section, { title: "Armes equipees", children: [
              equippedWeapons.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.65)" }, children: "Aucune arme equipee." }),
              equippedWeapons.map((weapon) => {
                const damageLabel = formatWeaponDamageLabel(weapon);
                const category2 = String(weapon.category ?? "?");
                const rangeLabel = formatWeaponRangeLabel(weapon);
                const harmonized = harmonizedByWeaponId.get(String(weapon.id));
                const harmonizedLabel = (harmonized == null ? void 0 : harmonized.harmonisable) ? ` | harm:${harmonized.harmonized ? "active" : "inactive"}` : "";
                const subtitle = `${category2} | ${damageLabel} | ${rangeLabel}${harmonizedLabel}`;
                return /* @__PURE__ */ jsxRuntimeExports.jsx(StatRow, { label: weapon.name, value: subtitle, dim: true }, weapon.id);
              })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Section, { title: "Magie", children: [
            spellSlots.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.65)" }, children: "Aucun emplacement." }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "grid", gridTemplateColumns: "repeat(auto-fit, minmax(200px, 1fr))", gap: 10 }, children: spellSlots.map((slot) => {
              const parts = slot.text.split("/").map((v2) => v2.trim());
              const remaining = Number(parts[0]);
              const max = Number(parts[1]);
              const total = Number.isFinite(max) ? max : 0;
              const filled = Number.isFinite(remaining) ? remaining : 0;
              return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", flexDirection: "column", gap: 6 }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, color: "rgba(255,255,255,0.75)", fontWeight: 800 }, children: slot.label }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex", gap: 6, flexWrap: "wrap" }, children: Array.from({ length: total }).map((_, idx) => {
                  const isFilled = idx < filled;
                  return /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "span",
                    {
                      style: {
                        width: 16,
                        height: 16,
                        borderRadius: 6,
                        border: "1px solid rgba(140, 220, 255, 0.35)",
                        background: isFilled ? "rgba(120, 220, 255, 0.75)" : "rgba(20, 28, 36, 0.6)",
                        boxShadow: isFilled ? "0 0 10px rgba(120, 220, 255, 0.9), inset 0 0 6px rgba(255,255,255,0.6)" : "inset 0 0 6px rgba(0,0,0,0.6)"
                      }
                    },
                    `${slot.label}-${idx}`
                  );
                }) })
              ] }, slot.label);
            }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginTop: 8 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 11, color: "rgba(255,255,255,0.6)", marginBottom: 4 }, children: "Sorts prepares" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                ChipButtonList,
                {
                  items: displayedPreparedSpellIds,
                  emptyLabel: "Aucun sort prepare.",
                  onSelect: openSpellInfo
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginTop: 8 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 11, color: "rgba(255,255,255,0.6)", marginBottom: 4 }, children: "Sorts accordes" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                ChipButtonList,
                {
                  items: displayedGrantedSpellIds,
                  emptyLabel: "Aucun sort accorde.",
                  onSelect: openSpellInfo
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginTop: 8 }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 11, color: "rgba(255,255,255,0.6)", marginBottom: 4 }, children: "Sorts connus" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                ChipButtonList,
                {
                  items: displayedKnownSpellIds,
                  emptyLabel: "Aucun sort connu.",
                  onSelect: openSpellInfo
                }
              )
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          JsonInfoPanel,
          {
            open: Boolean(infoPanel),
            title: (infoPanel == null ? void 0 : infoPanel.title) ?? "",
            subtitle: (infoPanel == null ? void 0 : infoPanel.subtitle) ?? null,
            data: (infoPanel == null ? void 0 : infoPanel.data) ?? {},
            onClose: () => setInfoPanel(null)
          }
        )
      ]
    }
  );
}
function clamp(value2, min, max) {
  return Math.max(min, Math.min(max, value2));
}
function costLabel(cost) {
  if (cost === "action") return "Action";
  if (cost === "bonus") return "Bonus";
  return "Libre";
}
function InteractionContextWindow(props) {
  var _a, _b;
  const containerRef = reactExports.useRef(null);
  const [pos, setPos] = reactExports.useState({ left: 16, top: 16 });
  const [isDragging, setIsDragging] = reactExports.useState(false);
  const dragRef = reactExports.useRef(null);
  const hasUserMovedRef = reactExports.useRef(false);
  reactExports.useLayoutEffect(() => {
    if (!props.open) return;
    if (hasUserMovedRef.current) return;
    const el = containerRef.current;
    if (!el) return;
    const parent = el.parentElement;
    if (!parent) return;
    const parentRect = parent.getBoundingClientRect();
    const rect = el.getBoundingClientRect();
    const desiredLeft = props.anchorX + 18;
    const desiredTop = props.anchorY + 18;
    const left = clamp(desiredLeft, 8, Math.max(8, parentRect.width - rect.width - 8));
    const top = clamp(desiredTop, 8, Math.max(8, parentRect.height - rect.height - 8));
    setPos({ left, top });
  }, [props.anchorX, props.anchorY, props.open, (_a = props.interaction) == null ? void 0 : _a.id]);
  reactExports.useEffect(() => {
    if (!props.open) return;
    hasUserMovedRef.current = false;
  }, [props.open, (_b = props.interaction) == null ? void 0 : _b.id]);
  reactExports.useEffect(() => {
    if (!isDragging) return;
    const onMove = (event) => {
      const el = containerRef.current;
      const drag = dragRef.current;
      if (!el || !drag) return;
      const parent = el.parentElement;
      if (!parent) return;
      const parentRect = parent.getBoundingClientRect();
      const rect = el.getBoundingClientRect();
      const dx = event.clientX - drag.startClientX;
      const dy = event.clientY - drag.startClientY;
      const nextLeft = drag.startLeft + dx;
      const nextTop = drag.startTop + dy;
      const left = clamp(nextLeft, 8, Math.max(8, parentRect.width - rect.width - 8));
      const top = clamp(nextTop, 8, Math.max(8, parentRect.height - rect.height - 8));
      hasUserMovedRef.current = true;
      setPos({ left, top });
    };
    const onUp = () => {
      setIsDragging(false);
      dragRef.current = null;
    };
    window.addEventListener("pointermove", onMove);
    window.addEventListener("pointerup", onUp, { once: true });
    return () => {
      window.removeEventListener("pointermove", onMove);
    };
  }, [isDragging]);
  if (!props.open || !props.interaction) return null;
  const availability = props.availability;
  const isBlocked = availability ? !availability.ok : false;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      ref: containerRef,
      onMouseDown: (event) => event.stopPropagation(),
      style: {
        position: "absolute",
        left: pos.left,
        top: pos.top,
        zIndex: 65,
        width: 300,
        maxWidth: "min(90vw, 360px)",
        background: "rgba(10, 10, 16, 0.92)",
        border: "1px solid rgba(255,255,255,0.14)",
        borderRadius: 12,
        padding: 12,
        boxShadow: "0 18px 60px rgba(0,0,0,0.55)",
        backdropFilter: "blur(8px)"
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            style: {
              display: "flex",
              justifyContent: "space-between",
              gap: 10,
              alignItems: "flex-start"
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "div",
                {
                  onPointerDown: (event) => {
                    if (event.button !== 0) return;
                    const el = containerRef.current;
                    if (!el) return;
                    event.preventDefault();
                    event.stopPropagation();
                    dragRef.current = {
                      startClientX: event.clientX,
                      startClientY: event.clientY,
                      startLeft: pos.left,
                      startTop: pos.top
                    };
                    setIsDragging(true);
                  },
                  style: {
                    minWidth: 0,
                    flex: "1 1 auto",
                    cursor: isDragging ? "grabbing" : "grab",
                    userSelect: "none"
                  },
                  title: "Glisser pour deplacer",
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 13, fontWeight: 900, color: "#fff" }, children: props.interaction.label }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", gap: 8, flexWrap: "wrap", marginTop: 6 }, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "span",
                        {
                          style: {
                            fontSize: 11,
                            padding: "2px 6px",
                            borderRadius: 6,
                            background: "#2c3e50",
                            color: "#fff",
                            fontWeight: 800
                          },
                          children: costLabel(props.interaction.cost)
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "span",
                        {
                          style: {
                            fontSize: 11,
                            padding: "2px 6px",
                            borderRadius: 6,
                            background: isBlocked ? "rgba(231,76,60,0.25)" : "rgba(46,204,113,0.18)",
                            border: `1px solid ${isBlocked ? "rgba(231,76,60,0.55)" : "rgba(46,204,113,0.45)"}`,
                            color: isBlocked ? "#ffb2aa" : "#bdf6d2",
                            fontWeight: 800
                          },
                          children: availability ? availability.ok ? "Disponible" : "Bloquee" : "Etat inconnu"
                        }
                      )
                    ] })
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  type: "button",
                  onClick: props.onClose,
                  style: {
                    width: 32,
                    height: 32,
                    borderRadius: 10,
                    border: "1px solid rgba(255,255,255,0.14)",
                    background: "rgba(255,255,255,0.06)",
                    color: "rgba(255,255,255,0.85)",
                    cursor: "pointer",
                    fontWeight: 900,
                    flex: "0 0 auto"
                  },
                  title: "Fermer",
                  children: "-"
                }
              )
            ]
          }
        ),
        props.interaction.forceDc !== void 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { marginTop: 10, fontSize: 12, color: "rgba(255,255,255,0.82)" }, children: [
          "Test de force: d20 + ",
          props.forceMod,
          " vs DD ",
          props.interaction.forceDc,
          "."
        ] }),
        availability && !availability.ok && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginTop: 10, fontSize: 12, color: "#ffb2aa" }, children: availability.reason || "Interaction indisponible." }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginTop: 12 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            type: "button",
            onClick: props.onExecute,
            disabled: Boolean(availability && !availability.ok),
            style: {
              padding: "6px 10px",
              borderRadius: 10,
              border: "1px solid rgba(255,255,255,0.12)",
              background: (availability == null ? void 0 : availability.ok) ? "#2ecc71" : "rgba(90, 90, 100, 0.55)",
              color: (availability == null ? void 0 : availability.ok) ? "#0b0b12" : "rgba(255,255,255,0.75)",
              cursor: (availability == null ? void 0 : availability.ok) ? "pointer" : "not-allowed",
              fontSize: 12,
              fontWeight: 900
            },
            children: "Executer"
          }
        ) })
      ]
    }
  );
}
const THEME_COLORS = {
  forest: 3107631,
  dungeon: 2763322,
  city: 5194291,
  generic: 1841961
};
function boardThemeColor(theme2) {
  return THEME_COLORS[theme2 ?? "generic"] ?? THEME_COLORS.generic;
}
function colorToCssHex(color) {
  return `#${Math.max(0, Math.min(16777215, color)).toString(16).padStart(6, "0")}`;
}
const DEFAULT_MOVEMENT_MODE_ID = "walk";
const MOVEMENT_MODE_CATALOG = {
  walk: {
    id: "walk",
    label: "Marcher",
    speed: 9,
    directions: 8,
    profile: {
      type: "ground",
      canPassThroughWalls: false,
      canPassThroughEntities: false,
      canStopOnOccupiedTile: false
    }
  },
  swim: {
    id: "swim",
    label: "Nager",
    speed: 4.5,
    directions: 8,
    profile: {
      type: "swim",
      canPassThroughWalls: false,
      canPassThroughEntities: false,
      canStopOnOccupiedTile: false
    }
  }
};
function getCatalogMode(id2) {
  return MOVEMENT_MODE_CATALOG[id2] ?? null;
}
function buildLabelFromId(id2) {
  if (!id2) return "Deplacement";
  return id2.charAt(0).toUpperCase() + id2.slice(1);
}
function getDefaultMovementMode() {
  return MOVEMENT_MODE_CATALOG[DEFAULT_MOVEMENT_MODE_ID];
}
function buildMovementProfileFromMode(mode) {
  var _a, _b, _c, _d;
  const fallback = getDefaultMovementMode();
  const source2 = mode ?? fallback;
  const profile = {
    type: ((_a = source2.profile) == null ? void 0 : _a.type) ?? "ground",
    speed: source2.speed,
    directions: source2.directions,
    canPassThroughWalls: ((_b = source2.profile) == null ? void 0 : _b.canPassThroughWalls) ?? false,
    canPassThroughEntities: ((_c = source2.profile) == null ? void 0 : _c.canPassThroughEntities) ?? false,
    canStopOnOccupiedTile: ((_d = source2.profile) == null ? void 0 : _d.canStopOnOccupiedTile) ?? false
  };
  return profile;
}
function getMovementModesForCharacter(character) {
  const raw = character.movementModes;
  if (Array.isArray(raw) && raw.length > 0) {
    const modes = [];
    for (const entry of raw) {
      if (typeof entry === "string") {
        const def = MOVEMENT_MODE_CATALOG[entry];
        if (def) {
          modes.push(def);
        }
        continue;
      }
      if (entry && typeof entry === "object") {
        const id2 = String(entry.id || entry.label || "custom");
        const label2 = String(entry.label || entry.id || "Deplacement");
        const speed2 = Number.isFinite(entry.speed) ? Math.max(1, Number(entry.speed)) : 9;
        const directions = entry.directions === 4 ? 4 : 8;
        modes.push({
          id: id2,
          label: label2,
          speed: speed2,
          directions,
          profile: entry.profile
        });
      }
    }
    if (modes.length > 0) return modes;
  }
  if (raw && typeof raw === "object" && !Array.isArray(raw)) {
    const modes = [];
    for (const [key2, value2] of Object.entries(raw)) {
      const speed2 = Number.isFinite(value2) ? Math.max(1, Number(value2)) : null;
      if (speed2 === null) continue;
      const catalogMode = getCatalogMode(key2);
      modes.push({
        id: key2,
        label: (catalogMode == null ? void 0 : catalogMode.label) ?? buildLabelFromId(key2),
        speed: speed2,
        directions: (catalogMode == null ? void 0 : catalogMode.directions) ?? 8,
        profile: catalogMode == null ? void 0 : catalogMode.profile
      });
    }
    if (modes.length > 0) return modes;
  }
  return [getDefaultMovementMode()];
}
function isMoveTypeAction(action2) {
  var _a;
  return Boolean(action2 && ((_a = action2.tags) == null ? void 0 : _a.includes("move-type")));
}
const pngModules = /* @__PURE__ */ Object.assign({});
const DECOR_PNG_BY_KEY = {};
for (const [path2, url] of Object.entries(pngModules)) {
  const file = path2.split("/").pop() ?? "";
  const baseName = file.replace(/\.png$/i, "");
  if (!baseName) continue;
  DECOR_PNG_BY_KEY[`decor:${baseName}`] = url;
}
const loadedDecorAliases = /* @__PURE__ */ new Set();
const pendingDecorAliases = /* @__PURE__ */ new Set();
async function preloadDecorTexturesFor(spriteKeys) {
  if (!Array.isArray(spriteKeys) || spriteKeys.length === 0) return;
  const assets = /* @__PURE__ */ new Map();
  for (const spriteKey of spriteKeys) {
    if (!spriteKey) continue;
    const url = DECOR_PNG_BY_KEY[spriteKey];
    if (!url) continue;
    if (loadedDecorAliases.has(spriteKey) || pendingDecorAliases.has(spriteKey)) continue;
    assets.set(spriteKey, { alias: spriteKey, src: url });
    pendingDecorAliases.add(spriteKey);
  }
  if (assets.size === 0) return;
  try {
    for (const asset of assets.values()) {
      Assets.add(asset);
    }
    const aliases = [...assets.keys()];
    await Assets.load(aliases);
    for (const alias of aliases) {
      loadedDecorAliases.add(alias);
      pendingDecorAliases.delete(alias);
    }
  } catch (error) {
    for (const alias of assets.keys()) {
      pendingDecorAliases.delete(alias);
    }
    throw error;
  }
}
const MOVE_TYPE_MODULES = {
  "./types/walk.json": walkMoveType,
  "./types/sprint.json": sprintMoveType
};
const ENEMY_TYPE_MODULES = {
  "./brute.json": bruteType,
  "./archer.json": archerType,
  "./assassin.json": assassinType,
  "./ghost.json": ghostType
};
const CORE_BASE_ACTION_IDS = [
  "melee-strike",
  "disengage",
  "dodge",
  "study",
  "hide",
  "influence",
  "observe",
  "help",
  "ready-action"
];
const WEAPON_CARRY_SLOTS = /* @__PURE__ */ new Set(["ceinture_gauche", "ceinture_droite", "dos_gauche", "dos_droit"]);
function buildCellKey(x2, y2) {
  return `${x2},${y2}`;
}
function getEquippedWeaponIds(character) {
  const inventory = Array.isArray(character == null ? void 0 : character.inventoryItems) ? character.inventoryItems : [];
  const equippedWeaponIds = inventory.filter(
    (item) => (item == null ? void 0 : item.type) === "weapon" && (item == null ? void 0 : item.equippedSlot) && WEAPON_CARRY_SLOTS.has(item.equippedSlot)
  ).map((item) => item.id).filter((value2) => typeof value2 === "string" && value2.length > 0);
  const primary = inventory.find(
    (item) => (item == null ? void 0 : item.type) === "weapon" && (item == null ? void 0 : item.isPrimaryWeapon) && (item == null ? void 0 : item.equippedSlot) && WEAPON_CARRY_SLOTS.has(item.equippedSlot)
  );
  if (primary == null ? void 0 : primary.id) {
    return Array.from(/* @__PURE__ */ new Set([primary.id, ...equippedWeaponIds]));
  }
  if (equippedWeaponIds.length > 0) {
    return Array.from(new Set(equippedWeaponIds));
  }
  return [];
}
function getPrimaryWeaponIds(character) {
  const inventory = Array.isArray(character == null ? void 0 : character.inventoryItems) ? character.inventoryItems : [];
  const primaryIds = inventory.filter(
    (item) => (item == null ? void 0 : item.type) === "weapon" && (item == null ? void 0 : item.isPrimaryWeapon) && (item == null ? void 0 : item.equippedSlot) && WEAPON_CARRY_SLOTS.has(item.equippedSlot)
  ).map((item) => item.id).filter((value2) => typeof value2 === "string" && value2.length > 0);
  return Array.from(new Set(primaryIds));
}
const ABILITY_CARAC_KEY = {
  FOR: "force",
  DEX: "dexterite",
  CON: "constitution",
  INT: "intelligence",
  SAG: "sagesse",
  CHA: "charisme"
};
const ABILITY_SCORE_KEY = {
  FOR: "FOR",
  DEX: "DEX",
  CON: "CON",
  INT: "INT",
  SAG: "SAG",
  CHA: "CHA"
};
function computeAbilityModFromScore(score) {
  if (!Number.isFinite(score)) return 0;
  return Math.floor((Number(score) - 10) / 2);
}
function getCharacterAbilityMod(character, ability) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
  const statMod = ability === "FOR" ? (_b = (_a = character.combatStats) == null ? void 0 : _a.mods) == null ? void 0 : _b.modFOR : ability === "DEX" ? (_d = (_c = character.combatStats) == null ? void 0 : _c.mods) == null ? void 0 : _d.modDEX : ability === "CON" ? (_f = (_e = character.combatStats) == null ? void 0 : _e.mods) == null ? void 0 : _f.modCON : ability === "INT" ? (_h = (_g = character.combatStats) == null ? void 0 : _g.mods) == null ? void 0 : _h.modINT : ability === "SAG" ? (_j = (_i = character.combatStats) == null ? void 0 : _i.mods) == null ? void 0 : _j.modSAG : (_l = (_k = character.combatStats) == null ? void 0 : _k.mods) == null ? void 0 : _l.modCHA;
  if (typeof statMod === "number" && Number.isFinite(statMod)) {
    return statMod;
  }
  const caracKey = ABILITY_CARAC_KEY[ability];
  const scoreKey = ABILITY_SCORE_KEY[ability];
  const score = (_n = (_m = character.caracs) == null ? void 0 : _m[caracKey]) == null ? void 0 : _n[scoreKey];
  return computeAbilityModFromScore(score);
}
function buildCombatStatsFromCharacter(character, armorItemsById) {
  var _a, _b, _c;
  const movementModes2 = getMovementModesForCharacter(character);
  const defaultSpeed = ((_a = movementModes2[0]) == null ? void 0 : _a.speed) ?? 3;
  const level2 = Number(((_b = character.combatStats) == null ? void 0 : _b.level) ?? character.niveauGlobal ?? 1) || 1;
  const mods = {
    modFOR: getCharacterAbilityMod(character, "FOR"),
    modDEX: getCharacterAbilityMod(character, "DEX"),
    modCON: getCharacterAbilityMod(character, "CON"),
    modINT: getCharacterAbilityMod(character, "INT"),
    modSAG: getCharacterAbilityMod(character, "SAG"),
    modCHA: getCharacterAbilityMod(character, "CHA")
  };
  const maxHp = Number(((_c = character.combatStats) == null ? void 0 : _c.maxHp) ?? character.pvActuels ?? 1) || 1;
  const armorClass = computeArmorClassFromEquipment(character, armorItemsById, mods.modDEX);
  const proficiencyBonus = getProficiencyBonusForLevel(level2);
  return {
    level: level2,
    mods,
    maxHp,
    armorClass,
    attackBonus: mods.modFOR + proficiencyBonus,
    moveRange: defaultSpeed,
    maxAttacksPerTurn: 1,
    resources: {}
  };
}
function getProficiencyBonusForLevel(levelRaw) {
  const level2 = Number(levelRaw) || 1;
  if (level2 <= 4) return 2;
  if (level2 <= 8) return 3;
  if (level2 <= 12) return 4;
  if (level2 <= 16) return 5;
  return 6;
}
function computeArmorClassFromEquipment(character, armorItemsById, dexMod) {
  const inventory = Array.isArray(character == null ? void 0 : character.inventoryItems) ? character.inventoryItems : [];
  const equippedArmor = inventory.filter(
    (item) => (item == null ? void 0 : item.type) === "armor" && (item == null ? void 0 : item.equippedSlot)
  );
  const base = 10 + dexMod;
  let armorBase = base;
  let shieldBonus = 0;
  for (const item of equippedArmor) {
    const def = armorItemsById.get(item.id);
    if (!def) continue;
    if (def.armorCategory === "shield") {
      shieldBonus = Math.max(shieldBonus, def.baseAC ?? 2);
      continue;
    }
    const baseAC2 = typeof def.baseAC === "number" ? def.baseAC : 10;
    const dexCap2 = def.dexCap === null || typeof def.dexCap === "undefined" ? dexMod : Math.max(0, Math.min(dexMod, def.dexCap));
    armorBase = Math.max(armorBase, baseAC2 + dexCap2);
  }
  return Math.max(1, armorBase + shieldBonus);
}
function loadEnemyTypesFromIndex() {
  const indexed = Array.isArray(enemyTypesIndex.types) ? enemyTypesIndex.types : [];
  const loaded = [];
  for (const path2 of indexed) {
    const mod = ENEMY_TYPE_MODULES[path2];
    if (mod) {
      loaded.push(mod);
    } else {
      console.warn("[enemy-types] Type path missing in bundle:", path2);
    }
  }
  if (loaded.length === 0) {
    console.warn("[enemy-types] No enemy types loaded from index.json");
  }
  return loaded;
}
function scaleDiceFormula(formula, multiplier) {
  if (!Number.isFinite(multiplier) || multiplier <= 0) return null;
  const cleaned = formula.replace(/\s+/g, "");
  const tokens = cleaned.split(/(?=[+-])/);
  const out2 = [];
  for (const raw of tokens) {
    if (!raw) continue;
    const sign2 = raw.startsWith("-") ? "-" : "";
    const token = raw.replace(/^[+-]/, "");
    const diceMatch = token.match(/^(\d*)d(\d+)$/i);
    if (diceMatch) {
      const count2 = diceMatch[1] ? Number.parseInt(diceMatch[1], 10) : 1;
      if (!Number.isFinite(count2)) return null;
      out2.push(`${sign2}${count2 * multiplier}d${diceMatch[2]}`);
      continue;
    }
    if (!Number.isNaN(Number.parseInt(token, 10))) {
      out2.push(`${sign2}${token}`);
      continue;
    }
    return null;
  }
  return out2.join("");
}
function resolveEnemyMovementSpeed(enemyType) {
  var _a, _b;
  const modes = enemyType.movementModes;
  if (modes && typeof modes === "object") {
    if (typeof modes.walk === "number" && Number.isFinite(modes.walk)) {
      return Math.max(1, modes.walk);
    }
    const first = Object.values(modes).find((value2) => Number.isFinite(value2));
    if (typeof first === "number") return Math.max(1, first);
  }
  if (typeof ((_a = enemyType.movement) == null ? void 0 : _a.speed) === "number") {
    return Math.max(1, enemyType.movement.speed);
  }
  if (typeof ((_b = enemyType.combatStats) == null ? void 0 : _b.moveRange) === "number") {
    return Math.max(1, enemyType.combatStats.moveRange);
  }
  return 3;
}
function resolveEnemyMovementProfile(enemyType, speed2) {
  if (enemyType.movement) {
    return { ...enemyType.movement, speed: speed2 };
  }
  return {
    type: "ground",
    speed: speed2,
    canPassThroughWalls: false,
    canPassThroughEntities: false,
    canStopOnOccupiedTile: false
  };
}
function createEnemy(index, enemyType, position) {
  const { x: x2, y: y2 } = position;
  const speed2 = resolveEnemyMovementSpeed(enemyType);
  const base = {
    ...enemyType.combatStats,
    moveRange: speed2
  };
  const movementProfile = resolveEnemyMovementProfile(enemyType, speed2);
  return {
    id: `enemy-${index + 1}`,
    type: "enemy",
    enemyTypeId: enemyType.id,
    enemyTypeLabel: enemyType.label,
    aiRole: enemyType.aiRole,
    actionIds: Array.isArray(enemyType.actions) ? enemyType.actions : null,
    reactionIds: Array.isArray(enemyType.reactionIds) ? enemyType.reactionIds : null,
    appearance: enemyType.appearance,
    speechProfile: enemyType.speechProfile ?? null,
    combatStats: base,
    spellcastingState: enemyType.spellcastingState,
    moveRange: base.moveRange,
    maxAttacksPerTurn: typeof base.maxAttacksPerTurn === "number" ? base.maxAttacksPerTurn : 1,
    armorClass: base.armorClass,
    movementProfile,
    facing: "left",
    visionProfile: enemyType.vision ? enemyType.vision : {
      shape: "cone",
      range: 100,
      apertureDeg: 180
    },
    footprint: enemyType.footprint,
    x: x2,
    y: y2,
    hp: base.maxHp,
    maxHp: base.maxHp
  };
}
function createSummon(params) {
  const enemyType = enemyTypeById.get(params.entityTypeId) ?? null;
  if (!enemyType) {
    pushLog(`Invocation echouee: type inconnu (${params.entityTypeId}).`);
    return null;
  }
  const summonBehavior = enemyType.summonBehavior ?? {};
  const controlMode = summonBehavior.controlMode ?? "auto";
  const turnTiming = summonBehavior.turnTiming ?? "after_player";
  const initiativeMode = summonBehavior.initiativeMode ?? "roll_on_spawn";
  const obeyChance = typeof summonBehavior.obeyChance === "number" ? summonBehavior.obeyChance : 1;
  const order = summonBehavior.order ?? { kind: "attack_nearest" };
  const speed2 = resolveEnemyMovementSpeed(enemyType);
  const base = {
    ...enemyType.combatStats,
    moveRange: speed2
  };
  const movementProfile = resolveEnemyMovementProfile(enemyType, speed2);
  const id2 = `summon-${summonCounterRef.current++}`;
  return {
    id: id2,
    type: params.ownerType,
    summonOwnerId: params.ownerId,
    summonOwnerType: params.ownerType,
    summonControlMode: controlMode,
    summonTurnTiming: turnTiming,
    summonInitiativeMode: initiativeMode,
    summonObeyChance: obeyChance,
    summonOrder: order,
    enemyTypeId: enemyType.id,
    enemyTypeLabel: enemyType.label,
    aiRole: enemyType.aiRole ?? "summon",
    actionIds: Array.isArray(enemyType.actions) ? enemyType.actions : null,
    reactionIds: Array.isArray(enemyType.reactionIds) ? enemyType.reactionIds : null,
    appearance: enemyType.appearance,
    speechProfile: enemyType.speechProfile ?? null,
    combatStats: base,
    moveRange: base.moveRange,
    maxAttacksPerTurn: typeof base.maxAttacksPerTurn === "number" ? base.maxAttacksPerTurn : 1,
    armorClass: base.armorClass,
    movementProfile,
    facing: params.ownerType === "enemy" ? "left" : "right",
    visionProfile: enemyType.vision ? enemyType.vision : {
      shape: "cone",
      range: 100,
      apertureDeg: 180
    },
    footprint: enemyType.footprint,
    x: params.x,
    y: params.y,
    hp: base.maxHp,
    maxHp: base.maxHp
  };
}
const PLAYER_TORCH_RADIUS = 4;
function collectSpellActionIds(character) {
  var _a, _b, _c;
  const ids = /* @__PURE__ */ new Set();
  const state = character.spellcastingState;
  const spellGrants = (state == null ? void 0 : state.spellGrants) ?? {};
  for (const entries of Object.values(spellGrants)) {
    if (!Array.isArray(entries)) continue;
    for (const entry of entries) {
      const id2 = typeof (entry == null ? void 0 : entry.spellId) === "string" ? String(entry.spellId) : "";
      if (id2) ids.add(id2);
    }
  }
  const sources2 = (state == null ? void 0 : state.sources) ?? {};
  for (const source2 of Object.values(sources2)) {
    const prepared = Array.isArray(source2.preparedSpellIds) ? source2.preparedSpellIds : [];
    const known = Array.isArray(source2.knownSpellIds) ? source2.knownSpellIds : [];
    const granted = Array.isArray(source2.grantedSpellIds) ? source2.grantedSpellIds : [];
    for (const id2 of [...prepared, ...known, ...granted]) {
      if (id2) ids.add(id2);
    }
  }
  const derivedGrants = (_b = (_a = character == null ? void 0 : character.derived) == null ? void 0 : _a.grants) == null ? void 0 : _b.spells;
  if (Array.isArray(derivedGrants)) {
    for (const id2 of derivedGrants) {
      if (id2) ids.add(id2);
    }
  }
  const spellSelections = (_c = character == null ? void 0 : character.choiceSelections) == null ? void 0 : _c.spellcasting;
  if (spellSelections && typeof spellSelections === "object") {
    for (const entry of Object.values(spellSelections)) {
      const granted = Array.isArray(entry == null ? void 0 : entry.grantedSpells) ? entry.grantedSpells : [];
      const prepared = Array.isArray(entry == null ? void 0 : entry.preparedSpells) ? entry.preparedSpells : [];
      const known = Array.isArray(entry == null ? void 0 : entry.knownSpells) ? entry.knownSpells : [];
      for (const spell of [...granted, ...prepared, ...known]) {
        const id2 = typeof spell === "string" ? spell : spell == null ? void 0 : spell.id;
        if (id2) ids.add(id2);
      }
    }
  }
  return Array.from(ids);
}
const GameBoard = () => {
  var _a, _b, _c;
  const pixiContainerRef = reactExports.useRef(null);
  const narrationPendingRef = reactExports.useRef(false);
  const narrationOpenRef = reactExports.useRef(false);
  const narrationIdRef = reactExports.useRef(1);
  const playerBubbleTimeoutRef = reactExports.useRef(null);
  const playerThoughtRef = reactExports.useRef(null);
  const playerBubbleOverrideRef = reactExports.useRef(false);
  const [characterConfig, setCharacterConfig] = reactExports.useState(
    () => JSON.parse(JSON.stringify(sampleCharacter))
  );
  const [combatCharacterConfig, setCombatCharacterConfig] = reactExports.useState(null);
  const activeCharacterConfig = combatCharacterConfig ?? characterConfig;
  const movementModes2 = reactExports.useMemo(
    () => getMovementModesForCharacter(activeCharacterConfig),
    [activeCharacterConfig]
  );
  const defaultMovementMode = movementModes2[0] ?? getDefaultMovementMode();
  const defaultMovementProfile = reactExports.useMemo(
    () => buildMovementProfileFromMode(defaultMovementMode),
    [defaultMovementMode]
  );
  const [armorItems, setArmorItems] = reactExports.useState([]);
  const [actionsCatalog, setActionsCatalog] = reactExports.useState([]);
  const armorItemsById = reactExports.useMemo(() => {
    const map = /* @__PURE__ */ new Map();
    for (const item of armorItems) {
      if (!(item == null ? void 0 : item.id)) continue;
      map.set(item.id, item);
    }
    return map;
  }, [armorItems]);
  const weaponMasteryActions = reactExports.useMemo(
    () => actionsCatalog.filter(
      (action2) => Array.isArray(action2.tags) && action2.tags.includes("weaponMastery")
    ),
    [actionsCatalog]
  );
  const weaponMasteryIds = reactExports.useMemo(
    () => weaponMasteryActions.map((action2) => {
      const id2 = typeof action2.id === "string" && action2.id.startsWith("wm-") ? action2.id.slice("wm-".length) : null;
      if (id2) return id2;
      const tags2 = Array.isArray(action2.tags) ? action2.tags : [];
      const candidate = tags2.find(
        (tag) => tag !== "weaponMastery" && !tag.startsWith("wm-trigger:")
      );
      return candidate ?? null;
    }).filter((id2) => Boolean(id2)),
    [weaponMasteryActions]
  );
  const [featureTypes, setFeatureTypes] = reactExports.useState([]);
  const runtimeFeatureTypes = reactExports.useMemo(
    () => featureTypes.length > 0 ? featureTypes : loadFeatureTypesFromIndex(),
    [featureTypes]
  );
  const runtimeFeatureById = reactExports.useMemo(() => {
    const map = /* @__PURE__ */ new Map();
    runtimeFeatureTypes.forEach((def) => {
      if (def == null ? void 0 : def.id) map.set(String(def.id), def);
    });
    return map;
  }, [runtimeFeatureTypes]);
  const activePlayerFeatureIds = reactExports.useMemo(() => {
    var _a2, _b2;
    const ids = ((_b2 = (_a2 = activeCharacterConfig == null ? void 0 : activeCharacterConfig.derived) == null ? void 0 : _a2.grants) == null ? void 0 : _b2.features) ?? [];
    return Array.isArray(ids) ? ids.map((id2) => String(id2)).filter(Boolean) : [];
  }, [activeCharacterConfig]);
  const activePlayerFeatures = reactExports.useMemo(
    () => activePlayerFeatureIds.map((id2) => runtimeFeatureById.get(id2) ?? null).filter((feature) => Boolean(feature)),
    [activePlayerFeatureIds, runtimeFeatureById]
  );
  const playerEquipmentPolicy = reactExports.useMemo(
    () => resolveEquipmentRuntimePolicy({ features: activePlayerFeatures }),
    [activePlayerFeatures]
  );
  const baseCombatStats = reactExports.useMemo(
    () => {
      const built = buildCombatStatsFromCharacter(activeCharacterConfig, armorItemsById);
      const merged = !activeCharacterConfig.combatStats ? built : {
        ...built,
        ...activeCharacterConfig.combatStats,
        armorClass: built.armorClass
      };
      const weaponById = /* @__PURE__ */ new Map();
      loadWeaponTypesFromIndex().forEach((def) => {
        if (def == null ? void 0 : def.id) weaponById.set(def.id, def);
      });
      const objectById = /* @__PURE__ */ new Map();
      loadObjectItemsFromIndex().forEach((def) => {
        if (def == null ? void 0 : def.id) objectById.set(def.id, def);
      });
      const bonusById = /* @__PURE__ */ new Map();
      loadBonusTypesFromIndex().forEach((def) => {
        if (def == null ? void 0 : def.id) bonusById.set(def.id, def);
      });
      const equipmentStats = applyEquipmentBonusesToCombatStats({
        character: activeCharacterConfig,
        baseStats: merged,
        weaponById,
        armorById: armorItemsById,
        objectById,
        bonusById
      }).stats;
      return applyFeatureCombatStatModifiers(
        {
          id: activeCharacterConfig.id ?? "player-1",
          type: "player"
        },
        equipmentStats
      );
    },
    [activeCharacterConfig, armorItemsById, activePlayerFeatures]
  );
  const playerCombatStats = reactExports.useMemo(
    () => {
      const profs = activeCharacterConfig.proficiencies ?? {};
      const rawMasteries = Array.isArray(activeCharacterConfig == null ? void 0 : activeCharacterConfig.weaponMasteries) ? (activeCharacterConfig == null ? void 0 : activeCharacterConfig.weaponMasteries).map((id2) => String(id2)).filter(Boolean) : Array.isArray(profs.weapons) ? profs.weapons : [];
      const masterySet = new Set(weaponMasteryIds);
      const weaponMasteries = rawMasteries.filter((id2) => masterySet.has(id2));
      const wmTags = weaponMasteries.map((id2) => `wm:${id2}`);
      const baseTags = Array.isArray(baseCombatStats.tags) ? baseCombatStats.tags : [];
      const tags2 = Array.from(/* @__PURE__ */ new Set([...baseTags, ...wmTags]));
      return {
        ...baseCombatStats,
        moveRange: defaultMovementProfile.speed,
        maxHp: baseCombatStats.maxHp,
        actionsPerTurn: baseCombatStats.actionsPerTurn ?? 1,
        bonusActionsPerTurn: baseCombatStats.bonusActionsPerTurn ?? 1,
        actionRules: baseCombatStats.actionRules ?? { forbidSecondAttack: true },
        tags: tags2
      };
    },
    [baseCombatStats, defaultMovementProfile.speed, activeCharacterConfig, weaponMasteryIds]
  );
  const defaultPlayerVisionProfile = reactExports.useMemo(
    () => activeCharacterConfig.visionProfile ?? {
      shape: "cone",
      range: 100,
      apertureDeg: 180,
      lightVision: "normal"
    },
    [activeCharacterConfig]
  );
  const [log2, setLog] = reactExports.useState([]);
  const [narrationEntries, setNarrationEntries] = reactExports.useState([]);
  const [narrationUnread, setNarrationUnread] = reactExports.useState(0);
  const [isNarrationOpen, setIsNarrationOpen] = reactExports.useState(false);
  const [speechBubbles, setSpeechBubbles] = reactExports.useState([]);
  const [player, setPlayer] = reactExports.useState({
    id: "player-1",
    type: "player",
    appearance: activeCharacterConfig.appearance,
    actionIds: Array.isArray(activeCharacterConfig.actionIds) ? activeCharacterConfig.actionIds : [],
    reactionIds: Array.isArray(activeCharacterConfig.reactionIds) ? activeCharacterConfig.reactionIds : [],
    x: 0,
    y: Math.floor(GRID_ROWS / 2),
    facing: "right",
    movementProfile: defaultMovementProfile,
    moveRange: playerCombatStats.moveRange,
    visionProfile: defaultPlayerVisionProfile,
    combatStats: playerCombatStats,
    spellcastingState: activeCharacterConfig.spellcastingState,
    maxAttacksPerTurn: playerCombatStats.maxAttacksPerTurn,
    hp: activeCharacterConfig.pvActuels,
    maxHp: playerCombatStats.maxHp
  });
  const [enemyTypes, setEnemyTypes] = reactExports.useState([]);
  const [enemies, setEnemies] = reactExports.useState([]);
  const [obstacleTypes, setObstacleTypes] = reactExports.useState([]);
  const [obstacles, setObstacles] = reactExports.useState([]);
  const [effectTypes, setEffectTypes] = reactExports.useState([]);
  const [effects, setEffects] = reactExports.useState([]);
  const [actionEffects, setActionEffects] = reactExports.useState([]);
  const [statusTypes, setStatusTypes] = reactExports.useState([]);
  const [wallTypes, setWallTypes] = reactExports.useState([]);
  const [wallSegments, setWallSegments] = reactExports.useState([]);
  const [decorations, setDecorations] = reactExports.useState([]);
  const [playableCells, setPlayableCells] = reactExports.useState(null);
  const [mapTerrain, setMapTerrain] = reactExports.useState([]);
  const [mapHeight, setMapHeight] = reactExports.useState([]);
  const [mapLight, setMapLight] = reactExports.useState([]);
  const [roofOpenCells, setRoofOpenCells] = reactExports.useState(null);
  const [mapGrid, setMapGrid] = reactExports.useState({
    cols: GRID_COLS,
    rows: GRID_ROWS
  });
  const [mapTheme, setMapTheme] = reactExports.useState("generic");
  const [mapPaletteId, setMapPaletteId] = reactExports.useState(null);
  const [activeLevel, setActiveLevel] = reactExports.useState(0);
  const [phase, setPhase] = reactExports.useState("player");
  const [round2, setRound] = reactExports.useState(1);
  const [isResolvingEnemies, setIsResolvingEnemies] = reactExports.useState(false);
  const [hasRolledInitiative, setHasRolledInitiative] = reactExports.useState(false);
  const [playerInitiative, setPlayerInitiative] = reactExports.useState(null);
  const [playerInitiativeRoll, setPlayerInitiativeRoll] = reactExports.useState(null);
  const [playerInitiativeMod, setPlayerInitiativeMod] = reactExports.useState(null);
  const [turnOrder, setTurnOrder] = reactExports.useState([]);
  const [currentTurnIndex, setCurrentTurnIndex] = reactExports.useState(0);
  const [turnTick, setTurnTick] = reactExports.useState(0);
  const [isCombatConfigured, setIsCombatConfigured] = reactExports.useState(false);
  const [configEnemyCount, setConfigEnemyCount] = reactExports.useState(3);
  const [mapPrompt, setMapPrompt] = reactExports.useState("");
  reactExports.useEffect(() => {
    if (isCombatConfigured) return;
    setPlayer((prev) => ({
      ...prev,
      appearance: activeCharacterConfig.appearance,
      actionIds: Array.isArray(activeCharacterConfig.actionIds) ? activeCharacterConfig.actionIds : [],
      reactionIds: Array.isArray(activeCharacterConfig.reactionIds) ? activeCharacterConfig.reactionIds : [],
      movementProfile: defaultMovementProfile,
      moveRange: playerCombatStats.moveRange,
      visionProfile: defaultPlayerVisionProfile,
      combatStats: playerCombatStats,
      spellcastingState: activeCharacterConfig.spellcastingState,
      maxAttacksPerTurn: playerCombatStats.maxAttacksPerTurn,
      hp: activeCharacterConfig.pvActuels,
      maxHp: playerCombatStats.maxHp
    }));
  }, [
    activeCharacterConfig,
    defaultMovementProfile,
    defaultPlayerVisionProfile,
    playerCombatStats,
    isCombatConfigured
  ]);
  const ZOOM_MIN = 0.5;
  const ZOOM_MAX = 4;
  const ZOOM_STEP = 0.1;
  const DEFAULT_ZOOM = 1.5;
  const [boardZoom, setBoardZoom] = reactExports.useState(DEFAULT_ZOOM);
  const [boardPan, setBoardPan] = reactExports.useState({ x: 0, y: 0 });
  const [isPanningBoard, setIsPanningBoard] = reactExports.useState(false);
  const panDragRef = reactExports.useRef(null);
  const BOARD_FPS_IDLE = 8;
  const BOARD_FPS_ACTIVE = 20;
  const [renderTick, setRenderTick] = reactExports.useState(0);
  const boardBackgroundColor = boardThemeColor(mapTheme);
  const [actions2, setActions] = reactExports.useState([]);
  const [moveTypes2, setMoveTypes] = reactExports.useState([]);
  const [weaponTypes, setWeaponTypes] = reactExports.useState([]);
  const [raceTypes, setRaceTypes] = reactExports.useState([]);
  const [classTypes, setClassTypes] = reactExports.useState([]);
  const [subclassTypes, setSubclassTypes] = reactExports.useState([]);
  const [backgroundTypes, setBackgroundTypes] = reactExports.useState([]);
  const [languageTypes, setLanguageTypes] = reactExports.useState([]);
  const [toolItems, setToolItems] = reactExports.useState([]);
  const [objectItems, setObjectItems] = reactExports.useState([]);
  const [ammoItems, setAmmoItems] = reactExports.useState([]);
  const [reactionCatalog, setReactionCatalog] = reactExports.useState([]);
  const [reactionQueue, setReactionQueue] = reactExports.useState([]);
  const [reactionUsage, setReactionUsage] = reactExports.useState({});
  const [reactionCombatUsage, setReactionCombatUsage] = reactExports.useState({});
  const [killerInstinctTargetId, setKillerInstinctTargetId] = reactExports.useState(null);
  const [selectedActionId, setSelectedActionId] = reactExports.useState(null);
  const [selectedSpellSourceBySpellId, setSelectedSpellSourceBySpellId] = reactExports.useState({});
  const itemLabelMap = reactExports.useMemo(() => {
    const map = {};
    for (const weapon of weaponTypes) {
      if (weapon == null ? void 0 : weapon.id) map[weapon.id] = weapon.name ?? weapon.id;
    }
    for (const armor of armorItems) {
      if (armor == null ? void 0 : armor.id) map[armor.id] = armor.label ?? armor.id;
    }
    for (const obj of objectItems) {
      if (obj == null ? void 0 : obj.id) map[obj.id] = obj.label ?? obj.id;
    }
    for (const ammo of ammoItems) {
      if (ammo == null ? void 0 : ammo.id) map[ammo.id] = ammo.label ?? ammo.name ?? ammo.id;
    }
    for (const tool of toolItems) {
      if (tool == null ? void 0 : tool.id) map[tool.id] = tool.label ?? tool.id;
    }
    return map;
  }, [weaponTypes, armorItems, objectItems, ammoItems, toolItems]);
  const [validatedActionId, setValidatedActionId] = reactExports.useState(null);
  const [advantageMode, setAdvantageMode] = reactExports.useState("normal");
  const [attackRoll, setAttackRoll] = reactExports.useState(null);
  const [damageRoll, setDamageRoll] = reactExports.useState(null);
  const [attackOutcome, setAttackOutcome] = reactExports.useState(null);
  const [diceLogs, setDiceLogs] = reactExports.useState([]);
  const [pendingHazardRoll, setPendingHazardRoll] = reactExports.useState(null);
  const [hazardResolution, setHazardResolution] = reactExports.useState(null);
  const [hasRolledAttackForCurrentAction, setHasRolledAttackForCurrentAction] = reactExports.useState(false);
  const [turnActionUsage, setTurnActionUsage] = reactExports.useState({ usedActionCount: 0, usedBonusCount: 0 });
  const [turnEquipmentUsage, setTurnEquipmentUsage] = reactExports.useState({ usedInteractionCount: 0 });
  const [actionUsageCounts, setActionUsageCounts] = reactExports.useState({ turn: {}, encounter: {} });
  const [actionUsageByActor, setActionUsageByActor] = reactExports.useState({});
  const [actionContextOpen, setActionContextOpen] = reactExports.useState(false);
  const suppressBoardClickUntilRef = reactExports.useRef(0);
  const [playerResources, setPlayerResources] = reactExports.useState({});
  const [pathLimit, setPathLimit] = reactExports.useState(
    metersToCells(defaultMovementProfile.speed)
  );
  const [basePathLimit, setBasePathLimit] = reactExports.useState(
    metersToCells(defaultMovementProfile.speed)
  );
  const [movementSpent, setMovementSpent] = reactExports.useState(0);
  const [activeMovementModeId, setActiveMovementModeId] = reactExports.useState(
    defaultMovementMode.id
  );
  const [selectedPath, setSelectedPath] = reactExports.useState(
    []
  );
  const [selectedTargetIds, setSelectedTargetIds] = reactExports.useState([]);
  const [selectedObstacleTarget, setSelectedObstacleTarget] = reactExports.useState(null);
  const [selectedWallTarget, setSelectedWallTarget] = reactExports.useState(null);
  const [targetMode, setTargetMode] = reactExports.useState("none");
  const [interactionMode, setInteractionMode] = reactExports.useState("idle");
  const [interactionContext, setInteractionContext] = reactExports.useState(null);
  const [interactionMenuItems, setInteractionMenuItems] = reactExports.useState([]);
  const [revealedEnemyIds, setRevealedEnemyIds] = reactExports.useState(
    () => /* @__PURE__ */ new Set()
  );
  const [revealedCells, setRevealedCells] = reactExports.useState(
    () => /* @__PURE__ */ new Set()
  );
  const [radialMenu, setRadialMenu] = reactExports.useState({
    cell: null,
    token: null
  });
  const [actionContext, setActionContext] = reactExports.useState(null);
  const [sheetOpen, setSheetOpen] = reactExports.useState(false);
  const [hazardAnchor, setHazardAnchor] = reactExports.useState(
    null
  );
  const actionLabelById = reactExports.useMemo(() => {
    var _a2;
    const map = /* @__PURE__ */ new Map();
    for (const action2 of actionsCatalog) map.set(action2.id, action2.name);
    for (const action2 of moveTypes2) map.set(action2.id, action2.name);
    for (const reaction of reactionCatalog) {
      if ((_a2 = reaction == null ? void 0 : reaction.action) == null ? void 0 : _a2.id) {
        map.set(reaction.action.id, reaction.action.name);
      }
    }
    return map;
  }, [actionsCatalog, moveTypes2, reactionCatalog]);
  const actionUsageDebug = reactExports.useMemo(() => {
    const tokenById = /* @__PURE__ */ new Map();
    for (const token of [player, ...enemies]) tokenById.set(token.id, token);
    const entries = [];
    for (const [actorId, usage2] of Object.entries(actionUsageByActor)) {
      const turn = (usage2 == null ? void 0 : usage2.turn) ?? {};
      const combat = (usage2 == null ? void 0 : usage2.combat) ?? {};
      const actionIds2 = /* @__PURE__ */ new Set([
        ...Object.keys(turn),
        ...Object.keys(combat)
      ]);
      const actions22 = Array.from(actionIds2).map((id2) => ({
        id: id2,
        label: actionLabelById.get(id2) ?? id2,
        turn: Math.max(0, Number(turn[id2] ?? 0)),
        combat: Math.max(0, Number(combat[id2] ?? 0))
      })).filter((item) => item.turn > 0 || item.combat > 0).sort((a2, b2) => a2.label.localeCompare(b2.label));
      if (actions22.length === 0) continue;
      const token = tokenById.get(actorId);
      const actorLabel = token ? token.type === "player" ? "Joueur" : token.id : actorId;
      entries.push({ actorId, actorLabel, actions: actions22 });
    }
    return entries;
  }, [actionUsageByActor, actionLabelById, player, enemies]);
  const [effectSpecs, setEffectSpecs] = reactExports.useState([]);
  const [showVisionDebug, setShowVisionDebug] = reactExports.useState(false);
  const [showLightOverlay, setShowLightOverlay] = reactExports.useState(true);
  const [showFogSegments, setShowFogSegments] = reactExports.useState(false);
  const [showAllLevels, setShowAllLevels] = reactExports.useState(false);
  const [playerTorchOn, setPlayerTorchOn] = reactExports.useState(false);
  const [showCellIds, setShowCellIds] = reactExports.useState(false);
  const [showTerrainIds, setShowTerrainIds] = reactExports.useState(false);
  const [showTerrainContours, setShowTerrainContours] = reactExports.useState(false);
  const [showGridLines, setShowGridLines] = reactExports.useState(false);
  const [shadowLightAngleDeg, setShadowLightAngleDeg] = reactExports.useState(90);
  const [bumpIntensity, setBumpIntensity] = reactExports.useState(0.45);
  const [windSpeed, setWindSpeed] = reactExports.useState(0.06);
  const [windStrength, setWindStrength] = reactExports.useState(1);
  const [bumpDebug, setBumpDebug] = reactExports.useState(false);
  const [floatingPanel, setFloatingPanel] = reactExports.useState(null);
  const textureLoadingCounterRef = reactExports.useRef(0);
  const [isTextureLoading, setIsTextureLoading] = reactExports.useState(false);
  const [textureLoadingHint, setTextureLoadingHint] = reactExports.useState(null);
  const actionEffectTimersRef = reactExports.useRef(/* @__PURE__ */ new Map());
  const lastActionVfxKeyRef = reactExports.useRef(null);
  const actionCycleIdRef = reactExports.useRef(0);
  const contextCompleteRef = reactExports.useRef(false);
  const seenTargetsByActorRef = reactExports.useRef(/* @__PURE__ */ new Map());
  const enemyTurnPauseRef = reactExports.useRef(null);
  reactExports.useRef(1);
  const [hpPopups, setHpPopups] = reactExports.useState([]);
  const prevPlayerHpRef = reactExports.useRef(null);
  const prevEnemyHpRef = reactExports.useRef(/* @__PURE__ */ new Map());
  const [reactionToast, setReactionToast] = reactExports.useState(null);
  const reactionToastTimerRef = reactExports.useRef(null);
  const enemyMemoryRef = reactExports.useRef(/* @__PURE__ */ new Map());
  const teamAlertRef = reactExports.useRef(null);
  const [combatToast, setCombatToast] = reactExports.useState(null);
  const combatToastTimerRef = reactExports.useRef(null);
  const suppressCombatToastUntilRef = reactExports.useRef(0);
  const [aiLastState, setAiLastState] = reactExports.useState(null);
  const [aiLastDecisions, setAiLastDecisions] = reactExports.useState(null);
  const [aiLastIntents, setAiLastIntents] = reactExports.useState(null);
  const [aiLastError, setAiLastError] = reactExports.useState(null);
  const [aiUsedFallback, setAiUsedFallback] = reactExports.useState(false);
  const [isGameOver, setIsGameOver] = reactExports.useState(false);
  reactExports.useEffect(() => {
    return () => {
      for (const timer of actionEffectTimersRef.current.values()) {
        window.clearTimeout(timer);
      }
      actionEffectTimersRef.current.clear();
    };
  }, []);
  reactExports.useEffect(() => {
    narrationOpenRef.current = isNarrationOpen;
    if (isNarrationOpen) setNarrationUnread(0);
  }, [isNarrationOpen]);
  const obstacleBlocking = reactExports.useMemo(() => {
    const obstacleSets = buildObstacleBlockingSets(obstacleTypes, obstacles);
    return {
      movement: /* @__PURE__ */ new Set([...obstacleSets.movement]),
      vision: /* @__PURE__ */ new Set([...obstacleSets.vision]),
      attacks: /* @__PURE__ */ new Set([...obstacleSets.attacks]),
      occupied: /* @__PURE__ */ new Set([...obstacleSets.occupied])
    };
  }, [obstacleTypes, obstacles]);
  const wallEdges = reactExports.useMemo(
    () => buildWallEdgeSets(wallSegments),
    [wallSegments]
  );
  const reactionById = reactExports.useMemo(
    () => new Map(reactionCatalog.map((reaction) => [reaction.id, reaction])),
    [reactionCatalog]
  );
  const reactionActionById = reactExports.useMemo(
    () => new Map(reactionCatalog.map((reaction) => [reaction.action.id, reaction.action])),
    [reactionCatalog]
  );
  const actionCatalogById = reactExports.useMemo(() => {
    const map = /* @__PURE__ */ new Map();
    for (const action2 of actionsCatalog) map.set(action2.id, action2);
    return map;
  }, [actionsCatalog]);
  const actionInfoById = reactExports.useMemo(() => {
    const map = new Map(actionCatalogById);
    for (const [id2, action2] of reactionActionById) {
      map.set(id2, action2);
    }
    return map;
  }, [actionCatalogById, reactionActionById]);
  const enemyTypeById2 = reactExports.useMemo(() => {
    const map = /* @__PURE__ */ new Map();
    for (const t2 of enemyTypes) map.set(t2.id, t2);
    return map;
  }, [enemyTypes]);
  const closedCells = reactExports.useMemo(() => {
    if (!wallSegments.length) return null;
    return computeClosedCells({
      cols: mapGrid.cols,
      rows: mapGrid.rows,
      playableCells: playableCells ?? null,
      walls: wallSegments
    });
  }, [mapGrid, playableCells, wallSegments]);
  const obstacleTypeById = reactExports.useMemo(() => {
    const map = /* @__PURE__ */ new Map();
    for (const t2 of obstacleTypes) map.set(t2.id, t2);
    return map;
  }, [obstacleTypes]);
  const effectTypeById = reactExports.useMemo(() => {
    const map = /* @__PURE__ */ new Map();
    for (const t2 of effectTypes) map.set(t2.id, t2);
    return map;
  }, [effectTypes]);
  const weaponTypeById = reactExports.useMemo(() => {
    const map = /* @__PURE__ */ new Map();
    for (const t2 of weaponTypes) map.set(t2.id, t2);
    return map;
  }, [weaponTypes]);
  const weaponActionById = reactExports.useMemo(() => {
    var _a2;
    const map = /* @__PURE__ */ new Map();
    for (const weapon of weaponTypes) {
      const actionId = (_a2 = weapon.links) == null ? void 0 : _a2.actionId;
      if (!actionId) continue;
      const action2 = actionCatalogById.get(actionId);
      if (action2) map.set(weapon.id, action2);
    }
    return map;
  }, [weaponTypes, actionCatalogById]);
  const statusTypeById = reactExports.useMemo(() => {
    const map = /* @__PURE__ */ new Map();
    for (const t2 of statusTypes) map.set(t2.id, t2);
    return map;
  }, [statusTypes]);
  const wallTypeById = reactExports.useMemo(() => {
    const map = /* @__PURE__ */ new Map();
    for (const t2 of wallTypes) map.set(t2.id, t2);
    return map;
  }, [wallTypes]);
  const equippedWeaponIds = reactExports.useMemo(() => getEquippedWeaponIds(activeCharacterConfig), [
    activeCharacterConfig
  ]);
  const primaryWeaponIds = reactExports.useMemo(() => getPrimaryWeaponIds(activeCharacterConfig), [
    activeCharacterConfig
  ]);
  const equippedWeapons = reactExports.useMemo(
    () => equippedWeaponIds.map((id2) => weaponTypeById.get(id2) ?? null).filter((weapon) => Boolean(weapon)),
    [equippedWeaponIds, weaponTypeById]
  );
  const primaryWeapons = reactExports.useMemo(
    () => primaryWeaponIds.map((id2) => weaponTypeById.get(id2) ?? null).filter((weapon) => Boolean(weapon)),
    [primaryWeaponIds, weaponTypeById]
  );
  const equipmentAppliedBonuses = reactExports.useMemo(() => {
    const built = buildCombatStatsFromCharacter(activeCharacterConfig, armorItemsById);
    const merged = !activeCharacterConfig.combatStats ? built : {
      ...built,
      ...activeCharacterConfig.combatStats,
      armorClass: built.armorClass
    };
    const objectById = /* @__PURE__ */ new Map();
    objectItems.forEach((def) => {
      if (def == null ? void 0 : def.id) objectById.set(def.id, def);
    });
    const bonusById = /* @__PURE__ */ new Map();
    loadBonusTypesFromIndex().forEach((def) => {
      if (def == null ? void 0 : def.id) bonusById.set(def.id, def);
    });
    return applyEquipmentBonusesToCombatStats({
      character: activeCharacterConfig,
      baseStats: merged,
      weaponById: weaponTypeById,
      armorById: armorItemsById,
      objectById,
      bonusById
    }).applied;
  }, [activeCharacterConfig, armorItemsById, objectItems, weaponTypeById]);
  const floorMaterialById = reactExports.useMemo(() => {
    const map = /* @__PURE__ */ new Map();
    for (const t2 of FLOOR_MATERIALS) map.set(t2.id, t2);
    return map;
  }, []);
  const resolveAnchoredEffects = reactExports.useCallback(
    (list) => {
      if (!list.length) return list;
      const tokenById = /* @__PURE__ */ new Map();
      tokenById.set(player.id, player);
      for (const enemy of enemies) tokenById.set(enemy.id, enemy);
      let touched = false;
      const resolved = list.map((effect) => {
        if (effect.kind !== "aura" || !effect.anchorTokenId) return effect;
        const token = tokenById.get(effect.anchorTokenId);
        if (!token) return effect;
        if (effect.x === token.x && effect.y === token.y) return effect;
        touched = true;
        return { ...effect, x: token.x, y: token.y };
      });
      return touched ? resolved : list;
    },
    [player, enemies]
  );
  const resolvedEffects = reactExports.useMemo(
    () => resolveAnchoredEffects(effects),
    [effects, resolveAnchoredEffects]
  );
  const hasAnimatedSprites = reactExports.useMemo(() => {
    var _a2;
    if (!isCombatConfigured) return false;
    for (const effect of resolvedEffects) {
      const def = effectTypeById.get(effect.typeId);
      const key2 = (_a2 = def == null ? void 0 : def.appearance) == null ? void 0 : _a2.spriteKey;
      if (key2 && key2.startsWith("effect:")) return true;
    }
    for (const obstacle of obstacles) {
      const def = obstacleTypeById.get(obstacle.typeId) ?? null;
      const appearance2 = (def == null ? void 0 : def.appearance) ?? null;
      if ((appearance2 == null ? void 0 : appearance2.spriteKey) && appearance2.spriteKey.startsWith("effect:")) return true;
      for (const layer of (appearance2 == null ? void 0 : appearance2.layers) ?? []) {
        if ((layer == null ? void 0 : layer.spriteKey) && layer.spriteKey.startsWith("effect:")) return true;
      }
    }
    return false;
  }, [effectTypeById, isCombatConfigured, obstacles, obstacleTypeById, resolvedEffects]);
  const isBoardIdle = reactExports.useMemo(() => {
    if (!isCombatConfigured) return true;
    if (isResolvingEnemies) return false;
    if (isPanningBoard) return false;
    if (interactionMode !== "idle") return false;
    if (selectedPath.length > 0) return false;
    if (actionContext) return false;
    if (interactionContext) return false;
    if (pendingHazardRoll) return false;
    if (radialMenu.cell || radialMenu.token) return false;
    return true;
  }, [
    isCombatConfigured,
    isResolvingEnemies,
    isPanningBoard,
    interactionMode,
    selectedPath.length,
    actionContext,
    interactionContext,
    pendingHazardRoll,
    radialMenu.cell,
    radialMenu.token
  ]);
  const hasAnyInteractionSource = reactExports.useMemo(() => {
    const wallHas = wallSegments.some((seg) => {
      var _a2;
      const def = seg.typeId ? wallTypeById.get(seg.typeId) ?? null : null;
      return (((_a2 = def == null ? void 0 : def.behavior) == null ? void 0 : _a2.interactions) ?? []).length > 0;
    });
    if (wallHas) return true;
    return obstacles.some((obs) => {
      const def = obstacleTypeById.get(obs.typeId) ?? null;
      return ((def == null ? void 0 : def.interactions) ?? []).length > 0;
    });
  }, [obstacleTypeById, obstacles, wallSegments, wallTypeById]);
  const isEffectAllowedOnFloor = (effectDef, floorId) => {
    const placement2 = effectDef.placement;
    if (!placement2) return true;
    const material = getFloorMaterial(floorId);
    const tags2 = (material == null ? void 0 : material.tags) ?? [];
    if (placement2.avoidLiquid && (material == null ? void 0 : material.liquid)) return false;
    if (placement2.allowedFloors && placement2.allowedFloors.length > 0) {
      if (!floorId || !placement2.allowedFloors.includes(floorId)) return false;
    }
    if (placement2.blockedFloors && placement2.blockedFloors.length > 0) {
      if (floorId && placement2.blockedFloors.includes(floorId)) return false;
    }
    if (placement2.allowedFloorTags && placement2.allowedFloorTags.length > 0) {
      if (!tags2.some((tag) => {
        var _a2;
        return (_a2 = placement2.allowedFloorTags) == null ? void 0 : _a2.includes(tag);
      })) return false;
    }
    if (placement2.blockedFloorTags && placement2.blockedFloorTags.length > 0) {
      if (tags2.some((tag) => {
        var _a2;
        return (_a2 = placement2.blockedFloorTags) == null ? void 0 : _a2.includes(tag);
      })) return false;
    }
    return true;
  };
  const buildEffectsFromObstacles = (params) => {
    var _a2, _b2;
    const results = [];
    const { obstacles: obstacles2, terrain, grid } = params;
    for (const obstacle of obstacles2) {
      const def = obstacleTypeById.get(obstacle.typeId) ?? null;
      if (!def) continue;
      const effectEntries = def.effects && def.effects.length > 0 ? def.effects : ((_a2 = def.tags) == null ? void 0 : _a2.includes("fire")) ? [{ id: "fire", enabled: true }] : [];
      if (((_b2 = obstacle.state) == null ? void 0 : _b2.lit) === false) continue;
      if (!effectEntries.length) continue;
      for (const entry of effectEntries) {
        if (entry.enabled === false) continue;
        const effectDef = effectTypeById.get(entry.id);
        if (!effectDef) continue;
        const idx = obstacle.y * grid.cols + obstacle.x;
        const floorId = idx >= 0 && idx < terrain.length ? terrain[idx] : null;
        if (!isEffectAllowedOnFloor(effectDef, floorId)) continue;
        results.push({
          id: `effect-${obstacle.id}-${entry.id}`,
          typeId: entry.id,
          x: obstacle.x,
          y: obstacle.y,
          active: true,
          sourceObstacleId: obstacle.id
        });
      }
    }
    return results;
  };
  reactExports.useEffect(() => {
    if (effectTypes.length === 0) return;
    if (!Array.isArray(obstacles) || obstacles.length === 0) return;
    if (!Array.isArray(mapTerrain) || mapTerrain.length === 0) return;
    const desired = buildEffectsFromObstacles({
      obstacles,
      terrain: mapTerrain,
      grid: mapGrid
    });
    const currentById = /* @__PURE__ */ new Map();
    for (const effect of effects) currentById.set(effect.id, effect);
    const merged = desired.map((effect) => {
      const existing = currentById.get(effect.id);
      if (!existing) return effect;
      return { ...effect, active: existing.active };
    });
    const currentKey = effects.map((e2) => `${e2.id}:${e2.typeId}:${e2.x}:${e2.y}:${e2.active}`).join("|");
    const mergedKey = merged.map((e2) => `${e2.id}:${e2.typeId}:${e2.x}:${e2.y}:${e2.active}`).join("|");
    if (currentKey !== mergedKey) {
      setEffects(merged);
    }
  }, [effectTypes.length, obstacles, mapTerrain, mapGrid.cols, mapGrid.rows, effects]);
  const obstacleLegend = reactExports.useMemo(() => {
    return obstacles.filter((o2) => o2.hp > 0).map((o2) => {
      const def = obstacleTypeById.get(o2.typeId) ?? null;
      const orientation = o2.orientation ?? orientationFromRotationDeg(o2.rotation ?? 0);
      return {
        id: o2.id,
        label: (def == null ? void 0 : def.label) ?? o2.typeId,
        orientation
      };
    });
  }, [obstacleTypeById, obstacles]);
  const terrainLegend = reactExports.useMemo(() => {
    var _a2;
    const entries = [];
    const idMap = /* @__PURE__ */ new Map();
    const terrain = Array.isArray(mapTerrain) ? mapTerrain : null;
    if (!terrain || terrain.length === 0) {
      return { entries, idMap };
    }
    const { cols, rows } = mapGrid;
    const playable = playableCells;
    const unique = /* @__PURE__ */ new Set();
    for (let y2 = 0; y2 < rows; y2++) {
      for (let x2 = 0; x2 < cols; x2++) {
        if (playable && playable.size > 0 && !playable.has(`${x2},${y2}`)) continue;
        const index = y2 * cols + x2;
        const cellTerrain = terrain[index] ?? "unknown";
        unique.add(cellTerrain);
      }
    }
    const ordered = [];
    const pending = new Set(unique);
    for (const material of FLOOR_MATERIALS) {
      if (pending.has(material.id)) {
        ordered.push(material.id);
        pending.delete(material.id);
      }
    }
    const leftovers = Array.from(pending);
    leftovers.sort();
    ordered.push(...leftovers);
    let nextId = 1;
    for (const id2 of ordered) {
      const label2 = ((_a2 = getFloorMaterial(id2)) == null ? void 0 : _a2.label) ?? id2;
      idMap.set(id2, nextId);
      entries.push({ id: id2, label: label2, index: nextId });
      nextId += 1;
    }
    return { entries, idMap };
  }, [mapTerrain, mapGrid, playableCells]);
  const terrainMixLayer = reactExports.useMemo(() => {
    if (!Array.isArray(mapTerrain) || mapTerrain.length === 0) return [];
    return buildTerrainMixLayer({
      terrain: mapTerrain,
      cols: mapGrid.cols,
      rows: mapGrid.rows,
      playableCells
    });
  }, [mapTerrain, mapGrid.cols, mapGrid.rows, playableCells]);
  const lightSources = reactExports.useMemo(() => {
    var _a2, _b2;
    const sources2 = [];
    for (const effect of effects) {
      if (effect.active === false) continue;
      const def = effectTypeById.get(effect.typeId);
      const radiusRaw = (_a2 = def == null ? void 0 : def.light) == null ? void 0 : _a2.radius;
      const radius = Number.isFinite(radiusRaw) ? Math.floor(radiusRaw) : 0;
      if (radius <= 0) continue;
      sources2.push({ x: effect.x, y: effect.y, radius, color: (_b2 = def == null ? void 0 : def.light) == null ? void 0 : _b2.color });
    }
    return sources2;
  }, [effects, effectTypeById]);
  const activeLightSources = reactExports.useMemo(() => {
    const sources2 = [...lightSources];
    if (playerTorchOn) {
      sources2.push({
        x: player.x,
        y: player.y,
        radius: Math.max(1, Math.floor(PLAYER_TORCH_RADIUS)),
        color: 16757611
      });
    }
    return sources2;
  }, [lightSources, player.x, player.y, playerTorchOn]);
  const isNight = reactExports.useMemo(() => {
    if (!Array.isArray(mapLight) || mapLight.length === 0) return false;
    const total = mapLight.reduce((acc, value2) => acc + (Number(value2) || 0), 0);
    const avg = total / mapLight.length;
    return avg < LIGHT_LEVEL_SHADOW_MIN;
  }, [mapLight]);
  const levelRange = reactExports.useMemo(() => {
    let min = 0;
    let max = 0;
    for (const value2 of mapHeight) {
      if (!Number.isFinite(value2)) continue;
      min = Math.min(min, value2);
      max = Math.max(max, value2);
    }
    for (const obs of obstacles) {
      const def = obstacleTypeById.get(obs.typeId);
      const connects2 = def == null ? void 0 : def.connects;
      if (!connects2) continue;
      min = Math.min(min, connects2.from, connects2.to);
      max = Math.max(max, connects2.from, connects2.to);
    }
    return { min, max };
  }, [mapHeight, obstacles, obstacleTypeById]);
  const floorVisionBlockersByLevel = reactExports.useMemo(() => {
    const blockers = /* @__PURE__ */ new Map();
    const cols = mapGrid.cols;
    const rows = mapGrid.rows;
    if (!Array.isArray(mapTerrain) || mapTerrain.length === 0) return blockers;
    const addBlocker = (level2, x2, y2) => {
      let set = blockers.get(level2);
      if (!set) {
        set = /* @__PURE__ */ new Set();
        blockers.set(level2, set);
      }
      set.add(buildCellKey(x2, y2));
    };
    for (let y2 = 0; y2 < rows; y2++) {
      for (let x2 = 0; x2 < cols; x2++) {
        const idx = y2 * cols + x2;
        if (idx < 0 || idx >= mapTerrain.length) continue;
        const floorId = mapTerrain[idx];
        const mat = getFloorMaterial(floorId);
        if (!(mat == null ? void 0 : mat.blocksVision)) continue;
        const level2 = getHeightAtGrid(mapHeight, cols, rows, x2, y2);
        addBlocker(level2, x2, y2);
      }
    }
    return blockers;
  }, [mapGrid, mapHeight, mapTerrain]);
  const visionBlockersByLevel = reactExports.useMemo(() => {
    var _a2;
    const blockers = /* @__PURE__ */ new Map();
    const addBlocker = (level2, x2, y2) => {
      let set = blockers.get(level2);
      if (!set) {
        set = /* @__PURE__ */ new Set();
        blockers.set(level2, set);
      }
      set.add(buildCellKey(x2, y2));
    };
    const heightAt = (x2, y2) => getHeightAtGrid(mapHeight, mapGrid.cols, mapGrid.rows, x2, y2);
    for (const obs of obstacles) {
      if (obs.hp <= 0) continue;
      const def = obstacleTypeById.get(obs.typeId) ?? null;
      if (!((_a2 = def == null ? void 0 : def.blocking) == null ? void 0 : _a2.vision)) continue;
      const cells = getObstacleOccupiedCells(obs, def);
      for (const cell of cells) {
        const level2 = heightAt(cell.x, cell.y);
        addBlocker(level2, cell.x, cell.y);
      }
    }
    for (const [level2, cells] of floorVisionBlockersByLevel.entries()) {
      let set = blockers.get(level2);
      if (!set) {
        set = /* @__PURE__ */ new Set();
        blockers.set(level2, set);
      }
      for (const cell of cells) {
        set.add(cell);
      }
    }
    return blockers;
  }, [mapGrid, mapHeight, obstacles, obstacleTypeById, floorVisionBlockersByLevel]);
  const visionBlockersActive = reactExports.useMemo(() => {
    const floorBlockers = floorVisionBlockersByLevel.get(activeLevel) ?? /* @__PURE__ */ new Set();
    if (floorBlockers.size === 0) return /* @__PURE__ */ new Set([...obstacleBlocking.vision]);
    return /* @__PURE__ */ new Set([...obstacleBlocking.vision, ...floorBlockers]);
  }, [activeLevel, floorVisionBlockersByLevel, obstacleBlocking.vision]);
  const lightLevels = reactExports.useMemo(() => {
    if (mapGrid.cols <= 0 || mapGrid.rows <= 0) return [];
    return computeLightLevels({
      grid: mapGrid,
      mapLight,
      lightSources: activeLightSources,
      obstacleVisionCells: visionBlockersActive,
      wallVisionEdges: wallEdges.vision,
      closedCells,
      roofOpenCells: roofOpenCells ?? null
    });
  }, [
    activeLightSources,
    closedCells,
    mapGrid,
    mapLight,
    roofOpenCells,
    visionBlockersActive,
    wallEdges.vision
  ]);
  const lightTints = reactExports.useMemo(() => {
    if (mapGrid.cols <= 0 || mapGrid.rows <= 0) return null;
    return computeLightTints({
      grid: mapGrid,
      lightSources: activeLightSources,
      obstacleVisionCells: visionBlockersActive,
      wallVisionEdges: wallEdges.vision
    });
  }, [activeLightSources, mapGrid, visionBlockersActive, wallEdges.vision]);
  const playerLightMode = reactExports.useMemo(() => {
    const profile = player.visionProfile;
    const raw = (profile == null ? void 0 : profile.lightVision) ?? ((profile == null ? void 0 : profile.canSeeInDark) ? "darkvision" : "normal");
    return resolveLightVisionMode(raw);
  }, [player.visionProfile]);
  const visionBlockersForVisibility = reactExports.useMemo(() => {
    const combined = /* @__PURE__ */ new Map();
    const activeBlockers = visionBlockersByLevel.get(activeLevel) ?? /* @__PURE__ */ new Set();
    for (let level2 = levelRange.min; level2 <= levelRange.max; level2++) {
      const levelBlockers = visionBlockersByLevel.get(level2) ?? /* @__PURE__ */ new Set();
      if (level2 === activeLevel || activeBlockers.size === 0) {
        combined.set(level2, levelBlockers);
        continue;
      }
      if (levelBlockers.size === 0) {
        combined.set(level2, activeBlockers);
        continue;
      }
      combined.set(level2, /* @__PURE__ */ new Set([...activeBlockers, ...levelBlockers]));
    }
    return combined;
  }, [activeLevel, levelRange.min, levelRange.max, visionBlockersByLevel]);
  const visibilityByLevel = reactExports.useMemo(() => {
    if (showAllLevels) return null;
    const perLevel = /* @__PURE__ */ new Map();
    const hasLight = lightLevels.length > 0;
    for (let level2 = levelRange.min; level2 <= levelRange.max; level2++) {
      const blockers = visionBlockersForVisibility.get(level2) ?? /* @__PURE__ */ new Set();
      const baseVisibility = computeVisibilityLevelsForToken({
        token: player,
        playableCells: playableCells ?? null,
        grid: mapGrid,
        opaqueCells: blockers,
        wallVisionEdges: wallEdges.vision
      });
      const filtered = /* @__PURE__ */ new Map();
      for (const [key2, vis] of baseVisibility.entries()) {
        const [xs, ys] = key2.split(",");
        const x2 = Number(xs);
        const y2 = Number(ys);
        if (!Number.isFinite(x2) || !Number.isFinite(y2)) continue;
        if (hasLight) {
          const idx = y2 * mapGrid.cols + x2;
          const light2 = lightLevels[idx] ?? 0;
          if (!isLightVisible(light2, playerLightMode)) continue;
        }
        const cellLevel = getHeightAtGrid(mapHeight, mapGrid.cols, mapGrid.rows, x2, y2);
        if (cellLevel !== level2) continue;
        filtered.set(key2, vis);
      }
      const playerLevel = getHeightAtGrid(
        mapHeight,
        mapGrid.cols,
        mapGrid.rows,
        player.x,
        player.y
      );
      if (playerLevel === level2) {
        filtered.set(buildCellKey(player.x, player.y), 2);
      }
      perLevel.set(level2, filtered);
    }
    return perLevel;
  }, [
    activeLevel,
    levelRange.min,
    levelRange.max,
    lightLevels,
    mapGrid,
    mapHeight,
    player,
    playerLightMode,
    playableCells,
    showAllLevels,
    visionBlockersForVisibility,
    wallEdges
  ]);
  const visionByLevel = reactExports.useMemo(() => {
    if (showAllLevels) return null;
    const perLevel = /* @__PURE__ */ new Map();
    for (let level2 = levelRange.min; level2 <= levelRange.max; level2++) {
      const blockers = visionBlockersForVisibility.get(level2) ?? /* @__PURE__ */ new Set();
      const baseVisibility = computeVisibilityLevelsForToken({
        token: player,
        playableCells: playableCells ?? null,
        grid: mapGrid,
        opaqueCells: blockers,
        wallVisionEdges: wallEdges.vision
      });
      const filtered = /* @__PURE__ */ new Map();
      for (const [key2, vis] of baseVisibility.entries()) {
        const [xs, ys] = key2.split(",");
        const x2 = Number(xs);
        const y2 = Number(ys);
        if (!Number.isFinite(x2) || !Number.isFinite(y2)) continue;
        const cellLevel = getHeightAtGrid(mapHeight, mapGrid.cols, mapGrid.rows, x2, y2);
        if (cellLevel !== level2) continue;
        filtered.set(key2, vis);
      }
      const playerLevel = getHeightAtGrid(
        mapHeight,
        mapGrid.cols,
        mapGrid.rows,
        player.x,
        player.y
      );
      if (playerLevel === level2) {
        filtered.set(buildCellKey(player.x, player.y), 2);
      }
      perLevel.set(level2, filtered);
    }
    return perLevel;
  }, [
    activeLevel,
    levelRange.min,
    levelRange.max,
    mapGrid,
    mapHeight,
    player,
    playableCells,
    showAllLevels,
    visionBlockersForVisibility,
    wallEdges
  ]);
  const visibilityLevels = reactExports.useMemo(() => {
    if (showAllLevels) return null;
    const union = /* @__PURE__ */ new Map();
    if (!visibilityByLevel) return union;
    for (const levelMap of visibilityByLevel.values()) {
      for (const [key2, vis] of levelMap.entries()) {
        const prev = union.get(key2) ?? 0;
        if (vis > prev) union.set(key2, vis);
      }
    }
    return union;
  }, [showAllLevels, visibilityByLevel]);
  const visibleCellsFull = reactExports.useMemo(() => {
    if (showAllLevels) return null;
    const full = /* @__PURE__ */ new Set();
    if (!visibilityLevels) return full;
    for (const [key2, vis] of visibilityLevels.entries()) {
      if (vis >= 2) full.add(key2);
    }
    return full;
  }, [showAllLevels, visibilityLevels]);
  const visionCellsFull = reactExports.useMemo(() => {
    if (showAllLevels) return null;
    const full = /* @__PURE__ */ new Set();
    if (!visionByLevel) return full;
    for (const levelMap of visionByLevel.values()) {
      for (const [key2, vis] of levelMap.entries()) {
        if (vis >= 2) full.add(key2);
      }
    }
    return full;
  }, [showAllLevels, visionByLevel]);
  const visionLegend = reactExports.useMemo(() => {
    const modeFor = (profile) => {
      const raw = (profile == null ? void 0 : profile.lightVision) ?? ((profile == null ? void 0 : profile.canSeeInDark) ? "darkvision" : "normal");
      return resolveLightVisionMode(raw);
    };
    const playerMode = modeFor(player.visionProfile);
    const enemyModes = enemyTypes.map((t2) => `${t2.label ?? t2.id}: ${modeFor(t2.vision)}`).join(", ");
    return enemyModes.length > 0 ? `Vision: joueur=${playerMode} | ennemis: ${enemyModes}` : `Vision: joueur=${playerMode}`;
  }, [enemyTypes, player.visionProfile]);
  function clampActiveLevel(value2) {
    return Math.max(levelRange.min, Math.min(levelRange.max, value2));
  }
  function getBaseHeightAt(x2, y2) {
    return getHeightAtGrid(mapHeight, mapGrid.cols, mapGrid.rows, x2, y2);
  }
  function isCellVisibleForPlayer(x2, y2) {
    if (showAllLevels) return true;
    if (!visibilityLevels) return false;
    const level2 = visibilityLevels.get(buildCellKey(x2, y2)) ?? 0;
    return level2 > 0;
  }
  reactExports.useEffect(() => {
    setActiveLevel((prev) => clampActiveLevel(prev));
  }, [levelRange.min, levelRange.max]);
  const shouldAnimateBoard = hasAnimatedSprites && !isTextureLoading;
  const boardMaxFps = shouldAnimateBoard ? isBoardIdle ? BOARD_FPS_IDLE : BOARD_FPS_ACTIVE : 0;
  const invalidateBoard = reactExports.useCallback(() => {
    if (!shouldAnimateBoard) {
      setRenderTick((t2) => t2 + 1);
    }
  }, [shouldAnimateBoard]);
  const {
    staticDepthLayerRef,
    dynamicDepthLayerRef,
    pathLayerRef,
    terrainNaturalLayerRef,
    terrainFxLayerRef,
    terrainLabelLayerRef,
    speechLayerRef,
    labelLayerRef,
    viewportRef,
    pixiReadyTick
  } = usePixiBoard({
    enabled: isCombatConfigured,
    containerRef: pixiContainerRef,
    zoom: boardZoom,
    panX: boardPan.x,
    panY: boardPan.y,
    backgroundColor: boardBackgroundColor,
    playableCells,
    terrain: mapTerrain,
    terrainMix: terrainMixLayer,
    grid: mapGrid,
    animate: shouldAnimateBoard,
    maxFps: boardMaxFps,
    renderTick
  });
  usePixiNaturalTiling({
    layerRef: terrainNaturalLayerRef,
    terrain: mapTerrain,
    terrainMix: terrainMixLayer,
    playableCells,
    grid: mapGrid,
    materials: floorMaterialById,
    lightLevels,
    lightMap: mapLight,
    bumpIntensity,
    windSpeed,
    windStrength,
    bumpDebug,
    pixiReadyTick,
    onInvalidate: invalidateBoard
  });
  usePixiTerrainFx({
    terrainFxLayerRef,
    terrainLabelLayerRef,
    showTerrainIds,
    showTerrainContours,
    playableCells,
    grid: mapGrid,
    terrain: mapTerrain,
    terrainMix: terrainMixLayer,
    terrainIdMap: terrainLegend.idMap,
    pixiReadyTick
  });
  reactExports.useEffect(() => {
    if (shouldAnimateBoard) return;
    setRenderTick((t2) => t2 + 1);
  }, [
    shouldAnimateBoard,
    mapGrid,
    mapTerrain,
    terrainMixLayer,
    playableCells,
    mapHeight,
    mapLight,
    obstacles,
    wallSegments,
    decorations,
    effects,
    player,
    enemies,
    selectedPath,
    selectedTargetIds,
    selectedObstacleTarget,
    selectedWallTarget,
    visibilityLevels,
    showAllLevels,
    showLightOverlay,
    showVisionDebug,
    showTerrainIds,
    showTerrainContours,
    activeLevel,
    speechBubbles,
    isTextureLoading,
    boardZoom,
    boardPan.x,
    boardPan.y
  ]);
  usePixiWalls({
    depthLayerRef: staticDepthLayerRef,
    walls: wallSegments,
    pixiReadyTick,
    grid: mapGrid,
    heightMap: mapHeight,
    activeLevel,
    visibleCells: visibleCellsFull,
    showAllLevels
  });
  usePixiObstacles({
    depthLayerRef: staticDepthLayerRef,
    obstacleTypes,
    obstacles,
    tokens: [player, ...enemies],
    pixiReadyTick,
    grid: mapGrid,
    heightMap: mapHeight,
    activeLevel,
    visibleCells: visibleCellsFull,
    showAllLevels,
    paletteId: mapPaletteId,
    lightAngleDeg: shadowLightAngleDeg,
    suspendRendering: isTextureLoading
  });
  usePixiDecorations({
    depthLayerRef: staticDepthLayerRef,
    decorations,
    pixiReadyTick,
    grid: mapGrid,
    heightMap: mapHeight,
    activeLevel,
    visibleCells: visibleCellsFull,
    showAllLevels
  });
  const renderEffects = reactExports.useMemo(
    () => [...resolvedEffects, ...actionEffects],
    [resolvedEffects, actionEffects]
  );
  const fxAnimations = reactExports.useMemo(() => {
    return getEffectAnimationKeys().map((key2) => ({ key: key2, frames: getObstacleAnimationFrames(key2) ?? [] })).filter((entry) => entry.frames.length > 0);
  }, []);
  usePixiEffects({
    depthLayerRef: dynamicDepthLayerRef,
    effects: renderEffects,
    effectTypes,
    pixiReadyTick,
    grid: mapGrid,
    visibleCells: visibleCellsFull,
    showAllLevels,
    suspendRendering: isTextureLoading
  });
  usePixiTokens({
    depthLayerRef: dynamicDepthLayerRef,
    player,
    enemies,
    pixiReadyTick,
    grid: mapGrid,
    heightMap: mapHeight,
    activeLevel,
    visibleCells: visibleCellsFull,
    showAllLevels,
    lightAngleDeg: shadowLightAngleDeg,
    suspendRendering: isTextureLoading
  });
  usePixiSpeechBubbles({
    speechLayerRef,
    player,
    enemies,
    speechBubbles,
    pixiReadyTick,
    grid: mapGrid,
    heightMap: mapHeight,
    activeLevel,
    visibleCells: visibleCellsFull,
    showAllLevels
  });
  const overlayAction = actionContext ? getActionById(actionContext.actionId) : null;
  const actionOverlaySpecs = reactExports.useMemo(() => {
    var _a2;
    if (!actionContextOpen || !overlayAction) return [];
    if (targetMode !== "selecting") return [];
    const range = ((_a2 = overlayAction.targeting) == null ? void 0 : _a2.range) ?? null;
    if (!range) return [];
    const specs = [];
    const rangeCells = metersToCells(Math.max(0, range.max));
    const targetCell = (() => {
      const primaryTargetId2 = getPrimaryTargetId();
      if (primaryTargetId2) {
        const target = [player, ...enemies].find((token) => token.id === primaryTargetId2);
        if (target) return { x: target.x, y: target.y };
      }
      if (selectedObstacleTarget) return { x: selectedObstacleTarget.x, y: selectedObstacleTarget.y };
      if (selectedWallTarget) return { x: selectedWallTarget.x, y: selectedWallTarget.y };
      return null;
    })();
    const direction = (() => {
      if (!targetCell) return "right";
      const dx = targetCell.x - player.x;
      const dy = targetCell.y - player.y;
      const absX = Math.abs(dx);
      const absY = Math.abs(dy);
      if (absX === absY) {
        if (dx >= 0 && dy >= 0) return "down-right";
        if (dx >= 0 && dy < 0) return "up-right";
        if (dx < 0 && dy >= 0) return "down-left";
        return "up-left";
      }
      return absX > absY ? dx >= 0 ? "right" : "left" : dy >= 0 ? "down" : "up";
    })();
    if (range.shape === "rectangle" || range.shape === "CUBE") {
      specs.push({
        id: "action-range",
        kind: "rectangle",
        width: Math.max(1, rangeCells),
        height: Math.max(1, rangeCells)
      });
    } else if (range.shape === "cone" || range.shape === "CONE") {
      specs.push({
        id: "action-range",
        kind: "cone",
        range: Math.max(1, rangeCells),
        direction
      });
    } else {
      specs.push({
        id: "action-range",
        kind: "circle",
        radius: Math.max(1, rangeCells)
      });
    }
    if (targetCell) {
      const distCells = Math.max(Math.abs(targetCell.x - player.x), Math.abs(targetCell.y - player.y));
      const dist = cellsToMeters(distCells);
      const inRange = (typeof range.min !== "number" || dist >= range.min) && (typeof range.max !== "number" || dist <= range.max);
      const hasLoS = isCellVisible(
        player,
        targetCell,
        visionBlockersActive,
        playableCells,
        wallEdges.vision,
        lightLevels,
        mapGrid
      );
      const hasLoE = hasLineOfEffect(
        { x: player.x, y: player.y },
        targetCell,
        obstacleBlocking.attacks,
        wallEdges.vision
      );
      const ok = inRange && hasLoS && hasLoE;
      specs.push({
        id: "action-line",
        kind: "line",
        toX: targetCell.x,
        toY: targetCell.y,
        color: ok ? 7328383 : 15158332,
        alpha: 0.9,
        thickness: 2
      });
    }
    return specs;
  }, [
    actionContextOpen,
    overlayAction,
    targetMode,
    player,
    enemies,
    selectedObstacleTarget,
    selectedWallTarget,
    visionBlockersActive,
    playableCells,
    wallEdges.vision,
    lightLevels,
    mapGrid,
    obstacleBlocking.attacks
  ]);
  const selectedStructureCell = selectedObstacleTarget ?? selectedWallTarget;
  getPrimaryTargetId();
  usePixiOverlays({
    pathLayerRef,
    player,
    enemies,
    selectedPath,
    effectSpecs: [...effectSpecs, ...actionOverlaySpecs],
    selectedTargetIds,
    selectedObstacleCell: selectedStructureCell ? { x: selectedStructureCell.x, y: selectedStructureCell.y } : null,
    obstacleVisionCells: visionBlockersActive,
    wallVisionEdges: wallEdges.vision,
    closedCells,
    showVisionDebug,
    showFogSegments,
    visibleCells: visibleCellsFull,
    visionCells: visionCellsFull,
    visibilityLevels,
    showAllLevels,
    lightMap: mapLight,
    lightSources,
    showLightOverlay,
    showGridLines,
    lightLevels,
    lightTints,
    isNight,
    playerTorchOn,
    playerTorchRadius: PLAYER_TORCH_RADIUS,
    pixiReadyTick,
    playableCells,
    grid: mapGrid,
    heightMap: mapHeight,
    activeLevel
  });
  usePixiGridLabels({
    labelLayerRef,
    showLabels: showCellIds,
    playableCells,
    grid: mapGrid,
    heightMap: mapHeight,
    activeLevel,
    obstacles,
    obstacleTypes,
    pixiReadyTick
  });
  const INSPECT_RANGE = 10;
  function closeRadialMenu() {
    setRadialMenu({ cell: null, token: null });
    if (interactionMode === "interact-select") {
      setInteractionMode("idle");
    }
    setInteractionMenuItems([]);
    closeInteractionContext();
  }
  function resolveWheelAnchor() {
    const container = pixiContainerRef.current;
    const margin = 110;
    if (!container) return { x: margin, y: margin };
    const rect = container.getBoundingClientRect();
    const clampedX = Math.max(margin, Math.min(rect.width - margin, margin));
    const clampedY = Math.max(margin, rect.height - margin);
    return { x: clampedX, y: clampedY };
  }
  function closeInteractionContext() {
    setInteractionContext(null);
  }
  function cellKey(x2, y2) {
    return `${x2},${y2}`;
  }
  function isCellPlayable(x2, y2) {
    if (!isCellInsideGrid(x2, y2, mapGrid.cols, mapGrid.rows)) return false;
    if (!playableCells || playableCells.size === 0) return true;
    return playableCells.has(cellKey(x2, y2));
  }
  function findObstacleAtCell(x2, y2) {
    if (getBaseHeightAt(x2, y2) !== activeLevel) return null;
    for (const obs of obstacles) {
      if (obs.hp <= 0) continue;
      const def = obstacleTypeById.get(obs.typeId) ?? null;
      const cells = getObstacleOccupiedCells(obs, def);
      if (cells.some((c2) => c2.x === x2 && c2.y === y2)) {
        return { instance: obs, def };
      }
    }
    return null;
  }
  function findObstacleAtCellAnyLevel(x2, y2) {
    for (const obs of obstacles) {
      if (obs.hp <= 0) continue;
      const def = obstacleTypeById.get(obs.typeId) ?? null;
      const cells = getObstacleOccupiedCells(obs, def);
      if (cells.some((c2) => c2.x === x2 && c2.y === y2)) {
        return { instance: obs, def };
      }
    }
    return null;
  }
  function findWallSegmentAtCell(x2, y2) {
    if (getBaseHeightAt(x2, y2) !== activeLevel) return null;
    for (const seg of wallSegments) {
      if (typeof seg.hp === "number" && seg.hp <= 0) continue;
      const cells = getAdjacentCellsForEdge(seg);
      if (cells.a.x === x2 && cells.a.y === y2 || cells.b.x === x2 && cells.b.y === y2) {
        const def = seg.typeId ? wallTypeById.get(seg.typeId) ?? null : null;
        return { segment: seg, def };
      }
    }
    return null;
  }
  function findWallSegmentAtCellAnyLevel(x2, y2) {
    for (const seg of wallSegments) {
      if (typeof seg.hp === "number" && seg.hp <= 0) continue;
      const cells = getAdjacentCellsForEdge(seg);
      if (cells.a.x === x2 && cells.a.y === y2 || cells.b.x === x2 && cells.b.y === y2) {
        const def = seg.typeId ? wallTypeById.get(seg.typeId) ?? null : null;
        return { segment: seg, def };
      }
    }
    return null;
  }
  function getObstacleDistance(from, obstacle, def, targetCell) {
    const cells = def ? getObstacleOccupiedCells(obstacle, def) : [targetCell];
    const fromCells = "id" in from ? getTokenOccupiedCells(from) : [from];
    let best = Number.POSITIVE_INFINITY;
    for (const src of fromCells) {
      for (const cell of cells) {
        const dist = Math.abs(src.x - cell.x) + Math.abs(src.y - cell.y);
        if (dist < best) best = dist;
      }
    }
    if (Number.isFinite(best)) return best;
    const fallback = Math.abs(from.x - targetCell.x) + Math.abs(from.y - targetCell.y);
    return fallback;
  }
  function getWallSegmentDistance(from, segment) {
    const cells = getAdjacentCellsForEdge(segment);
    const distA = Math.abs(from.x - cells.a.x) + Math.abs(from.y - cells.a.y);
    const distB = Math.abs(from.x - cells.b.x) + Math.abs(from.y - cells.b.y);
    return Math.min(distA, distB);
  }
  function getChebyshevDistanceFromEntity(from, cells) {
    const fromCells = "id" in from ? getTokenOccupiedCells(from) : [from];
    return distanceBetweenCells(fromCells, cells);
  }
  function getWallSegmentChebyshevDistance(from, segment) {
    const cells = getAdjacentCellsForEdge(segment);
    return getChebyshevDistanceFromEntity(from, [cells.a, cells.b]);
  }
  function getObstacleChebyshevDistance(from, obstacle, def, targetCell) {
    const cells = def ? getObstacleOccupiedCells(obstacle, def) : [targetCell];
    return getChebyshevDistanceFromEntity(from, cells);
  }
  function canPayInteractionCost(cost) {
    var _a2, _b2;
    if (!canInteractWithBoard) {
      return { ok: false, reason: "Tour joueur requis." };
    }
    if (cost === "action" && turnActionUsage.usedActionCount >= (((_a2 = player.combatStats) == null ? void 0 : _a2.actionsPerTurn) ?? 1)) {
      return { ok: false, reason: "Action principale deja utilisee." };
    }
    if (cost === "bonus" && turnActionUsage.usedBonusCount >= (((_b2 = player.combatStats) == null ? void 0 : _b2.bonusActionsPerTurn) ?? 1)) {
      return { ok: false, reason: "Action bonus deja utilisee." };
    }
    return { ok: true };
  }
  function applyInteractionCost(cost) {
    const isStandardAction = cost === "action";
    const isBonusAction = cost === "bonus";
    if (!isStandardAction && !isBonusAction) return;
    setTurnActionUsage((prev) => ({
      usedActionCount: prev.usedActionCount + (isStandardAction ? 1 : 0),
      usedBonusCount: prev.usedBonusCount + (isBonusAction ? 1 : 0)
    }));
  }
  function getSelectedTargetLabels() {
    if (selectedTargetIds.length > 0) return [...selectedTargetIds];
    if (selectedObstacleTarget) {
      const obstacle = obstacles.find((o2) => o2.id === selectedObstacleTarget.id) ?? null;
      if (!obstacle) return ["obstacle"];
      const def = obstacleTypeById.get(obstacle.typeId) ?? null;
      return [(def == null ? void 0 : def.label) ?? obstacle.typeId ?? "obstacle"];
    }
    if (selectedWallTarget) {
      const wall = wallSegments.find((w2) => w2.id === selectedWallTarget.id) ?? null;
      if (!wall) return ["mur"];
      const def = wall.typeId ? wallTypeById.get(wall.typeId) ?? null : null;
      return [(def == null ? void 0 : def.label) ?? wall.typeId ?? "mur"];
    }
    return [];
  }
  function getPrimaryTargetId() {
    return selectedTargetIds.length > 0 ? selectedTargetIds[0] : null;
  }
  function toggleSelectedTargetId(targetId, maxTargets) {
    const cap = typeof maxTargets === "number" && maxTargets > 0 ? maxTargets : 1;
    setSelectedTargetIds((prev) => {
      if (prev.includes(targetId)) {
        return prev.filter((id2) => id2 !== targetId);
      }
      if (prev.length >= cap) {
        pushLog2(`Maximum de cibles atteint (${cap}).`);
        return prev;
      }
      return [...prev, targetId];
    });
  }
  function getMovementModeById(id2) {
    return movementModes2.find((mode) => mode.id === id2) ?? null;
  }
  function handleCancelMoveFromWheel() {
    handleResetPath();
    setInteractionMode("idle");
  }
  function handleCancelInteractFromWheel() {
    setInteractionMode("idle");
    setInteractionMenuItems([]);
    closeInteractionContext();
  }
  function handleSelectPathFromContext() {
    if (!canInteractWithBoard) return;
    suppressBoardClickUntilRef.current = Date.now() + 220;
    window.setTimeout(() => {
      setInteractionMode("moving");
    }, 120);
  }
  function resourceKey(name2, pool) {
    return `${pool ?? "default"}:${name2}`;
  }
  const objectItemMap = reactExports.useMemo(() => {
    const map = /* @__PURE__ */ new Map();
    for (const item of objectItems) {
      if (item == null ? void 0 : item.id) map.set(item.id, item);
    }
    return map;
  }, [objectItems]);
  const physicalResourceMap = reactExports.useMemo(() => {
    const map = {
      dagger: { itemIds: ["dague", "dagger"] },
      torch: { itemIds: ["torch", "torche", "obj_torche", "obj_torch"] }
    };
    for (const ammo of ammoItems) {
      const ammoId = String(ammo.id ?? "").toLowerCase();
      if (!ammoId) continue;
      const ammoType2 = String(ammo.ammoType ?? ammo.id ?? "").toLowerCase();
      const attach = (key2) => {
        if (!key2) return;
        map[key2] = map[key2] ?? { itemIds: [] };
        if (!map[key2].itemIds.includes(ammoId)) map[key2].itemIds.push(ammoId);
      };
      attach(ammoId);
      attach(ammoType2);
    }
    return map;
  }, [ammoItems]);
  function resolveObjectTags(itemId) {
    const def = objectItemMap.get(itemId);
    if (!(def == null ? void 0 : def.tags)) return [];
    return def.tags.map((tag) => String(tag).toLowerCase());
  }
  function findContainerForStoredItem(items, storedIn) {
    return items.find((item) => (item == null ? void 0 : item.instanceId) === storedIn) ?? items.find((item) => (item == null ? void 0 : item.equippedSlot) === storedIn) ?? null;
  }
  function isAmmoContainer(item) {
    if (!(item == null ? void 0 : item.id)) return false;
    const tags2 = resolveObjectTags(String(item.id));
    return tags2.includes("ammo_container");
  }
  function isItemAccessible(item, allItems) {
    if (!item) return false;
    if (item.equippedSlot && !item.storedIn) return true;
    if (!item.storedIn) return false;
    const container = findContainerForStoredItem(allItems, String(item.storedIn));
    if (!(container == null ? void 0 : container.equippedSlot)) return false;
    return isAmmoContainer(container);
  }
  function getInventoryResourceCount(character, resourceName) {
    const def = physicalResourceMap[resourceName.toLowerCase()];
    if (!def) return 0;
    const items = Array.isArray(character == null ? void 0 : character.inventoryItems) ? character.inventoryItems : [];
    let total = 0;
    for (const item of items) {
      const rawId = typeof (item == null ? void 0 : item.id) === "string" ? item.id.toLowerCase() : "";
      if (!rawId || !def.itemIds.includes(rawId)) continue;
      if (!isItemAccessible(item, items)) continue;
      const qty = typeof (item == null ? void 0 : item.qty) === "number" ? item.qty : 1;
      if (!Number.isFinite(qty) || qty <= 0) continue;
      total += qty;
    }
    return total;
  }
  function spendInventoryResource(character, resourceName, amount) {
    const def = physicalResourceMap[resourceName.toLowerCase()];
    if (!def || amount <= 0) return character;
    const items = Array.isArray(character == null ? void 0 : character.inventoryItems) ? character.inventoryItems : [];
    let remaining = amount;
    const nextItems = items.map((item) => ({ ...item }));
    const candidates = nextItems.filter((item) => {
      const rawId = typeof (item == null ? void 0 : item.id) === "string" ? item.id.toLowerCase() : "";
      return rawId && def.itemIds.includes(rawId) && isItemAccessible(item, nextItems);
    }).sort((a2, b2) => {
      const aDirect = a2.equippedSlot && !a2.storedIn ? 0 : 1;
      const bDirect = b2.equippedSlot && !b2.storedIn ? 0 : 1;
      return aDirect - bDirect;
    });
    for (const item of candidates) {
      if (remaining <= 0) break;
      const qty = typeof (item == null ? void 0 : item.qty) === "number" ? item.qty : 1;
      const spend = Math.min(remaining, Math.max(0, qty));
      if (spend <= 0) continue;
      const nextQty = qty - spend;
      remaining -= spend;
      item.qty = nextQty;
    }
    const cleaned = nextItems.filter((item) => {
      const qty = typeof (item == null ? void 0 : item.qty) === "number" ? item.qty : 1;
      return qty > 0;
    });
    const byInstance = /* @__PURE__ */ new Map();
    for (const item of cleaned) {
      if (item == null ? void 0 : item.instanceId) byInstance.set(String(item.instanceId), item);
    }
    for (const item of cleaned) {
      if (!Array.isArray(item == null ? void 0 : item.contenu)) continue;
      item.contenu = item.contenu.filter((id2) => byInstance.has(String(id2)));
    }
    return { ...character, inventoryItems: cleaned };
  }
  function getSlotAmountFromCharacter(character, slot, level2) {
    var _a2;
    if (!((_a2 = character == null ? void 0 : character.spellcastingState) == null ? void 0 : _a2.slots)) return 0;
    const slots = character.spellcastingState.slots;
    const key2 = typeof level2 === "number" ? String(level2) : slot;
    const entry = slots[key2];
    if (typeof entry === "number") return entry;
    if (entry && typeof entry === "object") {
      const current = entry.current ?? entry.remaining ?? entry.value;
      if (typeof current === "number") return current;
    }
    return 0;
  }
  function isSpellActionId(actionId) {
    if (!actionId) return false;
    return spellCatalog.byId.has(String(actionId));
  }
  function getSpellLevel(actionId) {
    var _a2;
    const level2 = Number(((_a2 = spellCatalog.byId.get(actionId)) == null ? void 0 : _a2.level) ?? 0);
    if (!Number.isFinite(level2) || level2 < 0) return 0;
    return level2;
  }
  function buildSpellUsageCandidates(character, spellId) {
    if (!(character == null ? void 0 : character.spellcastingState) || !spellId) return [];
    const spellLevel = getSpellLevel(spellId);
    const candidates = [];
    const pushCandidate = (candidate) => {
      if (!candidate.spellId) return;
      candidates.push(candidate);
    };
    const spellGrants = character.spellcastingState.spellGrants ?? {};
    Object.entries(spellGrants).forEach(([sourceKey, entries]) => {
      if (!Array.isArray(entries)) return;
      entries.forEach((entry) => {
        if (String((entry == null ? void 0 : entry.spellId) ?? "") !== spellId) return;
        const usage2 = (entry == null ? void 0 : entry.usage) ?? {};
        const usageType = String((usage2 == null ? void 0 : usage2.type) ?? "");
        const consumesSlot = typeof (usage2 == null ? void 0 : usage2.consumesSlot) === "boolean" ? Boolean(usage2.consumesSlot) : usageType.toLowerCase() === "slot";
        const fixedSlotLevel = typeof (usage2 == null ? void 0 : usage2.fixedSlotLevel) === "number" && Number.isFinite(usage2.fixedSlotLevel) ? Number(usage2.fixedSlotLevel) : null;
        const slotLevel = consumesSlot && spellLevel > 0 ? Math.max(1, fixedSlotLevel ?? spellLevel) : consumesSlot && fixedSlotLevel ? Math.max(1, fixedSlotLevel) : null;
        const maxUses = typeof (usage2 == null ? void 0 : usage2.maxUses) === "number" && Number.isFinite(usage2.maxUses) ? Number(usage2.maxUses) : void 0;
        const remainingUses = typeof (usage2 == null ? void 0 : usage2.remainingUses) === "number" && Number.isFinite(usage2.remainingUses) ? Number(usage2.remainingUses) : maxUses;
        pushCandidate({
          sourceKey,
          entryId: String((entry == null ? void 0 : entry.entryId) ?? `${sourceKey}:${spellId}`),
          spellId,
          usageType,
          consumesSlot,
          slotLevel,
          sourceType: typeof (entry == null ? void 0 : entry.sourceType) === "string" ? entry.sourceType : void 0,
          sourceId: typeof (entry == null ? void 0 : entry.sourceId) === "string" ? entry.sourceId : void 0,
          sourceInstanceId: typeof (entry == null ? void 0 : entry.sourceInstanceId) === "string" ? entry.sourceInstanceId : void 0,
          remainingUses,
          maxUses
        });
      });
    });
    if (candidates.length > 0) return candidates;
    const sources2 = character.spellcastingState.sources ?? {};
    Object.entries(sources2).forEach(([sourceKey, source2]) => {
      const prepared = Array.isArray(source2 == null ? void 0 : source2.preparedSpellIds) ? source2.preparedSpellIds : [];
      const known = Array.isArray(source2 == null ? void 0 : source2.knownSpellIds) ? source2.knownSpellIds : [];
      const granted = Array.isArray(source2 == null ? void 0 : source2.grantedSpellIds) ? source2.grantedSpellIds : [];
      if (![...prepared, ...known, ...granted].includes(spellId)) return;
      const slotLevel = spellLevel > 0 ? Math.max(1, spellLevel) : null;
      pushCandidate({
        sourceKey,
        entryId: `${sourceKey}:${spellId}:legacy`,
        spellId,
        usageType: spellLevel > 0 ? "slot" : "at-will",
        consumesSlot: spellLevel > 0,
        slotLevel,
        sourceType: sourceKey.split(":")[0] || "manual",
        sourceId: sourceKey.includes(":") ? sourceKey.split(":").slice(1).join(":") : void 0
      });
    });
    return candidates;
  }
  function canConsumeSpellUsage(character, candidate) {
    if (!character) return false;
    const usageType = candidate.usageType.toLowerCase();
    if (candidate.consumesSlot) {
      if (candidate.slotLevel === null) return true;
      return getSlotAmountFromCharacter(character, "slot", candidate.slotLevel) > 0;
    }
    if (usageType === "limited" || usageType === "charge") {
      return Number(candidate.remainingUses ?? 0) > 0;
    }
    return true;
  }
  function getSpellCandidatePriority(candidate) {
    const usageType = candidate.usageType.toLowerCase();
    if (usageType === "at-will" || usageType === "passive") return 0;
    if (candidate.consumesSlot) return 1;
    if (usageType === "limited") return 2;
    if (usageType === "charge") return 3;
    return 4;
  }
  function buildSpellCandidateFailureReason(candidate) {
    if (candidate.consumesSlot && candidate.slotLevel !== null) {
      const level2 = candidate.slotLevel;
      return `Aucun emplacement de sort niveau ${level2}+ disponible pour la source selectionnee.`;
    }
    const usageType = candidate.usageType.toLowerCase();
    if (usageType === "limited" || usageType === "charge") {
      return "Cette source de sort n'a plus d'usages disponibles.";
    }
    return "Cette source de sort n'est pas utilisable actuellement.";
  }
  function resolveSpellUsageCandidate(character, spellId, preferredEntryId) {
    const candidates = buildSpellUsageCandidates(character, spellId);
    if (candidates.length === 0) {
      const spellLevel2 = getSpellLevel(spellId);
      if (spellLevel2 <= 0) return { candidate: null, reason: null };
      return { candidate: null, reason: "Aucune source de sort disponible." };
    }
    if (preferredEntryId) {
      const preferred = candidates.find((candidate) => candidate.entryId === preferredEntryId) ?? null;
      if (preferred) {
        if (canConsumeSpellUsage(character, preferred)) {
          return { candidate: preferred, reason: null };
        }
        return { candidate: null, reason: buildSpellCandidateFailureReason(preferred) };
      }
    }
    const ordered = [...candidates].sort((a2, b2) => {
      const delta = getSpellCandidatePriority(a2) - getSpellCandidatePriority(b2);
      if (delta !== 0) return delta;
      return String(a2.sourceKey).localeCompare(String(b2.sourceKey));
    });
    const chosen = ordered.find((candidate) => canConsumeSpellUsage(character, candidate)) ?? null;
    if (chosen) return { candidate: chosen, reason: null };
    const spellLevel = getSpellLevel(spellId);
    if (spellLevel > 0) {
      return { candidate: null, reason: `Aucun emplacement de sort niveau ${spellLevel}+ disponible.` };
    }
    return { candidate: null, reason: "Usages de sort epuises." };
  }
  function consumeSlotInCharacter(character, slotLevel, amount) {
    const spellcastingState2 = character == null ? void 0 : character.spellcastingState;
    if (!(spellcastingState2 == null ? void 0 : spellcastingState2.slots)) return character;
    const slots = { ...spellcastingState2.slots };
    const key2 = String(slotLevel);
    const currentEntry = slots[key2];
    if (typeof currentEntry === "number") {
      slots[key2] = Math.max(0, currentEntry - amount);
    } else if (currentEntry && typeof currentEntry === "object") {
      const nextEntry = { ...currentEntry };
      if (typeof nextEntry.remaining === "number") {
        nextEntry.remaining = Math.max(0, nextEntry.remaining - amount);
      } else if (typeof nextEntry.current === "number") {
        nextEntry.current = Math.max(0, nextEntry.current - amount);
      } else if (typeof nextEntry.value === "number") {
        nextEntry.value = Math.max(0, nextEntry.value - amount);
      }
      slots[key2] = nextEntry;
    }
    return {
      ...character,
      spellcastingState: {
        ...spellcastingState2,
        slots
      }
    };
  }
  function consumeSpellGrantUsesInCharacter(character, sourceKey, entryId, amount) {
    const spellcastingState2 = character == null ? void 0 : character.spellcastingState;
    const bySource = spellcastingState2 == null ? void 0 : spellcastingState2.spellGrants;
    if (!bySource || typeof bySource !== "object") return character;
    const currentEntries = Array.isArray(bySource[sourceKey]) ? bySource[sourceKey] : null;
    if (!currentEntries) return character;
    const nextEntries = currentEntries.map((entry) => {
      if (String((entry == null ? void 0 : entry.entryId) ?? "") !== entryId) return entry;
      const usage2 = entry == null ? void 0 : entry.usage;
      if (!usage2 || typeof usage2 !== "object") return entry;
      const maxUses = typeof usage2.maxUses === "number" && Number.isFinite(usage2.maxUses) ? Number(usage2.maxUses) : 0;
      const remainingBefore = typeof usage2.remainingUses === "number" && Number.isFinite(usage2.remainingUses) ? Number(usage2.remainingUses) : maxUses;
      return {
        ...entry,
        usage: {
          ...usage2,
          remainingUses: Math.max(0, remainingBefore - amount)
        }
      };
    });
    return {
      ...character,
      spellcastingState: {
        ...spellcastingState2,
        spellGrants: {
          ...bySource,
          [sourceKey]: nextEntries
        }
      }
    };
  }
  function consumeSpellUsageForPlayer(candidate) {
    const applyToCharacter = (character) => {
      if (candidate.consumesSlot && candidate.slotLevel !== null) {
        return consumeSlotInCharacter(character, candidate.slotLevel, 1);
      }
      const usageType = candidate.usageType.toLowerCase();
      if (usageType === "limited" || usageType === "charge") {
        return consumeSpellGrantUsesInCharacter(character, candidate.sourceKey, candidate.entryId, 1);
      }
      return character;
    };
    setCombatCharacterConfig((prev) => prev ? applyToCharacter(prev) : prev);
    setCharacterConfig((prev) => applyToCharacter(prev));
  }
  function getActionUsageForActor(actorId) {
    const current = actionUsageByActor[actorId];
    if (!current) return { turn: {}, combat: {} };
    return { turn: current.turn ?? {}, combat: current.combat ?? {} };
  }
  function updateActionUsageForActor(actorId, actionId, delta) {
    setActionUsageByActor((prev) => {
      const current = prev[actorId] ?? { turn: {}, combat: {} };
      const nextTurn = { ...current.turn };
      const nextCombat = { ...current.combat };
      const applyDelta = (map) => {
        const value2 = (map[actionId] ?? 0) + delta;
        map[actionId] = Math.max(0, value2);
      };
      applyDelta(nextTurn);
      applyDelta(nextCombat);
      return { ...prev, [actorId]: { turn: nextTurn, combat: nextCombat } };
    });
  }
  function resetTurnUsageForActor(actorId) {
    setActionUsageByActor((prev) => {
      const current = prev[actorId] ?? { combat: {} };
      return { ...prev, [actorId]: { turn: {}, combat: current.combat ?? {} } };
    });
  }
  function isSummonToken(token) {
    return Boolean(token.summonOwnerId || token.summonOwnerType);
  }
  function shouldSummonHaveTurnEntry(token) {
    const timing = token.summonTurnTiming ?? "after_player";
    if (timing === "player_turn") return false;
    if (token.summonInitiativeMode === "attach_to_player") return true;
    return timing !== "player_turn";
  }
  function getSummonTurnTiming(token) {
    if (token.summonInitiativeMode === "attach_to_player") return "after_player";
    const timing = token.summonTurnTiming ?? "after_player";
    return timing === "initiative" ? "initiative" : "after_player";
  }
  function applySummonTurnOrder(params) {
    const prevIds = new Set(params.prevEnemies.map((e2) => e2.id));
    const nextIds = new Set(params.nextEnemies.map((e2) => e2.id));
    const removedSummons = params.prevEnemies.filter(
      (e2) => isSummonToken(e2) && !nextIds.has(e2.id)
    );
    const addedSummons = params.nextEnemies.filter(
      (e2) => isSummonToken(e2) && !prevIds.has(e2.id)
    );
    if (removedSummons.length > 0) {
      setTurnOrder((prev) => prev.filter((entry) => !removedSummons.some((s2) => s2.id === entry.id)));
    }
    if (!hasRolledInitiative || addedSummons.length === 0) {
      return params.nextEnemies;
    }
    const nextEnemies = params.nextEnemies.map((enemy) => ({ ...enemy }));
    const rollD20 = () => Math.floor(Math.random() * 20) + 1;
    for (const summon of addedSummons) {
      if (!shouldSummonHaveTurnEntry(summon)) continue;
      const timing = getSummonTurnTiming(summon);
      let initiative = summon.initiative ?? null;
      if (summon.summonInitiativeMode === "roll_on_spawn" || typeof initiative !== "number") {
        initiative = rollD20();
      }
      const idx = nextEnemies.findIndex((e2) => e2.id === summon.id);
      if (idx >= 0) nextEnemies[idx] = { ...nextEnemies[idx], initiative };
      if (timing === "after_player") {
        setTurnOrder((prev) => {
          const playerIndex = prev.findIndex((entry2) => entry2.kind === "player");
          const insertIndex = playerIndex >= 0 ? playerIndex + 1 : prev.length;
          const entry = {
            id: summon.id,
            kind: "summon",
            initiative,
            ownerType: summon.summonOwnerType ?? summon.type,
            ownerId: summon.summonOwnerId ?? player.id
          };
          const next = prev.filter((e2) => e2.id !== summon.id);
          next.splice(insertIndex, 0, entry);
          return next;
        });
      } else {
        setTurnOrder((prev) => {
          const entry = {
            id: summon.id,
            kind: "summon",
            initiative,
            ownerType: summon.summonOwnerType ?? summon.type,
            ownerId: summon.summonOwnerId ?? player.id
          };
          const next = [...prev.filter((e2) => e2.id !== summon.id), entry];
          next.sort((a2, b2) => b2.initiative - a2.initiative);
          return next;
        });
      }
    }
    return nextEnemies;
  }
  function isTokenConcentrating(token) {
    return Boolean(token.concentration);
  }
  function isTokenSurprised(token) {
    var _a2;
    return Boolean((_a2 = token.statuses) == null ? void 0 : _a2.some((status) => status.id === "surprised"));
  }
  function getSeenTargetsForActor(actorId) {
    const existing = seenTargetsByActorRef.current.get(actorId);
    if (existing) return existing;
    const next = /* @__PURE__ */ new Set();
    seenTargetsByActorRef.current.set(actorId, next);
    return next;
  }
  function requestEnemyTurnPause() {
    if (enemyTurnPauseRef.current) return;
    let resolve = () => {
    };
    const promise2 = new Promise((res) => {
      resolve = res;
    });
    enemyTurnPauseRef.current = { promise: promise2, resolve };
  }
  async function waitForEnemyTurnResume() {
    const pause = enemyTurnPauseRef.current;
    if (pause) {
      await pause.promise;
    }
  }
  async function runSingleSummonTurn(summonId) {
    const summon = enemies.find((e2) => e2.id === summonId) ?? null;
    if (!summon) {
      advanceTurn();
      return;
    }
    let playerCopy = { ...player };
    let enemiesCopy = enemies.map((e2) => ({ ...e2 }));
    playerCopy = applyWeaponMasteryStartExpiryForToken(playerCopy, summonId);
    enemiesCopy = enemiesCopy.map(
      (enemy) => applyWeaponMasteryStartExpiryForToken(enemy, summonId)
    );
    setPlayer(playerCopy);
    setEnemies(enemiesCopy);
    const actor = enemiesCopy.find((e2) => e2.id === summonId) ?? summon;
    const allTokens = getTokensOnActiveLevel([playerCopy, ...enemiesCopy]);
    const hostiles = getHostileTokensFor(actor, allTokens).filter((t2) => t2.id !== actor.id);
    const order = resolveSummonOrderTarget({
      summon: actor,
      allTokens,
      hostiles
    });
    if (order.kind === "hold") {
      pushLog2(`Summon ${actor.id}: reste en attente.`);
      advanceTurn();
      return;
    }
    const actionIds2 = Array.isArray(actor.actionIds) && actor.actionIds.length ? actor.actionIds : ["move", "melee-strike"];
    const getActionById2 = (id2) => actionsCatalog.find((a2) => a2.id === id2) ?? null;
    const tryResolve = (actionId, target) => {
      const baseAction = getActionById2(actionId);
      const action2 = baseAction ? applyWeaponOverrideForActor(baseAction, actor) : null;
      if (!action2) return false;
      const result = resolveActionUnified(
        action2,
        {
          round: round2,
          phase: "player",
          actor,
          player: playerCopy,
          enemies: enemiesCopy,
          blockedMovementCells: obstacleBlocking.movement,
          blockedMovementEdges: wallEdges.movement,
          blockedVisionCells: visionBlockersActive,
          blockedAttackCells: obstacleBlocking.attacks,
          wallVisionEdges: wallEdges.vision,
          lightLevels,
          playableCells,
          grid: mapGrid,
          heightMap: mapHeight,
          floorIds: mapTerrain,
          activeLevel,
          sampleCharacter: activeCharacterConfig,
          getSlotAmount: (slot, level2) => getSlotAmountFromCharacter(actor, slot, level2),
          usage: getActionUsageForActor(actor.id),
          reactionAvailable: canUseReaction(actor.id),
          concentrating: isTokenConcentrating(actor),
          surprised: isTokenSurprised(actor),
          getActionConstraintIssues: ({ action: action22, actor: actor2 }) => {
            var _a2;
            return getWeaponActionConstraintIssues(action22, actor2, {
              reaction: ((_a2 = action22.actionCost) == null ? void 0 : _a2.actionType) === "reaction"
            });
          },
          spawnEntity: createSummon,
          onLog: pushLog2
        },
        target,
        { weaponMasteryActions }
      );
      if (!result.ok || !result.playerAfter || !result.enemiesAfter) return false;
      playerCopy = result.playerAfter;
      enemiesCopy = applySummonTurnOrder({
        prevEnemies: enemiesCopy,
        nextEnemies: result.enemiesAfter
      });
      setPlayer(playerCopy);
      setEnemies(enemiesCopy);
      updateActionUsageForActor(actor.id, action2.id, 1);
      updateWeaponPropertyUsageForAction(actor.id, action2, 1);
      return true;
    };
    const targetToken = order.target ?? null;
    const attackActions = actionIds2.map((id2) => getActionById2(id2)).filter((action2) => action2 && action2.category === "attack");
    if (targetToken && attackActions.length > 0) {
      for (const action2 of attackActions) {
        const ok = tryResolve(action2.id, { kind: "token", token: targetToken });
        if (ok) {
          advanceTurn();
          return;
        }
      }
    }
    if (order.kind === "follow_owner" && targetToken) {
      const moveActionId = actionIds2.includes("move") ? "move" : null;
      if (moveActionId) {
        const path2 = computePathTowards(
          actor,
          { x: targetToken.x, y: targetToken.y },
          allTokens,
          {
            maxDistance: metersToCells(actor.moveRange ?? 3),
            allowTargetOccupied: false,
            blockedCells: obstacleBlocking.movement,
            wallEdges: wallEdges.movement,
            playableCells,
            grid: mapGrid,
            heightMap: mapHeight,
            floorIds: mapTerrain,
            activeLevel
          }
        );
        if (path2.length) {
          const destination = path2[path2.length - 1];
          const ok = tryResolve(moveActionId, {
            kind: "cell",
            x: destination.x,
            y: destination.y
          });
          if (ok) {
            advanceTurn();
            return;
          }
        }
      }
    }
    pushLog2(`Summon ${actor.id}: aucune action possible.`);
    advanceTurn();
  }
  function getHostileTokensFor(actor, allTokens) {
    const actorSide = actor.summonOwnerType ?? actor.type;
    return allTokens.filter((token) => {
      const side = token.summonOwnerType ?? token.type;
      return side !== actorSide;
    });
  }
  function resolveSummonOrderTarget(params) {
    var _a2;
    const { summon, allTokens, hostiles } = params;
    const order = ((_a2 = summon.summonOrder) == null ? void 0 : _a2.kind) ?? "attack_nearest";
    const obeyChance = typeof summon.summonObeyChance === "number" ? summon.summonObeyChance : 1;
    const shouldObey = Math.random() <= Math.max(0, Math.min(1, obeyChance));
    const effectiveOrder = shouldObey ? order : "attack_nearest";
    if (effectiveOrder === "hold") {
      return { kind: "hold" };
    }
    if (effectiveOrder === "follow_owner") {
      const ownerId = summon.summonOwnerId;
      const owner = ownerId === player.id ? player : allTokens.find((token) => token.id === ownerId) ?? null;
      return { kind: "follow_owner", target: owner };
    }
    if (hostiles.length === 0) return { kind: "attack_nearest", target: null };
    let best = null;
    let bestDist = Number.POSITIVE_INFINITY;
    for (const hostile of hostiles) {
      const dist = distanceBetweenTokens(summon, hostile);
      if (dist < bestDist) {
        bestDist = dist;
        best = hostile;
      }
    }
    return { kind: "attack_nearest", target: best };
  }
  function markTargetsSeen(actorId, targets) {
    const seen2 = getSeenTargetsForActor(actorId);
    for (const target of targets) {
      seen2.add(target.id);
    }
  }
  function pushHpPopup(token, delta) {
    if (!Number.isFinite(delta) || delta === 0) return;
    const anchor2 = resolveAnchorForCell({ x: token.x, y: token.y });
    if (!anchor2) return;
    const id2 = `hp-${token.id}-${Date.now()}-${Math.random().toString(36).slice(2, 7)}`;
    const text = delta > 0 ? `+${delta}` : `${delta}`;
    const color = delta > 0 ? "#2ecc71" : "#e74c3c";
    const x2 = anchor2.anchorX;
    const y2 = anchor2.anchorY - 24;
    setHpPopups((prev) => [...prev, { id: id2, x: x2, y: y2, text, color }]);
    window.setTimeout(() => {
      setHpPopups((prev) => prev.filter((popup) => popup.id !== id2));
    }, 2600);
  }
  function showReactionToast(text, kind2 = "info") {
    if (!text) return;
    if (reactionToastTimerRef.current) {
      window.clearTimeout(reactionToastTimerRef.current);
    }
    const id2 = `reaction-${Date.now()}-${Math.random().toString(36).slice(2, 7)}`;
    setReactionToast({ id: id2, text, kind: kind2 });
    reactionToastTimerRef.current = window.setTimeout(() => {
      setReactionToast((current) => (current == null ? void 0 : current.id) === id2 ? null : current);
      reactionToastTimerRef.current = null;
    }, 3200);
  }
  function showCombatToast(text, kind2 = "info") {
    if (!text) return;
    if (combatToastTimerRef.current) {
      window.clearTimeout(combatToastTimerRef.current);
    }
    const id2 = `combat-${Date.now()}-${Math.random().toString(36).slice(2, 7)}`;
    setCombatToast({ id: id2, text, kind: kind2 });
    const COMBAT_TOAST_DURATION_MS = 5200;
    combatToastTimerRef.current = window.setTimeout(() => {
      setCombatToast((current) => (current == null ? void 0 : current.id) === id2 ? null : current);
      combatToastTimerRef.current = null;
    }, COMBAT_TOAST_DURATION_MS);
  }
  function formatDamageTypeLabel(damageType) {
    if (!damageType) return null;
    const normalized = damageType.toString().trim().toUpperCase();
    if (!normalized) return null;
    const labels = {
      BLUDGEONING: "contondant",
      PIERCING: "perforant",
      SLASHING: "tranchant",
      FIRE: "feu",
      COLD: "froid",
      LIGHTNING: "foudre",
      THUNDER: "tonnerre",
      POISON: "poison",
      ACID: "acide",
      NECROTIC: "necrotique",
      RADIANT: "radiant",
      PSYCHIC: "psychique",
      FORCE: "force"
    };
    return labels[normalized] ?? normalized.toLowerCase();
  }
  function buildDamageTypeSuffix(damageType) {
    const label2 = formatDamageTypeLabel(damageType);
    return label2 ? `, type ${label2}` : "";
  }
  function reactionCombatKey(actorId, reactionId) {
    return `${actorId}:${reactionId}`;
  }
  function isPhysicalResource(name2) {
    return Boolean(physicalResourceMap[name2.toLowerCase()]);
  }
  function getResourceAmount(name2, pool) {
    if (isPhysicalResource(name2)) {
      return getInventoryResourceCount(activeCharacterConfig, name2);
    }
    const key2 = resourceKey(name2, pool);
    return typeof playerResources[key2] === "number" ? playerResources[key2] : 0;
  }
  function canUseReaction(actorId) {
    return (reactionUsage[actorId] ?? 0) < 1;
  }
  function resetReactionUsageForActor(actorId) {
    setReactionUsage((prev) => ({ ...prev, [actorId]: 0 }));
  }
  function markReactionUsed(actorId) {
    setReactionUsage((prev) => ({ ...prev, [actorId]: (prev[actorId] ?? 0) + 1 }));
  }
  function hasReactionUsedInCombat(actorId, reactionId) {
    const key2 = reactionCombatKey(actorId, reactionId);
    return (reactionCombatUsage[key2] ?? 0) > 0;
  }
  function markReactionUsedInCombat(actorId, reactionId) {
    const key2 = reactionCombatKey(actorId, reactionId);
    setReactionCombatUsage((prev) => ({ ...prev, [key2]: (prev[key2] ?? 0) + 1 }));
  }
  function getTokensOnActiveLevel(tokens) {
    return tokens.filter((t2) => getBaseHeightAt(t2.x, t2.y) === activeLevel);
  }
  function areTokensOnSameLevel(a2, b2) {
    return getBaseHeightAt(a2.x, a2.y) === getBaseHeightAt(b2.x, b2.y);
  }
  function getEnemyTypeForToken(token) {
    if (token.type !== "enemy") return null;
    const id2 = token.enemyTypeId ?? "";
    return enemyTypeById2.get(id2) ?? null;
  }
  function resolveCombatProfile(token) {
    var _a2, _b2;
    const enemyType = getEnemyTypeForToken(token);
    const raw = (enemyType == null ? void 0 : enemyType.combatProfile) ?? {};
    const fallbackPrimary = token.aiRole === "archer" ? "ranged" : "melee";
    const primaryStyle = raw.primaryStyle ?? fallbackPrimary;
    const allowedStyles = raw.allowedStyles && raw.allowedStyles.length > 0 ? raw.allowedStyles : [primaryStyle];
    const preferredAbilities = raw.preferredAbilities && raw.preferredAbilities.length > 0 ? raw.preferredAbilities : [primaryStyle === "ranged" ? "DEX" : "FOR"];
    const preferredRangeMin = raw.preferredRangeMin ?? ((_a2 = enemyType == null ? void 0 : enemyType.behavior) == null ? void 0 : _a2.preferredRangeMin) ?? (primaryStyle === "ranged" ? 2 : 1);
    const preferredRangeMax = raw.preferredRangeMax ?? ((_b2 = enemyType == null ? void 0 : enemyType.behavior) == null ? void 0 : _b2.preferredRangeMax) ?? (primaryStyle === "ranged" ? 6 : 1);
    const intelligence = raw.intelligence ?? 0;
    const awareness = raw.awareness ?? 0;
    const tactics = Array.isArray(raw.tactics) ? raw.tactics : [];
    return {
      ...raw,
      primaryStyle,
      allowedStyles,
      preferredAbilities,
      preferredRangeMin,
      preferredRangeMax,
      intelligence,
      awareness,
      tactics
    };
  }
  function getEnemyMemory(enemyId) {
    const existing = enemyMemoryRef.current.get(enemyId);
    if (existing) return existing;
    const next = {};
    enemyMemoryRef.current.set(enemyId, next);
    return next;
  }
  function updateEnemyMemory(enemyId, patch) {
    const current = getEnemyMemory(enemyId);
    enemyMemoryRef.current.set(enemyId, { ...current, ...patch });
  }
  function classifyFailureReason(reason) {
    const text = (reason ?? "").toLowerCase();
    if (!text) return "unknown";
    if (text.includes("portee") || text.includes("distance")) return "out_of_range";
    if (text.includes("vision") || text.includes("ligne")) return "no_los";
    if (text.includes("cible")) return "no_target";
    return "other";
  }
  function getActiveTeamAlert() {
    const alert = teamAlertRef.current;
    if (!alert) return null;
    if (round2 > alert.expiresRound) {
      teamAlertRef.current = null;
      return null;
    }
    return alert;
  }
  function fuzzAlertPosition(pos) {
    const dx = Math.round(Math.random() * 2 - 1);
    const dy = Math.round(Math.random() * 2 - 1);
    const x2 = clamp$5(pos.x + dx, 0, mapGrid.cols - 1);
    const y2 = clamp$5(pos.y + dy, 0, mapGrid.rows - 1);
    if (isCellPlayable(x2, y2)) return { x: x2, y: y2 };
    return { x: pos.x, y: pos.y };
  }
  function broadcastTeamAlert(source2, position, confidence) {
    const payload = {
      sourceId: source2.id,
      position,
      createdRound: round2,
      expiresRound: round2 + 2,
      confidence
    };
    teamAlertRef.current = payload;
    setEnemyBubble(source2.id, "Je l'ai repere, par la !");
  }
  function getActionStyle(action2) {
    var _a2, _b2, _c2, _d, _e;
    if (action2.category === "movement" || ((_a2 = action2.tags) == null ? void 0 : _a2.includes("movement"))) {
      return "move";
    }
    if (action2.category === "support") return "support";
    const rangeMax = ((_c2 = (_b2 = action2.targeting) == null ? void 0 : _b2.range) == null ? void 0 : _c2.max) ?? 1;
    if (((_d = action2.tags) == null ? void 0 : _d.includes("melee")) || rangeMax <= 1.5) return "melee";
    if (((_e = action2.tags) == null ? void 0 : _e.includes("distance")) || rangeMax > 1.5) return "ranged";
    return "other";
  }
  function scoreActionForEnemy(params) {
    var _a2;
    const { action: action2, profile, distanceToPlayer, memory } = params;
    const style = getActionStyle(action2);
    if (style === "move" || style === "other") return -100;
    if (!profile.allowedStyles.includes(style)) return -100;
    let score = 0;
    if (style === profile.primaryStyle) score += 30;
    if (profile.preferredAbilities.includes("FOR") && style === "melee") score += 10;
    if (profile.preferredAbilities.includes("DEX") && style === "ranged") score += 10;
    const range = (_a2 = action2.targeting) == null ? void 0 : _a2.range;
    const min = (range == null ? void 0 : range.min) ?? 0;
    const max = (range == null ? void 0 : range.max) ?? 1;
    const inRange = distanceToPlayer >= min && distanceToPlayer <= max;
    score += inRange ? 15 : -25;
    const preferredMin = profile.preferredRangeMin;
    const preferredMax = profile.preferredRangeMax;
    if (distanceToPlayer >= preferredMin && distanceToPlayer <= preferredMax) {
      score += 8;
    } else {
      score -= 8;
    }
    if (memory.lastFailedReason === "out_of_range" && !inRange) {
      score -= 20;
    }
    if (memory.lastEffectiveActionId === action2.id) {
      score += 4;
    }
    return score;
  }
  function buildEnemyActionContext(params) {
    return {
      round: round2,
      phase: "enemies",
      actor: params.actor,
      player: params.playerSnapshot,
      enemies: params.enemiesSnapshot,
      blockedMovementCells: obstacleBlocking.movement,
      blockedMovementEdges: wallEdges.movement,
      blockedVisionCells: visionBlockersActive,
      blockedAttackCells: obstacleBlocking.attacks,
      wallVisionEdges: wallEdges.vision,
      lightLevels,
      playableCells,
      grid: mapGrid,
      heightMap: mapHeight,
      floorIds: mapTerrain,
      activeLevel,
      sampleCharacter: activeCharacterConfig,
      getSlotAmount: (slot, level2) => getSlotAmountFromCharacter(params.actor, slot, level2),
      usage: getActionUsageForActor(params.actor.id),
      reactionAvailable: canUseReaction(params.actor.id),
      concentrating: isTokenConcentrating(params.actor),
      surprised: isTokenSurprised(params.actor),
      getActionConstraintIssues: ({ action: action2, actor }) => {
        var _a2;
        return getWeaponActionConstraintIssues(action2, actor, {
          reaction: ((_a2 = action2.actionCost) == null ? void 0 : _a2.actionType) === "reaction"
        });
      },
      spawnEntity: createSummon,
      onLog: pushLog2
    };
  }
  const computePathCost = (path2) => {
    if (!path2.length) return 0;
    const cols = mapGrid.cols;
    const rows = mapGrid.rows;
    let total = 0;
    for (const cell of path2) {
      if (!isCellInsideGrid(cell.x, cell.y, cols, rows)) continue;
      const idx = cell.y * cols + cell.x;
      if (idx < 0 || idx >= mapTerrain.length) continue;
      const mat = getFloorMaterial(mapTerrain[idx]);
      const cost = Number((mat == null ? void 0 : mat.moveCost) ?? 1);
      if (!Number.isFinite(cost) || cost <= 0) continue;
      total += cost;
    }
    return Math.round(total * 10) / 10;
  };
  const selectedPathCost = reactExports.useMemo(
    () => computePathCost(selectedPath),
    [mapGrid, mapTerrain, selectedPath]
  );
  reactExports.useEffect(() => {
    if (phase !== "player" || isGameOver) {
      setInteractionMode("idle");
      closeRadialMenu();
      closeInteractionContext();
    }
  }, [phase, isGameOver]);
  reactExports.useEffect(() => {
    const handler = (event) => {
      if (event.key !== "Escape") return;
      if (targetMode === "selecting") {
        setTargetMode("none");
        return;
      }
      if (interactionMode !== "idle") {
        setInteractionMode("idle");
      }
    };
    window.addEventListener("keydown", handler);
    return () => window.removeEventListener("keydown", handler);
  }, [interactionMode, targetMode]);
  function handleBoardWheel(event) {
    if (event.deltaY === 0) return;
    event.preventDefault();
    const direction = event.deltaY < 0 ? 1 : -1;
    const nextZoom = clamp$5(
      Math.round((boardZoom + direction * ZOOM_STEP) * 10) / 10,
      ZOOM_MIN,
      ZOOM_MAX
    );
    if (Math.abs(nextZoom - boardZoom) < 1e-6) return;
    const viewport = viewportRef.current;
    if (!viewport) {
      setBoardZoom(nextZoom);
      return;
    }
    const target = event.currentTarget;
    if (!(target instanceof HTMLDivElement)) return;
    const rect = target.getBoundingClientRect();
    const localX = event.clientX - rect.left;
    const localY = event.clientY - rect.top;
    const { scale, offsetX, offsetY } = viewport;
    const boardX = (localX - offsetX) / scale;
    const boardY = (localY - offsetY) / scale;
    const boardW = getBoardWidth(mapGrid.cols);
    const boardH = getBoardHeight(mapGrid.rows);
    const baseScale = scale / boardZoom;
    const nextScale = baseScale * nextZoom;
    const nextOffsetX = localX - boardX * nextScale;
    const nextOffsetY = localY - boardY * nextScale;
    const width = Math.max(1, target.clientWidth);
    const height = Math.max(1, target.clientHeight);
    const nextPanX = nextOffsetX - (width - boardW * nextScale) / 2;
    const nextPanY = nextOffsetY - (height - boardH * nextScale) / 2;
    setBoardZoom(nextZoom);
    setBoardPan({ x: nextPanX, y: nextPanY });
  }
  reactExports.useEffect(() => {
    const container = pixiContainerRef.current;
    if (!container) return;
    const handler = (event) => {
      handleBoardWheel(event);
    };
    container.addEventListener("wheel", handler, { passive: false });
    return () => {
      container.removeEventListener("wheel", handler);
    };
  }, [boardZoom, mapGrid.cols, mapGrid.rows, viewportRef]);
  async function queueMapTexturePreload(params) {
    var _a2;
    const tokenRequests = [];
    const addToken = (token) => {
      var _a3, _b2;
      const spriteKey = (_a3 = token == null ? void 0 : token.appearance) == null ? void 0 : _a3.spriteKey;
      if (!spriteKey) return;
      tokenRequests.push({
        spriteKey,
        variants: ((_b2 = token == null ? void 0 : token.appearance) == null ? void 0 : _b2.spriteVariants) ?? null
      });
    };
    addToken(params.player);
    for (const enemy of params.enemies) addToken(enemy);
    const obstacleSpriteKeys = /* @__PURE__ */ new Set();
    for (const obstacle of params.obstacles) {
      const def = obstacleTypeById.get(obstacle.typeId) ?? null;
      const appearance2 = (def == null ? void 0 : def.appearance) ?? null;
      if (appearance2 == null ? void 0 : appearance2.spriteKey) obstacleSpriteKeys.add(appearance2.spriteKey);
      if (appearance2 == null ? void 0 : appearance2.shadowSpriteLeafy) obstacleSpriteKeys.add(appearance2.shadowSpriteLeafy);
      if (appearance2 == null ? void 0 : appearance2.shadowSpriteLeafless) obstacleSpriteKeys.add(appearance2.shadowSpriteLeafless);
      for (const layer of (appearance2 == null ? void 0 : appearance2.layers) ?? []) {
        if (layer == null ? void 0 : layer.spriteKey) obstacleSpriteKeys.add(layer.spriteKey);
      }
    }
    const effectSpriteKeys = /* @__PURE__ */ new Set();
    for (const effect of params.effects) {
      const def = effectTypeById.get(effect.typeId);
      const spriteKey = (_a2 = def == null ? void 0 : def.appearance) == null ? void 0 : _a2.spriteKey;
      if (spriteKey) effectSpriteKeys.add(spriteKey);
    }
    const decorSpriteKeys = /* @__PURE__ */ new Set();
    for (const decor of params.decorations) {
      if (decor == null ? void 0 : decor.spriteKey) decorSpriteKeys.add(decor.spriteKey);
    }
    const obstacleKeys = /* @__PURE__ */ new Set([...obstacleSpriteKeys, ...effectSpriteKeys]);
    const totalCount = tokenRequests.length + obstacleKeys.size + decorSpriteKeys.size;
    if (totalCount === 0) return;
    const hint = `textures: ${tokenRequests.length} tokens, ${obstacleKeys.size} obstacles/effects, ${decorSpriteKeys.size} decors`;
    textureLoadingCounterRef.current += 1;
    if (textureLoadingCounterRef.current === 1) {
      setIsTextureLoading(true);
    }
    setTextureLoadingHint(hint);
    const start = typeof performance !== "undefined" ? performance.now() : Date.now();
    const minDurationMs = 350;
    try {
      const tasks = [];
      if (tokenRequests.length > 0) {
        tasks.push(preloadTokenPngTexturesFor(tokenRequests));
      }
      if (obstacleKeys.size > 0) {
        tasks.push(preloadObstaclePngTexturesFor([...obstacleKeys]));
      }
      if (decorSpriteKeys.size > 0) {
        tasks.push(preloadDecorTexturesFor([...decorSpriteKeys]));
      }
      await Promise.all(tasks);
    } catch (error) {
      console.warn("[textures] preload failed:", error);
    } finally {
      const end = typeof performance !== "undefined" ? performance.now() : Date.now();
      const elapsed = end - start;
      if (elapsed < minDurationMs) {
        await new Promise((resolve) => setTimeout(resolve, minDurationMs - elapsed));
      }
      textureLoadingCounterRef.current = Math.max(0, textureLoadingCounterRef.current - 1);
      if (textureLoadingCounterRef.current === 0) {
        setIsTextureLoading(false);
        setTextureLoadingHint(null);
      }
    }
  }
  function getClassLevelForCharacter(character, classId2) {
    const entries = Object.values((character == null ? void 0 : character.classe) ?? {});
    let best = 0;
    for (const entry of entries) {
      const id2 = String((entry == null ? void 0 : entry.classeId) ?? "").toLowerCase();
      if (id2 !== classId2.toLowerCase()) continue;
      const level2 = Number((entry == null ? void 0 : entry.niveau) ?? 0);
      if (Number.isFinite(level2)) best = Math.max(best, level2);
    }
    return best;
  }
  function getHighestClassLevel(character) {
    const entries = Object.values((character == null ? void 0 : character.classe) ?? {});
    let best = 0;
    for (const entry of entries) {
      const level2 = Number((entry == null ? void 0 : entry.niveau) ?? 0);
      if (Number.isFinite(level2)) best = Math.max(best, level2);
    }
    return best > 0 ? best : Number(character.niveauGlobal ?? 1) || 1;
  }
  function getClassLevelForSubclass(character, subclassId) {
    const entries = Object.values((character == null ? void 0 : character.classe) ?? {});
    let best = 0;
    for (const entry of entries) {
      const id2 = String((entry == null ? void 0 : entry.subclasseId) ?? "").toLowerCase();
      if (id2 !== subclassId.toLowerCase()) continue;
      const level2 = Number((entry == null ? void 0 : entry.niveau) ?? 0);
      if (Number.isFinite(level2)) best = Math.max(best, level2);
    }
    return best;
  }
  function deriveRuntimeFromFeatures(character) {
    var _a2, _b2, _c2, _d, _e, _f, _g;
    const featureDefs = featureTypes.length > 0 ? featureTypes : loadFeatureTypesFromIndex();
    const featureById = /* @__PURE__ */ new Map();
    for (const feature of featureDefs) {
      if (feature == null ? void 0 : feature.id) featureById.set(feature.id, feature);
    }
    const featureIds = Array.isArray((_b2 = (_a2 = character == null ? void 0 : character.derived) == null ? void 0 : _a2.grants) == null ? void 0 : _b2.features) ? character.derived.grants.features : [];
    const directActionIds = Array.isArray((_d = (_c2 = character == null ? void 0 : character.derived) == null ? void 0 : _c2.grants) == null ? void 0 : _d.actions) ? character.derived.grants.actions : [];
    const directReactionIds = Array.isArray((_f = (_e = character == null ? void 0 : character.derived) == null ? void 0 : _e.grants) == null ? void 0 : _f.reactions) ? character.derived.grants.reactions : [];
    const actionIds2 = /* @__PURE__ */ new Set();
    const reactionIds2 = /* @__PURE__ */ new Set();
    const resources = {};
    const progressionEntries = Array.isArray(character == null ? void 0 : character.progressionHistory) ? character.progressionHistory : [];
    const featureSourceById = /* @__PURE__ */ new Map();
    progressionEntries.forEach((entry) => {
      if ((entry == null ? void 0 : entry.type) !== "grant") return;
      const payload = (entry == null ? void 0 : entry.payload) ?? {};
      if (String((payload == null ? void 0 : payload.kind) ?? "").toLowerCase() !== "feature") return;
      const ids = Array.isArray(payload == null ? void 0 : payload.ids) ? payload.ids : [];
      const source2 = String((payload == null ? void 0 : payload.source) ?? (entry == null ? void 0 : entry.source) ?? "");
      const level2 = Number((payload == null ? void 0 : payload.level) ?? (entry == null ? void 0 : entry.level) ?? 0);
      ids.forEach((id2) => {
        const key2 = String(id2);
        if (!key2) return;
        const list = featureSourceById.get(key2) ?? [];
        list.push({ source: source2, level: Number.isFinite(level2) ? level2 : 0 });
        featureSourceById.set(key2, list);
      });
    });
    const resolveScaleLevel = (featureId, grant) => {
      const meta = (grant == null ? void 0 : grant.meta) ?? {};
      const scaleRaw = meta.scale ?? null;
      const sourceContexts = featureSourceById.get(String(featureId)) ?? [];
      const levelFromSource = (source2) => {
        const normalized = String(source2 ?? "").trim().toLowerCase();
        if (!normalized) return 0;
        if (normalized.startsWith("class:")) {
          return getClassLevelForCharacter(character, normalized.slice("class:".length));
        }
        if (normalized.startsWith("subclass:")) {
          return getClassLevelForSubclass(character, normalized.slice("subclass:".length));
        }
        return 0;
      };
      if (typeof scaleRaw === "string") {
        const value2 = scaleRaw.trim().toLowerCase();
        if (value2 === "character_level") return Number(character.niveauGlobal ?? 1) || 1;
        if (value2 === "highest_class") return getHighestClassLevel(character);
        if (value2.startsWith("class:")) {
          return getClassLevelForCharacter(character, value2.slice("class:".length));
        }
        if (value2.startsWith("subclass:")) {
          return getClassLevelForSubclass(character, value2.slice("subclass:".length));
        }
        return getClassLevelForCharacter(character, value2);
      }
      if (scaleRaw && typeof scaleRaw === "object") {
        const basis = String(scaleRaw.basis ?? "").trim().toLowerCase();
        if (basis === "character_level") return Number(character.niveauGlobal ?? 1) || 1;
        if (basis === "highest_class") return getHighestClassLevel(character);
        if (basis === "class") {
          const classId2 = String(scaleRaw.classId ?? "").trim();
          if (classId2) return getClassLevelForCharacter(character, classId2);
        }
        if (basis === "source") {
          const source2 = String(scaleRaw.source ?? "").trim();
          const level2 = levelFromSource(source2);
          if (level2 > 0) return level2;
        }
      }
      const contextMax = sourceContexts.reduce((best, ctx) => {
        const fromSource = levelFromSource(ctx.source);
        if (fromSource > 0) return Math.max(best, fromSource);
        if (Number.isFinite(ctx.level)) return Math.max(best, Number(ctx.level));
        return best;
      }, 0);
      if (contextMax > 0) return contextMax;
      return getHighestClassLevel(character);
    };
    const resolveMaxFromGrant = (featureId, grant) => {
      const meta = (grant == null ? void 0 : grant.meta) ?? {};
      const directMax = Number(meta.max ?? NaN);
      if (Number.isFinite(directMax) && directMax >= 0) return directMax;
      const maxByLevel = meta.maxByLevel ?? {};
      const scaleLevel = resolveScaleLevel(featureId, grant);
      let max = 0;
      Object.entries(maxByLevel).map(([lvl, value2]) => [Number(lvl), Number(value2)]).filter(([lvl, value2]) => Number.isFinite(lvl) && Number.isFinite(value2) && lvl > 0 && value2 >= 0).sort((a2, b2) => a2[0] - b2[0]).forEach(([lvl, value2]) => {
        if (scaleLevel >= lvl) max = value2;
      });
      return max;
    };
    directActionIds.forEach((id2) => {
      const key2 = String(id2);
      if (key2) actionIds2.add(key2);
    });
    directReactionIds.forEach((id2) => {
      const key2 = String(id2);
      if (key2) reactionIds2.add(key2);
    });
    for (const featureId of featureIds) {
      const feature = featureById.get(String(featureId));
      if (!feature) continue;
      const grants2 = Array.isArray(feature.grants) ? feature.grants : [];
      for (const grant of grants2) {
        const ids = Array.isArray(grant == null ? void 0 : grant.ids) ? grant.ids : [];
        if ((grant == null ? void 0 : grant.kind) === "action") {
          ids.forEach((id2) => actionIds2.add(String(id2)));
          continue;
        }
        if ((grant == null ? void 0 : grant.kind) === "reaction") {
          ids.forEach((id2) => reactionIds2.add(String(id2)));
          continue;
        }
        if ((grant == null ? void 0 : grant.kind) !== "resource") continue;
        const max = resolveMaxFromGrant(String(featureId), grant);
        const pool = (_g = grant == null ? void 0 : grant.meta) == null ? void 0 : _g.pool;
        const poolKey = typeof pool === "string" && pool.trim() ? pool.trim() : null;
        ids.forEach((id2) => {
          const key2 = resourceKey(String(id2), poolKey);
          resources[key2] = Math.max(resources[key2] ?? 0, max);
        });
      }
    }
    return {
      actionIds: Array.from(actionIds2),
      reactionIds: Array.from(reactionIds2),
      resources
    };
  }
  function handleStartCombat() {
    var _a2, _b2;
    if (enemyTypes.length === 0) {
      pushLog2(
        "Aucun type d'ennemi charge (enemyTypes). Impossible de generer le combat."
      );
      return;
    }
    const loadActiveSavedCharacter = () => {
      if (typeof window === "undefined") return null;
      try {
        const activeId = window.localStorage.getItem("jdr5e_active_sheet");
        if (!activeId) return null;
        const raw = window.localStorage.getItem("jdr5e_saved_sheets");
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        if (!Array.isArray(parsed)) return null;
        const entry = parsed.find((item) => item && item.id === activeId);
        return (entry == null ? void 0 : entry.character) ?? null;
      } catch {
        return null;
      }
    };
    const savedCharacter = loadActiveSavedCharacter();
    const sheetValidated = Boolean((_a2 = characterConfig.choiceSelections) == null ? void 0 : _a2.sheetValidated);
    const combatCharacter = savedCharacter ?? (sheetValidated ? characterConfig : sampleCharacter);
    setCombatCharacterConfig(JSON.parse(JSON.stringify(combatCharacter)));
    const combatMovementModes = getMovementModesForCharacter(combatCharacter);
    const combatDefaultMovementMode = combatMovementModes[0] ?? getDefaultMovementMode();
    const combatDefaultMovementProfile = buildMovementProfileFromMode(combatDefaultMovementMode);
    const combatVisionProfile = combatCharacter.visionProfile ?? {
      shape: "cone",
      range: 100,
      apertureDeg: 180,
      lightVision: "normal"
    };
    const combatBuiltStats = buildCombatStatsFromCharacter(combatCharacter, armorItemsById);
    const combatBaseStats = combatCharacter.combatStats ? { ...combatBuiltStats, ...combatCharacter.combatStats, armorClass: combatBuiltStats.armorClass } : combatBuiltStats;
    const combatPlayerStats = {
      ...combatBaseStats,
      moveRange: combatDefaultMovementProfile.speed,
      maxHp: combatBaseStats.maxHp,
      actionsPerTurn: combatBaseStats.actionsPerTurn ?? 1,
      bonusActionsPerTurn: combatBaseStats.bonusActionsPerTurn ?? 1,
      actionRules: combatBaseStats.actionRules ?? { forbidSecondAttack: true }
    };
    const featureRuntime = deriveRuntimeFromFeatures(combatCharacter);
    const combatActionIds = Array.from(
      /* @__PURE__ */ new Set([
        ...CORE_BASE_ACTION_IDS,
        ...Array.isArray(combatCharacter.actionIds) ? combatCharacter.actionIds : [],
        ...featureRuntime.actionIds
      ])
    );
    const combatReactionIds = Array.from(
      /* @__PURE__ */ new Set([
        ...Array.isArray(combatCharacter.reactionIds) ? combatCharacter.reactionIds : [],
        ...featureRuntime.reactionIds
      ])
    );
    const baseResourcesFromStats = {};
    const statsResources = ((_b2 = combatCharacter == null ? void 0 : combatCharacter.combatStats) == null ? void 0 : _b2.resources) ?? {};
    Object.entries(statsResources).forEach(([name2, value2]) => {
      if (typeof value2 === "number" && Number.isFinite(value2)) {
        baseResourcesFromStats[resourceKey(name2, null)] = value2;
        return;
      }
      if (typeof (value2 == null ? void 0 : value2.current) === "number" && Number.isFinite(value2.current)) {
        baseResourcesFromStats[resourceKey(name2, null)] = value2.current;
      }
    });
    const initialPlayerResources = { ...baseResourcesFromStats, ...featureRuntime.resources };
    let grid = { ...mapGrid };
    let map = generateBattleMap({
      prompt: mapPrompt,
      grid,
      enemyCount: configEnemyCount,
      enemyTypes,
      obstacleTypes,
      wallTypes
    });
    let safety = 0;
    while (safety < 3) {
      const rec = map.recommendedGrid;
      if (!rec || rec.cols <= grid.cols && rec.rows <= grid.rows) break;
      pushLog2(`[map] Redimensionnement automatique: ${grid.cols}x${grid.rows} -> ${rec.cols}x${rec.rows} (${rec.reason}).`);
      grid = { cols: rec.cols, rows: rec.rows };
      map = generateBattleMap({
        prompt: mapPrompt,
        grid,
        enemyCount: configEnemyCount,
        enemyTypes,
        obstacleTypes,
        wallTypes
      });
      safety++;
    }
    const generationLines = Array.isArray(map.generationLog) ? map.generationLog.map((line) => `[map] ${line}`) : [];
    pushLogBatch([map.summary, ...generationLines]);
    setMapTheme(map.theme ?? "generic");
    setMapPaletteId(map.paletteId ?? null);
    grid = map.grid ?? grid;
    setMapGrid(grid);
    setPlayer((prev) => ({
      ...prev,
      appearance: combatCharacter.appearance,
      actionIds: combatActionIds,
      reactionIds: combatReactionIds,
      movementProfile: combatDefaultMovementProfile,
      moveRange: combatPlayerStats.moveRange,
      visionProfile: combatVisionProfile,
      combatStats: combatPlayerStats,
      maxAttacksPerTurn: combatPlayerStats.maxAttacksPerTurn,
      hp: combatCharacter.pvActuels,
      maxHp: combatPlayerStats.maxHp,
      x: map.playerStart.x,
      y: map.playerStart.y
    }));
    setObstacles(map.obstacles);
    setWallSegments(Array.isArray(map.wallSegments) ? map.wallSegments : []);
    setPlayableCells(new Set(map.playableCells ?? []));
    setMapTerrain(Array.isArray(map.terrain) ? map.terrain : []);
    const flatHeight = Array(grid.cols * grid.rows).fill(0);
    setMapHeight(flatHeight);
    setMapLight(Array.isArray(map.light) ? map.light : []);
    setRoofOpenCells(new Set(map.roofOpenCells ?? []));
    setActiveLevel(0);
    const nextDecorations = Array.isArray(map.decorations) ? map.decorations : [];
    setDecorations(nextDecorations);
    const nextEffects = buildEffectsFromObstacles({
      obstacles: map.obstacles ?? [],
      terrain: Array.isArray(map.terrain) ? map.terrain : [],
      grid
    });
    setEffects(nextEffects);
    setPendingHazardRoll(null);
    setHazardAnchor(null);
    const newEnemies = map.enemySpawns.map(
      (spawn, i2) => createEnemy(i2, spawn.enemyType, spawn.position)
    );
    setEnemies(newEnemies);
    setRevealedEnemyIds(/* @__PURE__ */ new Set());
    setRevealedCells(/* @__PURE__ */ new Set());
    void queueMapTexturePreload({
      player,
      enemies: newEnemies,
      obstacles: map.obstacles ?? [],
      effects: nextEffects,
      decorations: nextDecorations
    });
    setRound(1);
    setHasRolledInitiative(false);
    setPlayerInitiative(null);
    setPlayerInitiativeRoll(null);
    setPlayerInitiativeMod(null);
    setTurnOrder([]);
    setCurrentTurnIndex(0);
    setIsCombatConfigured(true);
    setActionUsageCounts({ turn: {}, encounter: {} });
    setActionUsageByActor({});
    setTurnActionUsage({ usedActionCount: 0, usedBonusCount: 0 });
    setTurnEquipmentUsage({ usedInteractionCount: 0 });
    setReactionUsage({});
    setReactionQueue([]);
    setReactionCombatUsage({});
    setKillerInstinctTargetId(null);
    seenTargetsByActorRef.current.clear();
    enemyTurnPauseRef.current = null;
    setPlayerResources(initialPlayerResources);
    setPathLimit(combatDefaultMovementProfile.speed);
    setBasePathLimit(combatDefaultMovementProfile.speed);
    setMovementSpent(0);
    if (newEnemies.length === 0) {
      rollSoloInitiative();
    }
  }
  function getActiveTurnEntry() {
    if (!hasRolledInitiative || turnOrder.length === 0) return null;
    const clampedIndex = currentTurnIndex >= 0 && currentTurnIndex < turnOrder.length ? currentTurnIndex : 0;
    return turnOrder[clampedIndex] ?? null;
  }
  function peekNextTurnEntry() {
    if (!hasRolledInitiative || turnOrder.length === 0) {
      return { entry: null, willWrap: false };
    }
    const nextIndex = (currentTurnIndex + 1) % turnOrder.length;
    return { entry: turnOrder[nextIndex] ?? null, willWrap: nextIndex === 0 };
  }
  function advanceTurn() {
    if (turnOrder.length === 0) return;
    const currentEntry = turnOrder[currentTurnIndex] ?? null;
    applyEndOfTurnDurations(currentEntry);
    const willWrap = (currentTurnIndex + 1) % turnOrder.length === 0;
    if (willWrap) {
      applyEndOfRoundDurations();
    }
    setCurrentTurnIndex((prev) => {
      const next = (prev + 1) % turnOrder.length;
      if (next === 0) {
        setRound((r2) => r2 + 1);
      }
      return next;
    });
    setTurnTick((tick) => tick + 1);
  }
  function rollInitialInitiativeIfNeeded() {
    if (hasRolledInitiative) return;
    const playerMod = getCharacterAbilityMod(activeCharacterConfig, "DEX");
    const rollD20 = () => Math.floor(Math.random() * 20) + 1;
    const pjRoll = rollD20();
    const pjTotal = pjRoll + playerMod;
    const entries = [];
    const summonEntries = [];
    const afterPlayerSummons = [];
    entries.push({
      id: player.id,
      kind: "player",
      initiative: pjTotal
    });
    const enemiesWithInit = enemies.map((enemy) => {
      const initRoll = rollD20();
      const totalInit = initRoll;
      const side = enemy.summonOwnerType ?? enemy.type;
      const timing = getSummonTurnTiming(enemy);
      if (side === "enemy") {
        entries.push({
          id: enemy.id,
          kind: "enemy",
          initiative: totalInit
        });
      } else if (enemy.summonOwnerType === "player" && shouldSummonHaveTurnEntry(enemy)) {
        const entry = {
          id: enemy.id,
          kind: "summon",
          initiative: totalInit,
          ownerType: "player",
          ownerId: enemy.summonOwnerId ?? player.id
        };
        if (timing === "after_player") {
          afterPlayerSummons.push(entry);
        } else {
          summonEntries.push(entry);
        }
      }
      return {
        ...enemy,
        initiative: totalInit
      };
    });
    setPlayerInitiative(pjTotal);
    setPlayerInitiativeRoll(pjRoll);
    setPlayerInitiativeMod(playerMod);
    setEnemies(enemiesWithInit);
    entries.push(...summonEntries);
    entries.sort((a2, b2) => b2.initiative - a2.initiative);
    if (afterPlayerSummons.length > 0) {
      const playerIndex = entries.findIndex((entry) => entry.kind === "player");
      const insertIndex = playerIndex >= 0 ? playerIndex + 1 : entries.length;
      entries.splice(insertIndex, 0, ...afterPlayerSummons);
    }
    setTurnOrder(entries);
    setCurrentTurnIndex(0);
    setHasRolledInitiative(true);
    const first = entries[0];
    if (!first) return;
    if (first.kind === "player") {
      pushLog2(
        `Initiative: Joueur ${pjTotal} (d20=${pjRoll}, mod=${playerMod}) ??? le joueur commence.`
      );
    } else if (first.kind === "summon") {
      pushLog2(
        `Initiative: Joueur ${pjTotal} (d20=${pjRoll}, mod=${playerMod}) ??? ${first.id} (summon) commence (initiative ${first.initiative}).`
      );
    } else {
      pushLog2(
        `Initiative: Joueur ${pjTotal} (d20=${pjRoll}, mod=${playerMod}) ??? ${first.id} commence (initiative ${first.initiative}).`
      );
    }
  }
  function pushLog2(message) {
    setLog((prev) => [message, ...prev]);
  }
  function pushLogBatch(messages) {
    const trimmed = messages.filter(Boolean);
    if (!trimmed.length) return;
    setLog((prev) => [...trimmed, ...prev]);
  }
  function pushNarrative(message) {
    const text = (message ?? "").trim();
    if (!text) return;
    const entry = {
      id: `narr-${narrationIdRef.current++}`,
      round: round2,
      text
    };
    setNarrationEntries((prev) => [entry, ...prev].slice(0, 40));
    if (!narrationOpenRef.current) {
      setNarrationUnread((prev) => Math.min(prev + 1, 99));
    }
  }
  function pushDiceLog(message) {
    setDiceLogs((prev) => [message, ...prev].slice(0, 6));
    pushLog2(message);
  }
  function setEnemyBubble(enemyId, line) {
    const text = (line ?? "").trim();
    if (!text) return;
    setSpeechBubbles((prev) => {
      const filtered = prev.filter((b2) => b2.tokenId !== enemyId);
      return [
        ...filtered,
        { tokenId: enemyId, text, updatedAtRound: round2 }
      ];
    });
  }
  function clearEnemyBubble(enemyId) {
    setSpeechBubbles((prev) => prev.filter((b2) => b2.tokenId !== enemyId));
  }
  function applyPlayerBubble(text, updatedAtRound = round2) {
    setSpeechBubbles((prev) => {
      const filtered = prev.filter((b2) => b2.tokenId !== player.id);
      return text ? [...filtered, { tokenId: player.id, text, updatedAtRound }] : filtered;
    });
  }
  function setPlayerBubble(textInput) {
    const text = (textInput ?? "").trim();
    if (!text) return;
    if (playerBubbleTimeoutRef.current !== null) {
      window.clearTimeout(playerBubbleTimeoutRef.current);
      playerBubbleTimeoutRef.current = null;
    }
    playerBubbleOverrideRef.current = true;
    applyPlayerBubble(text, round2);
    playerBubbleTimeoutRef.current = window.setTimeout(() => {
      playerBubbleOverrideRef.current = false;
      applyPlayerBubble(playerThoughtRef.current, round2);
    }, 2600);
  }
  function buildCombatStateSummaryFrom(focusSide, playerState, enemiesState) {
    const actors = [
      {
        id: playerState.id,
        kind: "player",
        label: "Heros",
        aiRole: null,
        enemyTypeId: null,
        x: playerState.x,
        y: playerState.y,
        hp: playerState.hp,
        maxHp: playerState.maxHp
      },
      ...enemiesState.map((e2) => ({
        id: e2.id,
        kind: "enemy",
        label: e2.enemyTypeLabel || e2.enemyTypeId || e2.id,
        aiRole: e2.aiRole ?? null,
        enemyTypeId: e2.enemyTypeId ?? null,
        x: e2.x,
        y: e2.y,
        hp: e2.hp,
        maxHp: e2.maxHp
      }))
    ];
    return {
      round: round2,
      phase: focusSide,
      grid: { cols: mapGrid.cols, rows: mapGrid.rows },
      actors
    };
  }
  function buildCombatStateSummary(focusSide) {
    return buildCombatStateSummaryFrom(focusSide, player, enemies);
  }
  reactExports.useEffect(() => {
    const loadedTypes = loadEnemyTypesFromIndex();
    setEnemyTypes(loadedTypes);
  }, []);
  reactExports.useEffect(() => {
    const loadedTypes = loadObstacleTypesFromIndex();
    setObstacleTypes(loadedTypes);
  }, []);
  reactExports.useEffect(() => {
    const loadedTypes = loadEffectTypesFromIndex();
    setEffectTypes(loadedTypes);
  }, []);
  reactExports.useEffect(() => {
    const loadedTypes = loadStatusTypesFromIndex();
    setStatusTypes(loadedTypes);
  }, []);
  reactExports.useEffect(() => {
    const loadedTypes = loadWallTypesFromIndex();
    setWallTypes(loadedTypes);
  }, []);
  reactExports.useEffect(() => {
    const loadedTypes = loadWeaponTypesFromIndex();
    setWeaponTypes(loadedTypes);
  }, []);
  reactExports.useEffect(() => {
    const loadedTypes = loadRaceTypesFromIndex();
    setRaceTypes(loadedTypes);
  }, []);
  reactExports.useEffect(() => {
    const loadedTypes = loadClassTypesFromIndex();
    setClassTypes(loadedTypes);
    const loadedSubclasses = loadSubclassTypesFromIndex();
    setSubclassTypes(loadedSubclasses);
  }, []);
  reactExports.useEffect(() => {
    const loadedTypes = loadBackgroundTypesFromIndex();
    setBackgroundTypes(loadedTypes);
  }, []);
  reactExports.useEffect(() => {
    const loadedTypes = loadLanguageTypesFromIndex();
    setLanguageTypes(loadedTypes);
  }, []);
  reactExports.useEffect(() => {
    const loadedTypes = loadToolItemsFromIndex();
    setToolItems(loadedTypes);
  }, []);
  reactExports.useEffect(() => {
    const loadedTypes = loadObjectItemsFromIndex();
    setObjectItems(loadedTypes);
  }, []);
  reactExports.useEffect(() => {
    const loadedTypes = loadAmmoTypesFromIndex();
    setAmmoItems(loadedTypes);
  }, []);
  reactExports.useEffect(() => {
    const loadedTypes = loadArmorItemsFromIndex();
    setArmorItems(loadedTypes);
  }, []);
  reactExports.useEffect(() => {
    const loadedTypes = loadFeatureTypesFromIndex();
    setFeatureTypes(loadedTypes);
  }, []);
  reactExports.useEffect(() => {
    if (!isCombatConfigured) return;
    if (hasRolledInitiative) return;
    if (configEnemyCount > 0 && enemies.length === 0) return;
    rollInitialInitiativeIfNeeded();
  }, [isCombatConfigured, hasRolledInitiative, enemies.length, configEnemyCount]);
  reactExports.useEffect(() => {
    setSpeechBubbles(
      (prev) => prev.filter(
        (b2) => b2.tokenId === player.id || enemies.some((e2) => e2.id === b2.tokenId && e2.hp > 0)
      )
    );
  }, [enemies, player.id]);
  reactExports.useEffect(() => {
    if (!pixiContainerRef.current) return;
    const prevPlayerHp = prevPlayerHpRef.current;
    if (prevPlayerHp !== null && player.hp !== prevPlayerHp) {
      const delta = player.hp - prevPlayerHp;
      const now = Date.now();
      pushHpPopup(player, delta);
      if (now >= suppressCombatToastUntilRef.current) {
        if (delta < 0) {
          showCombatToast(`Vous avez subi ${Math.abs(delta)} degats.`, "hit");
        } else if (delta > 0) {
          showCombatToast(`Vous recuperez ${delta} PV.`, "heal");
        }
      }
    }
    prevPlayerHpRef.current = player.hp;
    const prevEnemies = prevEnemyHpRef.current;
    const nextEnemies = /* @__PURE__ */ new Map();
    for (const enemy of enemies) {
      const prevHp = prevEnemies.get(enemy.id);
      if (prevHp !== void 0 && enemy.hp !== prevHp) {
        pushHpPopup(enemy, enemy.hp - prevHp);
      }
      nextEnemies.set(enemy.id, enemy.hp);
    }
    prevEnemyHpRef.current = nextEnemies;
  }, [player, enemies]);
  reactExports.useEffect(() => {
    if (!enemyTurnPauseRef.current) return;
    if (phase !== "enemies") {
      enemyTurnPauseRef.current.resolve();
      enemyTurnPauseRef.current = null;
      return;
    }
    if (!actionContext && reactionQueue.length === 0) {
      enemyTurnPauseRef.current.resolve();
      enemyTurnPauseRef.current = null;
    }
  }, [phase, actionContext, reactionQueue.length]);
  reactExports.useEffect(() => {
    if (!killerInstinctTargetId) return;
    const target = enemies.find((e2) => e2.id === killerInstinctTargetId);
    if (!target || target.hp <= 0) {
      pushLog2("Instinct de tueur: cible tombee, avantage termine.");
      setKillerInstinctTargetId(null);
    }
  }, [enemies, killerInstinctTargetId]);
  reactExports.useEffect(() => {
    setActionsCatalog(loadActionTypesFromIndex());
  }, []);
  reactExports.useEffect(() => {
    if (actionsCatalog.length === 0) return;
    const playerActionIds = Array.isArray(player.actionIds) ? player.actionIds : [];
    const spellActionIds = collectSpellActionIds(activeCharacterConfig);
    const visibleIds = /* @__PURE__ */ new Set([...playerActionIds, ...spellActionIds]);
    const playerVisible = visibleIds.size > 0 ? actionsCatalog.filter((a2) => visibleIds.has(a2.id)) : actionsCatalog.filter((a2) => !(a2.tags || []).includes("enemy"));
    const filtered = playerVisible.filter((a2) => a2.category !== "movement");
    setActions(filtered);
    setSelectedActionId(filtered.length ? filtered[0].id : null);
  }, [actionsCatalog, player.actionIds, activeCharacterConfig]);
  reactExports.useEffect(() => {
    const indexed = Array.isArray(moveTypesIndex.moveTypes) ? moveTypesIndex.moveTypes : [];
    const loaded = [];
    for (const path2 of indexed) {
      const mod = MOVE_TYPE_MODULES[path2];
      if (mod) {
        loaded.push(mod);
      } else {
        console.warn("[move-types] Move type path missing in bundle:", path2);
      }
    }
    if (loaded.length === 0) {
      console.warn("[move-types] No move types loaded from index.json");
    }
    setMoveTypes(loaded);
  }, []);
  reactExports.useEffect(() => {
    var _a2, _b2;
    if (weaponTypes.length === 0) return;
    for (const weapon of weaponTypes) {
      const actionId = (_a2 = weapon.links) == null ? void 0 : _a2.actionId;
      const linkedAction = actionId ? weaponActionById.get(weapon.id) ?? null : null;
      if (actionId && !linkedAction) {
        console.warn(
          "[weapon-types] Linked action missing for weapon:",
          weapon.id,
          "->",
          actionId
        );
      }
      const effectId = (_b2 = weapon.links) == null ? void 0 : _b2.effectId;
      if (effectId && !effectTypeById.has(effectId)) {
        console.warn(
          "[weapon-types] Linked effect missing for weapon:",
          weapon.id,
          "->",
          effectId
        );
      }
    }
  }, [weaponTypes, actionCatalogById, effectTypeById]);
  reactExports.useEffect(() => {
    const loadedTypes = loadReactionTypesFromIndex();
    setReactionCatalog(loadedTypes);
  }, []);
  reactExports.useEffect(() => {
    var _a2;
    if (!isCombatConfigured) return;
    if (isGameOver) return;
    if (reactionCatalog.length === 0) return;
    const allTokens = getTokensOnActiveLevel([player, ...enemies]);
    const reactors = [player, ...enemies].filter((token) => !isTokenDead(token));
    for (const reactor of reactors) {
      const reactionIds2 = Array.isArray(reactor.reactionIds) ? reactor.reactionIds : [];
      if (reactionIds2.length === 0) continue;
      const visibilityReactions = reactionIds2.map((id2) => reactionById.get(id2) ?? null).filter((reaction) => {
        var _a3;
        return reaction && ((_a3 = reaction.trigger) == null ? void 0 : _a3.event) === "visibility.first_seen";
      });
      if (visibilityReactions.length === 0) continue;
      const visibleTargets = getEntitiesInVision(
        reactor,
        allTokens,
        visionBlockersActive,
        playableCells,
        wallEdges.vision,
        lightLevels,
        mapGrid
      ).filter((target) => target.id !== reactor.id && !isTokenDead(target));
      const seenTargets = getSeenTargetsForActor(reactor.id);
      const newlyVisible = visibleTargets.filter((target) => !seenTargets.has(target.id));
      if (newlyVisible.length === 0) continue;
      if (reactor.id === player.id) {
        setRevealedEnemyIds((prev) => {
          const next = new Set(prev);
          for (const enemy of newlyVisible.filter((t2) => t2.type === "enemy")) {
            next.add(enemy.id);
          }
          return next;
        });
      }
      for (const reaction of visibilityReactions) {
        const candidates = newlyVisible.filter(
          (target) => {
            var _a3;
            return reactionSourceMatches((_a3 = reaction.trigger) == null ? void 0 : _a3.source, target, reactor);
          }
        );
        if (candidates.length === 0) continue;
        const closest = (_a2 = candidates.map((target) => ({ target, dist: distanceBetweenTokens(reactor, target) })).sort((a2, b2) => a2.dist - b2.dist)[0]) == null ? void 0 : _a2.target;
        for (const target of candidates) {
          const conditionCheck = checkReactionConditions({
            reaction,
            reactor,
            target,
            distance: distanceBetweenTokens(reactor, target),
            isFirstSeen: true,
            isClosestVisible: target.id === ((closest == null ? void 0 : closest.id) ?? null),
            allTokens
          });
          if (!conditionCheck.ok) continue;
          const actionCheck = checkReactionActionEligibility({
            reaction,
            reactor,
            target,
            playerSnapshot: player,
            enemiesSnapshot: enemies
          });
          if (!actionCheck.ok) continue;
          const handled = applyInstantReactionEffects({
            reaction,
            reactor,
            target
          });
          if (!handled) {
            const anchor2 = resolveAnchorForCell({ x: target.x, y: target.y });
            const anchorX = (anchor2 == null ? void 0 : anchor2.anchorX) ?? 0;
            const anchorY = (anchor2 == null ? void 0 : anchor2.anchorY) ?? 0;
            const instance = {
              reactionId: reaction.id,
              reactorId: reactor.id,
              targetId: target.id,
              actionId: reaction.action.id,
              anchorX,
              anchorY
            };
            if (reactor.type === "player") {
              tryStartReaction(instance);
            } else {
              autoResolveReaction({
                reaction,
                reactor,
                target,
                playerSnapshot: player,
                enemiesSnapshot: enemies
              });
            }
          }
        }
      }
      markTargetsSeen(reactor.id, newlyVisible);
    }
  }, [
    isCombatConfigured,
    isGameOver,
    player,
    enemies,
    reactionCatalog,
    visionBlockersActive,
    playableCells,
    wallEdges.vision,
    lightLevels,
    mapGrid
  ]);
  reactExports.useEffect(() => {
    var _a2;
    if (!isCombatConfigured) return;
    if (!hasRolledInitiative) return;
    const entry = getActiveTurnEntry();
    if (!entry) return;
    if (entry.kind === "player") {
      setPhase("player");
      resetReactionUsageForActor(player.id);
      resetTurnUsageForActor(player.id);
      setTurnActionUsage({ usedActionCount: 0, usedBonusCount: 0 });
      setTurnEquipmentUsage({ usedInteractionCount: 0 });
      setActionUsageCounts((prev) => ({ ...prev, turn: {} }));
      const speed2 = ((_a2 = player.movementProfile) == null ? void 0 : _a2.speed) ?? defaultMovementProfile.speed;
      setBasePathLimit(speed2);
      setMovementSpent(0);
      setPathLimit(speed2);
      setHasRolledAttackForCurrentAction(false);
      setAttackRoll(null);
      setDamageRoll(null);
      narrationPendingRef.current = false;
      beginRoundNarrationBuffer(round2, buildCombatStateSummary("player"));
      setPlayer(
        (prev) => applyStartOfTurnStatuses({
          token: applyWeaponMasteryStartExpiryForToken(prev, player.id),
          side: "player"
        })
      );
      setEnemies(
        (prev) => prev.map((enemy) => applyWeaponMasteryStartExpiryForToken(enemy, player.id))
      );
      recordCombatEvent({
        round: round2,
        phase: "player",
        kind: "turn_start",
        actorId: player.id,
        actorKind: "player",
        summary: `Debut du tour du heros (round ${round2}).`
      });
      return;
    }
    if (entry.kind === "summon") {
      if (entry.ownerType === "player") {
        setPhase("player");
        resetReactionUsageForActor(entry.id);
        resetTurnUsageForActor(entry.id);
        setPlayer((prev) => applyWeaponMasteryStartExpiryForToken(prev, entry.id));
        setEnemies(
          (prev) => prev.map((enemy) => applyWeaponMasteryStartExpiryForToken(enemy, entry.id))
        );
        void runSingleSummonTurn(entry.id);
        return;
      }
      setPhase("enemies");
      resetReactionUsageForActor(entry.id);
      resetTurnUsageForActor(entry.id);
      setPlayer((prev) => applyWeaponMasteryStartExpiryForToken(prev, entry.id));
      setEnemies((prev) => prev.map((enemy) => applyWeaponMasteryStartExpiryForToken(enemy, entry.id)));
      void runSingleEnemyTurnV2(entry.id);
      return;
    }
    if (isResolvingEnemies) return;
    setPhase("enemies");
    resetReactionUsageForActor(entry.id);
    resetTurnUsageForActor(entry.id);
    void runSingleEnemyTurnV2(entry.id);
  }, [
    isCombatConfigured,
    hasRolledInitiative,
    turnOrder,
    currentTurnIndex,
    turnTick,
    isResolvingEnemies
  ]);
  function minDistanceToAnyEnemy() {
    if (enemies.length === 0) return null;
    let best = null;
    for (const enemy of enemies) {
      if (enemy.summonOwnerType === "player") continue;
      const dist = distanceBetweenTokens(player, enemy);
      if (best === null || dist < best) {
        best = dist;
      }
    }
    return best;
  }
  function rollSoloInitiative() {
    const playerMod = getCharacterAbilityMod(activeCharacterConfig, "DEX");
    const rollD20 = () => Math.floor(Math.random() * 20) + 1;
    const pjRoll = rollD20();
    const pjTotal = pjRoll + playerMod;
    const entries = [
      {
        id: player.id,
        kind: "player",
        initiative: pjTotal
      }
    ];
    for (const enemy of enemies) {
      if (!enemy.summonOwnerType) continue;
      if (!shouldSummonHaveTurnEntry(enemy)) continue;
      getSummonTurnTiming(enemy);
      let initiative = enemy.initiative ?? null;
      if (enemy.summonInitiativeMode === "roll_on_spawn" || typeof initiative !== "number") {
        initiative = rollD20();
      }
      ({
        id: enemy.id,
        ownerType: enemy.summonOwnerType ?? enemy.type,
        ownerId: enemy.summonOwnerId ?? player.id
      });
    }
    setPlayerInitiative(pjTotal);
    setPlayerInitiativeRoll(pjRoll);
    setPlayerInitiativeMod(playerMod);
    setTurnOrder(entries);
    setCurrentTurnIndex(0);
    setHasRolledInitiative(true);
    pushLog2(
      `Initiative: Joueur ${pjTotal} (d20=${pjRoll}, mod=${playerMod}) ??? le joueur commence.`
    );
  }
  function minDistanceToAnyObstacle() {
    if (obstacles.length === 0) return null;
    let best = null;
    for (const obstacle of obstacles) {
      if (obstacle.hp <= 0) continue;
      if (getBaseHeightAt(obstacle.x, obstacle.y) !== activeLevel) continue;
      const def = obstacleTypeById.get(obstacle.typeId) ?? null;
      const dist = getObstacleDistance(player, obstacle, def, {
        x: obstacle.x,
        y: obstacle.y
      });
      if (best === null || dist < best) {
        best = dist;
      }
    }
    return best;
  }
  function minDistanceToAnyWall() {
    if (wallSegments.length === 0) return null;
    let best = null;
    for (const seg of wallSegments) {
      if (typeof seg.hp === "number" && seg.hp <= 0) continue;
      const def = seg.typeId ? wallTypeById.get(seg.typeId) ?? null : null;
      if (!isWallDestructible(def)) continue;
      const cells = getAdjacentCellsForEdge(seg);
      const levelA = getBaseHeightAt(cells.a.x, cells.a.y);
      const levelB = getBaseHeightAt(cells.b.x, cells.b.y);
      if (levelA !== activeLevel && levelB !== activeLevel) continue;
      const dist = getWallSegmentDistance(player, seg);
      if (best === null || dist < best) {
        best = dist;
      }
    }
    return best;
  }
  function minDistanceToAnyHostileTarget() {
    const enemyDist = minDistanceToAnyEnemy();
    const obstacleDist = minDistanceToAnyObstacle();
    const wallDist = minDistanceToAnyWall();
    const distances = [enemyDist, obstacleDist, wallDist].filter(
      (value2) => typeof value2 === "number" && Number.isFinite(value2)
    );
    if (distances.length === 0) return null;
    return Math.min(...distances);
  }
  function validateEnemyTargetForAction(action2, enemy, actor, allTokens) {
    if (enemy.type !== "enemy") {
      return { ok: false, reason: "La cible selectionnee n'est pas un ennemi." };
    }
    if (enemy.hp <= 0) {
      return { ok: false, reason: "La cible est deja a terre." };
    }
    if (!areTokensOnSameLevel(actor, enemy)) {
      return { ok: false, reason: "Cible sur un autre niveau." };
    }
    const targeting2 = action2.targeting;
    const isHostileTargeting = (targeting2 == null ? void 0 : targeting2.target) === "enemy" || (targeting2 == null ? void 0 : targeting2.target) === "hostile";
    if (!targeting2 || !isHostileTargeting) {
      return {
        ok: false,
        reason: "Cette action ne cible pas une cible hostile."
      };
    }
    return validateTokenTargetForAction(action2, enemy, actor, allTokens);
  }
  function validateTokenTargetForAction(action2, token, actor, allTokens) {
    if (token.hp <= 0) {
      return { ok: false, reason: "La cible est deja a terre." };
    }
    if (!areTokensOnSameLevel(actor, token)) {
      return { ok: false, reason: "Cible sur un autre niveau." };
    }
    const targeting2 = action2.targeting;
    const dist = distanceBetweenTokens(actor, token);
    const range = targeting2 == null ? void 0 : targeting2.range;
    if (range) {
      if (typeof range.min === "number" && dist < range.min) {
        return {
          ok: false,
          reason: `Cible trop proche pour ${action2.name} (distance ${dist}, min ${range.min}).`
        };
      }
      if (typeof range.max === "number" && dist > range.max) {
        return {
          ok: false,
          reason: `Cible hors portee pour ${action2.name} (distance ${dist}, max ${range.max}).`
        };
      }
    }
    for (const cond of action2.conditions || []) {
      if (cond.type === "DISTANCE_MAX") {
        if (typeof cond.max === "number" && dist > cond.max) {
          return {
            ok: false,
            reason: cond.reason || `Distance cible > ${cond.max}.`
          };
        }
      }
      if (cond.type === "DISTANCE_BETWEEN") {
        const min = typeof cond.min === "number" ? cond.min : typeof (range == null ? void 0 : range.min) === "number" ? range.min : null;
        const max = typeof cond.max === "number" ? cond.max : typeof (range == null ? void 0 : range.max) === "number" ? range.max : null;
        if (min !== null && dist < min) {
          return {
            ok: false,
            reason: cond.reason || `Distance cible < ${min}.`
          };
        }
        if (max !== null && dist > max) {
          return {
            ok: false,
            reason: cond.reason || `Distance cible > ${max}.`
          };
        }
      }
      if (cond.type === "TARGET_ALIVE" && token.hp <= 0) {
        return {
          ok: false,
          reason: cond.reason || "La cible doit avoir des PV restants."
        };
      }
    }
    if (targeting2 == null ? void 0 : targeting2.requiresLos) {
      const visible = isTargetVisible(
        actor,
        token,
        allTokens,
        visionBlockersActive,
        playableCells,
        wallEdges.vision,
        lightLevels,
        mapGrid
      );
      if (!visible) {
        return {
          ok: false,
          reason: "Cible hors du champ de vision ou derriere un obstacle (ligne de vue requise)."
        };
      }
      const targetCell = getClosestFootprintCellToPoint({ x: actor.x, y: actor.y }, token) ?? { x: token.x, y: token.y };
      const canHit = hasLineOfEffect(
        { x: actor.x, y: actor.y },
        targetCell,
        obstacleBlocking.attacks,
        wallEdges.vision
      );
      if (!canHit) {
        return {
          ok: false,
          reason: "Trajectoire bloquee (obstacle entre l'attaquant et la cible)."
        };
      }
    }
    return { ok: true };
  }
  function validateObstacleTargetForAction(action2, obstacle, targetCell, actor, allTokens) {
    if (obstacle.hp <= 0) {
      return { ok: false, reason: "L'obstacle est deja detruit." };
    }
    const targeting2 = action2.targeting;
    const isHostileTargeting = (targeting2 == null ? void 0 : targeting2.target) === "enemy" || (targeting2 == null ? void 0 : targeting2.target) === "hostile";
    if (!targeting2 || !isHostileTargeting) {
      return {
        ok: false,
        reason: "Cette action ne cible pas un ennemi/obstacle."
      };
    }
    const def = obstacleTypeById.get(obstacle.typeId) ?? null;
    const dist = getObstacleDistance(actor, obstacle, def, targetCell);
    const range = targeting2.range;
    if (range) {
      if (typeof range.min === "number" && dist < range.min) {
        return {
          ok: false,
          reason: `Cible trop proche pour ${action2.name} (distance ${dist}, min ${range.min}).`
        };
      }
      if (typeof range.max === "number" && dist > range.max) {
        return {
          ok: false,
          reason: `Cible hors portee pour ${action2.name} (distance ${dist}, max ${range.max}).`
        };
      }
    }
    for (const cond of action2.conditions || []) {
      if (cond.type === "DISTANCE_MAX") {
        if (typeof cond.max === "number" && dist > cond.max) {
          return {
            ok: false,
            reason: cond.reason || `Distance cible > ${cond.max}.`
          };
        }
      }
      if (cond.type === "DISTANCE_BETWEEN") {
        const min = typeof cond.min === "number" ? cond.min : typeof (range == null ? void 0 : range.min) === "number" ? range.min : null;
        const max = typeof cond.max === "number" ? cond.max : typeof (range == null ? void 0 : range.max) === "number" ? range.max : null;
        if (min !== null && dist < min) {
          return {
            ok: false,
            reason: cond.reason || `Distance cible < ${min}.`
          };
        }
        if (max !== null && dist > max) {
          return {
            ok: false,
            reason: cond.reason || `Distance cible > ${max}.`
          };
        }
      }
      if (cond.type === "TARGET_ALIVE" && obstacle.hp <= 0) {
        return {
          ok: false,
          reason: cond.reason || "La cible doit avoir des PV restants."
        };
      }
    }
    if (targeting2.requiresLos) {
      const visible = isCellVisible(
        actor,
        targetCell,
        visionBlockersActive,
        playableCells,
        wallEdges.vision,
        lightLevels,
        mapGrid
      );
      if (!visible) {
        return {
          ok: false,
          reason: "Cible hors du champ de vision ou derriere un obstacle (ligne de vue requise)."
        };
      }
      let attackBlockers = obstacleBlocking.attacks;
      if (attackBlockers.size > 0) {
        const cells = def ? getObstacleOccupiedCells(obstacle, def) : [targetCell];
        if (cells.length > 0) {
          const trimmed = new Set(attackBlockers);
          for (const cell of cells) {
            trimmed.delete(cellKey(cell.x, cell.y));
          }
          attackBlockers = trimmed;
        }
      }
      const canHit = hasLineOfEffect(
        { x: actor.x, y: actor.y },
        { x: targetCell.x, y: targetCell.y },
        attackBlockers,
        wallEdges.vision
      );
      if (!canHit) {
        return {
          ok: false,
          reason: "Trajectoire bloquee (obstacle entre l'attaquant et la cible)."
        };
      }
    }
    return { ok: true };
  }
  function validateWallSegmentTargetForAction(action2, segment, targetCell, actor) {
    if (typeof segment.hp === "number" && segment.hp <= 0) {
      return { ok: false, reason: "Le mur est deja detruit." };
    }
    const targeting2 = action2.targeting;
    const isHostileTargeting = (targeting2 == null ? void 0 : targeting2.target) === "enemy" || (targeting2 == null ? void 0 : targeting2.target) === "hostile";
    if (!targeting2 || !isHostileTargeting) {
      return {
        ok: false,
        reason: "Cette action ne cible pas un ennemi/obstacle."
      };
    }
    const def = segment.typeId ? wallTypeById.get(segment.typeId) ?? null : null;
    if (!isWallDestructible(def)) {
      return { ok: false, reason: "Ce mur est indestructible." };
    }
    const dist = getWallSegmentDistance(actor, segment);
    const range = targeting2.range;
    if (range) {
      if (typeof range.min === "number" && dist < range.min) {
        return {
          ok: false,
          reason: `Cible trop proche pour ${action2.name} (distance ${dist}, min ${range.min}).`
        };
      }
      if (typeof range.max === "number" && dist > range.max) {
        return {
          ok: false,
          reason: `Cible hors portee pour ${action2.name} (distance ${dist}, max ${range.max}).`
        };
      }
    }
    for (const cond of action2.conditions || []) {
      if (cond.type === "DISTANCE_MAX") {
        if (typeof cond.max === "number" && dist > cond.max) {
          return {
            ok: false,
            reason: cond.reason || `Distance cible > ${cond.max}.`
          };
        }
      }
      if (cond.type === "DISTANCE_BETWEEN") {
        const min = typeof cond.min === "number" ? cond.min : typeof (range == null ? void 0 : range.min) === "number" ? range.min : null;
        const max = typeof cond.max === "number" ? cond.max : typeof (range == null ? void 0 : range.max) === "number" ? range.max : null;
        if (min !== null && dist < min) {
          return {
            ok: false,
            reason: cond.reason || `Distance cible < ${min}.`
          };
        }
        if (max !== null && dist > max) {
          return {
            ok: false,
            reason: cond.reason || `Distance cible > ${max}.`
          };
        }
      }
      if (cond.type === "TARGET_ALIVE" && typeof segment.hp === "number" && segment.hp <= 0) {
        return {
          ok: false,
          reason: cond.reason || "La cible doit avoir des PV restants."
        };
      }
    }
    if (targeting2.requiresLos) {
      const visible = isCellVisible(
        actor,
        targetCell,
        visionBlockersActive,
        playableCells,
        wallEdges.vision,
        lightLevels,
        mapGrid
      );
      if (!visible) {
        return {
          ok: false,
          reason: "Cible hors du champ de vision ou derriere un obstacle (ligne de vue requise)."
        };
      }
      const canHit = hasLineOfEffect(
        { x: actor.x, y: actor.y },
        { x: targetCell.x, y: targetCell.y },
        obstacleBlocking.attacks,
        wallEdges.vision
      );
      if (!canHit) {
        return {
          ok: false,
          reason: "Trajectoire bloquee (obstacle entre l'attaquant et la cible)."
        };
      }
    }
    return { ok: true };
  }
  function computeActionAvailability(action2) {
    var _a2, _b2, _c2, _d, _e, _f, _g, _h;
    const reasons = [];
    const details = [];
    const speechBlockingStatuses = /* @__PURE__ */ new Set([
      "INCAPACITATED",
      "UNCONSCIOUS",
      "PARALYZED",
      "PETRIFIED",
      "STUNNED"
    ]);
    const handsBlockingStatuses = /* @__PURE__ */ new Set([
      "RESTRAINED",
      "GRAPPLED",
      "PARALYZED",
      "PETRIFIED",
      "UNCONSCIOUS",
      "STUNNED",
      "INCAPACITATED"
    ]);
    const actorStatuses = Array.isArray(player.statuses) ? player.statuses.map((status) => String(status.id)) : [];
    const costType = (_a2 = action2.actionCost) == null ? void 0 : _a2.actionType;
    const isActiveAction = (actionContext == null ? void 0 : actionContext.stage) === "active" && validatedActionId === action2.id;
    if (phase !== "player" && costType !== "reaction") {
      reasons.push("Action bloquee pendant le tour des ennemis.");
    }
    if (costType === "action" && turnActionUsage.usedActionCount >= (((_b2 = player.combatStats) == null ? void 0 : _b2.actionsPerTurn) ?? 1)) {
      if (!isActiveAction) {
        reasons.push("Action principale deja utilisee ce tour.");
      }
    }
    if (costType === "bonus" && turnActionUsage.usedBonusCount >= (((_c2 = player.combatStats) == null ? void 0 : _c2.bonusActionsPerTurn) ?? 1)) {
      if (!isActiveAction) {
        reasons.push("Action bonus deja utilisee ce tour.");
      }
    }
    if (costType === "reaction" && !canUseReaction(player.id) && !isActiveAction) {
      reasons.push("Reaction deja utilisee ce tour.");
    }
    const maxEquipmentInteractions = getMaxWeaponInteractionsPerTurnForActor(player);
    details.push(
      `Interactions equipement: ${turnEquipmentUsage.usedInteractionCount}/${maxEquipmentInteractions}`
    );
    const turnUses = typeof actionUsageCounts.turn[action2.id] === "number" ? actionUsageCounts.turn[action2.id] : 0;
    const encounterUses = typeof actionUsageCounts.encounter[action2.id] === "number" ? actionUsageCounts.encounter[action2.id] : 0;
    if (typeof ((_d = action2.usage) == null ? void 0 : _d.perTurn) === "number") {
      details.push(`Usages/tour: ${turnUses}/${action2.usage.perTurn}`);
      if (turnUses >= action2.usage.perTurn) {
        reasons.push("Limite d'usage atteinte pour ce tour.");
      }
    }
    if (typeof ((_e = action2.usage) == null ? void 0 : _e.perEncounter) === "number") {
      details.push(`Usages/rencontre: ${encounterUses}/${action2.usage.perEncounter}`);
      if (encounterUses >= action2.usage.perEncounter) {
        reasons.push("Limite d'usage atteinte pour la rencontre.");
      }
    }
    const usageResource = (_f = action2.usage) == null ? void 0 : _f.resource;
    if ((usageResource == null ? void 0 : usageResource.name) && typeof usageResource.min === "number") {
      const amount = getResourceAmount(usageResource.name, usageResource.pool);
      if (amount < usageResource.min) {
        const poolSuffix = usageResource.pool ? ` (${usageResource.pool})` : "";
        reasons.push(`Ressource insuffisante: ${usageResource.name}${poolSuffix} (${amount}/${usageResource.min}).`);
      }
    }
    if (isSpellActionId(action2.id)) {
      const preferredEntryId = selectedSpellSourceBySpellId[action2.id] ?? null;
      const spellResolution = resolveSpellUsageCandidate(
        activeCharacterConfig,
        action2.id,
        preferredEntryId
      );
      if (spellResolution.reason) {
        reasons.push(spellResolution.reason);
      }
      if (spellResolution.candidate) {
        const candidate = spellResolution.candidate;
        const sourceLabel = candidate.sourceId ? `${candidate.sourceType ?? "source"}:${candidate.sourceId}` : candidate.sourceKey;
        if (candidate.consumesSlot && candidate.slotLevel !== null) {
          const remaining = getSlotAmountFromCharacter(activeCharacterConfig, "slot", candidate.slotLevel);
          details.push(`Sort (${sourceLabel}) slot niv ${candidate.slotLevel}: ${remaining} restant(s)`);
        } else if (candidate.usageType.toLowerCase() === "limited" || candidate.usageType.toLowerCase() === "charge") {
          details.push(
            `Sort (${sourceLabel}) usages: ${Number(candidate.remainingUses ?? 0)}/${Number(
              candidate.maxUses ?? candidate.remainingUses ?? 0
            )}`
          );
        } else {
          details.push(`Sort (${sourceLabel}) usage: ${candidate.usageType || "at-will"}`);
        }
      }
    }
    const components2 = action2.components ?? null;
    if (components2 == null ? void 0 : components2.verbal) {
      if (actorStatuses.some((status) => speechBlockingStatuses.has(status))) {
        reasons.push("Composante verbale impossible (incapable de parler).");
      }
    }
    if ((components2 == null ? void 0 : components2.somatic) || (components2 == null ? void 0 : components2.material)) {
      if (actorStatuses.some((status) => handsBlockingStatuses.has(status))) {
        reasons.push("Composante somatique/materiale impossible (mains entravees).");
      }
    }
    const targeting2 = (_g = action2.targeting) == null ? void 0 : _g.target;
    const range = (_h = action2.targeting) == null ? void 0 : _h.range;
    const isHostileTargeting = targeting2 === "enemy" || targeting2 === "hostile";
    if (isHostileTargeting && costType !== "reaction") {
      const dist = minDistanceToAnyHostileTarget();
      if (dist === null) {
        reasons.push("Aucune cible hostile presente.");
      } else {
        details.push(`Distance mini cible hostile: ${dist}`);
        if (typeof (range == null ? void 0 : range.min) === "number" && dist < range.min) {
          reasons.push(`Trop proche (< ${range.min}).`);
        }
        if (typeof (range == null ? void 0 : range.max) === "number" && dist > range.max) {
          reasons.push(`Hors portee (> ${range.max}).`);
        }
      }
    }
    for (const cond of action2.conditions || []) {
      if (cond.type === "PHASE_IS" && cond.mustBe && cond.mustBe !== phase) {
        reasons.push(cond.reason || "Phase incorrecte.");
      }
      if (cond.type === "STAT_BELOW_PERCENT" && cond.who === "self" && cond.stat === "hp") {
        const max = Math.max(1, player.maxHp || 1);
        const ratio = player.hp / max;
        if (typeof cond.percentMax === "number" && ratio >= cond.percentMax) {
          reasons.push(cond.reason || `PV trop hauts (>= ${Math.round(cond.percentMax * 100)}%).`);
        }
      }
      if (cond.type === "DISTANCE_MAX" && isHostileTargeting) {
        const dist = minDistanceToAnyHostileTarget();
        if (dist !== null && typeof cond.max === "number" && dist > cond.max) {
          reasons.push(cond.reason || `Distance > ${cond.max}.`);
        }
      }
      if (cond.type === "DISTANCE_BETWEEN" && isHostileTargeting) {
        const dist = minDistanceToAnyHostileTarget();
        if (dist !== null) {
          if (typeof cond.min === "number" && dist < cond.min) {
            reasons.push(cond.reason || `Distance < ${cond.min}.`);
          }
          if (typeof cond.max === "number" && dist > cond.max) {
            reasons.push(cond.reason || `Distance > ${cond.max}.`);
          }
        }
      }
      if (cond.type === "RESOURCE_AT_LEAST" && cond.resource) {
        const pool = typeof cond.pool === "string" ? cond.pool : void 0;
        const amount = getResourceAmount(String(cond.resource), pool);
        const needed = typeof cond.value === "number" ? cond.value : 1;
        if (amount < needed) {
          const poolSuffix = pool ? ` (${pool})` : "";
          reasons.push(cond.reason || `Ressource insuffisante: ${cond.resource}${poolSuffix} (${amount}/${needed}).`);
        }
      }
    }
    const weaponConstraintIssues = getWeaponActionConstraintIssues(action2, player);
    if (weaponConstraintIssues.length > 0) {
      reasons.push(...weaponConstraintIssues);
    }
    return {
      enabled: reasons.length === 0,
      reasons,
      details
    };
  }
  function resolvePlayerFormula(formula) {
    var _a2, _b2, _c2, _d, _e, _f;
    const stats = player.combatStats;
    const fallbackStats = activeCharacterConfig.combatStats ?? null;
    const level2 = Number((stats == null ? void 0 : stats.level) ?? (fallbackStats == null ? void 0 : fallbackStats.level) ?? 1) || 1;
    const modSTR = Number(((_a2 = stats == null ? void 0 : stats.mods) == null ? void 0 : _a2.modFOR) ?? getCharacterAbilityMod(activeCharacterConfig, "FOR"));
    const modDEX = Number(((_b2 = stats == null ? void 0 : stats.mods) == null ? void 0 : _b2.modDEX) ?? getCharacterAbilityMod(activeCharacterConfig, "DEX"));
    const modCON = Number(((_c2 = stats == null ? void 0 : stats.mods) == null ? void 0 : _c2.modCON) ?? getCharacterAbilityMod(activeCharacterConfig, "CON"));
    const modINT = Number(((_d = stats == null ? void 0 : stats.mods) == null ? void 0 : _d.modINT) ?? getCharacterAbilityMod(activeCharacterConfig, "INT"));
    const modWIS = Number(((_e = stats == null ? void 0 : stats.mods) == null ? void 0 : _e.modSAG) ?? getCharacterAbilityMod(activeCharacterConfig, "SAG"));
    const modCHA = Number(((_f = stats == null ? void 0 : stats.mods) == null ? void 0 : _f.modCHA) ?? getCharacterAbilityMod(activeCharacterConfig, "CHA"));
    const attackBonus = Number((stats == null ? void 0 : stats.attackBonus) ?? 0);
    const moveRange = Number((stats == null ? void 0 : stats.moveRange) ?? player.moveRange ?? 0);
    return formula.replace(/\s+/g, "").replace(/attackBonus/gi, String(attackBonus)).replace(/moveRange/gi, String(moveRange)).replace(/level/gi, String(level2)).replace(/modFOR/gi, String(modSTR)).replace(/modDEX/gi, String(modDEX)).replace(/modCON/gi, String(modCON)).replace(/modINT/gi, String(modINT)).replace(/modSAG/gi, String(modWIS)).replace(/modCHA/gi, String(modCHA));
  }
  function handleUseAction(action2) {
    var _a2, _b2, _c2, _d;
    const costType = (_a2 = action2.actionCost) == null ? void 0 : _a2.actionType;
    const isStandardAction = costType === "action";
    const isBonusAction = costType === "bonus";
    const isReaction = costType === "reaction";
    if (isStandardAction && turnActionUsage.usedActionCount >= (((_b2 = player.combatStats) == null ? void 0 : _b2.actionsPerTurn) ?? 1)) {
      pushLog2(
        `Action ${action2.name} refusee: action principale deja utilisee ce tour.`
      );
      return false;
    }
    if (isBonusAction && turnActionUsage.usedBonusCount >= (((_c2 = player.combatStats) == null ? void 0 : _c2.bonusActionsPerTurn) ?? 1)) {
      pushLog2(
        `Action ${action2.name} refusee: action bonus deja utilisee ce tour.`
      );
      return false;
    }
    if (isReaction && !canUseReaction(player.id)) {
      pushLog2(`Reaction ${action2.name} refusee: reaction deja utilisee ce tour.`);
      return false;
    }
    const availability = computeActionAvailability(action2);
    if (!availability.enabled) {
      pushLog2(
        `Action ${action2.name} bloque: ${availability.reasons.join(" | ")}`
      );
      return false;
    }
    const selectedWeapon = action2.category === "attack" ? pickWeaponForAction(
      action2,
      player,
      ((_d = action2.actionCost) == null ? void 0 : _d.actionType) === "reaction" ? { reaction: true } : void 0
    ) : null;
    const handlingCost = resolveWeaponHandlingCost({
      action: action2,
      actor: player,
      weapon: selectedWeapon
    });
    setActionUsageCounts((prev) => ({
      turn: { ...prev.turn, [action2.id]: (prev.turn[action2.id] ?? 0) + 1 },
      encounter: { ...prev.encounter, [action2.id]: (prev.encounter[action2.id] ?? 0) + 1 }
    }));
    setAttackRoll(null);
    setDamageRoll(null);
    setAttackOutcome(null);
    setHasRolledAttackForCurrentAction(false);
    setValidatedActionId(action2.id);
    setTurnActionUsage((prev) => ({
      usedActionCount: prev.usedActionCount + (isStandardAction ? 1 : 0),
      usedBonusCount: prev.usedBonusCount + (isBonusAction ? 1 : 0)
    }));
    if (handlingCost.requiresInteraction > 0) {
      setTurnEquipmentUsage((prev) => ({
        usedInteractionCount: prev.usedInteractionCount + handlingCost.requiresInteraction
      }));
    }
    if (isReaction) {
      markReactionUsed(player.id);
      if (actionContext == null ? void 0 : actionContext.reactionId) {
        markReactionUsedInCombat(player.id, actionContext.reactionId);
      }
    }
    if (actionTargetsHostile(action2)) {
      setTargetMode("selecting");
      setSelectedTargetIds([]);
      setSelectedObstacleTarget(null);
      setSelectedWallTarget(null);
    } else {
      setTargetMode("none");
      setSelectedTargetIds([]);
      setSelectedObstacleTarget(null);
      setSelectedWallTarget(null);
    }
    return true;
  }
  function getActionById(id2) {
    if (!id2) return null;
    const reactionAction = reactionActionById.get(id2);
    if (reactionAction) return reactionAction;
    return actions2.find((a2) => a2.id === id2) || moveTypes2.find((a2) => a2.id === id2) || null;
  }
  function getEnemyWeaponIds(enemy) {
    const enemyType = enemyTypeById2.get(enemy.enemyTypeId ?? "") ?? null;
    const slots = (enemyType == null ? void 0 : enemyType.armesDefaut) ?? null;
    if (!slots) return [];
    const ids = [slots.main_droite, slots.main_gauche, slots.mains].filter(
      (value2) => typeof value2 === "string" && value2.length > 0
    );
    return Array.from(new Set(ids));
  }
  function getWeaponsForActor(actor, options) {
    if (actor.type === "player") {
      if (options == null ? void 0 : options.reaction) return primaryWeapons;
      return equippedWeapons;
    }
    const ids = getEnemyWeaponIds(actor);
    return ids.map((id2) => weaponTypeById.get(id2) ?? null).filter((weapon) => Boolean(weapon));
  }
  function setLastUsedWeaponAsPrimaryForPlayer(weaponId) {
    const targetId = String(weaponId ?? "").trim();
    if (!targetId) return;
    const normalize = (character) => {
      const inventory = Array.isArray(character == null ? void 0 : character.inventoryItems) ? character.inventoryItems.map((entry) => ({ ...entry })) : [];
      let targetFound = false;
      inventory.forEach((entry) => {
        if ((entry == null ? void 0 : entry.type) !== "weapon") return;
        if (!(entry == null ? void 0 : entry.equippedSlot) || (entry == null ? void 0 : entry.storedIn)) return;
        if (String(entry.id ?? "") === targetId && !targetFound) {
          entry.isPrimaryWeapon = true;
          targetFound = true;
          return;
        }
        entry.isPrimaryWeapon = false;
      });
      if (!targetFound) return character;
      return { ...character, inventoryItems: inventory };
    };
    setCombatCharacterConfig((prev) => prev ? normalize(prev) : prev);
    setCharacterConfig((prev) => normalize(prev));
  }
  function getWeaponProficienciesForActor(actor) {
    var _a2, _b2, _c2, _d;
    if (actor.type === "player") {
      return Array.isArray((_a2 = activeCharacterConfig.proficiencies) == null ? void 0 : _a2.weapons) ? (_b2 = activeCharacterConfig.proficiencies) == null ? void 0 : _b2.weapons : [];
    }
    const enemyType = enemyTypeById2.get(actor.enemyTypeId ?? "") ?? null;
    return Array.isArray((_c2 = enemyType == null ? void 0 : enemyType.proficiencies) == null ? void 0 : _c2.weapons) ? (_d = enemyType == null ? void 0 : enemyType.proficiencies) == null ? void 0 : _d.weapons : [];
  }
  function getActorLevel(actor) {
    var _a2, _b2;
    if (actor.type === "player") {
      return Number((activeCharacterConfig == null ? void 0 : activeCharacterConfig.niveauGlobal) ?? ((_a2 = actor.combatStats) == null ? void 0 : _a2.level) ?? 1) || 1;
    }
    return Number(((_b2 = actor.combatStats) == null ? void 0 : _b2.level) ?? 1) || 1;
  }
  function getProficiencyBonusForActor(actor) {
    return getProficiencyBonusForLevel(getActorLevel(actor));
  }
  function getAbilityModForActor(actor, modToken) {
    var _a2;
    if (!modToken) return 0;
    if (actor.type === "player") {
      if (modToken === "modFOR") return getCharacterAbilityMod(activeCharacterConfig, "FOR");
      if (modToken === "modDEX") return getCharacterAbilityMod(activeCharacterConfig, "DEX");
      if (modToken === "modCON") return getCharacterAbilityMod(activeCharacterConfig, "CON");
      if (modToken === "modINT") return getCharacterAbilityMod(activeCharacterConfig, "INT");
      if (modToken === "modSAG") return getCharacterAbilityMod(activeCharacterConfig, "SAG");
      if (modToken === "modCHA") return getCharacterAbilityMod(activeCharacterConfig, "CHA");
    }
    const mods = (_a2 = actor.combatStats) == null ? void 0 : _a2.mods;
    if (!mods) return 0;
    if (modToken === "modFOR") return Number(mods.modFOR ?? 0);
    if (modToken === "modDEX") return Number(mods.modDEX ?? 0);
    if (modToken === "modCON") return Number(mods.modCON ?? 0);
    if (modToken === "modINT") return Number(mods.modINT ?? 0);
    if (modToken === "modSAG") return Number(mods.modSAG ?? 0);
    if (modToken === "modCHA") return Number(mods.modCHA ?? 0);
    return 0;
  }
  function pickWeaponForAction(action2, actor, options) {
    var _a2, _b2;
    const weapons = getWeaponsForActor(actor, options);
    if (!weapons || weapons.length === 0) return null;
    const taggedWeaponId = getWeaponIdFromActionTags(action2.tags ?? []);
    if (taggedWeaponId) {
      const taggedWeapon = weapons.find((weapon) => weapon.id === taggedWeaponId) ?? null;
      if (taggedWeapon) return taggedWeapon;
    }
    const tags2 = action2.tags ?? [];
    const wantsRanged = tags2.includes("ranged") || ((_b2 = (_a2 = action2.targeting) == null ? void 0 : _a2.range) == null ? void 0 : _b2.max) > 1.5;
    if (wantsRanged) {
      return weapons.find((w2) => w2.category === "distance") ?? weapons.find((w2) => {
        var _a3, _b3;
        return (_b3 = (_a3 = w2.properties) == null ? void 0 : _a3.range) == null ? void 0 : _b3.normal;
      }) ?? weapons.find((w2) => {
        var _a3, _b3;
        return (_b3 = (_a3 = w2.properties) == null ? void 0 : _a3.thrown) == null ? void 0 : _b3.normal;
      }) ?? null;
    }
    return weapons.find((w2) => w2.category === "melee" || w2.category === "polyvalent") ?? weapons[0] ?? null;
  }
  function inferAmmoTypeFromWeapon(weapon) {
    var _a2;
    const explicit = (_a2 = weapon.properties) == null ? void 0 : _a2.ammoType;
    if (typeof explicit === "string" && explicit.trim()) return explicit;
    const id2 = String(weapon.id ?? "").toLowerCase();
    const name2 = String(weapon.name ?? "").toLowerCase();
    const tags2 = Array.isArray(weapon.tags) ? weapon.tags.map((tag) => String(tag).toLowerCase()) : [];
    const tokens = [id2, name2, ...tags2].join(" ");
    if (tokens.includes("arbalete") || tokens.includes("crossbow")) return "bolt";
    if (tokens.includes("arc") || tokens.includes("bow")) return "arrow";
    if (tokens.includes("fronde") || tokens.includes("sling")) return "stone";
    if (tokens.includes("sarbacane") || tokens.includes("blowgun")) return "needle";
    if (tokens.includes("dart") || tokens.includes("dard")) return "dart";
    return null;
  }
  function resolveAmmoUsageForAction(action2, actor, options) {
    var _a2, _b2, _c2;
    if (action2.category !== "attack") return null;
    const weapon = pickWeaponForAction(action2, actor, options);
    if (!weapon) return null;
    const usesAmmo = Boolean((_a2 = weapon.properties) == null ? void 0 : _a2.ammunition) || Boolean((_b2 = weapon.properties) == null ? void 0 : _b2.ammoType);
    if (!usesAmmo) return null;
    const ammoType2 = inferAmmoTypeFromWeapon(weapon);
    if (!ammoType2) return null;
    const amount = typeof ((_c2 = weapon.properties) == null ? void 0 : _c2.ammoPerShot) === "number" && weapon.properties.ammoPerShot > 0 ? weapon.properties.ammoPerShot : 1;
    return { ammoType: ammoType2, amount, weaponId: weapon.id ?? null };
  }
  function isShieldEquippedByPlayer() {
    const inventory = Array.isArray(activeCharacterConfig == null ? void 0 : activeCharacterConfig.inventoryItems) ? activeCharacterConfig.inventoryItems : [];
    return getHandUsageState({
      inventoryItems: inventory,
      weaponById: weaponTypeById,
      armorById: armorItemsById
    }).hasShieldInHands;
  }
  function hasOffhandWeaponEquippedByPlayer() {
    const inventory = Array.isArray(activeCharacterConfig == null ? void 0 : activeCharacterConfig.inventoryItems) ? activeCharacterConfig.inventoryItems : [];
    return getHandUsageState({
      inventoryItems: inventory,
      weaponById: weaponTypeById,
      armorById: armorItemsById
    }).hasOffhandWeapon;
  }
  function isArmorEquippedByPlayer() {
    const inventory = Array.isArray(activeCharacterConfig == null ? void 0 : activeCharacterConfig.inventoryItems) ? activeCharacterConfig.inventoryItems : [];
    return inventory.some((item) => {
      if ((item == null ? void 0 : item.type) !== "armor" || !(item == null ? void 0 : item.equippedSlot)) return false;
      const def = armorItemsById.get(item.id);
      return Boolean(def && def.armorCategory !== "shield");
    });
  }
  function getFeatureRuleModifiersForActor(actor) {
    if (actor.type !== "player") return [];
    return activePlayerFeatures.flatMap((feature) => {
      const rules2 = feature.rules ?? {};
      const modifiers = Array.isArray(rules2.modifiers) ? rules2.modifiers : [];
      return modifiers.map((mod) => {
        const value2 = Number((mod == null ? void 0 : mod.value) ?? 0);
        if (!Number.isFinite(value2)) return null;
        return {
          applyTo: String((mod == null ? void 0 : mod.applyTo) ?? "").trim(),
          stat: typeof (mod == null ? void 0 : mod.stat) === "string" ? mod.stat : void 0,
          value: value2,
          when: (mod == null ? void 0 : mod.when) && typeof mod.when === "object" ? mod.when : {}
        };
      }).filter(Boolean);
    });
  }
  function getFeatureReactionModifiersForActor(actor) {
    if (actor.type !== "player") return [];
    return activePlayerFeatures.flatMap((feature) => {
      const rules2 = feature.rules ?? {};
      const modifiers = Array.isArray(rules2.reactionModifiers) ? rules2.reactionModifiers : [];
      return modifiers.map((mod) => ({
        event: typeof (mod == null ? void 0 : mod.event) === "string" ? mod.event : void 0,
        mode: typeof (mod == null ? void 0 : mod.mode) === "string" ? mod.mode : void 0,
        formula: typeof (mod == null ? void 0 : mod.formula) === "string" ? mod.formula : void 0,
        when: (mod == null ? void 0 : mod.when) && typeof mod.when === "object" ? mod.when : {},
        uiMessage: typeof (mod == null ? void 0 : mod.uiMessage) === "string" ? mod.uiMessage : void 0
      })).filter((mod) => Boolean(mod.event) && Boolean(mod.mode));
    });
  }
  function getFeatureSecondaryAttackPoliciesForActor(actor) {
    if (actor.type !== "player") return [];
    return activePlayerFeatures.flatMap((feature) => {
      const rules2 = feature.rules ?? {};
      const policy = rules2.secondaryAttackPolicy;
      if (!policy || typeof policy !== "object") return [];
      return [
        {
          mode: typeof policy.mode === "string" ? policy.mode : void 0,
          ability: typeof policy.ability === "string" ? policy.ability : void 0,
          when: policy.when && typeof policy.when === "object" ? policy.when : {}
        }
      ];
    });
  }
  function featureModifierMatches(params) {
    var _a2, _b2, _c2, _d, _e, _f, _g, _h, _i, _j, _k, _l;
    const when = params.modifier.when ?? {};
    const actorType = String(when.actorType ?? "").trim();
    if (actorType && actorType !== params.actor.type) return false;
    if (when.actionCategory && String(when.actionCategory) !== String(((_a2 = params.action) == null ? void 0 : _a2.category) ?? "")) {
      return false;
    }
    if (when.actionCostType) {
      const costType = String(((_c2 = (_b2 = params.action) == null ? void 0 : _b2.actionCost) == null ? void 0 : _c2.actionType) ?? "");
      if (String(when.actionCostType) !== costType) return false;
    }
    if (Array.isArray(when.actionTagsAny) && when.actionTagsAny.length > 0) {
      const tags2 = Array.isArray((_d = params.action) == null ? void 0 : _d.tags) ? (_e = params.action) == null ? void 0 : _e.tags : [];
      const any = when.actionTagsAny.some((tag) => tags2.includes(String(tag)));
      if (!any) return false;
    }
    if (Array.isArray(when.actionTagsAll) && when.actionTagsAll.length > 0) {
      const tags2 = Array.isArray((_f = params.action) == null ? void 0 : _f.tags) ? (_g = params.action) == null ? void 0 : _g.tags : [];
      const all = when.actionTagsAll.every((tag) => tags2.includes(String(tag)));
      if (!all) return false;
    }
    if (when.weaponCategory || Array.isArray(when.weaponCategories)) {
      const category2 = String(((_h = params.weapon) == null ? void 0 : _h.category) ?? "");
      const expected = Array.isArray(when.weaponCategories) ? when.weaponCategories.map((entry) => String(entry)) : [String(when.weaponCategory)];
      if (!category2 || !expected.includes(category2)) return false;
    }
    if (typeof when.weaponTwoHanded === "boolean") {
      if (Boolean((_j = (_i = params.weapon) == null ? void 0 : _i.properties) == null ? void 0 : _j.twoHanded) !== Boolean(when.weaponTwoHanded)) return false;
    }
    if (typeof when.weaponLight === "boolean") {
      if (Boolean((_l = (_k = params.weapon) == null ? void 0 : _k.properties) == null ? void 0 : _l.light) !== Boolean(when.weaponLight)) return false;
    }
    if (typeof when.requiresArmor === "boolean" && params.actor.type === "player") {
      if (isArmorEquippedByPlayer() !== Boolean(when.requiresArmor)) return false;
    }
    if (typeof when.requiresShield === "boolean" && params.actor.type === "player") {
      if (isShieldEquippedByPlayer() !== Boolean(when.requiresShield)) return false;
    }
    if (typeof when.requiresOffhandWeapon === "boolean" && params.actor.type === "player") {
      if (hasOffhandWeaponEquippedByPlayer() !== Boolean(when.requiresOffhandWeapon)) return false;
    }
    if (typeof when.requiresNoOffhandWeapon === "boolean" && params.actor.type === "player") {
      const noOffhand = !hasOffhandWeaponEquippedByPlayer();
      if (noOffhand !== Boolean(when.requiresNoOffhandWeapon)) return false;
    }
    return true;
  }
  function reactionModifierMatches(params) {
    const when = params.modifier.when ?? {};
    if (when.actionCategory && String(when.actionCategory) !== String(params.action.category ?? "")) {
      return false;
    }
    if (typeof when.targetMustBeAlly === "boolean") {
      const isAlly = params.target.type === params.reactor.type;
      if (isAlly !== Boolean(when.targetMustBeAlly)) return false;
    }
    if (typeof when.targetMustNotBeSelf === "boolean") {
      const mustNotBeSelf = Boolean(when.targetMustNotBeSelf);
      if (mustNotBeSelf && params.target.id === params.reactor.id) return false;
    }
    if (typeof when.requiresShield === "boolean" && params.reactor.type === "player") {
      if (isShieldEquippedByPlayer() !== Boolean(when.requiresShield)) return false;
    }
    if (typeof when.maxDistanceToTarget === "number") {
      if (params.distanceToTarget > Number(when.maxDistanceToTarget)) return false;
    }
    if (typeof when.targetVisible === "boolean" && Boolean(when.targetVisible)) {
      const allTokens = getTokensOnActiveLevel([player, ...enemies]);
      const visible = isTargetVisible(
        params.reactor,
        params.attacker,
        allTokens,
        visionBlockersActive,
        playableCells,
        wallEdges.vision,
        lightLevels,
        mapGrid
      );
      if (!visible) return false;
    }
    return true;
  }
  function secondaryPolicyMatches(params) {
    var _a2, _b2, _c2;
    const when = params.policy.when ?? {};
    if (when.actionCategory && String(when.actionCategory) !== String(params.action.category ?? "")) {
      return false;
    }
    if (when.actionCostType) {
      const costType = String(((_a2 = params.action.actionCost) == null ? void 0 : _a2.actionType) ?? "");
      if (String(when.actionCostType) !== costType) return false;
    }
    if (typeof when.requiresOffhandWeapon === "boolean" && params.actor.type === "player") {
      if (hasOffhandWeaponEquippedByPlayer() !== Boolean(when.requiresOffhandWeapon)) return false;
    }
    if (typeof when.weaponLight === "boolean") {
      if (Boolean((_c2 = (_b2 = params.weapon) == null ? void 0 : _b2.properties) == null ? void 0 : _c2.light) !== Boolean(when.weaponLight)) return false;
    }
    if (Array.isArray(when.actionTagsAny) && when.actionTagsAny.length > 0) {
      const tags2 = Array.isArray(params.action.tags) ? params.action.tags : [];
      const any = when.actionTagsAny.some((tag) => tags2.includes(String(tag)));
      if (!any) return false;
    }
    return true;
  }
  function isSecondaryAttackAction(action2) {
    var _a2;
    const tags2 = Array.isArray(action2.tags) ? action2.tags : [];
    if (tags2.includes("secondary-attack")) return true;
    if (tags2.includes("offhand-attack")) return true;
    return ((_a2 = action2.actionCost) == null ? void 0 : _a2.actionType) === "bonus" && action2.category === "attack";
  }
  function appendModTokenToFormula(formula, modToken) {
    if (!formula || !modToken) return formula;
    const normalizedFormula = formula.replace(/\s+/g, "");
    if (normalizedFormula.toLowerCase().includes(modToken.toLowerCase())) return formula;
    return `${formula} + ${modToken}`;
  }
  function applyFeatureCombatStatModifiers(actor, stats) {
    const modifiers = getFeatureRuleModifiersForActor(actor);
    if (modifiers.length === 0) return stats;
    const next = { ...stats, mods: { ...stats.mods } };
    modifiers.forEach((mod) => {
      if (mod.applyTo !== "combatStat" || !mod.stat) return;
      if (!featureModifierMatches({ modifier: mod, actor })) return;
      if (mod.stat === "armorClass") {
        next.armorClass = Number(next.armorClass ?? 0) + Number(mod.value ?? 0);
      } else if (mod.stat === "attackBonus") {
        next.attackBonus = Number(next.attackBonus ?? 0) + Number(mod.value ?? 0);
      } else if (mod.stat === "maxHp") {
        next.maxHp = Number(next.maxHp ?? 0) + Number(mod.value ?? 0);
      }
    });
    return next;
  }
  function appendDamageDeltaToFormula(formula, delta) {
    if (!Number.isFinite(delta) || delta === 0) return formula;
    return delta > 0 ? `${formula}+${delta}` : `${formula}${delta}`;
  }
  function applyFeatureActionModifiers(params) {
    var _a2;
    const modifiers = getFeatureRuleModifiersForActor(params.actor);
    const secondaryPolicies = getFeatureSecondaryAttackPoliciesForActor(params.actor);
    if (modifiers.length === 0 && secondaryPolicies.length === 0) return params.action;
    const attackDelta = modifiers.reduce((sum, mod) => {
      if (mod.applyTo !== "attack") return sum;
      if (!featureModifierMatches({
        modifier: mod,
        actor: params.actor,
        action: params.action,
        weapon: params.weapon ?? null
      })) {
        return sum;
      }
      return sum + Number(mod.value ?? 0);
    }, 0);
    const damageDelta = modifiers.reduce((sum, mod) => {
      if (mod.applyTo !== "damage") return sum;
      if (!featureModifierMatches({
        modifier: mod,
        actor: params.actor,
        action: params.action,
        weapon: params.weapon ?? null
      })) {
        return sum;
      }
      return sum + Number(mod.value ?? 0);
    }, 0);
    const damageRerollLow = modifiers.reduce((best, mod) => {
      if (mod.applyTo !== "damageReroll") return best;
      if (!featureModifierMatches({
        modifier: mod,
        actor: params.actor,
        action: params.action,
        weapon: params.weapon ?? null
      })) {
        return best;
      }
      return Math.max(best, Math.floor(Number(mod.value ?? 0)));
    }, 0);
    const secondaryAbilityToken = secondaryPolicies.reduce((selected, policy) => {
      if (selected) return selected;
      if (policy.mode !== "addAbilityModToDamage") return selected;
      if (!isSecondaryAttackAction(params.action)) return selected;
      if (!secondaryPolicyMatches({
        policy,
        actor: params.actor,
        action: params.action,
        weapon: params.weapon ?? null
      })) {
        return selected;
      }
      const ability = String(policy.ability ?? "").trim().toUpperCase();
      if (ability === "FOR" || ability === "STR") return "modFOR";
      if (ability === "DEX") return "modDEX";
      if (ability === "CON") return "modCON";
      if (ability === "INT") return "modINT";
      if (ability === "SAG" || ability === "WIS") return "modSAG";
      if (ability === "CHA") return "modCHA";
      return params.modToken ?? null;
    }, null);
    if (attackDelta === 0 && damageDelta === 0 && damageRerollLow <= 0 && !secondaryAbilityToken) {
      return params.action;
    }
    const nextDamageFormula = params.action.damage && secondaryAbilityToken ? appendModTokenToFormula(params.action.damage.formula, secondaryAbilityToken) : (_a2 = params.action.damage) == null ? void 0 : _a2.formula;
    return {
      ...params.action,
      attack: params.action.attack ? { ...params.action.attack, bonus: Number(params.action.attack.bonus ?? 0) + attackDelta } : params.action.attack,
      damage: params.action.damage && (damageDelta !== 0 || damageRerollLow > 0) ? {
        ...params.action.damage,
        formula: damageDelta !== 0 ? appendDamageDeltaToFormula(String(nextDamageFormula ?? "0"), damageDelta) : nextDamageFormula,
        ...damageRerollLow > 0 ? {
          rerollLow: {
            lte: damageRerollLow
          }
        } : null
      } : params.action.damage
    };
  }
  function getWeaponActionConstraintIssues(action2, actor, options) {
    var _a2, _b2;
    const weapon = action2.category === "attack" ? pickWeaponForAction(action2, actor, options) : null;
    const reasons = getEquipmentConstraintIssuesForActor(action2, actor, weapon);
    const handlingCost = resolveWeaponHandlingCost({ action: action2, actor, weapon });
    if (handlingCost.requiresAction) {
      reasons.push(
        "Changement d'arme impossible: arme rangee dans le sac (sortie d'arme = une action dediee)."
      );
    }
    if (handlingCost.requiresInteraction > 0 && actor.type === "player") {
      const maxInteractions = getMaxWeaponInteractionsPerTurnForActor(actor);
      if (turnEquipmentUsage.usedInteractionCount + handlingCost.requiresInteraction > maxInteractions) {
        reasons.push("Interaction d'equipement deja consommee ce tour.");
      }
    }
    if (action2.category !== "attack" || !weapon) return reasons;
    const loadingUsageKey = getWeaponLoadingUsageKey(action2);
    if (loadingUsageKey) {
      const used = Number(getActionUsageForActor(actor.id).turn[loadingUsageKey] ?? 0);
      if (used >= 1) {
        reasons.push("Arme a chargement: deja utilisee pour ce type d'action ce tour.");
      }
    }
    if ((_a2 = weapon.properties) == null ? void 0 : _a2.ammunition) {
      const ammoType2 = inferAmmoTypeFromWeapon(weapon);
      if (!ammoType2) {
        reasons.push(`Type de munition introuvable pour ${weapon.name}.`);
      } else if (actor.type === "player" && isPhysicalResource(ammoType2)) {
        const amount = typeof ((_b2 = weapon.properties) == null ? void 0 : _b2.ammoPerShot) === "number" && weapon.properties.ammoPerShot > 0 ? weapon.properties.ammoPerShot : 1;
        const available = activeCharacterConfig ? getInventoryResourceCount(activeCharacterConfig, ammoType2) : 0;
        if (available < amount) {
          reasons.push(`Munitions insuffisantes (${ammoType2}: ${available}/${amount}).`);
        }
      }
    }
    return reasons;
  }
  function getEquipmentConstraintIssuesForActor(action2, actor, selectedWeapon) {
    if (actor.type !== "player") return [];
    const inventory = Array.isArray(activeCharacterConfig == null ? void 0 : activeCharacterConfig.inventoryItems) ? activeCharacterConfig.inventoryItems : [];
    return getEquipmentConstraintIssues({
      action: action2,
      inventoryItems: inventory,
      weaponById: weaponTypeById,
      armorById: armorItemsById,
      selectedWeapon,
      features: activePlayerFeatures
    });
  }
  function getMaxWeaponInteractionsPerTurnForActor(actor) {
    if (actor.type !== "player") return 0;
    const extra = Number(playerEquipmentPolicy.extraWeaponInteractionsPerTurn ?? 0);
    const normalizedExtra = Number.isFinite(extra) ? Math.max(0, Math.floor(extra)) : 0;
    return 1 + normalizedExtra;
  }
  function resolveWeaponHandlingCost(params) {
    const { action: action2, actor } = params;
    const weapon = params.weapon ?? null;
    if (actor.type !== "player" || action2.category !== "attack" || !weapon) {
      return { requiresInteraction: 0, requiresAction: false };
    }
    const inventory = Array.isArray(activeCharacterConfig == null ? void 0 : activeCharacterConfig.inventoryItems) ? activeCharacterConfig.inventoryItems : [];
    const primaryIds = getPrimaryWeaponIds(activeCharacterConfig);
    if (primaryIds.length === 0) {
      return { requiresInteraction: 0, requiresAction: false };
    }
    if (primaryIds.includes(weapon.id)) {
      return { requiresInteraction: 0, requiresAction: false };
    }
    const hasCarried = inventory.some(
      (entry) => (entry == null ? void 0 : entry.type) === "weapon" && String((entry == null ? void 0 : entry.id) ?? "") === weapon.id && Boolean(entry == null ? void 0 : entry.equippedSlot) && !(entry == null ? void 0 : entry.storedIn) && WEAPON_CARRY_SLOTS.has(String(entry.equippedSlot))
    );
    const hasPacked = inventory.some(
      (entry) => (entry == null ? void 0 : entry.type) === "weapon" && String((entry == null ? void 0 : entry.id) ?? "") === weapon.id && (Boolean(entry == null ? void 0 : entry.storedIn) || Boolean(entry == null ? void 0 : entry.equippedSlot) && !WEAPON_CARRY_SLOTS.has(String(entry.equippedSlot)))
    );
    const ignoreInteraction = Boolean(playerEquipmentPolicy.allowWeaponSwapWithoutInteraction);
    if (hasCarried) {
      return { requiresInteraction: ignoreInteraction ? 0 : 1, requiresAction: false };
    }
    if (hasPacked) {
      const drawAsInteraction = Boolean(playerEquipmentPolicy.drawWeaponFromPackAsInteraction);
      if (drawAsInteraction) {
        return { requiresInteraction: ignoreInteraction ? 0 : 1, requiresAction: false };
      }
      return { requiresInteraction: 0, requiresAction: true };
    }
    return { requiresInteraction: 0, requiresAction: false };
  }
  function shouldUseTwoHandedDamageForAction(action2, actor, weapon) {
    var _a2, _b2, _c2;
    const versatile = (_a2 = weapon.properties) == null ? void 0 : _a2.versatile;
    if (typeof versatile !== "string" || !versatile.trim()) return false;
    const tags2 = action2.tags ?? [];
    const isRangedMode = tags2.includes("ranged") || ((_c2 = (_b2 = action2.targeting) == null ? void 0 : _b2.range) == null ? void 0 : _c2.max) > 1.5;
    if (isRangedMode) return false;
    if (actor.type === "player") return !isShieldEquippedByPlayer();
    return true;
  }
  function updateWeaponPropertyUsageForAction(actorId, action2, delta) {
    const loadingUsageKey = getWeaponLoadingUsageKey(action2);
    if (!loadingUsageKey) return;
    updateActionUsageForActor(actorId, loadingUsageKey, delta);
  }
  function actionSpendsResource(action2, name2) {
    if (!action2.ops || !name2) return false;
    const match = name2.toLowerCase();
    return Object.values(action2.ops).some(
      (list) => Array.isArray(list) ? list.some(
        (op) => (op == null ? void 0 : op.op) === "SpendResource" && String(op.name ?? "").toLowerCase() === match
      ) : false
    );
  }
  function computeWeaponAttackBonus$1(actor, weapon) {
    const modToken = resolveWeaponModToken({ actor, weapon, getAbilityModForActor });
    return computeWeaponAttackBonus({
      actor,
      weapon,
      getAbilityModForActor,
      getProficiencyBonusForActor,
      getWeaponProficienciesForActor,
      forceModToken: modToken
    });
  }
  function applyWeaponOverrideForActor(action2, actor, options) {
    var _a2, _b2;
    if (action2.category !== "attack") return action2;
    const weapon = pickWeaponForAction(action2, actor, options);
    if (!weapon) return action2;
    const tags2 = action2.tags ?? [];
    const prefersRanged = tags2.includes("ranged") || ((_b2 = (_a2 = action2.targeting) == null ? void 0 : _a2.range) == null ? void 0 : _b2.max) > 1.5;
    const modToken = resolveWeaponModToken({ actor, weapon, getAbilityModForActor });
    const useTwoHandedDamage = shouldUseTwoHandedDamageForAction(action2, actor, weapon);
    const attackBonus = computeWeaponAttackBonus$1(actor, weapon);
    const overridden = buildWeaponOverrideAction({
      action: action2,
      weapon,
      attackBonus,
      modToken,
      prefersRanged,
      useTwoHandedDamage
    });
    return applyFeatureActionModifiers({ actor, action: overridden, weapon, modToken });
  }
  function getEnemyAttackAction(enemy) {
    const ids = Array.isArray(enemy.actionIds) ? enemy.actionIds : [];
    const candidates = ids.map((id2) => getActionById(id2)).filter((a2) => Boolean(a2)).filter((a2) => a2.category === "attack");
    if (candidates.length === 0) return null;
    const overridden = candidates.map((a2) => applyWeaponOverrideForActor(a2, enemy));
    return overridden.reduce((best, cur) => {
      var _a2, _b2, _c2, _d;
      const bestRange = ((_b2 = (_a2 = best.targeting) == null ? void 0 : _a2.range) == null ? void 0 : _b2.max) ?? 1.5;
      const curRange = ((_d = (_c2 = cur.targeting) == null ? void 0 : _c2.range) == null ? void 0 : _d.max) ?? 1.5;
      return curRange > bestRange ? cur : best;
    }, overridden[0]);
  }
  function getEnemyAttackRange(enemy) {
    var _a2, _b2;
    const action2 = getEnemyAttackAction(enemy);
    return typeof ((_b2 = (_a2 = action2 == null ? void 0 : action2.targeting) == null ? void 0 : _a2.range) == null ? void 0 : _b2.max) === "number" ? action2.targeting.range.max : 1.5;
  }
  function getActorDefaultReach(actor) {
    if (actor.type === "enemy") return getEnemyAttackRange(actor);
    const weapons = getWeaponsForActor(actor);
    if (!weapons || weapons.length === 0) return 1.5;
    const reachValues = weapons.map((weapon) => {
      var _a2, _b2, _c2;
      const reach = (_a2 = weapon.properties) == null ? void 0 : _a2.reach;
      if (typeof reach === "number" && reach > 0) return reach;
      const range = (_c2 = (_b2 = weapon.properties) == null ? void 0 : _b2.range) == null ? void 0 : _c2.normal;
      if (typeof range === "number" && range > 0) return range;
      return 1.5;
    });
    return Math.max(1.5, ...reachValues);
  }
  function getActorOpportunityReach(actor) {
    const weapons = getWeaponsForActor(actor, { reaction: true });
    if (!weapons || weapons.length === 0) return 1.5;
    const meleeReaches = weapons.filter((weapon) => weapon.category === "melee" || weapon.category === "polyvalent").map((weapon) => {
      var _a2;
      const reach = (_a2 = weapon.properties) == null ? void 0 : _a2.reach;
      return typeof reach === "number" && reach > 0 ? reach : 1.5;
    });
    if (meleeReaches.length === 0) return 1.5;
    return Math.max(1.5, ...meleeReaches);
  }
  function getValidatedAction() {
    const action2 = getActionById(validatedActionId);
    if (!action2) return null;
    return applyWeaponOverrideForActor(action2, player);
  }
  function actionNeedsDiceUI(action2) {
    if (pendingHazardRoll) return true;
    if (!action2) return false;
    return Boolean(action2.attack || action2.damage || action2.skillCheck);
  }
  function actionTargetsHostile(action2) {
    var _a2;
    const target = (_a2 = action2 == null ? void 0 : action2.targeting) == null ? void 0 : _a2.target;
    return target === "enemy" || target === "hostile";
  }
  function getActionVisualEffects(action2) {
    if (!action2) return [];
    const v2Ops = action2.ops ? Object.entries(action2.ops).flatMap(
      ([key2, list]) => Array.isArray(list) ? list.filter((op) => (op == null ? void 0 : op.op) === "PlayVisualEffect" && typeof op.effectId === "string").map((op) => ({
        effectId: String(op.effectId),
        anchor: op.anchor,
        offset: op.offset,
        orientation: op.orientation,
        rotationOffsetDeg: op.rotationOffsetDeg,
        durationMs: typeof op.durationMs === "number" ? op.durationMs : void 0,
        onlyOnHit: key2 === "onHit",
        onlyOnMiss: key2 === "onMiss"
      })) : []
    ) : [];
    return v2Ops;
  }
  function resolveActionEffectOrientation(action2, spec) {
    const orientation = spec.orientation ?? (actionTargetsHostile(action2) ? "to_target" : "none");
    if (orientation === "none") return null;
    const actorPos = { x: player.x, y: player.y };
    let targetPos = null;
    const primaryTargetId2 = getPrimaryTargetId();
    if (primaryTargetId2) {
      const target = enemies.find((e2) => e2.id === primaryTargetId2) ?? null;
      if (target) targetPos = { x: target.x, y: target.y };
    } else if (selectedObstacleTarget) {
      targetPos = { x: selectedObstacleTarget.x, y: selectedObstacleTarget.y };
    } else if (selectedWallTarget) {
      targetPos = { x: selectedWallTarget.x, y: selectedWallTarget.y };
    }
    if (!targetPos) return null;
    const from = orientation === "to_target" ? actorPos : targetPos;
    const to = orientation === "to_target" ? targetPos : actorPos;
    const dx = to.x - from.x;
    const dy = to.y - from.y;
    if (dx === 0 && dy === 0) return null;
    const angleDeg = Math.atan2(dy, dx) * 180 / Math.PI;
    const offset = typeof spec.rotationOffsetDeg === "number" ? spec.rotationOffsetDeg : 0;
    return angleDeg + offset;
  }
  function resolveActionEffectAnchor(action2, spec) {
    const anchor2 = spec.anchor ?? (actionTargetsHostile(action2) ? "target" : "self");
    if (anchor2 === "target") {
      const primaryTargetId2 = getPrimaryTargetId();
      if (primaryTargetId2) {
        const target = enemies.find((e2) => e2.id === primaryTargetId2) ?? null;
        if (target) return { x: target.x, y: target.y };
      }
      if (selectedObstacleTarget) {
        return { x: selectedObstacleTarget.x, y: selectedObstacleTarget.y };
      }
      if (selectedWallTarget) {
        return { x: selectedWallTarget.x, y: selectedWallTarget.y };
      }
      return { x: player.x, y: player.y };
    }
    return { x: player.x, y: player.y };
  }
  function computeActionEffectDurationMs(params) {
    var _a2, _b2, _c2;
    if (typeof params.spec.durationMs === "number") {
      return Math.max(120, params.spec.durationMs);
    }
    const defDuration = (_a2 = params.def) == null ? void 0 : _a2.durationMs;
    if (typeof defDuration === "number") {
      return Math.max(120, defDuration);
    }
    const spriteKey = (_b2 = params.appearance) == null ? void 0 : _b2.spriteKey;
    const frames = spriteKey ? getObstacleAnimationFrames(spriteKey) : null;
    if (frames && frames.length > 0) {
      const speed2 = typeof ((_c2 = params.appearance) == null ? void 0 : _c2.animationSpeed) === "number" ? params.appearance.animationSpeed : 0.15;
      const framesPerSecond = Math.max(1, speed2 * 60);
      return Math.max(160, Math.round(frames.length / framesPerSecond * 1e3));
    }
    return 450;
  }
  function scheduleActionEffectRemoval(effectId, durationMs2) {
    const timer = window.setTimeout(() => {
      setActionEffects((prev) => prev.filter((effect) => effect.id !== effectId));
      actionEffectTimersRef.current.delete(effectId);
    }, durationMs2);
    actionEffectTimersRef.current.set(effectId, timer);
  }
  async function spawnActionVisualEffects(action2) {
    const specs = getActionVisualEffects(action2);
    if (specs.length === 0) return false;
    const entries = [];
    const spriteKeys = /* @__PURE__ */ new Set();
    specs.forEach((spec) => {
      if (spec.onlyOnHit && attackOutcome !== "hit") return;
      if (spec.onlyOnMiss && attackOutcome !== "miss") return;
      const def = effectTypeById.get(spec.effectId) ?? null;
      const appearance2 = (def == null ? void 0 : def.appearance) ?? null;
      if (!(appearance2 == null ? void 0 : appearance2.spriteKey)) return;
      entries.push({ spec, def, appearance: appearance2 });
      spriteKeys.add(appearance2.spriteKey);
    });
    if (entries.length === 0) return false;
    try {
      await preloadObstaclePngTexturesFor([...spriteKeys]);
    } catch (error) {
      console.warn("[actions] VFX preload failed:", error);
      return false;
    }
    const created = [];
    entries.forEach((entry, index) => {
      const { spec, def, appearance: appearance2 } = entry;
      const anchor2 = resolveActionEffectAnchor(action2, spec);
      if (!anchor2) return;
      const offset = spec.offset ?? { x: 0, y: 0 };
      const x2 = Math.max(0, Math.min(mapGrid.cols - 1, anchor2.x + offset.x));
      const y2 = Math.max(0, Math.min(mapGrid.rows - 1, anchor2.y + offset.y));
      const rotationDeg = resolveActionEffectOrientation(action2, spec);
      const id2 = `action-effect-${action2.id}-${Date.now()}-${index}`;
      const durationMs2 = computeActionEffectDurationMs({ spec, def, appearance: appearance2 });
      created.push({
        id: id2,
        typeId: spec.effectId,
        x: x2,
        y: y2,
        active: true,
        rotationDeg: typeof rotationDeg === "number" ? rotationDeg : void 0,
        expiresAt: Date.now() + durationMs2
      });
      scheduleActionEffectRemoval(id2, durationMs2);
    });
    if (created.length === 0) return false;
    setActionEffects((prev) => [...prev, ...created]);
    return true;
  }
  function resolvePlayerAdvantageMode(action2) {
    if (!action2 || !actionTargetsHostile(action2)) return advantageMode;
    const primaryTargetId2 = getPrimaryTargetId();
    if (!primaryTargetId2) return advantageMode;
    if (primaryTargetId2 !== killerInstinctTargetId) return advantageMode;
    const target = enemies.find((e2) => e2.id === primaryTargetId2) ?? null;
    if (!target || isTokenDead(target)) return advantageMode;
    return "advantage";
  }
  function getActionResourceInfo(action2) {
    var _a2, _b2;
    if (!((_b2 = (_a2 = action2 == null ? void 0 : action2.usage) == null ? void 0 : _a2.resource) == null ? void 0 : _b2.name) || typeof action2.usage.resource.min !== "number") {
      return null;
    }
    const resource = action2.usage.resource;
    const pool = typeof resource.pool === "string" ? resource.pool : null;
    const current = getResourceAmount(resource.name, pool);
    const label2 = pool ? `${pool}:${resource.name}` : resource.name;
    return { label: label2, current, min: resource.min };
  }
  function resolvePlayerActionTarget(action2) {
    var _a2;
    const target = (_a2 = action2.targeting) == null ? void 0 : _a2.target;
    if (target === "self") return { kind: "token", token: player };
    if (target === "cell" || target === "emptyCell") {
      if (selectedPath.length > 0) {
        const last = selectedPath[selectedPath.length - 1];
        return { kind: "cell", x: last.x, y: last.y };
      }
      if (selectedObstacleTarget) {
        return { kind: "cell", x: selectedObstacleTarget.x, y: selectedObstacleTarget.y };
      }
      if (selectedWallTarget) {
        return { kind: "cell", x: selectedWallTarget.x, y: selectedWallTarget.y };
      }
      return null;
    }
    if (selectedTargetIds.length > 0) {
      const allTokens = [player, ...enemies];
      const tokens = selectedTargetIds.map((id2) => allTokens.find((t2) => t2.id === id2) ?? null).filter((value2) => Boolean(value2));
      if (tokens.length > 1) return { kind: "tokens", tokens };
      if (tokens.length === 1) return { kind: "token", token: tokens[0] };
    }
    return null;
  }
  async function playVisualEffectFromOp(op) {
    if (!op.effectId) return;
    const def = effectTypeById.get(op.effectId) ?? null;
    const appearance2 = (def == null ? void 0 : def.appearance) ?? null;
    if (!(appearance2 == null ? void 0 : appearance2.spriteKey)) return;
    try {
      await preloadObstaclePngTexturesFor([appearance2.spriteKey]);
    } catch (error) {
      console.warn("[actions] VFX preload failed:", error);
    }
    const primaryTargetId2 = getPrimaryTargetId();
    const anchor2 = op.anchor === "self" || op.anchor === "actor" ? { x: player.x, y: player.y } : primaryTargetId2 ? (() => {
      const target = enemies.find((e2) => e2.id === primaryTargetId2) ?? null;
      return target ? { x: target.x, y: target.y } : { x: player.x, y: player.y };
    })() : selectedObstacleTarget ? { x: selectedObstacleTarget.x, y: selectedObstacleTarget.y } : selectedWallTarget ? { x: selectedWallTarget.x, y: selectedWallTarget.y } : { x: player.x, y: player.y };
    const offset = op.offset ?? { x: 0, y: 0 };
    const x2 = Math.max(0, Math.min(mapGrid.cols - 1, anchor2.x + offset.x));
    const y2 = Math.max(0, Math.min(mapGrid.rows - 1, anchor2.y + offset.y));
    const id2 = `op-effect-${op.effectId}-${Date.now()}`;
    const durationMs2 = typeof op.durationMs === "number" ? op.durationMs : 800;
    setActionEffects((prev) => [
      ...prev,
      { id: id2, typeId: op.effectId, x: x2, y: y2, active: true, expiresAt: Date.now() + durationMs2 }
    ]);
    scheduleActionEffectRemoval(id2, durationMs2);
  }
  function spendPlayerResource(name2, pool, amount) {
    if (isPhysicalResource(name2)) {
      setCombatCharacterConfig((prev) => prev ? spendInventoryResource(prev, name2, amount) : prev);
      setCharacterConfig((prev) => spendInventoryResource(prev, name2, amount));
      return;
    }
    const key2 = resourceKey(name2, pool);
    setPlayerResources((prev) => ({
      ...prev,
      [key2]: Math.max(0, (prev[key2] ?? 0) - amount)
    }));
  }
  function resolvePlayerActionV2(action2, overrides) {
    var _a2, _b2, _c2;
    const target = resolvePlayerActionTarget(action2);
    pushLog2(
      `[pipeline-ui] Resolve start: action=${action2.id} target=${(target == null ? void 0 : target.kind) ?? "none"} resolution=${((_a2 = action2.resolution) == null ? void 0 : _a2.kind) ?? (action2.attack ? "ATTACK_ROLL" : "NO_ROLL")}`
    );
    if (((_b2 = action2.targeting) == null ? void 0 : _b2.target) !== "self" && !target) {
      pushLog2("Cible manquante pour l'action.");
      return false;
    }
    const constraintIssues = getWeaponActionConstraintIssues(action2, player);
    if (constraintIssues.length > 0) {
      pushLog2(`Action impossible: ${constraintIssues.join(" | ")}`);
      return false;
    }
    const attackOverride = (overrides == null ? void 0 : overrides.attackRoll) ?? attackRoll ?? null;
    let damageUsed = false;
    const damageOverride = (overrides == null ? void 0 : overrides.damageRoll) ?? damageRoll ?? null;
    const isReactionAction = ((_c2 = action2.actionCost) == null ? void 0 : _c2.actionType) === "reaction";
    const usedWeapon = action2.category === "attack" ? pickWeaponForAction(action2, player, isReactionAction ? { reaction: true } : void 0) : null;
    const ammoUsage = resolveAmmoUsageForAction(action2, player);
    const ammoSpendInOps = ammoUsage ? actionSpendsResource(action2, ammoUsage.ammoType) : false;
    const spellUsageResolution = isSpellActionId(action2.id) ? resolveSpellUsageCandidate(
      activeCharacterConfig,
      action2.id,
      selectedSpellSourceBySpellId[action2.id] ?? null
    ) : { candidate: null, reason: null };
    if (spellUsageResolution.reason) {
      pushLog2(`Action impossible: ${spellUsageResolution.reason}`);
      return false;
    }
    if (ammoUsage && isPhysicalResource(ammoUsage.ammoType)) {
      const available = activeCharacterConfig ? getInventoryResourceCount(activeCharacterConfig, ammoUsage.ammoType) : 0;
      if (available < ammoUsage.amount) {
        pushLog2(
          `Munitions insuffisantes (${ammoUsage.ammoType}).`
        );
        return false;
      }
    } else if (ammoUsage) {
      pushLog2(
        `Munitions non referencees: ${ammoUsage.ammoType}.`
      );
    }
    const result = resolveActionUnified(
      action2,
      {
        round: round2,
        phase: "player",
        actor: player,
        player,
        enemies,
        blockedMovementCells: obstacleBlocking.movement,
        blockedMovementEdges: wallEdges.movement,
        blockedVisionCells: visionBlockersActive,
        blockedAttackCells: obstacleBlocking.attacks,
        wallVisionEdges: wallEdges.vision,
        lightLevels,
        playableCells,
        grid: mapGrid,
        heightMap: mapHeight,
        floorIds: mapTerrain,
        activeLevel,
        sampleCharacter: activeCharacterConfig,
        getResourceAmount,
        getSlotAmount: (slot, level2) => getSlotAmountFromCharacter(activeCharacterConfig, slot, level2),
        usage: getActionUsageForActor(player.id),
        reactionAvailable: canUseReaction(player.id),
        concentrating: isTokenConcentrating(player),
        surprised: isTokenSurprised(player),
        getActionConstraintIssues: ({ action: action22, actor }) => {
          var _a3;
          return getWeaponActionConstraintIssues(action22, actor, {
            reaction: ((_a3 = action22.actionCost) == null ? void 0 : _a3.actionType) === "reaction"
          });
        },
        spawnEntity: createSummon,
        spendResource: (name2, pool, amount) => {
          spendPlayerResource(name2, pool, amount);
        },
        onLog: void 0,
        onModifyPathLimit: (delta) => {
          setBasePathLimit((prev) => Math.max(0, prev + delta));
          setPathLimit((prev) => Math.max(0, prev + delta));
        },
        onToggleTorch: () => {
          setPlayerTorchOn((prev) => !prev);
        },
        onSetKillerInstinctTarget: (targetId) => {
          if (killerInstinctTargetId) return;
          setKillerInstinctTargetId(targetId);
          setSelectedTargetIds([targetId]);
          setEnemies(
            (prev) => prev.map(
              (enemy) => enemy.id === targetId ? addStatusToToken(enemy, "killer-mark", player.id) : enemy
            )
          );
        },
        onGrantTempHp: ({ targetId, amount, durationTurns: durationTurns2 }) => {
          if (targetId === player.id) {
            setPlayer((prev) => applyTempHpToToken(prev, amount, durationTurns2));
          } else {
            setEnemies(
              (prev) => prev.map((e2) => e2.id === targetId ? applyTempHpToToken(e2, amount, durationTurns2) : e2)
            );
          }
        },
        onPlayVisualEffect: (op) => {
          void playVisualEffectFromOp(op);
        },
        emitEvent: (evt) => {
          recordCombatEvent({
            round: round2,
            phase,
            kind: evt.kind,
            actorId: evt.actorId,
            actorKind: evt.actorKind,
            targetId: evt.targetId ?? null,
            targetKind: evt.targetKind ?? null,
            summary: evt.summary,
            data: evt.data ?? {}
          });
        }
      },
      target ?? { kind: "none" },
      {
        weaponMasteryActions,
        rollOverrides: {
          attack: attackOverride,
          consumeDamageRoll: () => {
            if (damageUsed || !damageOverride) return null;
            damageUsed = true;
            return damageOverride;
          }
        }
      }
    );
    if (result.logs.length > 0) {
      pushLogBatch(result.logs);
    }
    if (!result.ok || !result.playerAfter || !result.enemiesAfter) {
      pushLog2(`Action V2 echec: ${result.reason || "inconnu"}.`);
      return false;
    }
    if (ammoUsage && isPhysicalResource(ammoUsage.ammoType) && !ammoSpendInOps) {
      spendPlayerResource(ammoUsage.ammoType, null, ammoUsage.amount);
    }
    if (spellUsageResolution.candidate) {
      const candidate = spellUsageResolution.candidate;
      consumeSpellUsageForPlayer(candidate);
      const sourceLabel = candidate.sourceId ? `${candidate.sourceType ?? "source"}:${candidate.sourceId}` : candidate.sourceKey;
      if (candidate.consumesSlot && candidate.slotLevel !== null) {
        pushLog2(
          `Sort ${action2.name}: consommation d'un slot niveau ${candidate.slotLevel} (${sourceLabel}).`
        );
      } else if (candidate.usageType.toLowerCase() === "limited" || candidate.usageType.toLowerCase() === "charge") {
        const remainingAfter = Math.max(0, Number(candidate.remainingUses ?? 0) - 1);
        pushLog2(
          `Sort ${action2.name}: usage ${candidate.usageType} (${sourceLabel}) -> ${remainingAfter} restant(s).`
        );
      } else {
        pushLog2(`Sort ${action2.name}: usage ${candidate.usageType || "at-will"} (${sourceLabel}).`);
      }
    }
    updateActionUsageForActor(player.id, action2.id, 1);
    updateWeaponPropertyUsageForAction(player.id, action2, 1);
    const nextEnemies = applySummonTurnOrder({
      prevEnemies: enemies,
      nextEnemies: result.enemiesAfter
    });
    setPlayer(result.playerAfter);
    setEnemies(nextEnemies);
    if (usedWeapon == null ? void 0 : usedWeapon.id) {
      setLastUsedWeaponAsPrimaryForPlayer(usedWeapon.id);
    }
    if (result.outcomeKind) {
      setAttackOutcome(result.outcomeKind === "miss" ? "miss" : "hit");
    }
    pushLog2(`[pipeline-ui] Resolve end: outcome=${result.outcomeKind ?? "none"} ok=true`);
    return true;
  }
  function handleRollAttack() {
    var _a2, _b2;
    if (isGameOver) return;
    if (isTokenDead(player)) return;
    const action2 = getValidatedAction();
    if (!action2) {
      pushLog2("Aucune action validee pour lancer un jet.");
      return;
    }
    if (!action2.attack) {
      pushLog2("Cette action ne requiert pas de jet de touche.");
      return;
    }
    if (hasRolledAttackForCurrentAction) {
      pushLog2(
        "Jet de touche deja effectue pour cette action ce tour. Validez une nouvelle action ou terminez le tour."
      );
      return;
    }
    let targetArmorClass = null;
    let targetLabel = null;
    if (actionTargetsHostile(action2)) {
      const primaryTargetId2 = getPrimaryTargetId();
      if (primaryTargetId2) {
        const target = enemies.find((e2) => e2.id === primaryTargetId2);
        if (!target) {
          pushLog2("Cible ennemie introuvable ou deja vaincue.");
          return;
        }
        targetArmorClass = typeof target.armorClass === "number" ? target.armorClass : null;
        targetLabel = target.id;
      } else if (selectedObstacleTarget) {
        const obstacle = obstacles.find((o2) => o2.id === selectedObstacleTarget.id) ?? null;
        if (!obstacle || obstacle.hp <= 0) {
          pushLog2("Obstacle introuvable ou deja detruit.");
          return;
        }
        const def = obstacleTypeById.get(obstacle.typeId) ?? null;
        targetArmorClass = typeof ((_a2 = def == null ? void 0 : def.durability) == null ? void 0 : _a2.ac) === "number" ? def.durability.ac : null;
        targetLabel = (def == null ? void 0 : def.label) ?? obstacle.typeId ?? "obstacle";
      } else if (selectedWallTarget) {
        const wall = wallSegments.find((w2) => w2.id === selectedWallTarget.id) ?? null;
        if (!wall || typeof wall.hp === "number" && wall.hp <= 0) {
          pushLog2("Mur introuvable ou deja detruit.");
          return;
        }
        const def = wall.typeId ? wallTypeById.get(wall.typeId) ?? null : null;
        if (!isWallDestructible(def)) {
          pushLog2("Ce mur est indestructible.");
          return;
        }
        targetArmorClass = typeof ((_b2 = def == null ? void 0 : def.durability) == null ? void 0 : _b2.ac) === "number" ? def.durability.ac : null;
        targetLabel = (def == null ? void 0 : def.label) ?? wall.typeId ?? "mur";
      } else {
        pushLog2(
          "Aucune cible selectionnee pour cette action. Selectionnez une cible avant le jet."
        );
        return;
      }
    }
    const effectiveAdvantage = resolvePlayerAdvantageMode(action2);
    pushLog2(
      `[pipeline-ui] Resolve check (attack): action=${action2.id} target=${targetLabel ?? "n/a"} adv=${effectiveAdvantage} critRange=${action2.attack.critRange ?? 20}`
    );
    const result = rollAttack(
      action2.attack.bonus,
      effectiveAdvantage,
      action2.attack.critRange ?? 20
    );
    setAttackRoll(result);
    setHasRolledAttackForCurrentAction(true);
    setDamageRoll(null);
    const rollsText = result.mode === "normal" ? `${result.d20.total}` : `${result.d20.rolls.join(" / ")} -> ${result.d20.total}`;
    const targetSuffix = actionTargetsHostile(action2) && targetLabel ? ` sur ${targetLabel}` : "";
    const baseLine = `Jet de touche (${action2.name})${targetSuffix} : ${rollsText} + ${result.bonus} = ${result.total}`;
    if (targetArmorClass !== null) {
      const isHit = result.total >= targetArmorClass || result.isCrit;
      const outcome = isHit ? `TOUCHE (CA ${targetArmorClass})${result.isCrit ? " (critique!)" : ""}` : `RATE (CA ${targetArmorClass})`;
      pushDiceLog(`${baseLine} -> ${outcome}`);
      pushLog2(
        `[pipeline-ui] Attack outcome: ${isHit ? "hit" : "miss"} total=${result.total} ac=${targetArmorClass} crit=${result.isCrit ? "yes" : "no"}`
      );
      setAttackOutcome(isHit ? "hit" : "miss");
      if (!isHit) {
        pushLog2(`Action ${action2.name}: attaque ratee.`);
      }
    } else {
      pushDiceLog(
        `${baseLine}${result.isCrit ? " (critique!)" : ""}`
      );
      pushLog2(
        `[pipeline-ui] Attack outcome: hit total=${result.total} ac=n/a crit=${result.isCrit ? "yes" : "no"}`
      );
      setAttackOutcome("hit");
    }
  }
  function applyHazardRoll(hazard2) {
    const result = rollDamage(hazard2.formula);
    setDamageRoll(result);
    const diceText = result.dice.map((d2) => d2.rolls.join("+")).join(" | ");
    const totalDamage = result.total;
    pushDiceLog(
      `Degats (${hazard2.label}) : ${diceText || "0"} + ${result.flatModifier} = ${totalDamage}`
    );
    setPlayer((prev) => {
      const beforeHp = prev.hp;
      const afterHp = Math.max(0, beforeHp - totalDamage);
      recordCombatEvent({
        round: round2,
        phase,
        kind: "damage",
        actorId: prev.id,
        actorKind: "player",
        targetId: prev.id,
        targetKind: "player",
        summary: `Le heros subit ${totalDamage} degats (${hazard2.label}) (PV ${beforeHp} -> ${afterHp}).`,
        data: {
          hazardId: hazard2.id,
          damage: totalDamage,
          formula: hazard2.formula,
          targetHpBefore: beforeHp,
          targetHpAfter: afterHp
        }
      });
      return { ...prev, hp: afterHp };
    });
    let statusId = null;
    let statusTriggered = false;
    if (hazard2.statusRoll) {
      const roll = rollDie(hazard2.statusRoll.die);
      const trigger2 = hazard2.statusRoll.trigger;
      statusId = hazard2.statusRoll.statusId ?? "status";
      pushDiceLog(
        `Jet d'etat (${statusId}) : d${hazard2.statusRoll.die} = ${roll.total}`
      );
      if (roll.total === trigger2) {
        setPlayer((prev) => addStatusToToken(prev, statusId));
        pushLog2(`Etat ${statusId} declenche.`);
        statusTriggered = true;
        recordCombatEvent({
          round: round2,
          phase,
          kind: "status",
          actorId: player.id,
          actorKind: "player",
          targetId: player.id,
          targetKind: "player",
          summary: `Le heros prend l'etat ${statusId}.`,
          data: { statusId }
        });
      }
    }
    setHazardResolution({
      damageTotal: totalDamage,
      diceText,
      statusId,
      statusTriggered
    });
    setActionContextOpen(true);
  }
  function resolveHazardRoll(hazard2, anchorCell) {
    setPendingHazardRoll(hazard2);
    setHazardResolution(null);
    const anchor2 = resolveAnchorForCell(anchorCell);
    setHazardAnchor(anchor2);
    applyHazardRoll(hazard2);
  }
  function handleFinishHazard() {
    setPendingHazardRoll(null);
    setHazardAnchor(null);
    setHazardResolution(null);
    handleFinishAction();
  }
  function handleRollDamage() {
    var _a2, _b2;
    if (isGameOver) return;
    if (isTokenDead(player)) return;
    const action2 = getValidatedAction();
    if (!action2) {
      pushLog2("Aucune action validee pour lancer un jet.");
      return;
    }
    if (!action2.damage) {
      pushLog2("Cette action ne requiert pas de jet de degats.");
      return;
    }
    if (action2.attack && !attackRoll) {
      pushLog2("Un jet de touche est requis avant les degats pour cette action.");
      return;
    }
    const resolvedDamageFormula = resolvePlayerFormula(action2.damage.formula);
    const damageRerollLow = Number(((_b2 = (_a2 = action2.damage) == null ? void 0 : _a2.rerollLow) == null ? void 0 : _b2.lte) ?? 0);
    pushLog2(
      `[pipeline-ui] Resolve check (damage): action=${action2.id} formula=${resolvedDamageFormula} crit=${(attackRoll == null ? void 0 : attackRoll.isCrit) ? "yes" : "no"} critRule=${action2.damage.critRule ?? "double-dice"}`
    );
    const result = rollDamage(resolvedDamageFormula, {
      isCrit: Boolean(attackRoll == null ? void 0 : attackRoll.isCrit),
      critRule: action2.damage.critRule,
      ...damageRerollLow > 0 ? { rerollLow: { lte: damageRerollLow } } : null
    });
    setDamageRoll(result);
    const diceText = result.dice.map((d2) => d2.rolls.join("+")).join(" | ");
    pushDiceLog(
      `Degats (${action2.name}) : ${diceText || "0"} + ${result.flatModifier} = ${result.total}${(attackRoll == null ? void 0 : attackRoll.isCrit) ? " (critique)" : ""}`
    );
    const ok = resolvePlayerActionV2(action2, { attackRoll, damageRoll: result });
    if (ok) {
      handleFinishAction();
    }
  }
  function handleAutoResolveRolls() {
    const action2 = getValidatedAction();
    if (!action2) {
      pushLog2("Aucune action validee pour lancer un jet.");
      return;
    }
    if (!action2.attack) {
      pushLog2("Mode auto: pas de jet de touche necessaire.");
      if (action2.damage) {
        handleRollDamage();
      }
      return;
    }
    handleRollAttack();
    setTimeout(() => {
      if (action2.damage) {
        handleRollDamage();
      }
    }, 50);
  }
  function handleBoardClick(event) {
    var _a2, _b2, _c2, _d, _e, _f, _g, _h, _i;
    if (phase !== "player") return;
    if (isGameOver) return;
    if (isTokenDead(player)) return;
    if (Date.now() < suppressBoardClickUntilRef.current) return;
    const container = pixiContainerRef.current;
    if (!container) return;
    const canvas = container.querySelector("canvas");
    if (!canvas) return;
    const bounds = canvas.getBoundingClientRect();
    const localX = event.clientX - bounds.left;
    const localY = event.clientY - bounds.top;
    const viewport = viewportRef.current;
    if (!viewport) return;
    const stageX = (localX - viewport.offsetX) / viewport.scale;
    const stageY = (localY - viewport.offsetY) / viewport.scale;
    const boardWidth = getBoardWidth(mapGrid.cols);
    const boardHeight = getBoardHeight(mapGrid.rows);
    if (stageX < 0 || stageY < 0 || stageX > boardWidth || stageY > boardHeight) {
      return;
    }
    const { x: gx, y: gy } = screenToGridForGrid(stageX, stageY, mapGrid.cols, mapGrid.rows);
    const targetX = gx;
    const targetY = gy;
    if (!isCellPlayable(targetX, targetY)) return;
    if (targetMode === "selecting") {
      const action2 = getValidatedAction();
      if (!action2) {
        pushLog2("Aucune action validee pour selectionner une cible.");
        return;
      }
      const tokens = getTokensOnActiveLevel([player, ...enemies]);
      const target = getTokenAt({ x: targetX, y: targetY }, tokens);
      if (target) {
        const targetType = (_a2 = action2.targeting) == null ? void 0 : _a2.target;
        const isHostile = target.type !== player.type;
        const isAlly = target.type === player.type;
        const isPlayer = target.id === player.id;
        const isEnemy = target.type === "enemy";
        const isAllowed = targetType === "enemy" ? isEnemy : targetType === "player" ? isPlayer : targetType === "hostile" ? isHostile : targetType === "ally" ? isAlly : targetType === "self" ? target.id === player.id : false;
        if (!isAllowed) {
          pushLog2("Cette cible n'est pas valide pour cette action.");
          return;
        }
        const validation = isEnemy && (targetType === "enemy" || targetType === "hostile") ? validateEnemyTargetForAction(action2, target, player, [player, ...enemies]) : validateTokenTargetForAction(action2, target, player, [player, ...enemies]);
        if (!validation.ok) {
          pushLog2(validation.reason || "Cette cible n'est pas valide pour cette action.");
          return;
        }
        const maxTargets = typeof ((_b2 = action2.targeting) == null ? void 0 : _b2.maxTargets) === "number" && action2.targeting.maxTargets > 0 ? action2.targeting.maxTargets : 1;
        if (maxTargets <= 1) {
          setSelectedTargetIds([target.id]);
          setSelectedObstacleTarget(null);
          setSelectedWallTarget(null);
          setTargetMode("none");
          const dist = distanceBetweenTokens(player, target);
          const statusLabels = Array.isArray(target.statuses) ? target.statuses.map((status) => {
            var _a3;
            return ((_a3 = statusTypeById.get(status.id)) == null ? void 0 : _a3.label) ?? status.id;
          }).filter(Boolean) : [];
          const statusText = statusLabels.length ? statusLabels.join(", ") : "aucun";
          pushLog2(`Cible selectionnee: ${target.id} | distance: ${dist} m | etats: ${statusText}.`);
          return;
        }
        let actionLabel = "ajoutee";
        let didChange = true;
        setSelectedTargetIds((prev) => {
          const exists = prev.includes(target.id);
          if (exists) {
            actionLabel = "retiree";
            return prev.filter((id2) => id2 !== target.id);
          }
          if (prev.length >= maxTargets) {
            pushLog2(`Maximum de cibles atteint (${maxTargets}).`);
            didChange = false;
            return prev;
          }
          actionLabel = "ajoutee";
          if (prev.length + 1 >= maxTargets) {
            setTargetMode("none");
          }
          return [...prev, target.id];
        });
        setSelectedObstacleTarget(null);
        setSelectedWallTarget(null);
        if (didChange) {
          const dist = distanceBetweenTokens(player, target);
          const statusLabels = Array.isArray(target.statuses) ? target.statuses.map((status) => {
            var _a3;
            return ((_a3 = statusTypeById.get(status.id)) == null ? void 0 : _a3.label) ?? status.id;
          }).filter(Boolean) : [];
          const statusText = statusLabels.length ? statusLabels.join(", ") : "aucun";
          pushLog2(`Cible ${target.id} ${actionLabel} | distance: ${dist} m | etats: ${statusText}.`);
        }
        return;
      }
      const obstacleHit = findObstacleAtCell(targetX, targetY);
      if (obstacleHit) {
        const validation = validateObstacleTargetForAction(
          action2,
          obstacleHit.instance,
          { x: targetX, y: targetY },
          player,
          [player, ...enemies]
        );
        if (!validation.ok) {
          pushLog2(validation.reason || "Cette cible n'est pas valide pour cette action.");
          return;
        }
        const label2 = ((_c2 = obstacleHit.def) == null ? void 0 : _c2.label) ?? obstacleHit.instance.typeId ?? "obstacle";
        setSelectedTargetIds([]);
        setSelectedObstacleTarget({ id: obstacleHit.instance.id, x: targetX, y: targetY });
        setSelectedWallTarget(null);
        setTargetMode("none");
        pushLog2(`Cible selectionnee: ${label2}.`);
        return;
      }
      const wallHit = findWallSegmentAtCell(targetX, targetY);
      if (wallHit) {
        const validation = validateWallSegmentTargetForAction(
          action2,
          wallHit.segment,
          { x: targetX, y: targetY },
          player
        );
        if (!validation.ok) {
          pushLog2(validation.reason || "Cette cible n'est pas valide pour cette action.");
          return;
        }
        const label2 = ((_d = wallHit.def) == null ? void 0 : _d.label) ?? wallHit.segment.typeId ?? "mur";
        setSelectedTargetIds([]);
        setSelectedObstacleTarget(null);
        setSelectedWallTarget({ id: wallHit.segment.id, x: targetX, y: targetY });
        setTargetMode("none");
        pushLog2(`Cible selectionnee: ${label2}.`);
        return;
      }
      return;
    }
    if (interactionMode === "inspect-select") {
      const dist = distanceFromPointToToken({ x: targetX, y: targetY }, player);
      if (dist > INSPECT_RANGE) {
        pushLog2(
          `Inspection: case hors portee (${dist} > ${INSPECT_RANGE}).`
        );
        return;
      }
      if (!isCellVisibleForPlayer(targetX, targetY)) {
        pushLog2("Inspection: la case n'est pas dans votre champ de vision.");
        return;
      }
      setRevealedCells((prev) => {
        const next = new Set(prev);
        next.add(cellKey(targetX, targetY));
        return next;
      });
      const tokens = [player, ...enemies];
      const token = getTokenAt({ x: targetX, y: targetY }, tokens);
      if (!token) {
        const obstacleHit = findObstacleAtCellAnyLevel(targetX, targetY);
        if (obstacleHit) {
          const name2 = ((_e = obstacleHit.def) == null ? void 0 : _e.label) ?? obstacleHit.instance.typeId ?? "obstacle";
          const text = `Inspection (${targetX},${targetY}) : ${name2}
Etat: PV ${obstacleHit.instance.hp}/${obstacleHit.instance.maxHp}`;
          pushLog2(
            `Inspection: obstacle (${name2}) -> etat: PV ${obstacleHit.instance.hp}/${obstacleHit.instance.maxHp}.`
          );
          setPlayerBubble(text);
          setInteractionMode("idle");
          return;
        }
        const wallHit = findWallSegmentAtCellAnyLevel(targetX, targetY);
        if (wallHit) {
          const name2 = ((_f = wallHit.def) == null ? void 0 : _f.label) ?? wallHit.segment.typeId ?? "mur";
          const hp = typeof wallHit.segment.hp === "number" ? wallHit.segment.hp : null;
          const maxHp = typeof wallHit.segment.maxHp === "number" ? wallHit.segment.maxHp : null;
          const status = hp !== null && maxHp !== null ? `PV ${hp}/${maxHp}` : "indestructible";
          const text = `Inspection (${targetX},${targetY}) : ${name2}
Etat: ${status}`;
          pushLog2(
            `Inspection: mur (${name2}) -> etat: ${status}.`
          );
          setPlayerBubble(text);
          setInteractionMode("idle");
          return;
        }
        pushLog2(`Inspection: case (${targetX}, ${targetY}) -> sol.`);
        setPlayerBubble(`Inspection (${targetX},${targetY}) : sol.`);
        setInteractionMode("idle");
        return;
      }
      if (token.type === "enemy") {
        setRevealedEnemyIds((prev) => {
          const next = new Set(prev);
          next.add(token.id);
          return next;
        });
        const nature = token.enemyTypeLabel ?? token.enemyTypeId ?? "inconnu";
        const role = token.aiRole ?? "inconnu";
        const text = `Inspection (${targetX},${targetY}) : ${nature}
Etat: PV ${token.hp}/${token.maxHp}
Role: ${role}`;
        pushLog2(`Inspection: ennemi (${token.id}) -> nature: ${nature}, etat: PV ${token.hp}/${token.maxHp}, role: ${role}.`);
        setPlayerBubble(text);
      } else {
        const text = `Inspection (${targetX},${targetY}) : joueur
Etat: PV ${token.hp}/${token.maxHp}`;
        pushLog2(`Inspection: joueur (${token.id}) -> etat: PV ${token.hp}/${token.maxHp}.`);
        setPlayerBubble(text);
      }
      setInteractionMode("idle");
      return;
    }
    if (interactionMode === "interact-select") {
      const wallHit = findWallSegmentAtCell(targetX, targetY);
      const obstacleHit = findObstacleAtCell(targetX, targetY);
      if (!wallHit && !obstacleHit) {
        pushLog2("Interagir: aucun element interactif ici.");
        setInteractionMenuItems([]);
        return;
      }
      if (wallHit) {
        const interactions2 = ((_h = (_g = wallHit.def) == null ? void 0 : _g.behavior) == null ? void 0 : _h.interactions) ?? [];
        if (interactions2.length === 0) {
          pushLog2("Interagir: aucune interaction disponible pour ce mur.");
          setInteractionMenuItems([]);
          return;
        }
        const dist = getWallSegmentChebyshevDistance(player, wallHit.segment);
        if (dist > 1) {
          pushLog2("Interagir: placez-vous a une case de la porte.");
          setInteractionMenuItems([]);
          return;
        }
        const available = [];
        const reasons = [];
        for (const interaction of interactions2) {
          const check = getInteractionAvailability({
            interaction,
            target: { kind: "wall", segmentId: wallHit.segment.id, cell: wallHit.cell },
            player,
            wallSegments,
            obstacles,
            wallTypeById,
            obstacleTypeById,
            canPayCost: canPayInteractionCost,
            getWallDistance: getWallSegmentChebyshevDistance,
            getObstacleDistance: getObstacleChebyshevDistance
          });
          if (check.ok) {
            available.push(interaction);
          } else if (check.reason) {
            reasons.push(check.reason);
          }
        }
        if (available.length === 0) {
          const detail = reasons.length ? ` (${reasons[0]})` : "";
          pushLog2(`Interagir: aucune interaction possible${detail}.`);
          setInteractionMenuItems([]);
          return;
        }
        openInteractionWheel(localX, localY, {
          kind: "wall",
          segmentId: wallHit.segment.id,
          cell: { x: targetX, y: targetY }
        }, available);
        return;
      }
      if (obstacleHit) {
        const interactions2 = ((_i = obstacleHit.def) == null ? void 0 : _i.interactions) ?? [];
        if (interactions2.length === 0) {
          pushLog2("Interagir: aucune interaction disponible pour cet obstacle.");
          setInteractionMenuItems([]);
          return;
        }
        const dist = getObstacleChebyshevDistance(
          player,
          obstacleHit.instance,
          obstacleHit.def,
          { x: targetX, y: targetY }
        );
        if (dist > 1) {
          pushLog2("Interagir: placez-vous a une case de l'obstacle.");
          setInteractionMenuItems([]);
          return;
        }
        const available = [];
        const reasons = [];
        for (const interaction of interactions2) {
          const check = getInteractionAvailability({
            interaction,
            target: { kind: "obstacle", obstacleId: obstacleHit.instance.id, cell: obstacleHit.cell },
            player,
            wallSegments,
            obstacles,
            wallTypeById,
            obstacleTypeById,
            canPayCost: canPayInteractionCost,
            getWallDistance: getWallSegmentChebyshevDistance,
            getObstacleDistance: getObstacleChebyshevDistance
          });
          if (check.ok) {
            available.push(interaction);
          } else if (check.reason) {
            reasons.push(check.reason);
          }
        }
        if (available.length === 0) {
          const detail = reasons.length ? ` (${reasons[0]})` : "";
          pushLog2(`Interagir: aucune interaction possible${detail}.`);
          setInteractionMenuItems([]);
          return;
        }
        openInteractionWheel(localX, localY, {
          kind: "obstacle",
          obstacleId: obstacleHit.instance.id,
          cell: { x: targetX, y: targetY }
        }, available);
        return;
      }
    }
    if (interactionMode === "look-select") {
      const direction = computeFacingTowards(player, { x: targetX, y: targetY });
      handleSetPlayerFacing(direction);
      setInteractionMode("idle");
      return;
    }
    if (interactionMode !== "moving") {
      const tokens = getTokensOnActiveLevel([player, ...enemies]);
      const token = getTokenAt({ x: targetX, y: targetY }, tokens) ?? null;
      setRadialMenu({
        cell: { x: targetX, y: targetY },
        token
      });
      return;
    }
    const cellLevel = getBaseHeightAt(targetX, targetY);
    if (cellLevel !== activeLevel) {
      pushLog2(`Case (${targetX}, ${targetY}) au niveau ${cellLevel} (actif ${activeLevel}).`);
      return;
    }
    const isEnemyAt = (x2, y2) => enemies.some((e2) => e2.hp > 0 && e2.x === x2 && e2.y === y2);
    if (isEnemyAt(targetX, targetY)) {
      pushLog2(
        `Case (${targetX}, ${targetY}) occupee par un ennemi : impossible de s'y deplacer.`
      );
      return;
    }
    if (!isCellPlayable(targetX, targetY)) {
      pushLog2(`Case (${targetX}, ${targetY}) hors zone jouable.`);
      return;
    }
    if (obstacleBlocking.movement.has(cellKey(targetX, targetY))) {
      pushLog2(`Case (${targetX}, ${targetY}) bloquee par un obstacle.`);
      return;
    }
    if (pathLimit <= 0) {
      pushLog2("Deplacement impossible: budget de mouvement epuise.");
      return;
    }
    setSelectedPath((prev) => {
      const maxSteps = Math.max(0, pathLimit);
      const path2 = [...prev];
      const currentCost = computePathCost(path2);
      if (path2.length >= maxSteps) {
        pushLog2(`Limite de ${maxSteps} cases atteinte pour ce tour.`);
        return path2;
      }
      const start = path2.length > 0 ? path2[path2.length - 1] : { x: player.x, y: player.y };
      if (start.x === targetX && start.y === targetY) return path2;
      const stepsRemaining = maxSteps - path2.length;
      const tempPlayer = { ...player, x: start.x, y: start.y };
      const tokensForPath = getTokensOnActiveLevel([
        tempPlayer,
        ...enemies
      ]);
      const computed = computePathTowards(
        tempPlayer,
        { x: targetX, y: targetY },
        tokensForPath,
        {
          maxDistance: Math.max(0, stepsRemaining),
          allowTargetOccupied: false,
          blockedCells: obstacleBlocking.movement,
          wallEdges: wallEdges.movement,
          playableCells,
          grid: mapGrid,
          heightMap: mapHeight,
          floorIds: mapTerrain,
          activeLevel
        }
      );
      if (computed.length <= 1) {
        pushLog2("Aucun chemin valide vers cette case (bloque par obstacle ou entites).");
        return path2;
      }
      const appended = computed.slice(1);
      const appendedCost = computePathCost(appended);
      if (currentCost + appendedCost > pathLimit) {
        pushLog2("Budget de mouvement insuffisant pour ce trajet.");
        return path2;
      }
      pushLog2(`Trajectoire: +${appended.length} case(s) vers (${targetX}, ${targetY}).`);
      return path2.concat(appended);
    });
  }
  function resolveAnchorForCell(cell) {
    const container = pixiContainerRef.current;
    if (!container) return null;
    const viewport = viewportRef.current;
    if (!viewport) {
      const rect = container.getBoundingClientRect();
      return { anchorX: rect.width / 2, anchorY: rect.height / 2 };
    }
    const center = gridToScreenForGrid(cell.x, cell.y, mapGrid.cols, mapGrid.rows);
    return {
      anchorX: viewport.offsetX + center.x * viewport.scale,
      anchorY: viewport.offsetY + center.y * viewport.scale
    };
  }
  function reactionSourceMatches(source2, mover, reactor) {
    if (!source2 || source2 === "any") return true;
    if (source2 === "self") return mover.id === reactor.id;
    if (source2 === "player") return mover.type === "player";
    if (source2 === "enemy") return mover.type === "enemy";
    if (source2 === "hostile") return mover.type !== reactor.type;
    if (source2 === "ally") return mover.type === reactor.type;
    return true;
  }
  function checkReactionConditions(params) {
    const conditions2 = params.reaction.conditions ?? [];
    for (const cond of conditions2) {
      if (cond.type === "ACTOR_ALIVE" && isTokenDead(params.reactor)) {
        return { ok: false, reason: cond.reason || "Reactor is dead." };
      }
      if (cond.type === "TARGET_ALIVE" && isTokenDead(params.target)) {
        return { ok: false, reason: cond.reason || "Target is dead." };
      }
      if (cond.type === "REACTION_AVAILABLE" && !canUseReaction(params.reactor.id)) {
        return { ok: false, reason: cond.reason || "Reaction already used." };
      }
      if (cond.type === "REACTION_UNUSED_COMBAT") {
        if (hasReactionUsedInCombat(params.reactor.id, params.reaction.id)) {
          return { ok: false, reason: cond.reason || "Reaction already used this combat." };
        }
      }
      if (cond.type === "TARGET_FIRST_SEEN" && !params.isFirstSeen) {
        return { ok: false, reason: cond.reason || "Target already seen." };
      }
      if (cond.type === "TARGET_IS_CLOSEST_VISIBLE" && !params.isClosestVisible) {
        return { ok: false, reason: cond.reason || "Target not closest." };
      }
      if (cond.type === "TARGET_VISIBLE") {
        const visible = isTargetVisible(
          params.reactor,
          params.target,
          params.allTokens,
          visionBlockersActive,
          playableCells,
          wallEdges.vision,
          lightLevels,
          mapGrid
        );
        if (!visible) {
          return { ok: false, reason: cond.reason || "Target not visible." };
        }
      }
      if (cond.type === "DISTANCE_MAX" && typeof cond.max === "number") {
        if (params.distance > cond.max) {
          return { ok: false, reason: cond.reason || "Target too far." };
        }
      }
    }
    return { ok: true };
  }
  function mergeAdvantageModes(base, extra) {
    const baseMode = base ?? "normal";
    const extraMode = extra ?? "normal";
    if (baseMode === "normal") return extraMode;
    if (extraMode === "normal") return baseMode;
    if (baseMode === extraMode) return baseMode;
    return "normal";
  }
  function getIncomingAttackReactionModifier(params) {
    if (!canUseReaction(params.reactor.id)) return null;
    const distanceToTarget = distanceBetweenTokens(params.reactor, params.target);
    const modifiers = getFeatureReactionModifiersForActor(params.reactor);
    for (const modifier of modifiers) {
      if (modifier.event !== params.event) continue;
      if (!reactionModifierMatches({
        modifier,
        reactor: params.reactor,
        attacker: params.attacker,
        target: params.target,
        action: params.action,
        distanceToTarget
      })) {
        continue;
      }
      return modifier;
    }
    return null;
  }
  function applyIncomingHitReductionReaction(params) {
    var _a2;
    if (params.damageTaken <= 0) return { nextPlayer: params.nextPlayer, prevented: 0 };
    const modifier = getIncomingAttackReactionModifier({
      reactor: params.reactor,
      attacker: params.attacker,
      target: params.target,
      action: params.action,
      event: "incomingAttackHit"
    });
    if (!modifier || modifier.mode !== "reduceDamage") {
      return { nextPlayer: params.nextPlayer, prevented: 0 };
    }
    const baseFormula = String(modifier.formula ?? "").trim();
    if (!baseFormula) return { nextPlayer: params.nextPlayer, prevented: 0 };
    const resolved = resolveFormula(baseFormula, {
      actor: params.reactor,
      sampleCharacter: params.reactor.type === "player" ? activeCharacterConfig : void 0
    });
    const reductionRoll = rollDamage(resolved);
    const prevented = Math.max(0, Math.min(params.damageTaken, reductionRoll.total));
    if (prevented <= 0) return { nextPlayer: params.nextPlayer, prevented: 0 };
    markReactionUsed(params.reactor.id);
    const restoredHp = Math.min(
      Number(((_a2 = params.nextPlayer.combatStats) == null ? void 0 : _a2.maxHp) ?? params.nextPlayer.hp + prevented),
      params.nextPlayer.hp + prevented
    );
    const nextPlayer = { ...params.nextPlayer, hp: restoredHp };
    const uiLine = modifier.uiMessage ?? `Reaction: degats reduits de ${prevented} (${resolved} => ${reductionRoll.total}).`;
    pushLog2(uiLine);
    showReactionToast(uiLine, "info");
    return { nextPlayer, prevented };
  }
  function openReactionContext(instance) {
    setSelectedTargetIds(instance.targetId ? [instance.targetId] : []);
    setSelectedObstacleTarget(null);
    setSelectedWallTarget(null);
    setTargetMode("none");
    setActionContext({
      anchorX: instance.anchorX,
      anchorY: instance.anchorY,
      actionId: instance.actionId,
      stage: "draft",
      source: "reaction",
      reactionId: instance.reactionId
    });
    setActionContextOpen(true);
  }
  function enqueueReaction(instance) {
    setReactionQueue((prev) => [...prev, instance]);
  }
  function startNextReactionFromQueue(force) {
    setReactionQueue((prev) => {
      if (prev.length === 0) return prev;
      const [next, ...rest] = prev;
      if (!force && (actionContext || interactionContext || pendingHazardRoll || validatedActionId)) {
        return prev;
      }
      openReactionContext(next);
      return rest;
    });
  }
  function tryStartReaction(instance) {
    if (phase === "enemies" && instance.reactorId === player.id) {
      requestEnemyTurnPause();
    }
    if (actionContext || interactionContext || pendingHazardRoll || validatedActionId) {
      enqueueReaction(instance);
      return;
    }
    openReactionContext(instance);
  }
  function autoResolveReaction(params) {
    var _a2, _b2;
    if (!canUseReaction(params.reactor.id)) return;
    const baseAction = applyWeaponOverrideForActor(params.reaction.action, params.reactor, {
      reaction: true
    });
    let action2 = baseAction;
    if (params.ignoreRange && ((_a2 = baseAction.targeting) == null ? void 0 : _a2.range)) {
      const afterDistance = distanceBetweenTokens(params.reactor, params.target);
      const nextRangeMax = Math.max(
        baseAction.targeting.range.max,
        afterDistance
      );
      action2 = {
        ...baseAction,
        targeting: {
          ...baseAction.targeting,
          range: { ...baseAction.targeting.range, max: nextRangeMax }
        }
      };
    }
    const usedWeapon = action2.category === "attack" ? pickWeaponForAction(action2, params.reactor, { reaction: true }) : null;
    const constraintIssues = getWeaponActionConstraintIssues(action2, params.reactor, { reaction: true });
    if (constraintIssues.length > 0) {
      pushLog2(`Reaction impossible: ${constraintIssues.join(" | ")}`);
      return;
    }
    const ammoUsage = resolveAmmoUsageForAction(action2, params.reactor, { reaction: true });
    const ammoSpendInOps = ammoUsage ? actionSpendsResource(action2, ammoUsage.ammoType) : false;
    if (ammoUsage && params.reactor.type === "player") {
      if (isPhysicalResource(ammoUsage.ammoType)) {
        const available = activeCharacterConfig ? getInventoryResourceCount(activeCharacterConfig, ammoUsage.ammoType) : 0;
        if (available < ammoUsage.amount) {
          pushLog2(`Reaction impossible: munitions insuffisantes (${ammoUsage.ammoType}).`);
          return;
        }
      } else {
        pushLog2(`Reaction: munitions non referencees (${ammoUsage.ammoType}).`);
      }
    }
    const context2 = buildReactionActionContext({
      reactor: params.reactor,
      playerSnapshot: params.playerSnapshot,
      enemiesSnapshot: params.enemiesSnapshot
    });
    const result = resolveActionUnified(
      action2,
      context2,
      { kind: "token", token: params.target },
      { weaponMasteryActions }
    );
    if (!result.ok || !result.playerAfter || !result.enemiesAfter) {
      pushLog2(
        `[IA] Reaction ${action2.name} echec: ${result.reason || "inconnu"}.`
      );
      return;
    }
    if (ammoUsage && params.reactor.type === "player" && isPhysicalResource(ammoUsage.ammoType) && !ammoSpendInOps) {
      spendPlayerResource(ammoUsage.ammoType, null, ammoUsage.amount);
    }
    updateActionUsageForActor(params.reactor.id, action2.id, 1);
    updateWeaponPropertyUsageForAction(params.reactor.id, action2, 1);
    if (params.reactor.type === "player" && (usedWeapon == null ? void 0 : usedWeapon.id)) {
      setLastUsedWeaponAsPrimaryForPlayer(usedWeapon.id);
    }
    const nextEnemies = applySummonTurnOrder({
      prevEnemies: params.enemiesSnapshot,
      nextEnemies: result.enemiesAfter
    });
    setPlayer(result.playerAfter);
    setEnemies(nextEnemies);
    markReactionUsed(params.reactor.id);
    markReactionUsedInCombat(params.reactor.id, params.reaction.id);
    pushLog2(`[IA] Reaction resolue: ${action2.name}.`);
    const isEnemyReactionAgainstPlayer = params.reactor.type === "enemy" && params.target.type === "player";
    if (isEnemyReactionAgainstPlayer) {
      const missed = result.logs.some((line) => line.includes("rate sa cible"));
      const hit = !missed;
      const hitTypeSuffix = buildDamageTypeSuffix((_b2 = action2.damage) == null ? void 0 : _b2.damageType);
      const defaultHitMessage = `Vous avez subi une attaque de reaction: ${params.reaction.name}${hitTypeSuffix}.`;
      const defaultMissMessage = `Vous avez evite une attaque de reaction: ${params.reaction.name}.`;
      const message = missed ? params.reaction.uiMessageMiss || defaultMissMessage : params.reaction.uiMessage || defaultHitMessage;
      showReactionToast(message, hit ? "hit" : "miss");
      suppressCombatToastUntilRef.current = Date.now() + 500;
    }
  }
  function buildReactionActionContext(params) {
    return {
      round: round2,
      phase,
      actor: params.reactor,
      player: params.playerSnapshot,
      enemies: params.enemiesSnapshot,
      blockedMovementCells: obstacleBlocking.movement,
      blockedMovementEdges: wallEdges.movement,
      blockedVisionCells: visionBlockersActive,
      blockedAttackCells: obstacleBlocking.attacks,
      wallVisionEdges: wallEdges.vision,
      lightLevels,
      playableCells,
      grid: mapGrid,
      heightMap: mapHeight,
      floorIds: mapTerrain,
      activeLevel,
      sampleCharacter: activeCharacterConfig,
      getSlotAmount: (slot, level2) => getSlotAmountFromCharacter(params.reactor, slot, level2),
      usage: getActionUsageForActor(params.reactor.id),
      reactionAvailable: canUseReaction(params.reactor.id),
      concentrating: isTokenConcentrating(params.reactor),
      surprised: isTokenSurprised(params.reactor),
      getActionConstraintIssues: ({ action: action2, actor }) => {
        var _a2;
        return getWeaponActionConstraintIssues(action2, actor, {
          reaction: ((_a2 = action2.actionCost) == null ? void 0 : _a2.actionType) === "reaction"
        });
      },
      spawnEntity: createSummon,
      onLog: pushLog2,
      emitEvent: (evt) => {
        recordCombatEvent({
          round: round2,
          phase,
          kind: evt.kind,
          actorId: evt.actorId,
          actorKind: evt.actorKind,
          targetId: evt.targetId ?? null,
          targetKind: evt.targetKind ?? null,
          summary: evt.summary,
          data: evt.data ?? {}
        });
      }
    };
  }
  function checkReactionActionEligibility(params) {
    var _a2;
    const baseAction = applyWeaponOverrideForActor(params.reaction.action, params.reactor, {
      reaction: true
    });
    let action2 = baseAction;
    if (params.ignoreRange && ((_a2 = baseAction.targeting) == null ? void 0 : _a2.range)) {
      const afterDistance = distanceBetweenTokens(params.reactor, params.target);
      const nextRangeMax = Math.max(
        baseAction.targeting.range.max,
        afterDistance
      );
      action2 = {
        ...baseAction,
        targeting: {
          ...baseAction.targeting,
          range: { ...baseAction.targeting.range, max: nextRangeMax }
        }
      };
    }
    const context2 = buildReactionActionContext({
      reactor: params.reactor,
      playerSnapshot: params.playerSnapshot,
      enemiesSnapshot: params.enemiesSnapshot
    });
    const availability = computeAvailabilityForActor(action2, context2);
    if (!availability.enabled) {
      return { ok: false, reason: availability.reasons.join(" | ") };
    }
    const constraintIssues = getWeaponActionConstraintIssues(action2, params.reactor, {
      reaction: true
    });
    if (constraintIssues.length > 0) {
      return { ok: false, reason: constraintIssues.join(" | ") };
    }
    const validation = validateActionTarget(action2, context2, {
      kind: "token",
      token: params.target
    });
    if (!validation.ok) {
      return { ok: false, reason: validation.reason };
    }
    return { ok: true };
  }
  function applyInstantReactionEffects(params) {
    var _a2;
    const ops2 = ((_a2 = params.reaction.action.ops) == null ? void 0 : _a2.onResolve) && Array.isArray(params.reaction.action.ops.onResolve) ? params.reaction.action.ops.onResolve : [];
    let handled = false;
    for (const op of ops2) {
      if ((op == null ? void 0 : op.op) === "SetKillerInstinctTarget") {
        if (params.reactor.id !== player.id) continue;
        if (killerInstinctTargetId) return true;
        setKillerInstinctTargetId(params.target.id);
        setSelectedTargetIds([params.target.id]);
        setEnemies(
          (prev) => prev.map(
            (enemy) => enemy.id === params.target.id ? addStatusToToken(enemy, "killer-mark", params.reactor.id) : enemy
          )
        );
        pushLog2(
          `Instinct de tueur: cible marquee -> ${params.target.id} (avantage jusqu'a sa mort).`
        );
        markReactionUsedInCombat(params.reactor.id, params.reaction.id);
        handled = true;
      }
      if ((op == null ? void 0 : op.op) === "LogEvent" && typeof op.message === "string") {
        pushLog2(op.message);
      }
    }
    return handled;
  }
  function triggerMovementReactions(params) {
    var _a2, _b2, _c2, _d, _e;
    if (reactionById.size === 0) return;
    const moverFrom = { ...params.mover, x: params.from.x, y: params.from.y };
    const moverTo = { ...params.mover, x: params.to.x, y: params.to.y };
    const allTokens = getTokensOnActiveLevel([
      params.playerSnapshot,
      ...params.enemiesSnapshot
    ]);
    const reactors = [params.playerSnapshot, ...params.enemiesSnapshot].filter(
      (token) => token.id !== params.mover.id
    );
    for (const reactor of reactors) {
      if (isTokenDead(reactor)) continue;
      const reactionIds2 = Array.isArray(reactor.reactionIds) ? reactor.reactionIds : [];
      if (reactionIds2.length === 0) continue;
      for (const reactionId of reactionIds2) {
        const reaction = reactionById.get(reactionId);
        if (!reaction) continue;
        const event = ((_a2 = reaction.trigger) == null ? void 0 : _a2.event) ?? "";
        if (!event.startsWith("movement.")) continue;
        if (!reactionSourceMatches((_b2 = reaction.trigger) == null ? void 0 : _b2.source, moverTo, reactor)) {
          continue;
        }
        const rangedAction = applyWeaponOverrideForActor(reaction.action, reactor, { reaction: true });
        const reactionRangeMax = (_d = (_c2 = rangedAction == null ? void 0 : rangedAction.targeting) == null ? void 0 : _c2.range) == null ? void 0 : _d.max;
        const reactionTags = (rangedAction == null ? void 0 : rangedAction.tags) ?? ((_e = reaction.action) == null ? void 0 : _e.tags) ?? [];
        const isOpportunityReaction = reaction.id === "opportunity-attack" || reactionTags.includes("opportunity");
        const moverIsDisengaging = Array.isArray(moverTo.statuses) ? moverTo.statuses.some((status) => String(status.id).toLowerCase() === "disengaging") : false;
        if (isOpportunityReaction && moverIsDisengaging) {
          continue;
        }
        const reach = isOpportunityReaction ? getActorOpportunityReach(reactor) : typeof reactionRangeMax === "number" && Number.isFinite(reactionRangeMax) ? reactionRangeMax : getActorDefaultReach(reactor);
        const before = distanceBetweenTokens(reactor, moverFrom);
        const after = distanceBetweenTokens(reactor, moverTo);
        const isLeave = event === "movement.leave_reach";
        const isEnter = event === "movement.enter_reach";
        const matched = isLeave && before <= reach && after > reach || isEnter && before > reach && after <= reach;
        if (matched) {
          pushLog2(
            `[REACTION DEBUG] ${reaction.id} event=${event} reactor=${reactor.id} target=${params.mover.id} from=(${moverFrom.x},${moverFrom.y}) to=(${moverTo.x},${moverTo.y}) reach=${reach} distBefore=${before} distAfter=${after}`
          );
        }
        if (!matched) continue;
        const distanceForConditions = isLeave ? before : after;
        const conditionCheck = checkReactionConditions({
          reaction,
          reactor,
          target: moverTo,
          distance: distanceForConditions,
          isFirstSeen: true,
          isClosestVisible: true,
          allTokens
        });
        if (!conditionCheck.ok) {
          pushLog2(
            `[REACTION DEBUG] ${reaction.id} conditions reject reactor=${reactor.id} target=${params.mover.id} reason=${conditionCheck.reason || "unknown"}`
          );
          continue;
        }
        const actionCheck = checkReactionActionEligibility({
          reaction,
          reactor,
          target: moverTo,
          playerSnapshot: params.playerSnapshot,
          enemiesSnapshot: params.enemiesSnapshot,
          ignoreRange: isLeave
        });
        if (!actionCheck.ok) {
          pushLog2(
            `[REACTION DEBUG] ${reaction.id} action reject reactor=${reactor.id} target=${params.mover.id} reason=${actionCheck.reason || "unknown"}`
          );
          continue;
        }
        const anchor2 = resolveAnchorForCell(params.to) ?? { anchorX: 0, anchorY: 0 };
        const instance = {
          reactionId: reaction.id,
          reactorId: reactor.id,
          targetId: params.mover.id,
          actionId: reaction.action.id,
          anchorX: anchor2.anchorX,
          anchorY: anchor2.anchorY
        };
        if (reactor.type === "player") {
          if (isGameOver || isTokenDead(reactor)) continue;
          pushLog2(`Reaction disponible: ${reaction.name} (cible ${params.mover.id}).`);
          tryStartReaction(instance);
        } else {
          pushLog2(`[IA] Reaction: ${reaction.name} sur ${params.mover.id}.`);
          autoResolveReaction({
            reaction,
            reactor,
            target: moverTo,
            playerSnapshot: params.playerSnapshot,
            enemiesSnapshot: params.enemiesSnapshot,
            ignoreRange: event === "movement.leave_reach"
          });
        }
      }
    }
  }
  function handleValidatePath() {
    if (phase !== "player") return;
    if (isGameOver) return;
    if (isTokenDead(player)) return;
    if (pathLimit <= 0) {
      pushLog2("Deplacement impossible: budget de mouvement epuise.");
      return;
    }
    suppressBoardClickUntilRef.current = Date.now() + 220;
    if (selectedPath.length === 0) {
      const hazardRoll2 = buildHazardRollFromPath([], { x: player.x, y: player.y });
      if (hazardRoll2) {
        resolveHazardRoll(hazardRoll2, { x: player.x, y: player.y });
        pushLog2(
          `Danger: ${hazardRoll2.label} traverse (${hazardRoll2.cells} case${hazardRoll2.cells > 1 ? "s" : ""}). Jet de degats ${hazardRoll2.formula} requis.`
        );
      }
      return;
    }
    const last = selectedPath[selectedPath.length - 1];
    const from = { x: player.x, y: player.y };
    const facingFrom = selectedPath.length > 1 ? selectedPath[selectedPath.length - 2] : { x: player.x, y: player.y };
    const nextFacing = computeFacingTowards(facingFrom, last);
    const playerAfterMove = { ...player, x: last.x, y: last.y, facing: nextFacing };
    setPlayer((prev) => ({
      ...prev,
      x: last.x,
      y: last.y,
      facing: nextFacing
    }));
    recordCombatEvent({
      round: round2,
      phase: "player",
      kind: "move",
      actorId: player.id,
      actorKind: "player",
      summary: `Le heros se deplace de (${from.x}, ${from.y}) vers (${last.x}, ${last.y}).`,
      data: { from, to: { x: last.x, y: last.y }, steps: selectedPath.length }
    });
    triggerMovementReactions({
      mover: playerAfterMove,
      from,
      to: { x: last.x, y: last.y },
      playerSnapshot: playerAfterMove,
      enemiesSnapshot: enemies
    });
    const hazardRoll = buildHazardRollFromPath(selectedPath, { x: player.x, y: player.y });
    const moveCost2 = selectedPathCost;
    setSelectedPath([]);
    setInteractionMode("idle");
    setMovementSpent((prev) => Math.max(0, prev + moveCost2));
    setPathLimit((prev) => Math.max(0, prev - moveCost2));
    if (hazardRoll) {
      resolveHazardRoll(hazardRoll, last);
      pushLog2(
        `Danger: ${hazardRoll.label} traverse (${hazardRoll.cells} case${hazardRoll.cells > 1 ? "s" : ""}). Jet de degats ${hazardRoll.formula} requis.`
      );
      return;
    }
    if (isMoveTypeAction(getValidatedAction())) {
      handleFinishAction();
    } else {
      setActionContextOpen(false);
    }
  }
  function handleResetPath() {
    if (phase !== "player") return;
    if (isGameOver) return;
    setSelectedPath([]);
    pushLog2("Trajectoire reinitialisee.");
  }
  function handleSetPlayerFacing(direction) {
    if (phase !== "player") return;
    if (isGameOver) return;
    setPlayer((prev) => ({
      ...prev,
      facing: direction
    }));
    pushLog2(`Orientation du joueur mise a jour: ${direction}.`);
  }
  const parseDurationSpec = (value2) => {
    if (typeof value2 === "number" && Number.isFinite(value2)) {
      return { remainingTurns: Math.max(1, Math.floor(value2)), tick: "start" };
    }
    if (typeof value2 !== "string") return null;
    const normalized = value2.trim().toLowerCase();
    if (!normalized) return null;
    const [kind2, countRaw] = normalized.split(":");
    const count2 = Math.max(1, Number.parseInt(countRaw ?? "1", 10) || 1);
    const tick = kind2 === "end_of_turn" || kind2 === "end" ? "end" : kind2 === "start_of_turn" || kind2 === "start" ? "start" : kind2 === "end_of_round" || kind2 === "round" || kind2 === "round_end" ? "round" : null;
    if (!tick) return null;
    return { remainingTurns: count2, tick };
  };
  const applyTempHpToToken = (token, amount, durationTurns2) => {
    const next = { ...token, tempHp: Math.max(token.tempHp ?? 0, amount) };
    const duration = parseDurationSpec(durationTurns2 ?? null);
    if (duration) next.tempHpDuration = duration;
    return next;
  };
  const addStatusToToken = (token, statusId, sourceId) => {
    const def = statusTypeById.get(statusId);
    if (!def) return token;
    const duration = Math.max(1, Math.floor(def.durationTurns || 1));
    const current = Array.isArray(token.statuses) ? token.statuses : [];
    const existingIndex = current.findIndex((s2) => s2.id === statusId);
    const next = [...current];
    if (existingIndex >= 0) {
      next[existingIndex] = {
        ...next[existingIndex],
        remainingTurns: duration,
        sourceId: sourceId ?? next[existingIndex].sourceId,
        durationTick: next[existingIndex].durationTick ?? "start"
      };
    } else {
      next.push({ id: statusId, remainingTurns: duration, sourceId, durationTick: "start" });
    }
    return { ...token, statuses: next };
  };
  const applyWeaponMasteryStartExpiryForToken = (token, sourceId) => {
    const anyToken = token;
    const currentTags = Array.isArray(anyToken.tags) ? anyToken.tags : [];
    if (currentTags.length === 0) return token;
    const sapeTag = `wm-sape:next:${sourceId}`;
    const slowTag = `wm-ralentissement:${sourceId}`;
    const ouvertureTag = `wm-ouverture:adv:${sourceId}`;
    const expiringOuvertureTag = `${ouvertureTag}:expiring`;
    let changed = false;
    const nextTags = [];
    for (const tag of currentTags) {
      if (tag === sapeTag || tag === slowTag) {
        changed = true;
        continue;
      }
      if (tag === ouvertureTag) {
        changed = true;
        nextTags.push(expiringOuvertureTag);
        continue;
      }
      nextTags.push(tag);
    }
    if (!changed) return token;
    return { ...token, tags: nextTags };
  };
  const applyWeaponMasteryEndExpiryForToken = (token, sourceId) => {
    const anyToken = token;
    const currentTags = Array.isArray(anyToken.tags) ? anyToken.tags : [];
    if (currentTags.length === 0) return token;
    const expiringTag = `wm-ouverture:adv:${sourceId}:expiring`;
    if (!currentTags.includes(expiringTag)) return token;
    const nextTags = currentTags.filter((tag) => tag !== expiringTag);
    return { ...token, tags: nextTags };
  };
  const applyTokenDurations = (params) => {
    var _a2, _b2, _c2;
    const { token, side, tick } = params;
    let nextToken = { ...token };
    const currentStatuses = Array.isArray(token.statuses) ? token.statuses : [];
    const remainingStatuses = [];
    const effectsOnToken = resolvedEffects.filter((effect) => {
      var _a3, _b3, _c3;
      if (effect.active === false) return false;
      if (effect.kind === "aura") {
        const def = effectTypeById.get(effect.typeId);
        const radius = ((_a3 = def == null ? void 0 : def.aura) == null ? void 0 : _a3.radius) ?? null;
        if (!radius || radius <= 0) {
          return effect.x === nextToken.x && effect.y === nextToken.y;
        }
        const shape = ((_b3 = def == null ? void 0 : def.aura) == null ? void 0 : _b3.shape) ?? "SPHERE";
        const anchor2 = effect.anchorTokenId === player.id ? player : enemies.find((enemy) => enemy.id === effect.anchorTokenId) ?? null;
        const anchorPos = anchor2 ? { x: anchor2.x, y: anchor2.y, facing: anchor2.facing } : { x: effect.x, y: effect.y, facing: void 0 };
        const cells = metersToCells(radius);
        const dx = nextToken.x - anchorPos.x;
        const dy = nextToken.y - anchorPos.y;
        const inSquare = Math.max(Math.abs(dx), Math.abs(dy)) <= cells;
        const inLine = (() => {
          const facing = anchorPos.facing ?? "right";
          if (facing === "left") return dx <= 0 && Math.abs(dy) <= 1 && Math.abs(dx) <= cells;
          if (facing === "right") return dx >= 0 && Math.abs(dy) <= 1 && Math.abs(dx) <= cells;
          if (facing === "up") return dy <= 0 && Math.abs(dx) <= 1 && Math.abs(dy) <= cells;
          return dy >= 0 && Math.abs(dx) <= 1 && Math.abs(dy) <= cells;
        })();
        const inCone = (() => {
          const facing = anchorPos.facing ?? "right";
          if (facing === "left") return dx <= 0 && Math.abs(dx) >= Math.abs(dy) && Math.abs(dx) <= cells;
          if (facing === "right") return dx >= 0 && Math.abs(dx) >= Math.abs(dy) && Math.abs(dx) <= cells;
          if (facing === "up") return dy <= 0 && Math.abs(dy) >= Math.abs(dx) && Math.abs(dy) <= cells;
          return dy >= 0 && Math.abs(dy) >= Math.abs(dx) && Math.abs(dy) <= cells;
        })();
        const inSphere = (() => {
          if (anchor2) return distanceBetweenTokens(nextToken, anchor2) <= radius;
          const distCells = gridDistance$1(
            { x: nextToken.x, y: nextToken.y },
            { x: anchorPos.x, y: anchorPos.y }
          );
          return cellsToMeters(distCells) <= radius;
        })();
        let inShape = false;
        if (shape === "CUBE") inShape = inSquare;
        else if (shape === "LINE") inShape = inLine;
        else if (shape === "CONE") inShape = inCone;
        else inShape = inSphere;
        if (!inShape) return false;
        if (anchor2 && anchor2.id === nextToken.id && ((_c3 = def == null ? void 0 : def.aura) == null ? void 0 : _c3.includeSelf) === false) return false;
        return true;
      }
      return effect.x === nextToken.x && effect.y === nextToken.y;
    });
    if (effectsOnToken.length > 0) {
      for (const effect of effectsOnToken) {
        if (nextToken.hp <= 0) break;
        const def = effectTypeById.get(effect.typeId);
        const hazard2 = def == null ? void 0 : def.hazard;
        if (!(hazard2 == null ? void 0 : hazard2.damageFormula)) continue;
        const hazardTick = hazard2.tick ?? "start";
        if (hazardTick !== tick) continue;
        const result = rollDamage(hazard2.damageFormula);
        const diceText = result.dice.map((d2) => d2.rolls.join("+")).join(" | ");
        pushDiceLog(
          `Degats (${(def == null ? void 0 : def.label) ?? effect.typeId}) : ${diceText || "0"} + ${result.flatModifier} = ${result.total}`
        );
        const beforeHp = nextToken.hp;
        const tempHp = typeof nextToken.tempHp === "number" ? nextToken.tempHp : 0;
        if (tempHp > 0) {
          const remaining = Math.max(0, result.total - tempHp);
          nextToken.tempHp = Math.max(0, tempHp - result.total);
          nextToken.hp = Math.max(0, nextToken.hp - remaining);
        } else {
          nextToken.hp = Math.max(0, nextToken.hp - result.total);
        }
        pushLog2(
          `${nextToken.id} subit ${result.total} degats (${(def == null ? void 0 : def.label) ?? effect.typeId}).`
        );
        recordCombatEvent({
          round: round2,
          phase: side,
          kind: "damage",
          actorId: nextToken.id,
          actorKind: side === "player" ? "player" : "enemy",
          targetId: nextToken.id,
          targetKind: side === "player" ? "player" : "enemy",
          summary: `${nextToken.id} subit ${result.total} degats (${(def == null ? void 0 : def.label) ?? effect.typeId}) (PV ${beforeHp} -> ${nextToken.hp}).`,
          data: {
            effectId: effect.typeId,
            damage: result.total,
            formula: hazard2.damageFormula
          }
        });
        if (((_a2 = hazard2.statusRoll) == null ? void 0 : _a2.statusId) && ((_b2 = hazard2.statusRoll) == null ? void 0 : _b2.die) && ((_c2 = hazard2.statusRoll) == null ? void 0 : _c2.trigger)) {
          const roll = rollDie(hazard2.statusRoll.die);
          if (roll === hazard2.statusRoll.trigger) {
            nextToken = addStatusToToken(nextToken, hazard2.statusRoll.statusId, effect.sourceId);
            pushLog2(
              `${nextToken.id} subit l'etat ${hazard2.statusRoll.statusId} (${(def == null ? void 0 : def.label) ?? effect.typeId}).`
            );
            recordCombatEvent({
              round: round2,
              phase: side,
              kind: "status",
              actorId: nextToken.id,
              actorKind: side === "player" ? "player" : "enemy",
              targetId: nextToken.id,
              targetKind: side === "player" ? "player" : "enemy",
              summary: `${nextToken.id} subit l'etat ${hazard2.statusRoll.statusId}.`,
              data: {
                effectId: effect.typeId,
                statusId: hazard2.statusRoll.statusId
              }
            });
          }
        }
      }
    }
    for (const status of currentStatuses) {
      const def = statusTypeById.get(status.id);
      const statusTick = status.durationTick ?? "start";
      if (tick === "start" && statusTick === "start" && (def == null ? void 0 : def.damagePerTurnFormula) && nextToken.hp > 0) {
        const result = rollDamage(def.damagePerTurnFormula);
        const diceText = result.dice.map((d2) => d2.rolls.join("+")).join(" | ");
        pushDiceLog(
          `Degats (${def.label}) : ${diceText || "0"} + ${result.flatModifier} = ${result.total}`
        );
        const beforeHp = nextToken.hp;
        nextToken.hp = Math.max(0, nextToken.hp - result.total);
        pushLog2(`${nextToken.id} subit ${result.total} degats (${def.label}).`);
        recordCombatEvent({
          round: round2,
          phase: side,
          kind: "damage",
          actorId: nextToken.id,
          actorKind: side === "player" ? "player" : "enemy",
          targetId: nextToken.id,
          targetKind: side === "player" ? "player" : "enemy",
          summary: `${nextToken.id} subit ${result.total} degats (${def.label}) (PV ${beforeHp} -> ${nextToken.hp}).`,
          data: {
            statusId: status.id,
            damage: result.total,
            formula: def.damagePerTurnFormula
          }
        });
      }
      if (def == null ? void 0 : def.persistUntilDeath) {
        remainingStatuses.push({ ...status });
        continue;
      }
      if (statusTick !== tick) {
        remainingStatuses.push({ ...status });
        continue;
      }
      const nextRemaining = status.remainingTurns - 1;
      if (nextRemaining > 0) {
        remainingStatuses.push({ ...status, remainingTurns: nextRemaining });
      } else if (def) {
        pushLog2(`${nextToken.id}: etat termine (${def.label}).`);
      }
    }
    const duration = nextToken.tempHpDuration;
    if (duration) {
      if ((nextToken.tempHp ?? 0) <= 0) {
        nextToken.tempHp = 0;
        nextToken.tempHpDuration = void 0;
      } else if (duration.tick === tick) {
        const nextRemaining = duration.remainingTurns - 1;
        if (nextRemaining > 0) {
          nextToken.tempHpDuration = { ...duration, remainingTurns: nextRemaining };
        } else {
          nextToken.tempHp = 0;
          nextToken.tempHpDuration = void 0;
          pushLog2(`${nextToken.id}: PV temporaires termines.`);
        }
      }
    }
    if (currentStatuses.length > 0) {
      nextToken.statuses = remainingStatuses;
    }
    return nextToken;
  };
  const applyStartOfTurnStatuses = (params) => applyTokenDurations({ ...params, tick: "start" });
  const applyEndOfTurnDurations = (entry) => {
    if (!entry) return;
    if (entry.kind === "player") {
      setPlayer(
        (prev) => applyWeaponMasteryEndExpiryForToken(
          applyTokenDurations({ token: prev, side: "player", tick: "end" }),
          entry.id
        )
      );
      setEnemies(
        (prev) => prev.map((enemy) => applyWeaponMasteryEndExpiryForToken(enemy, entry.id))
      );
      return;
    }
    if (entry.kind === "enemy" || entry.kind === "summon") {
      setPlayer((prev) => applyWeaponMasteryEndExpiryForToken(prev, entry.id));
      setEnemies(
        (prev) => prev.map((enemy) => {
          const next = enemy.id === entry.id ? applyTokenDurations({ token: enemy, side: "enemies", tick: "end" }) : enemy;
          return applyWeaponMasteryEndExpiryForToken(next, entry.id);
        })
      );
    }
  };
  const applyEndOfRoundDurations = () => {
    setPlayer((prev) => applyTokenDurations({ token: prev, side: "player", tick: "round" }));
    setEnemies(
      (prev) => prev.map((enemy) => applyTokenDurations({ token: enemy, side: "enemies", tick: "round" }))
    );
  };
  const collectHazardsFromPath = (params) => {
    var _a2;
    const { path: path2, start } = params;
    const counts = /* @__PURE__ */ new Map();
    const defs = /* @__PURE__ */ new Map();
    const effectByCell = /* @__PURE__ */ new Map();
    const cellKey2 = (x2, y2) => `${x2},${y2}`;
    const sourceByKey = /* @__PURE__ */ new Map();
    for (const effect of resolvedEffects) {
      const key2 = `${effect.typeId}:${cellKey2(effect.x, effect.y)}`;
      sourceByKey.set(key2, effect);
    }
    if (effectTypes.length > 0 && obstacles.length > 0 && mapTerrain.length > 0) {
      const derived = buildEffectsFromObstacles({
        obstacles,
        terrain: mapTerrain,
        grid: mapGrid
      });
      for (const effect of derived) {
        const key2 = `${effect.typeId}:${cellKey2(effect.x, effect.y)}`;
        if (!sourceByKey.has(key2)) {
          sourceByKey.set(key2, effect);
        }
      }
    }
    for (const effect of sourceByKey.values()) {
      if (effect.active === false) continue;
      const def = effectTypeById.get(effect.typeId);
      if (!((_a2 = def == null ? void 0 : def.hazard) == null ? void 0 : _a2.onTraverse)) continue;
      defs.set(effect.typeId, def);
      const key2 = cellKey2(effect.x, effect.y);
      const list = effectByCell.get(key2) ?? [];
      list.push(effect);
      effectByCell.set(key2, list);
    }
    for (let i2 = 0; i2 < path2.length; i2++) {
      const cell = path2[i2];
      if (i2 === 0 && start && cell.x === start.x && cell.y === start.y) {
        continue;
      }
      const key2 = cellKey2(cell.x, cell.y);
      const list = effectByCell.get(key2);
      if (!list || list.length === 0) continue;
      for (const effect of list) {
        const count2 = counts.get(effect.typeId) ?? 0;
        counts.set(effect.typeId, count2 + 1);
      }
    }
    return { counts, defs };
  };
  const buildHazardRollFromPath = (path2, start) => {
    if (!path2.length && !start) return null;
    const pathCells = path2.length > 0 ? path2 : start ? [start] : [];
    const { counts, defs } = collectHazardsFromPath({ path: pathCells, start });
    let chosenType = null;
    let chosenCount = 0;
    for (const [typeId, count2] of counts.entries()) {
      if (count2 > chosenCount) {
        chosenType = typeId;
        chosenCount = count2;
      }
    }
    if (!chosenType || chosenCount <= 0) return null;
    const def = defs.get(chosenType);
    if (!(def == null ? void 0 : def.hazard)) return null;
    const formula = scaleDiceFormula(def.hazard.damageFormula, chosenCount);
    if (!formula) return null;
    return {
      id: `hazard-${chosenType}-${Date.now()}`,
      label: def.label,
      formula,
      cells: chosenCount,
      statusRoll: def.hazard.statusRoll
    };
  };
  const applyHazardsToTokenFromPath = (params) => {
    const { token, path: path2, start, side } = params;
    if (!path2.length) return token;
    const pathCells = path2.length > 0 ? path2 : start ? [start] : [];
    const { counts, defs } = collectHazardsFromPath({ path: pathCells, start });
    let nextToken = { ...token };
    for (const [typeId, count2] of counts.entries()) {
      const def = defs.get(typeId);
      if (!(def == null ? void 0 : def.hazard)) continue;
      const formula = scaleDiceFormula(def.hazard.damageFormula, count2);
      if (!formula) continue;
      const result = rollDamage(formula);
      const diceText = result.dice.map((d2) => d2.rolls.join("+")).join(" | ");
      pushDiceLog(
        `Degats (${def.label}) : ${diceText || "0"} + ${result.flatModifier} = ${result.total}`
      );
      const beforeHp = nextToken.hp;
      nextToken.hp = Math.max(0, nextToken.hp - result.total);
      pushLog2(`${nextToken.id} traverse ${def.label}: ${result.total} degats.`);
      recordCombatEvent({
        round: round2,
        phase: side,
        kind: "damage",
        actorId: nextToken.id,
        actorKind: side === "player" ? "player" : "enemy",
        targetId: nextToken.id,
        targetKind: side === "player" ? "player" : "enemy",
        summary: `${nextToken.id} subit ${result.total} degats (${def.label}) (PV ${beforeHp} -> ${nextToken.hp}).`,
        data: {
          hazardId: typeId,
          damage: result.total,
          formula
        }
      });
      if (def.hazard.statusRoll) {
        const roll = rollDie(def.hazard.statusRoll.die);
        const trigger2 = def.hazard.statusRoll.trigger;
        const statusId = def.hazard.statusRoll.statusId ?? "status";
        pushDiceLog(`Jet d'etat (${statusId}) : d${def.hazard.statusRoll.die} = ${roll.total}`);
        if (roll.total === trigger2) {
          nextToken = addStatusToToken(nextToken, statusId);
          pushLog2(`${nextToken.id}: etat ${statusId} declenche.`);
          recordCombatEvent({
            round: round2,
            phase: side,
            kind: "status",
            actorId: nextToken.id,
            actorKind: side === "player" ? "player" : "enemy",
            targetId: nextToken.id,
            targetKind: side === "player" ? "player" : "enemy",
            summary: `${nextToken.id} prend l'etat ${statusId}.`,
            data: { statusId }
          });
        }
      }
    }
    return nextToken;
  };
  function buildEnemyAiSummary() {
    const playerSummary = {
      id: player.id,
      x: player.x,
      y: player.y,
      hp: player.hp,
      maxHp: player.maxHp
    };
    const enemiesSummary = enemies.map((e2) => ({
      id: e2.id,
      x: e2.x,
      y: e2.y,
      hp: e2.hp,
      maxHp: e2.maxHp,
      type: e2.enemyTypeId,
      aiRole: e2.aiRole ?? null,
      moveRange: e2.moveRange ?? null,
      maxAttacksPerTurn: e2.maxAttacksPerTurn ?? null,
      actionIds: e2.actionIds ?? null
    }));
    return {
      round: round2,
      phase,
      grid: { cols: mapGrid.cols, rows: mapGrid.rows },
      player: playerSummary,
      enemies: enemiesSummary,
      actionsCatalog: actionsCatalog.map((a2) => {
        var _a2, _b2, _c2, _d, _e, _f, _g, _h;
        return {
          id: a2.id,
          name: a2.name,
          category: String(a2.category ?? ""),
          targeting: {
            target: String(((_a2 = a2.targeting) == null ? void 0 : _a2.target) ?? ""),
            range: {
              min: Number(((_c2 = (_b2 = a2.targeting) == null ? void 0 : _b2.range) == null ? void 0 : _c2.min) ?? 0),
              max: Number(((_e = (_d = a2.targeting) == null ? void 0 : _d.range) == null ? void 0 : _e.max) ?? 0),
              shape: String(((_g = (_f = a2.targeting) == null ? void 0 : _f.range) == null ? void 0 : _g.shape) ?? "")
            },
            requiresLos: Boolean((_h = a2.targeting) == null ? void 0 : _h.requiresLos)
          }
        };
      })
    };
  }
  function sanitizeEnemyIntents(intents) {
    const enemyIds = new Set(enemies.map((e2) => e2.id));
    const sanitized = [];
    for (const raw of intents) {
      if (!raw || typeof raw !== "object") continue;
      if (typeof raw.enemyId !== "string" || !enemyIds.has(raw.enemyId)) continue;
      if (typeof raw.actionId !== "string" || !raw.actionId.trim()) continue;
      const t2 = raw.target;
      let target = { kind: "none" };
      if (t2 && typeof t2 === "object") {
        if (t2.kind === "token" && typeof t2.tokenId === "string") {
          target = { kind: "token", tokenId: t2.tokenId };
        } else if (t2.kind === "cell" && typeof t2.x === "number" && typeof t2.y === "number") {
          target = { kind: "cell", x: t2.x, y: t2.y };
        }
      }
      const modeRaw = raw.advantageMode;
      const advantageMode2 = modeRaw === "advantage" || modeRaw === "disadvantage" ? modeRaw : "normal";
      sanitized.push({
        enemyId: raw.enemyId,
        actionId: raw.actionId.trim(),
        target,
        advantageMode: advantageMode2
      });
    }
    return sanitized;
  }
  async function requestEnemyAiIntents(state) {
    console.log("[enemy-ai] Envoi etat au backend:", state);
    setAiLastState(state);
    setAiLastError(null);
    setAiUsedFallback(false);
    try {
      const response = await fetch("/api/enemy-ai", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(state)
      });
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }
      const data = await response.json();
      if (!data.intents || !Array.isArray(data.intents)) {
        throw new Error("Reponse backend invalide (intents manquant).");
      }
      const sanitized = sanitizeEnemyIntents(data.intents);
      setAiLastIntents(sanitized);
      if (sanitized.length === 0) setAiUsedFallback(true);
      return sanitized;
    } catch (error) {
      setAiLastError(error instanceof Error ? error.message : String(error ?? "unknown"));
      setAiLastIntents(null);
      setAiUsedFallback(true);
      return [];
    }
  }
  async function updateEnemySpeechAfterTurn(enemyId, playerState, enemiesState) {
    const enemy = enemiesState.find((e2) => e2.id === enemyId);
    if (!enemy) return;
    if (isTokenDead(enemy)) return;
    const allTokens = getTokensOnActiveLevel([playerState, ...enemiesState]);
    const visible = getEntitiesInVision(
      enemy,
      allTokens,
      visionBlockersActive,
      playableCells,
      wallEdges.vision,
      lightLevels,
      mapGrid
    );
    const alliesVisible = visible.filter((t2) => t2.type === "enemy" && t2.id !== enemyId && !isTokenDead(t2)).map((t2) => t2.id);
    const enemiesVisible = visible.filter((t2) => t2.type === "player" && !isTokenDead(t2)).map((t2) => t2.id);
    const canSeePlayerNow = areTokensOnSameLevel(enemy, playerState) && canEnemySeePlayer(
      enemy,
      playerState,
      allTokens,
      visionBlockersActive,
      playableCells,
      wallEdges.vision,
      lightLevels,
      mapGrid
    );
    const distToPlayer = distanceBetweenTokens(enemy, playerState);
    const hpRatio = enemy.maxHp > 0 ? enemy.hp / enemy.maxHp : 0;
    const payload = {
      language: "fr",
      maxLines: 2,
      enemyId,
      enemyTypeId: enemy.enemyTypeId ?? null,
      aiRole: enemy.aiRole ?? null,
      speechProfile: enemy.speechProfile ?? null,
      perception: {
        canSeePlayer: canSeePlayerNow,
        distanceToPlayer: Number.isFinite(distToPlayer) ? distToPlayer : null,
        hpRatio: Number.isFinite(hpRatio) ? hpRatio : 0,
        alliesVisible,
        enemiesVisible,
        lastKnownPlayerPos: canSeePlayerNow ? { x: playerState.x, y: playerState.y } : null
      },
      priorSpeechesThisRound: getPriorEnemySpeechesThisRound(),
      selfLastSpeech: getLastSpeechForEnemy(enemyId),
      recentEvents: getRecentCombatEvents(16)
    };
    const response = await requestEnemySpeech(payload);
    const line = (response.line ?? "").trim();
    if (!line) {
      clearEnemyBubble(enemyId);
      return;
    }
    setEnemyBubble(enemyId, line);
    recordEnemySpeech(enemyId, line);
  }
  async function runSingleEnemyTurnV2(activeEnemyId) {
    var _a2;
    setIsResolvingEnemies(true);
    setSelectedPath([]);
    setEffectSpecs([]);
    let enemiesCopy = enemies.map((e2) => ({ ...e2 }));
    let playerCopy = { ...player };
    const activeEnemy = enemiesCopy.find((e2) => e2.id === activeEnemyId);
    if (!activeEnemy || isTokenDead(activeEnemy)) {
      setIsResolvingEnemies(false);
      advanceTurn();
      return;
    }
    const aiTurnLogs = [];
    playerCopy = applyWeaponMasteryStartExpiryForToken(playerCopy, activeEnemy.id);
    enemiesCopy = enemiesCopy.map(
      (enemy) => applyWeaponMasteryStartExpiryForToken(enemy, activeEnemy.id)
    );
    setPlayer(playerCopy);
    setEnemies(enemiesCopy);
    const activeEnemyAfterExpiry = enemiesCopy.find((enemy) => enemy.id === activeEnemy.id) ?? activeEnemy;
    const refreshedEnemy = applyStartOfTurnStatuses({
      token: activeEnemyAfterExpiry,
      side: "enemies"
    });
    const enemyIndex = enemiesCopy.findIndex((e2) => e2.id === activeEnemyId);
    if (enemyIndex >= 0) {
      enemiesCopy[enemyIndex] = refreshedEnemy;
    }
    if (isTokenDead(refreshedEnemy)) {
      pushLog2(`${refreshedEnemy.id} succombe a ses blessures.`);
      recordCombatEvent({
        round: round2,
        phase: "enemies",
        kind: "death",
        actorId: refreshedEnemy.id,
        actorKind: "enemy",
        summary: `${refreshedEnemy.id} s'effondre, hors de combat.`
      });
      setEnemies(enemiesCopy);
      setIsResolvingEnemies(false);
      advanceTurn();
      return;
    }
    const activeEnemyStart = { x: refreshedEnemy.x, y: refreshedEnemy.y };
    const summary2 = buildEnemyAiSummary();
    const intents = await requestEnemyAiIntents(summary2);
    const filtered = intents.filter((i2) => i2.enemyId === activeEnemyId);
    const allTokens = getTokensOnActiveLevel([
      playerCopy,
      ...enemiesCopy
    ]);
    const combatProfile2 = resolveCombatProfile(refreshedEnemy);
    const memory = getEnemyMemory(refreshedEnemy.id);
    const canSeePlayer = areTokensOnSameLevel(refreshedEnemy, playerCopy) && canEnemySeePlayer(
      refreshedEnemy,
      playerCopy,
      allTokens,
      visionBlockersActive,
      playableCells,
      wallEdges.vision,
      lightLevels,
      mapGrid
    );
    if (canSeePlayer) {
      updateEnemyMemory(refreshedEnemy.id, {
        lastSeenPos: { x: playerCopy.x, y: playerCopy.y },
        lastSeenRound: round2
      });
      if (combatProfile2.awareness > 0) {
        const approximate = fuzzAlertPosition({ x: playerCopy.x, y: playerCopy.y });
        const existingAlert = getActiveTeamAlert();
        if (!existingAlert || existingAlert.sourceId !== refreshedEnemy.id) {
          broadcastTeamAlert(refreshedEnemy, approximate, 0.7);
        }
      }
    }
    const enemyActionIds = Array.isArray(activeEnemy.actionIds) && activeEnemy.actionIds.length ? activeEnemy.actionIds : ["move", "melee-strike"];
    const getActionById2 = (id2) => actionsCatalog.find((a2) => a2.id === id2) ?? null;
    const describeActionTarget = (target) => {
      if (target.kind === "token") return target.token.id;
      if (target.kind === "cell") return `cell(${target.x},${target.y})`;
      return "aucune cible";
    };
    const tryResolve = async (actionId, target, advantageMode2) => {
      var _a3, _b2;
      const baseAction = getActionById2(actionId);
      const action2 = baseAction ? applyWeaponOverrideForActor(baseAction, activeEnemy) : null;
      if (!action2) {
        await waitForEnemyTurnResume();
        return { ok: false, reason: `Action inconnue: ${actionId}` };
      }
      if (!enemyActionIds.includes(actionId)) {
        await waitForEnemyTurnResume();
        return { ok: false, reason: `Action non autorisee pour ${activeEnemy.id}: ${actionId}` };
      }
      const beforePlayerHp = playerCopy.hp;
      const beforeEnemyHp = new Map(enemiesCopy.map((e2) => [e2.id, e2.hp]));
      const beforeActorPos = { x: activeEnemy.x, y: activeEnemy.y };
      let resolvedAdvantageMode = advantageMode2;
      if (target.kind === "token" && target.token.type === "player" && action2.category === "attack") {
        const preAttackModifier = getIncomingAttackReactionModifier({
          reactor: playerCopy,
          attacker: activeEnemy,
          target: target.token,
          action: action2,
          event: "incomingAttack"
        });
        if ((preAttackModifier == null ? void 0 : preAttackModifier.mode) === "imposeDisadvantage") {
          resolvedAdvantageMode = mergeAdvantageModes(advantageMode2, "disadvantage");
          markReactionUsed(playerCopy.id);
          const uiLine = preAttackModifier.uiMessage ?? `Reaction: desavantage impose a l'attaque ${action2.name}.`;
          pushLog2(uiLine);
          showReactionToast(uiLine, "info");
        }
      }
      const result = resolveActionUnified(
        action2,
        {
          round: round2,
          phase: "enemies",
          actor: activeEnemy,
          player: playerCopy,
          enemies: enemiesCopy,
          blockedMovementCells: obstacleBlocking.movement,
          blockedMovementEdges: wallEdges.movement,
          blockedVisionCells: visionBlockersActive,
          blockedAttackCells: obstacleBlocking.attacks,
          wallVisionEdges: wallEdges.vision,
          lightLevels,
          playableCells,
          grid: mapGrid,
          heightMap: mapHeight,
          floorIds: mapTerrain,
          activeLevel,
          sampleCharacter: activeCharacterConfig,
          getSlotAmount: (slot, level2) => getSlotAmountFromCharacter(activeEnemy, slot, level2),
          usage: getActionUsageForActor(activeEnemy.id),
          reactionAvailable: canUseReaction(activeEnemy.id),
          concentrating: isTokenConcentrating(activeEnemy),
          surprised: isTokenSurprised(activeEnemy),
          getActionConstraintIssues: ({ action: action22, actor }) => {
            var _a4;
            return getWeaponActionConstraintIssues(action22, actor, {
              reaction: ((_a4 = action22.actionCost) == null ? void 0 : _a4.actionType) === "reaction"
            });
          },
          spawnEntity: createSummon,
          onLog: pushLog2,
          emitEvent: (evt) => {
            recordCombatEvent({
              round: round2,
              phase: "enemies",
              kind: evt.kind,
              actorId: evt.actorId,
              actorKind: evt.actorKind,
              targetId: evt.targetId ?? null,
              targetKind: evt.targetKind ?? null,
              summary: evt.summary,
              data: evt.data ?? {}
            });
          }
        },
        target,
        { advantageMode: resolvedAdvantageMode, weaponMasteryActions }
      );
      if (!result.ok || !result.playerAfter || !result.enemiesAfter) {
        const msg = `[IA] ${activeEnemy.id}: ${action2.name} sur ${describeActionTarget(target)} -> echec (${result.reason || "inconnu"}).`;
        pushLog2(msg);
        aiTurnLogs.push(msg);
        updateEnemyMemory(activeEnemy.id, {
          lastFailedReason: classifyFailureReason(result.reason),
          lastFailedActionId: action2.id
        });
        await waitForEnemyTurnResume();
        return { ok: false, reason: result.reason || "Echec de resolution." };
      }
      updateActionUsageForActor(activeEnemy.id, action2.id, 1);
      updateWeaponPropertyUsageForAction(activeEnemy.id, action2, 1);
      let nextPlayerAfterResult = result.playerAfter;
      if (target.kind === "token" && target.token.type === "player" && action2.category === "attack") {
        const damageTaken = Math.max(0, beforePlayerHp - result.playerAfter.hp);
        const reduced = applyIncomingHitReductionReaction({
          reactor: playerCopy,
          attacker: activeEnemy,
          target: target.token,
          action: action2,
          damageTaken,
          nextPlayer: result.playerAfter
        });
        nextPlayerAfterResult = reduced.nextPlayer;
      }
      playerCopy = nextPlayerAfterResult;
      enemiesCopy = applySummonTurnOrder({
        prevEnemies: enemiesCopy,
        nextEnemies: result.enemiesAfter
      }).map((enemy) => ({ ...enemy }));
      setPlayer(playerCopy);
      setEnemies(enemiesCopy);
      const afterActor = enemiesCopy.find((e2) => e2.id === activeEnemy.id) ?? null;
      if (afterActor && action2.category === "movement" && (afterActor.x !== beforeActorPos.x || afterActor.y !== beforeActorPos.y)) {
        triggerMovementReactions({
          mover: afterActor,
          from: beforeActorPos,
          to: { x: afterActor.x, y: afterActor.y },
          playerSnapshot: playerCopy,
          enemiesSnapshot: enemiesCopy
        });
      }
      const targetDesc = describeActionTarget(target);
      const damageToPlayer = beforePlayerHp - playerCopy.hp;
      let damageToEnemy = null;
      if (target.kind === "token" && target.token.type === "enemy") {
        const afterHp = ((_a3 = enemiesCopy.find((e2) => e2.id === target.token.id)) == null ? void 0 : _a3.hp) ?? null;
        const beforeHp = beforeEnemyHp.get(target.token.id) ?? null;
        if (beforeHp !== null && afterHp !== null) {
          damageToEnemy = beforeHp - afterHp;
        }
      }
      const moved = activeEnemy.x !== beforeActorPos.x || activeEnemy.y !== beforeActorPos.y;
      const details = [];
      if (damageToPlayer > 0) details.push(`degats joueur: ${damageToPlayer}`);
      if (damageToEnemy && damageToEnemy > 0) {
        details.push(`degats ${targetDesc}: ${damageToEnemy}`);
      }
      if (moved) details.push(`deplacement -> (${activeEnemy.x},${activeEnemy.y})`);
      const detailText = details.length > 0 ? ` (${details.join(", ")})` : "";
      const okMsg = `[IA] ${activeEnemy.id}: ${action2.name} sur ${targetDesc} -> ok${detailText}.`;
      pushLog2(okMsg);
      aiTurnLogs.push(okMsg);
      updateEnemyMemory(activeEnemy.id, {
        lastFailedReason: void 0,
        lastFailedActionId: void 0,
        lastEffectiveActionId: action2.id
      });
      if (result.logs.length > 0) {
        for (const line of result.logs) {
          aiTurnLogs.push(`[IA] ${activeEnemy.id}: ${line}`);
        }
      }
      if (target.kind === "token" && target.token.type === "player") {
        const didHit = damageToPlayer > 0;
        const hitTypeSuffix = buildDamageTypeSuffix((_b2 = action2.damage) == null ? void 0 : _b2.damageType);
        const defaultHitMessage = `Vous avez ete touche par ${action2.name}: ${damageToPlayer} degats${hitTypeSuffix}.`;
        const customHitMessage = action2.uiMessageHit ? `${action2.uiMessageHit} (${damageToPlayer} degats${hitTypeSuffix}).` : null;
        const message = didHit ? customHitMessage || defaultHitMessage : action2.uiMessageMiss || null;
        if (message) {
          showCombatToast(message, didHit ? "hit" : "info");
          suppressCombatToastUntilRef.current = Date.now() + 500;
        }
      }
      await waitForEnemyTurnResume();
      return { ok: true, action: action2 };
    };
    let usedFallback = false;
    if (filtered.length > 0) {
      const context2 = buildEnemyActionContext({
        actor: activeEnemy,
        playerSnapshot: playerCopy,
        enemiesSnapshot: enemiesCopy
      });
      let resolvedIntent = false;
      for (const intent of filtered) {
        const action2 = getActionById2(intent.actionId);
        if (!action2) continue;
        const style = getActionStyle(action2);
        if (style !== "move" && style !== "other") {
          if (!combatProfile2.allowedStyles.includes(style)) {
            continue;
          }
        }
        const targetSpec = intent.target;
        let target = { kind: "none" };
        if (targetSpec.kind === "token") {
          const token = allTokens.find((t2) => t2.id === targetSpec.tokenId) ?? null;
          if (token) target = { kind: "token", token };
        } else if (targetSpec.kind === "cell") {
          target = { kind: "cell", x: targetSpec.x, y: targetSpec.y };
        }
        const availability = computeAvailabilityForActor(action2, context2);
        if (!availability.enabled) continue;
        const validation = validateActionTarget(action2, context2, target);
        if (!validation.ok) continue;
        const resolved = await tryResolve(
          intent.actionId,
          target,
          intent.advantageMode
        );
        if (!resolved.ok) {
          usedFallback = true;
          pushLog2(`${activeEnemy.id}: intent IA invalide (${resolved.reason}).`);
          break;
        }
        setAiUsedFallback(false);
        resolvedIntent = true;
        break;
      }
      if (!resolvedIntent) usedFallback = true;
    } else {
      usedFallback = true;
    }
    if (usedFallback) {
      setAiUsedFallback(true);
      const alert = combatProfile2.intelligence > 0 ? getActiveTeamAlert() : null;
      const lastSeen = combatProfile2.intelligence > 0 ? memory.lastSeenPos ?? null : null;
      const targetPos = canSeePlayer ? { x: playerCopy.x, y: playerCopy.y } : (alert == null ? void 0 : alert.position) ?? lastSeen;
      if (!canSeePlayer && !targetPos) {
        pushLog2(`${activeEnemy.id} ne voit pas le joueur et reste en alerte.`);
      } else {
        const distToPlayer = distanceBetweenTokens(activeEnemy, playerCopy);
        const canMove2 = enemyActionIds.includes("move");
        const moveRange = typeof activeEnemy.moveRange === "number" ? activeEnemy.moveRange : 3;
        const moveRangeCells = metersToCells(moveRange);
        let acted = false;
        const pickBestRetreatCell = (from) => {
          let best = null;
          let bestDist = -1;
          for (let dx = -moveRangeCells; dx <= moveRangeCells; dx++) {
            for (let dy = -moveRangeCells; dy <= moveRangeCells; dy++) {
              const steps = Math.abs(dx) + Math.abs(dy);
              if (steps === 0 || steps > moveRangeCells) continue;
              const x2 = from.x + dx;
              const y2 = from.y + dy;
              if (!isCellPlayable(x2, y2)) continue;
              if (getTokenAt({ x: x2, y: y2 }, allTokens)) continue;
              const d2 = distanceFromPointToToken({ x: x2, y: y2 }, playerCopy);
              if (d2 > bestDist) {
                bestDist = d2;
                best = { x: x2, y: y2 };
              }
            }
          }
          return best;
        };
        const shouldMoveFirst = combatProfile2.intelligence > 0 && memory.lastFailedReason === "out_of_range";
        if (!acted && canSeePlayer && !shouldMoveFirst) {
          const context2 = buildEnemyActionContext({
            actor: activeEnemy,
            playerSnapshot: playerCopy,
            enemiesSnapshot: enemiesCopy
          });
          let bestAttack = null;
          for (const actionId of enemyActionIds) {
            const action2 = getActionById2(actionId);
            if (!action2 || action2.category !== "attack") continue;
            const style = getActionStyle(action2);
            if (style !== "melee" && style !== "ranged" && style !== "support") continue;
            if (!combatProfile2.allowedStyles.includes(style)) continue;
            const availability = computeAvailabilityForActor(action2, context2);
            if (!availability.enabled) continue;
            const validation = validateActionTarget(action2, context2, {
              kind: "token",
              token: playerCopy
            });
            if (!validation.ok) continue;
            const score = scoreActionForEnemy({
              action: action2,
              profile: combatProfile2,
              distanceToPlayer: distToPlayer,
              memory
            });
            if (!bestAttack || score > bestAttack.score) {
              bestAttack = { action: action2, score };
            }
          }
          if (bestAttack) {
            const attack2 = await tryResolve(bestAttack.action.id, {
              kind: "token",
              token: playerCopy
            });
            if (attack2.ok) {
              recordCombatEvent({
                round: round2,
                phase: "enemies",
                kind: "enemy_attack",
                actorId: activeEnemy.id,
                actorKind: "enemy",
                targetId: playerCopy.id,
                targetKind: "player",
                summary: `${activeEnemy.id} attaque (${bestAttack.action.name}).`,
                data: { actionId: bestAttack.action.id, fallback: true }
              });
              acted = true;
            }
          }
        }
        if (!acted && canMove2 && targetPos) {
          const desiredMin = combatProfile2.preferredRangeMin;
          const desiredMax = combatProfile2.preferredRangeMax;
          const shouldRetreat = distToPlayer < desiredMin || combatProfile2.avoidRangeMax !== void 0 && distToPlayer <= combatProfile2.avoidRangeMax;
          const shouldApproach = distToPlayer > desiredMax || memory.lastFailedReason === "out_of_range";
          let destination = null;
          if (shouldRetreat) {
            destination = pickBestRetreatCell({ x: activeEnemy.x, y: activeEnemy.y });
          } else if (shouldApproach) {
            const tokensForPath = getTokensOnActiveLevel(allTokens);
            const path2 = computePathTowards(
              activeEnemy,
              { x: targetPos.x, y: targetPos.y },
              tokensForPath,
              {
                maxDistance: moveRangeCells,
                allowTargetOccupied: false,
                blockedCells: obstacleBlocking.movement,
                wallEdges: wallEdges.movement,
                playableCells,
                grid: mapGrid,
                heightMap: mapHeight,
                floorIds: mapTerrain,
                activeLevel
              }
            );
            if (path2.length) destination = path2[path2.length - 1];
          }
          if (destination) {
            const from = { x: activeEnemy.x, y: activeEnemy.y };
            const moved = await tryResolve("move", {
              kind: "cell",
              x: destination.x,
              y: destination.y
            });
            if (moved.ok) {
              recordCombatEvent({
                round: round2,
                phase: "enemies",
                kind: "move",
                actorId: activeEnemy.id,
                actorKind: "enemy",
                summary: `${activeEnemy.id} se deplace de (${from.x}, ${from.y}) vers (${destination.x}, ${destination.y}).`,
                data: { from, to: destination, fallback: true, actionId: moved.action.id }
              });
              acted = true;
            }
          }
        }
      }
    }
    const finalEnemy = enemiesCopy.find((e2) => e2.id === activeEnemyId) ?? null;
    if (finalEnemy) {
      const planned = Array.isArray(finalEnemy.plannedPath) ? finalEnemy.plannedPath : [];
      const moved = finalEnemy.x !== activeEnemyStart.x || finalEnemy.y !== activeEnemyStart.y;
      const fallbackPath = moved ? [activeEnemyStart, { x: finalEnemy.x, y: finalEnemy.y }] : [];
      const hazardPath = planned.length > 0 ? planned : fallbackPath;
      if (hazardPath.length > 0) {
        const updatedEnemy = applyHazardsToTokenFromPath({
          token: finalEnemy,
          path: hazardPath,
          start: activeEnemyStart,
          side: "enemies"
        });
        const idx = enemiesCopy.findIndex((e2) => e2.id === activeEnemyId);
        if (idx >= 0) enemiesCopy[idx] = updatedEnemy;
      }
    }
    setPlayer(playerCopy);
    setEnemies(enemiesCopy);
    if (aiTurnLogs.length > 0) {
      pushLog2(`[IA] ${activeEnemyId} recap:`);
      for (const line of aiTurnLogs) {
        pushLog2(`- ${line}`);
      }
    }
    try {
      await updateEnemySpeechAfterTurn(activeEnemyId, playerCopy, enemiesCopy);
    } catch {
    }
    const next = peekNextTurnEntry();
    if (narrationPendingRef.current && ((_a2 = next.entry) == null ? void 0 : _a2.kind) === "player") {
      try {
        const stateEnd = buildCombatStateSummaryFrom("player", playerCopy, enemiesCopy);
        const payload = buildRoundNarrationRequest({
          focusActorId: playerCopy.id ?? null,
          stateEnd
        });
        if (payload) {
          const narration = await requestRoundNarration(payload);
          const text = (narration.error || narration.summary || "").trim();
          if (text) pushNarrative(text);
        }
      } catch {
        pushNarrative("IA non fonctionnel.");
      } finally {
        clearRoundNarrationBuffer();
        narrationPendingRef.current = false;
      }
    }
    setIsResolvingEnemies(false);
    advanceTurn();
  }
  function handleEndPlayerTurn() {
    if (isGameOver) return;
    const entry = getActiveTurnEntry();
    if (!entry || entry.kind !== "player") return;
    pushLog2(`Fin du tour joueur (round ${round2}).`);
    narrationPendingRef.current = true;
    recordCombatEvent({
      round: round2,
      phase: "player",
      kind: "turn_end",
      actorId: player.id,
      actorKind: "player",
      summary: `Fin du tour du heros (round ${round2}).`
    });
    advanceTurn();
  }
  function handleShowCircleEffect() {
    setEffectSpecs([
      {
        id: "demo-circle",
        kind: "circle",
        radius: 2
      }
    ]);
    pushLog2("Zone d'effet: cercle (rayon 2) autour du joueur.");
  }
  function handleShowRectangleEffect() {
    setEffectSpecs([
      {
        id: "demo-rect",
        kind: "rectangle",
        width: 3,
        height: 3
      }
    ]);
    pushLog2("Zone d'effet: rectangle 3x3 centre sur le joueur.");
  }
  function handleShowConeEffect() {
    setEffectSpecs([
      {
        id: "demo-cone",
        kind: "cone",
        range: 4,
        direction: "right"
      }
    ]);
    pushLog2("Zone d'effet: cone vers la droite (portee 4).");
  }
  function handleClearEffects() {
    setEffectSpecs([]);
    pushLog2("Zones d'effet effacees.");
  }
  reactExports.useEffect(() => {
    if (isGameOver) return;
    if (player.hp <= 0) {
      const alliesAlive = [player, ...enemies].some(
        (t2) => t2.type === "player" && !isTokenDead(t2)
      );
      if (!alliesAlive) {
        setIsGameOver(true);
      }
    }
  }, [player, enemies, isGameOver]);
  const selectedAction = actions2.find((action2) => action2.id === selectedActionId) || actions2[0] || null;
  selectedAction ? computeActionAvailability(selectedAction) : null;
  const validatedAction = getValidatedAction();
  actionNeedsDiceUI(validatedAction);
  const contextAction = actionContext ? getActionById(actionContext.actionId) : null;
  const contextAvailabilityRaw = contextAction ? computeActionAvailability(contextAction) : null;
  const contextAvailability = (actionContext == null ? void 0 : actionContext.stage) === "active" && contextAction && validatedActionId === contextAction.id ? { enabled: true, reasons: [], details: (contextAvailabilityRaw == null ? void 0 : contextAvailabilityRaw.details) ?? [] } : contextAvailabilityRaw;
  const selectedTargetLabels = getSelectedTargetLabels();
  const contextResource = getActionResourceInfo(contextAction);
  const contextAmmoInfo = reactExports.useMemo(() => {
    if (!contextAction) return null;
    const usage2 = resolveAmmoUsageForAction(contextAction, player);
    if (!usage2) return null;
    const key2 = String(usage2.ammoType ?? "").toLowerCase();
    if (!key2) return null;
    const label2 = itemLabelMap[key2] ?? itemLabelMap[usage2.ammoType] ?? usage2.ammoType;
    const unknown2 = !isPhysicalResource(key2);
    const available = !unknown2 && activeCharacterConfig ? getInventoryResourceCount(activeCharacterConfig, key2) : 0;
    return {
      label: label2,
      available,
      required: usage2.amount,
      insufficient: !unknown2 && available < usage2.amount,
      unknown: unknown2
    };
  }, [contextAction, player, itemLabelMap, activeCharacterConfig]);
  const contextSpellSourceOptions = reactExports.useMemo(() => {
    if (!contextAction || !isSpellActionId(contextAction.id)) return [];
    const candidates = buildSpellUsageCandidates(activeCharacterConfig, contextAction.id);
    const unique = /* @__PURE__ */ new Map();
    candidates.forEach((candidate) => {
      if (!unique.has(candidate.entryId)) unique.set(candidate.entryId, candidate);
    });
    const list = Array.from(unique.values());
    return list.sort((a2, b2) => {
      const delta = getSpellCandidatePriority(a2) - getSpellCandidatePriority(b2);
      if (delta !== 0) return delta;
      return String(a2.sourceKey).localeCompare(String(b2.sourceKey));
    }).map((candidate) => {
      const sourceLabel = candidate.sourceId ? `${candidate.sourceType ?? "source"}:${candidate.sourceId}` : candidate.sourceKey;
      let detail = candidate.usageType || "at-will";
      if (candidate.consumesSlot && candidate.slotLevel !== null) {
        const remaining = getSlotAmountFromCharacter(activeCharacterConfig, "slot", candidate.slotLevel);
        detail = `slot niv ${candidate.slotLevel} (${remaining} restant(s))`;
      } else if (candidate.usageType.toLowerCase() === "limited" || candidate.usageType.toLowerCase() === "charge") {
        detail = `${candidate.usageType}: ${Number(candidate.remainingUses ?? 0)}/${Number(
          candidate.maxUses ?? candidate.remainingUses ?? 0
        )}`;
      }
      return {
        entryId: candidate.entryId,
        label: sourceLabel,
        detail,
        disabled: !canConsumeSpellUsage(activeCharacterConfig, candidate)
      };
    });
  }, [contextAction, activeCharacterConfig]);
  reactExports.useEffect(() => {
    if (!contextAction || !isSpellActionId(contextAction.id)) return;
    if (contextSpellSourceOptions.length === 0) return;
    const current = selectedSpellSourceBySpellId[contextAction.id];
    const valid = current ? contextSpellSourceOptions.some((option) => option.entryId === current) : false;
    if (valid) return;
    setSelectedSpellSourceBySpellId((prev) => ({
      ...prev,
      [contextAction.id]: contextSpellSourceOptions[0].entryId
    }));
  }, [contextAction, contextSpellSourceOptions, selectedSpellSourceBySpellId]);
  const contextNeedsTarget = actionTargetsHostile(contextAction);
  const contextPlan = contextAction ? buildActionPlan({
    action: contextAction,
    availability: contextAvailability ?? null,
    stage: (actionContext == null ? void 0 : actionContext.stage) ?? "draft",
    needsTarget: contextNeedsTarget,
    targetSelected: selectedTargetLabels.length > 0,
    hasAttack: Boolean(contextAction.attack),
    hasDamage: Boolean(contextAction.damage),
    attackRoll,
    damageRoll,
    attackOutcome,
    resource: contextResource
  }) : null;
  const contextSteps = (contextPlan == null ? void 0 : contextPlan.steps) ?? [];
  const contextComplete = (actionContext == null ? void 0 : actionContext.stage) === "active" && Boolean(contextAction) && (attackOutcome === "miss" || (contextSteps.length === 0 ? true : contextSteps.every((step) => step.status === "done")));
  reactExports.useEffect(() => {
    contextCompleteRef.current = contextComplete;
  }, [contextComplete]);
  const selectedTargetStatuses = reactExports.useMemo(() => {
    const primaryTargetId2 = getPrimaryTargetId();
    if (!primaryTargetId2) return [];
    const target = [player, ...enemies].find((token) => token.id === primaryTargetId2);
    if (!target || !Array.isArray(target.statuses) || target.statuses.length === 0) {
      return [];
    }
    return target.statuses.map((status) => {
      const def = statusTypeById.get(status.id);
      return {
        id: status.id,
        label: (def == null ? void 0 : def.label) ?? status.id,
        remainingTurns: status.remainingTurns,
        sourceId: status.sourceId ?? null,
        isPersistent: Boolean(def == null ? void 0 : def.persistUntilDeath)
      };
    });
  }, [enemies, selectedTargetIds, statusTypeById]);
  const isActionInProgress = (actionContext == null ? void 0 : actionContext.stage) === "active" && Boolean(validatedActionId) || Boolean(pendingHazardRoll);
  const canInteractWithBoard = phase === "player" && !isGameOver && !isTokenDead(player);
  const showResumeAction = isActionInProgress && !actionContextOpen;
  const contextMovement = contextAction && isMoveTypeAction(contextAction) ? {
    costUsed: selectedPathCost,
    costMax: pathLimit,
    hasPath: selectedPath.length > 0,
    isMoving: interactionMode === "moving",
    canInteract: canInteractWithBoard,
    onSelectPath: handleSelectPathFromContext,
    onValidateMove: handleValidatePath,
    onCancelMove: handleCancelMoveFromWheel
  } : null;
  const effectiveAdvantageMode = resolvePlayerAdvantageMode(contextAction);
  const isPlayerTurn = phase === "player";
  const phaseLabel = isPlayerTurn ? "Tour du joueur" : "Tour ennemi";
  const showReactionBanner = (actionContext == null ? void 0 : actionContext.source) === "reaction" || reactionQueue.length > 0;
  const activeEntry = getActiveTurnEntry();
  const timelineEntries = turnOrder;
  if (!isCombatConfigured) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      CombatSetupScreen,
      {
        configEnemyCount,
        enemyTypeCount: enemyTypes.length,
        gridCols: mapGrid.cols,
        gridRows: mapGrid.rows,
        mapPrompt,
        character: characterConfig,
        weaponTypes,
        raceTypes,
        classTypes,
        subclassTypes,
        backgroundTypes,
        languageTypes,
        toolItems,
        objectItems,
        armorItems,
        onChangeCharacter: setCharacterConfig,
        onChangeMapPrompt: setMapPrompt,
        onChangeEnemyCount: setConfigEnemyCount,
        onNoEnemyTypes: () => pushLog2(
          "Aucun type d'ennemi charge (enemyTypes). Impossible de generer le combat."
        ),
        onStartCombat: handleStartCombat
      }
    );
  }
  function openActionContextFromWheel(action2) {
    const anchor2 = resolveWheelAnchor();
    const anchorX = anchor2.x;
    const anchorY = anchor2.y;
    if (actions2.some((a2) => a2.id === action2.id)) {
      setSelectedActionId(action2.id);
    }
    setActionContext({ anchorX, anchorY, actionId: action2.id, stage: "draft", source: "action" });
    setActionContextOpen(true);
  }
  function resetActionContext() {
    setActionContext(null);
    setActionContextOpen(false);
    setTargetMode("none");
    setAttackOutcome(null);
    setPendingHazardRoll(null);
    setHazardAnchor(null);
    setHazardResolution(null);
  }
  function maybeTriggerActionVisuals(reason) {
    if (!actionContext || actionContext.stage !== "active") return;
    const action2 = getActionById(actionContext.actionId);
    if (!action2) return;
    if (!contextCompleteRef.current) return;
    const key2 = actionContext.cycleId ? `cycle:${actionContext.cycleId}` : `${action2.id}:${round2}:${validatedActionId ?? "none"}:${attackOutcome ?? "none"}`;
    if (lastActionVfxKeyRef.current === key2) return;
    lastActionVfxKeyRef.current = key2;
    void spawnActionVisualEffects(action2).then((spawned) => {
      if (!spawned && reason === "finish") {
        return;
      }
    });
  }
  function closeActionContext() {
    if ((actionContext == null ? void 0 : actionContext.stage) === "active" && validatedActionId || pendingHazardRoll) {
      if (!pendingHazardRoll) {
        maybeTriggerActionVisuals("close");
      }
      setActionContextOpen(false);
      return;
    }
    resetActionContext();
    startNextReactionFromQueue();
  }
  function openSheetFromWheel() {
    if (!canInteractWithBoard) return;
    setSheetOpen(true);
  }
  function handleFinishAction() {
    maybeTriggerActionVisuals("finish");
    setValidatedActionId(null);
    setAttackRoll(null);
    setDamageRoll(null);
    setAttackOutcome(null);
    setHasRolledAttackForCurrentAction(false);
    setSelectedTargetIds([]);
    setSelectedObstacleTarget(null);
    setSelectedWallTarget(null);
    resetActionContext();
    startNextReactionFromQueue(true);
  }
  function handleCancelAction() {
    var _a2, _b2;
    const action2 = getValidatedAction();
    if (action2 && isMoveTypeAction(action2)) {
      setSelectedPath([]);
      setInteractionMode("idle");
    }
    if (action2) {
      const costType = (_a2 = action2.actionCost) == null ? void 0 : _a2.actionType;
      const isStandardAction = costType === "action";
      const isBonusAction = costType === "bonus";
      const isReaction = costType === "reaction";
      setTurnActionUsage((prev) => ({
        usedActionCount: Math.max(0, prev.usedActionCount - (isStandardAction ? 1 : 0)),
        usedBonusCount: Math.max(0, prev.usedBonusCount - (isBonusAction ? 1 : 0))
      }));
      const canceledWeapon = action2.category === "attack" ? pickWeaponForAction(
        action2,
        player,
        ((_b2 = action2.actionCost) == null ? void 0 : _b2.actionType) === "reaction" ? { reaction: true } : void 0
      ) : null;
      const canceledHandlingCost = resolveWeaponHandlingCost({
        action: action2,
        actor: player,
        weapon: canceledWeapon
      });
      if (canceledHandlingCost.requiresInteraction > 0) {
        setTurnEquipmentUsage((prev) => ({
          usedInteractionCount: Math.max(
            0,
            prev.usedInteractionCount - canceledHandlingCost.requiresInteraction
          )
        }));
      }
      if (isReaction) {
        setReactionUsage((prev) => ({
          ...prev,
          [player.id]: Math.max(0, (prev[player.id] ?? 0) - 1)
        }));
      }
      setActionUsageCounts((prev) => ({
        turn: { ...prev.turn, [action2.id]: Math.max(0, (prev.turn[action2.id] ?? 0) - 1) },
        encounter: {
          ...prev.encounter,
          [action2.id]: Math.max(0, (prev.encounter[action2.id] ?? 0) - 1)
        }
      }));
    }
    setValidatedActionId(null);
    setAttackRoll(null);
    setDamageRoll(null);
    setAttackOutcome(null);
    setHasRolledAttackForCurrentAction(false);
    setSelectedTargetIds([]);
    setSelectedObstacleTarget(null);
    setSelectedWallTarget(null);
    resetActionContext();
    startNextReactionFromQueue(true);
    pushLog2("Action annulee.");
  }
  function handleValidateActionFromContext(action2) {
    var _a2, _b2, _c2, _d, _e;
    if (isMoveTypeAction(action2)) {
      const multiplier = ((_a2 = action2.movement) == null ? void 0 : _a2.pathLimitMultiplier) ?? 1;
      let baseLimit = basePathLimit;
      if ((_b2 = action2.movement) == null ? void 0 : _b2.modeId) {
        const mode = getMovementModeById(action2.movement.modeId) ?? defaultMovementMode;
        const profile = buildMovementProfileFromMode(mode);
        baseLimit = metersToCells(profile.speed);
      }
      const nextBase = Math.max(0, Math.round(baseLimit * multiplier));
      const available = Math.max(0, nextBase - movementSpent);
      if (available <= 0) {
        pushLog2("Deplacement impossible: budget de mouvement epuise.");
        return;
      }
    }
    const accepted = handleUseAction(action2);
    if (!accepted) return;
    if (!action2.attack && !action2.damage && !isMoveTypeAction(action2) && ((_c2 = action2.targeting) == null ? void 0 : _c2.target) === "self") {
      const ok = resolvePlayerActionV2(action2);
      if (ok) {
        handleFinishAction();
      }
      return;
    }
    if (isMoveTypeAction(action2)) {
      const multiplier = ((_d = action2.movement) == null ? void 0 : _d.pathLimitMultiplier) ?? 1;
      let baseLimit = basePathLimit;
      if ((_e = action2.movement) == null ? void 0 : _e.modeId) {
        const mode = getMovementModeById(action2.movement.modeId) ?? defaultMovementMode;
        const profile = buildMovementProfileFromMode(mode);
        baseLimit = metersToCells(profile.speed);
        setActiveMovementModeId(mode.id);
        setPlayer((prev) => ({
          ...prev,
          movementProfile: profile,
          moveRange: profile.speed,
          combatStats: prev.combatStats ? { ...prev.combatStats, moveRange: profile.speed } : prev.combatStats
        }));
        setBasePathLimit(metersToCells(profile.speed));
        baseLimit = metersToCells(profile.speed);
      }
      setSelectedPath([]);
      const nextBase = Math.max(0, Math.round(baseLimit * multiplier));
      setBasePathLimit(nextBase);
      setPathLimit(Math.max(0, nextBase - movementSpent));
      setInteractionMode("moving");
    }
    const nextCycleId = actionCycleIdRef.current + 1;
    actionCycleIdRef.current = nextCycleId;
    setActionContext(
      (current) => current ? { ...current, actionId: action2.id, stage: "active", cycleId: nextCycleId } : current
    );
    setActionContextOpen(true);
  }
  function handleEnterInspectModeFromWheel() {
    if (!canInteractWithBoard) return;
    setTargetMode("none");
    setInteractionMode("inspect-select");
    pushLog2(
      `Inspection: cliquez sur une case VISIBLE (portee ${INSPECT_RANGE}) pour reveler nature / etat / role.`
    );
  }
  function handleEnterLookModeFromWheel() {
    if (!canInteractWithBoard) return;
    setTargetMode("none");
    setInteractionMode("look-select");
    pushLog2("Tourner le regard: cliquez sur une case pour orienter le champ de vision.");
  }
  function openInteractionWheel(anchorX, anchorY, target, interactions2) {
    setInteractionContext(null);
    const items = interactions2.map((interaction) => ({
      id: `interaction-${interaction.id}`,
      label: interaction.label,
      color: "#9b59b6",
      onSelect: () => {
        setInteractionContext({ anchorX, anchorY, interaction, target });
      }
    }));
    setInteractionMenuItems(items);
  }
  function handleExecuteInteraction(interaction, target) {
    const availability = getInteractionAvailability({
      interaction,
      target,
      player,
      wallSegments,
      obstacles,
      wallTypeById,
      obstacleTypeById,
      canPayCost: canPayInteractionCost,
      getWallDistance: getWallSegmentChebyshevDistance,
      getObstacleDistance: getObstacleChebyshevDistance
    });
    if (!availability.ok) {
      pushLog2(`Interaction ${interaction.label}: ${availability.reason ?? "indisponible"}.`);
      return;
    }
    const modForce = getCharacterAbilityMod(activeCharacterConfig, "FOR");
    const forceDc = typeof interaction.forceDc === "number" ? interaction.forceDc : null;
    const needsCheck = interaction.kind === "break" && forceDc !== null;
    if (needsCheck) {
      const result = rollAttack(modForce, "normal");
      const total = result.total;
      const base = result.d20.total;
      const outcome = total >= forceDc ? "reussi" : "rate";
      pushLog2(
        `Test de force (${interaction.label}) : ${base} + ${modForce} = ${total} vs DD ${forceDc} -> ${outcome}.`
      );
      if (total < forceDc) {
        applyInteractionCost(interaction.cost);
        return;
      }
    }
    applyInteraction({
      interaction,
      target,
      wallTypeById,
      setWallSegments,
      setObstacles
    });
    applyInteractionCost(interaction.cost);
    pushLog2(`Interaction ${interaction.label} executee.`);
  }
  function handleInteractFromWheel() {
    if (!canInteractWithBoard) return;
    if (!hasAnyInteractionSource) {
      pushLog2("Interagir: aucune interaction possible.");
      return;
    }
    setTargetMode("none");
    setInteractionMode("interact-select");
    setInteractionMenuItems([]);
    pushLog2("Interagir: cliquez sur un element pour afficher ses interactions.");
  }
  const interactionAvailability = interactionContext ? getInteractionAvailability({
    interaction: interactionContext.interaction,
    target: interactionContext.target,
    player,
    wallSegments,
    obstacles,
    wallTypeById,
    obstacleTypeById,
    canPayCost: canPayInteractionCost,
    getWallDistance: getWallSegmentChebyshevDistance,
    getObstacleDistance: getObstacleChebyshevDistance
  }) : null;
  const forceMod = getCharacterAbilityMod(activeCharacterConfig, "FOR");
  const interactionState = interactionMode === "interact-select" ? interactionMenuItems.length > 0 ? "menu" : "select" : "idle";
  const wheelAnchor = resolveWheelAnchor();
  const actionWheelCategoryThreshold = 6;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      style: {
        display: "flex",
        flexDirection: "column",
        gap: "12px",
        height: "100vh",
        overflow: "hidden",
        background: "#0b0b12",
        color: "#f5f5f5",
        fontFamily: "system-ui, sans-serif",
        padding: "16px",
        boxSizing: "border-box",
        position: "relative"
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("style", { children: `
          @keyframes texturePulse {
            0% { opacity: 0.55; transform: translateY(0) scale(0.98); }
            50% { opacity: 1; transform: translateY(-2px) scale(1); }
            100% { opacity: 0.55; transform: translateY(0) scale(0.98); }
          }
          @keyframes textureDot {
            0% { transform: translateY(0); opacity: 0.45; }
            50% { transform: translateY(-4px); opacity: 1; }
            100% { transform: translateY(0); opacity: 0.45; }
          }
          @keyframes hpPopupFloat {
            0% { opacity: 0; transform: translate(-50%, -10%) scale(0.9); }
            20% { opacity: 1; transform: translate(-50%, -30%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -110%) scale(1.05); }
          }
          @keyframes reactionToastSlide {
            0% { opacity: 0; transform: translate(-50%, -8px) scale(0.98); }
            15% { opacity: 1; transform: translate(-50%, 0) scale(1); }
            85% { opacity: 1; transform: translate(-50%, 0) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -8px) scale(0.98); }
          }
        ` }),
        isTextureLoading && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            style: {
              position: "absolute",
              inset: 0,
              zIndex: 80,
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              background: "radial-gradient(circle at 30% 20%, rgba(120,90,30,0.25), transparent 55%), rgba(6,6,10,0.75)",
              backdropFilter: "blur(6px)",
              pointerEvents: "auto"
            },
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "div",
              {
                style: {
                  padding: "18px 22px",
                  borderRadius: 16,
                  background: "rgba(12,12,18,0.94)",
                  border: "1px solid rgba(255,255,255,0.14)",
                  boxShadow: "0 18px 60px rgba(0,0,0,0.45)",
                  minWidth: 220,
                  textAlign: "center",
                  animation: "texturePulse 1.6s ease-in-out infinite"
                },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 12, letterSpacing: 1, fontWeight: 700, opacity: 0.9 }, children: "CHARGEMENT TEXTURES" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    "div",
                    {
                      style: {
                        display: "flex",
                        justifyContent: "center",
                        gap: 8,
                        marginTop: 10,
                        marginBottom: 6,
                        fontSize: 20
                      },
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { animation: "textureDot 1s ease-in-out infinite" }, children: "" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { animation: "textureDot 1s ease-in-out infinite", animationDelay: "0.15s" }, children: "" }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { animation: "textureDot 1s ease-in-out infinite", animationDelay: "0.3s" }, children: "" })
                      ]
                    }
                  ),
                  textureLoadingHint && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 11, opacity: 0.7 }, children: textureLoadingHint })
                ]
              }
            )
          }
        ),
        isGameOver && /* @__PURE__ */ jsxRuntimeExports.jsx(GameOverOverlay, { onRestart: () => window.location.reload() }),
        showCellIds && obstacleLegend.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            style: {
              position: "absolute",
              top: 16,
              right: 16,
              zIndex: 50,
              background: "rgba(10,10,16,0.92)",
              border: "1px solid rgba(255,255,255,0.12)",
              borderRadius: 10,
              padding: "10px 12px",
              maxWidth: 260,
              maxHeight: "40vh",
              overflowY: "auto",
              fontSize: 12,
              lineHeight: 1.4
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontWeight: 600, marginBottom: 6 }, children: "Legende obstacles" }),
              obstacleLegend.map((item) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                item.label,
                " (",
                item.id,
                ") [",
                item.orientation,
                "]"
              ] }, item.id))
            ]
          }
        ),
        showTerrainIds && terrainLegend.entries.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            style: {
              position: "absolute",
              top: 16,
              left: 16,
              zIndex: 50,
              background: "rgba(10,10,16,0.92)",
              border: "1px solid rgba(255,255,255,0.12)",
              borderRadius: 10,
              padding: "10px 12px",
              maxWidth: 260,
              maxHeight: "40vh",
              overflowY: "auto",
              fontSize: 12,
              lineHeight: 1.4
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontWeight: 600, marginBottom: 6 }, children: "Legende sols" }),
              terrainLegend.entries.map((item) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                item.index,
                " - ",
                item.label,
                " (",
                item.id,
                ")"
              ] }, item.id))
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            style: {
              flex: "1 1 auto",
              display: "flex",
              flexDirection: "column",
              alignItems: "stretch",
              justifyContent: "flex-start",
              gap: 10,
              minHeight: 0,
              overflow: "hidden"
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  style: {
                    flex: "0 0 auto",
                    padding: "10px 12px",
                    borderRadius: 14,
                    background: "rgba(12,12,18,0.88)",
                    border: "1px solid rgba(255,255,255,0.10)",
                    boxShadow: "0 18px 60px rgba(0,0,0,0.35)"
                  },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    InitiativePanel,
                    {
                      round: round2,
                      timelineEntries,
                      activeEntry,
                      player,
                      enemies
                    }
                  )
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "div",
                {
                  style: {
                    display: "flex",
                    justifyContent: "space-between",
                    alignItems: "baseline",
                    padding: "0 4px"
                  },
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", flexDirection: "column", gap: 2 }, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { style: { fontSize: 18, fontWeight: 900, letterSpacing: 0.4 }, children: "Mini Donjon" }),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { style: { fontSize: 12, color: "rgba(255,255,255,0.70)" }, children: [
                        "Clic gauche: roue d'actions ??? Deplacer: clics successifs (max ",
                        basePathLimit,
                        ")"
                      ] })
                    ] }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: 8 }, children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "span",
                        {
                          style: {
                            fontSize: 12,
                            color: "rgba(255,255,255,0.85)",
                            background: "rgba(255,255,255,0.08)",
                            border: "1px solid rgba(255,255,255,0.18)",
                            padding: "4px 10px",
                            borderRadius: 999,
                            fontWeight: 700,
                            letterSpacing: 0.2
                          },
                          children: phaseLabel
                        }
                      ),
                      showReactionBanner && /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "span",
                        {
                          style: {
                            fontSize: 12,
                            color: "#0b0b12",
                            background: "#f1c40f",
                            border: "1px solid rgba(255,255,255,0.18)",
                            padding: "4px 10px",
                            borderRadius: 999,
                            fontWeight: 900,
                            letterSpacing: 0.6,
                            textTransform: "uppercase"
                          },
                          children: "Reaction !"
                        }
                      )
                    ] })
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  style: {
                    flex: "1 1 auto",
                    minHeight: 0,
                    borderRadius: 18,
                    padding: 10,
                    background: "radial-gradient(1200px 500px at 40% 0%, rgba(120,90,40,0.20), rgba(12,12,18,0.92))",
                    border: "1px solid rgba(255,255,255,0.12)",
                    boxShadow: "0 25px 90px rgba(0,0,0,0.55)",
                    overflow: "visible"
                  },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    "div",
                    {
                      ref: pixiContainerRef,
                      onClick: handleBoardClick,
                      onContextMenu: (event) => {
                        event.preventDefault();
                      },
                      onMouseDown: (event) => {
                        if (event.button !== 2) return;
                        event.preventDefault();
                        event.stopPropagation();
                        setIsPanningBoard(true);
                        panDragRef.current = { x: event.clientX, y: event.clientY };
                      },
                      onMouseMove: (event) => {
                        if (!isPanningBoard) return;
                        const start = panDragRef.current;
                        if (!start) return;
                        const dx = event.clientX - start.x;
                        const dy = event.clientY - start.y;
                        if (dx === 0 && dy === 0) return;
                        panDragRef.current = { x: event.clientX, y: event.clientY };
                        setBoardPan((prev) => ({ x: prev.x + dx, y: prev.y + dy }));
                      },
                      onMouseUp: (event) => {
                        if (event.button !== 2) return;
                        setIsPanningBoard(false);
                        panDragRef.current = null;
                      },
                      onMouseLeave: () => {
                        setIsPanningBoard(false);
                        panDragRef.current = null;
                      },
                      style: {
                        width: "100%",
                        height: "100%",
                        minHeight: 0,
                        borderRadius: 14,
                        border: "1px solid rgba(255,255,255,0.10)",
                        background: colorToCssHex(boardBackgroundColor),
                        position: "relative",
                        display: "flex",
                        alignItems: "center",
                        justifyContent: "center",
                        overflow: "visible",
                        cursor: isPanningBoard ? "grabbing" : "default"
                      },
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsxs(
                          "div",
                          {
                            style: {
                              position: "absolute",
                              inset: 0,
                              pointerEvents: "none",
                              zIndex: 35
                            },
                            children: [
                              reactionToast && /* @__PURE__ */ jsxRuntimeExports.jsx(
                                "div",
                                {
                                  style: {
                                    position: "absolute",
                                    left: "50%",
                                    top: 16,
                                    transform: "translateX(-50%)",
                                    padding: "10px 18px",
                                    borderRadius: 14,
                                    fontSize: 18,
                                    fontWeight: 900,
                                    letterSpacing: 0.4,
                                    background: reactionToast.kind === "miss" ? "rgba(46, 204, 113, 0.92)" : reactionToast.kind === "hit" ? "rgba(231, 76, 60, 0.92)" : "rgba(241, 196, 15, 0.92)",
                                    color: "#0b0b12",
                                    border: "1px solid rgba(255,255,255,0.35)",
                                    textShadow: "0 1px 6px rgba(0,0,0,0.35)",
                                    boxShadow: "0 12px 35px rgba(0,0,0,0.45)",
                                    animation: "reactionToastSlide 3.2s ease-out forwards"
                                  },
                                  children: reactionToast.text
                                },
                                reactionToast.id
                              ),
                              combatToast && /* @__PURE__ */ jsxRuntimeExports.jsx(
                                "div",
                                {
                                  style: {
                                    position: "absolute",
                                    left: "50%",
                                    top: reactionToast ? 60 : 16,
                                    transform: "translateX(-50%)",
                                    padding: "14px 24px",
                                    borderRadius: 16,
                                    fontSize: 24,
                                    fontWeight: 900,
                                    letterSpacing: 0.5,
                                    background: combatToast.kind === "heal" ? "rgba(46, 204, 113, 0.92)" : combatToast.kind === "hit" ? "rgba(231, 76, 60, 0.92)" : "rgba(241, 196, 15, 0.92)",
                                    color: "#0b0b12",
                                    border: "1px solid rgba(255,255,255,0.35)",
                                    textShadow: "0 1px 6px rgba(0,0,0,0.35)",
                                    boxShadow: "0 12px 35px rgba(0,0,0,0.45)",
                                    animation: "reactionToastSlide 5.2s ease-out forwards"
                                  },
                                  children: combatToast.text
                                },
                                combatToast.id
                              ),
                              hpPopups.map((popup) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                                "div",
                                {
                                  style: {
                                    position: "absolute",
                                    left: popup.x,
                                    top: popup.y,
                                    color: popup.color,
                                    fontSize: 18,
                                    fontWeight: 900,
                                    padding: "4px 10px",
                                    borderRadius: 10,
                                    background: "rgba(8,8,12,0.82)",
                                    border: "1px solid rgba(255,255,255,0.2)",
                                    textShadow: "0 2px 6px rgba(0,0,0,0.6)",
                                    animation: "hpPopupFloat 2.6s ease-out forwards",
                                    willChange: "transform, opacity"
                                  },
                                  children: popup.text
                                },
                                popup.id
                              ))
                            ]
                          }
                        ),
                        /* @__PURE__ */ jsxRuntimeExports.jsxs(
                          "div",
                          {
                            onMouseDown: (event) => event.stopPropagation(),
                            style: {
                              position: "absolute",
                              right: 12,
                              top: 12,
                              zIndex: 45,
                              display: "flex",
                              flexDirection: "column",
                              gap: 6,
                              padding: 8,
                              borderRadius: 12,
                              background: "rgba(10, 10, 16, 0.72)",
                              border: "1px solid rgba(255,255,255,0.14)",
                              backdropFilter: "blur(6px)",
                              boxShadow: "0 14px 40px rgba(0,0,0,0.35)"
                            },
                            children: [
                              /* @__PURE__ */ jsxRuntimeExports.jsx(
                                "button",
                                {
                                  type: "button",
                                  onClick: () => setBoardZoom((z) => clamp$5(Math.round((z + ZOOM_STEP) * 10) / 10, ZOOM_MIN, ZOOM_MAX)),
                                  disabled: boardZoom >= ZOOM_MAX - 1e-6,
                                  style: {
                                    width: 34,
                                    height: 34,
                                    borderRadius: 10,
                                    border: "1px solid rgba(255,255,255,0.14)",
                                    background: boardZoom >= ZOOM_MAX - 1e-6 ? "rgba(80,80,90,0.55)" : "rgba(255,255,255,0.08)",
                                    color: "#fff",
                                    cursor: boardZoom >= ZOOM_MAX - 1e-6 ? "default" : "pointer",
                                    fontSize: 18,
                                    fontWeight: 800,
                                    lineHeight: 1
                                  },
                                  title: "Zoom +",
                                  children: "+"
                                }
                              ),
                              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                                "div",
                                {
                                  style: {
                                    textAlign: "center",
                                    fontSize: 12,
                                    color: "rgba(255,255,255,0.75)",
                                    fontWeight: 700
                                  },
                                  title: "Niveau de zoom",
                                  children: [
                                    Math.round(boardZoom * 100),
                                    "%"
                                  ]
                                }
                              ),
                              /* @__PURE__ */ jsxRuntimeExports.jsx(
                                "button",
                                {
                                  type: "button",
                                  onClick: () => setBoardZoom((z) => clamp$5(Math.round((z - ZOOM_STEP) * 10) / 10, ZOOM_MIN, ZOOM_MAX)),
                                  disabled: boardZoom <= ZOOM_MIN + 1e-6,
                                  style: {
                                    width: 34,
                                    height: 34,
                                    borderRadius: 10,
                                    border: "1px solid rgba(255,255,255,0.14)",
                                    background: boardZoom <= ZOOM_MIN + 1e-6 ? "rgba(80,80,90,0.55)" : "rgba(255,255,255,0.08)",
                                    color: "#fff",
                                    cursor: boardZoom <= ZOOM_MIN + 1e-6 ? "default" : "pointer",
                                    fontSize: 22,
                                    fontWeight: 800,
                                    lineHeight: 1
                                  },
                                  title: "Zoom -",
                                  children: "???"
                                }
                              ),
                              /* @__PURE__ */ jsxRuntimeExports.jsx(
                                "button",
                                {
                                  type: "button",
                                  onClick: () => setBoardZoom(DEFAULT_ZOOM),
                                  disabled: Math.abs(boardZoom - DEFAULT_ZOOM) < 1e-6,
                                  style: {
                                    marginTop: 4,
                                    width: 34,
                                    height: 28,
                                    borderRadius: 10,
                                    border: "1px solid rgba(255,255,255,0.14)",
                                    background: Math.abs(boardZoom - DEFAULT_ZOOM) < 1e-6 ? "rgba(80,80,90,0.55)" : "rgba(255,255,255,0.06)",
                                    color: "rgba(255,255,255,0.85)",
                                    cursor: Math.abs(boardZoom - DEFAULT_ZOOM) < 1e-6 ? "default" : "pointer",
                                    fontSize: 11,
                                    fontWeight: 800
                                  },
                                  title: "Reset zoom",
                                  children: "1??"
                                }
                              ),
                              /* @__PURE__ */ jsxRuntimeExports.jsx(
                                "div",
                                {
                                  style: {
                                    width: "100%",
                                    height: 1,
                                    background: "rgba(255,255,255,0.12)",
                                    margin: "2px 0"
                                  }
                                }
                              ),
                              /* @__PURE__ */ jsxRuntimeExports.jsx(
                                "button",
                                {
                                  type: "button",
                                  onClick: () => {
                                    setIsNarrationOpen(false);
                                    setFloatingPanel((current) => current === "effects" ? null : "effects");
                                  },
                                  style: {
                                    width: 34,
                                    height: 28,
                                    borderRadius: 10,
                                    border: "1px solid rgba(255,255,255,0.14)",
                                    background: floatingPanel === "effects" ? "rgba(255,255,255,0.12)" : "rgba(255,255,255,0.06)",
                                    color: "rgba(255,255,255,0.85)",
                                    cursor: "pointer",
                                    fontSize: 10,
                                    fontWeight: 900,
                                    letterSpacing: 0.4
                                  },
                                  title: "Effets",
                                  children: "FX"
                                }
                              ),
                              /* @__PURE__ */ jsxRuntimeExports.jsx(
                                "button",
                                {
                                  type: "button",
                                  onClick: () => {
                                    setIsNarrationOpen(false);
                                    setFloatingPanel((current) => current === "logs" ? null : "logs");
                                  },
                                  style: {
                                    width: 34,
                                    height: 28,
                                    borderRadius: 10,
                                    border: "1px solid rgba(255,255,255,0.14)",
                                    background: floatingPanel === "logs" ? "rgba(255,255,255,0.12)" : "rgba(255,255,255,0.06)",
                                    color: "rgba(255,255,255,0.85)",
                                    cursor: "pointer",
                                    fontSize: 10,
                                    fontWeight: 900,
                                    letterSpacing: 0.4
                                  },
                                  title: "Logs",
                                  children: "LOG"
                                }
                              ),
                              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                                "button",
                                {
                                  type: "button",
                                  onClick: () => {
                                    setFloatingPanel(null);
                                    setIsNarrationOpen((prev) => !prev);
                                  },
                                  style: {
                                    position: "relative",
                                    width: 34,
                                    height: 28,
                                    borderRadius: 10,
                                    border: "1px solid rgba(255,255,255,0.14)",
                                    background: isNarrationOpen ? "rgba(255,255,255,0.12)" : "rgba(255,255,255,0.06)",
                                    color: "rgba(255,255,255,0.85)",
                                    cursor: "pointer",
                                    fontSize: 9,
                                    fontWeight: 900,
                                    letterSpacing: 0.3
                                  },
                                  title: "Narration",
                                  children: [
                                    "NAR",
                                    narrationUnread > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
                                      "span",
                                      {
                                        style: {
                                          position: "absolute",
                                          top: -6,
                                          right: -6,
                                          minWidth: 16,
                                          height: 16,
                                          padding: "0 4px",
                                          borderRadius: 10,
                                          background: "#e74c3c",
                                          color: "#fff",
                                          fontSize: 10,
                                          fontWeight: 900,
                                          lineHeight: "16px",
                                          border: "1px solid rgba(255,255,255,0.4)",
                                          boxShadow: "0 6px 12px rgba(0,0,0,0.35)"
                                        },
                                        children: narrationUnread > 9 ? "9+" : narrationUnread
                                      }
                                    )
                                  ]
                                }
                              )
                            ]
                          }
                        ),
                        floatingPanel && /* @__PURE__ */ jsxRuntimeExports.jsxs(
                          "div",
                          {
                            onMouseDown: (event) => event.stopPropagation(),
                            style: {
                              position: "absolute",
                              right: 60,
                              top: 12,
                              zIndex: 45,
                              width: 360,
                              maxWidth: "70vw",
                              maxHeight: "60vh",
                              height: "60vh",
                              overflow: "hidden",
                              padding: 10,
                              borderRadius: 12,
                              background: "rgba(10,10,16,0.92)",
                              border: "1px solid rgba(255,255,255,0.12)",
                              boxShadow: "0 18px 60px rgba(0,0,0,0.45)",
                              display: "flex",
                              flexDirection: "column"
                            },
                            children: [
                              floatingPanel === "effects" && /* @__PURE__ */ jsxRuntimeExports.jsx(
                                EffectsPanel,
                                {
                                  showVisionDebug,
                                  showLightOverlay,
                                  showFogSegments,
                                  showCellIds,
                                  showAllLevels,
                                  showTerrainIds,
                                  showTerrainContours,
                                  showGridLines,
                                  shadowLightAngleDeg,
                                  bumpIntensity,
                                  windSpeed,
                                  windStrength,
                                  bumpDebug,
                                  visionLegend,
                                  onShowCircle: handleShowCircleEffect,
                                  onShowRectangle: handleShowRectangleEffect,
                                  onShowCone: handleShowConeEffect,
                                  onToggleVisionDebug: () => setShowVisionDebug((prev) => !prev),
                                  onToggleLightOverlay: () => setShowLightOverlay((prev) => !prev),
                                  onToggleFogSegments: () => setShowFogSegments((prev) => !prev),
                                  onToggleCellIds: () => setShowCellIds((prev) => !prev),
                                  onToggleShowAllLevels: () => setShowAllLevels((prev) => !prev),
                                  onToggleTerrainIds: () => setShowTerrainIds((prev) => !prev),
                                  onToggleTerrainContours: () => setShowTerrainContours((prev) => !prev),
                                  onToggleGridLines: () => setShowGridLines((prev) => !prev),
                                  onChangeShadowLightAngleDeg: (value2) => setShadowLightAngleDeg(value2),
                                  onChangeBumpIntensity: (value2) => setBumpIntensity(value2),
                                  onChangeWindSpeed: (value2) => setWindSpeed(value2),
                                  onChangeWindStrength: (value2) => setWindStrength(value2),
                                  onToggleBumpDebug: () => setBumpDebug((prev) => !prev),
                                  onClear: handleClearEffects,
                                  fxAnimations,
                                  usageDebug: actionUsageDebug
                                }
                              ),
                              floatingPanel === "logs" && /* @__PURE__ */ jsxRuntimeExports.jsx(LogPanel, { log: log2 })
                            ]
                          }
                        ),
                        isNarrationOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(
                          "div",
                          {
                            onMouseDown: (event) => event.stopPropagation(),
                            style: {
                              position: "absolute",
                              right: 60,
                              top: 12,
                              zIndex: 45,
                              width: 380,
                              maxWidth: "72vw",
                              maxHeight: "70vh",
                              overflow: "hidden"
                            },
                            children: /* @__PURE__ */ jsxRuntimeExports.jsx(NarrationPanel, { entries: narrationEntries })
                          }
                        ),
                        showResumeAction && /* @__PURE__ */ jsxRuntimeExports.jsxs(
                          "div",
                          {
                            onMouseDown: (event) => event.stopPropagation(),
                            style: {
                              position: "absolute",
                              top: 16,
                              left: 16,
                              zIndex: 55,
                              padding: "8px 10px",
                              borderRadius: 10,
                              background: "rgba(10,10,16,0.92)",
                              border: "1px solid rgba(255,255,255,0.12)",
                              boxShadow: "0 12px 40px rgba(0,0,0,0.35)"
                            },
                            children: [
                              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { fontSize: 11, color: "rgba(255,255,255,0.7)", marginBottom: 6 }, children: "Action en cours" }),
                              /* @__PURE__ */ jsxRuntimeExports.jsx(
                                "button",
                                {
                                  type: "button",
                                  onClick: () => setActionContextOpen(true),
                                  style: {
                                    padding: "6px 10px",
                                    borderRadius: 10,
                                    border: "1px solid rgba(255,255,255,0.12)",
                                    background: "rgba(255,255,255,0.08)",
                                    color: "rgba(255,255,255,0.9)",
                                    cursor: "pointer",
                                    fontSize: 12,
                                    fontWeight: 900
                                  },
                                  children: "Reprendre l'action"
                                }
                              )
                            ]
                          }
                        ),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                          ActionWheelMenu,
                          {
                            open: isCombatConfigured,
                            anchorX: wheelAnchor.x,
                            anchorY: wheelAnchor.y,
                            size: 240,
                            categoryThreshold: actionWheelCategoryThreshold,
                            canInteractWithBoard,
                            hasCell: Boolean(radialMenu.cell),
                            isResolvingEnemies,
                            blockWheel: isActionInProgress,
                            blockEndTurn: showResumeAction,
                            actions: actions2,
                            moveTypes: moveTypes2,
                            isMoving: interactionMode === "moving",
                            interactionState,
                            interactionItems: interactionMenuItems,
                            interactionPrompt: "Selectionner la cible de l'interaction",
                            onCancelInteract: handleCancelInteractFromWheel,
                            computeActionAvailability,
                            onClose: closeRadialMenu,
                            onCancelMove: handleCancelMoveFromWheel,
                            onNoMoveTypes: () => pushLog2("Deplacement: aucun type disponible."),
                            onNoActions: () => pushLog2("Action: aucune action disponible."),
                            onInspectCell: handleEnterInspectModeFromWheel,
                            onLook: handleEnterLookModeFromWheel,
                            onInteract: handleInteractFromWheel,
                            onOpenSheet: openSheetFromWheel,
                            onEndTurn: () => {
                              handleEndPlayerTurn();
                            },
                            onPickAction: openActionContextFromWheel
                          }
                        ),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                          CharacterSheetWindow,
                          {
                            open: sheetOpen,
                            anchorX: 0,
                            anchorY: 0,
                            character: activeCharacterConfig,
                            player,
                            equippedWeapons,
                            weaponById: weaponTypeById,
                            equipmentAppliedBonuses,
                            itemLabels: itemLabelMap,
                            actionInfoById,
                            spellInfoById: spellCatalog.byId,
                            initiativeRoll: playerInitiativeRoll,
                            initiativeMod: playerInitiativeMod,
                            initiativeTotal: playerInitiative,
                            actionsRemaining: Math.max(
                              0,
                              (((_a = player.combatStats) == null ? void 0 : _a.actionsPerTurn) ?? 1) - turnActionUsage.usedActionCount
                            ),
                            bonusRemaining: Math.max(
                              0,
                              (((_b = player.combatStats) == null ? void 0 : _b.bonusActionsPerTurn) ?? 1) - turnActionUsage.usedBonusCount
                            ),
                            resources: playerResources,
                            onClose: () => setSheetOpen(false)
                          }
                        ),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                          ActionContextWindow,
                          {
                            open: actionContextOpen && (Boolean(actionContext) || Boolean(pendingHazardRoll)),
                            anchorX: (actionContext == null ? void 0 : actionContext.anchorX) ?? (hazardAnchor == null ? void 0 : hazardAnchor.anchorX) ?? 0,
                            anchorY: (actionContext == null ? void 0 : actionContext.anchorY) ?? (hazardAnchor == null ? void 0 : hazardAnchor.anchorY) ?? 0,
                            stage: (actionContext == null ? void 0 : actionContext.stage) ?? "active",
                            action: contextAction,
                            availability: contextAvailability,
                            pendingHazard: pendingHazardRoll,
                            hazardResolution,
                            player,
                            enemies,
                            validatedAction,
                            ammoInfo: contextAmmoInfo,
                            spellSourceOptions: contextSpellSourceOptions,
                            selectedSpellSourceEntryId: contextAction && isSpellActionId(contextAction.id) ? selectedSpellSourceBySpellId[contextAction.id] ?? null : null,
                            onSelectSpellSourceEntryId: (entryId) => {
                              if (!contextAction || !isSpellActionId(contextAction.id)) return;
                              setSelectedSpellSourceBySpellId((prev) => ({
                                ...prev,
                                [contextAction.id]: entryId
                              }));
                            },
                            targetMode,
                            selectedTargetIds,
                            selectedTargetLabels,
                            maxTargets: ((_c = contextAction == null ? void 0 : contextAction.targeting) == null ? void 0 : _c.maxTargets) ?? null,
                            targetStatuses: selectedTargetStatuses,
                            effectiveAdvantageMode,
                            plan: contextPlan,
                            isComplete: contextComplete,
                            movement: contextMovement,
                            onFinishHazard: handleFinishHazard,
                            onToggleTargetId: (enemyId) => {
                              var _a2;
                              return toggleSelectedTargetId(enemyId, ((_a2 = contextAction == null ? void 0 : contextAction.targeting) == null ? void 0 : _a2.maxTargets) ?? null);
                            },
                            onSetTargetMode: setTargetMode,
                            advantageMode,
                            onSetAdvantageMode: setAdvantageMode,
                            onRollAttack: handleRollAttack,
                            onRollDamage: handleRollDamage,
                            onAutoResolve: handleAutoResolveRolls,
                            attackRoll,
                            damageRoll,
                            diceLogs,
                            onValidateAction: handleValidateActionFromContext,
                            onFinishAction: handleFinishAction,
                            onCancelAction: handleCancelAction,
                            onClose: closeActionContext
                          }
                        ),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                          InteractionContextWindow,
                          {
                            open: Boolean(interactionContext),
                            anchorX: (interactionContext == null ? void 0 : interactionContext.anchorX) ?? 0,
                            anchorY: (interactionContext == null ? void 0 : interactionContext.anchorY) ?? 0,
                            interaction: (interactionContext == null ? void 0 : interactionContext.interaction) ?? null,
                            availability: interactionAvailability,
                            forceMod,
                            onExecute: () => {
                              if (!interactionContext) return;
                              handleExecuteInteraction(
                                interactionContext.interaction,
                                interactionContext.target
                              );
                            },
                            onClose: closeInteractionContext
                          }
                        )
                      ]
                    }
                  )
                }
              )
            ]
          }
        )
      ]
    }
  );
};
const rootElement = document.getElementById("root");
ReactDOM.createRoot(rootElement).render(/* @__PURE__ */ jsxRuntimeExports.jsx(GameBoard, {}));
export {
  TextureStyle as $,
  AbstractRenderer as A,
  BufferUsage as B,
  Container as C,
  DOMAdapter as D,
  ExtensionType as E,
  Filter as F,
  GpuProgram as G,
  Bounds as H,
  TexturePool as I,
  FilterEffect as J,
  Sprite as K,
  getAttributeInfoFromFormat as L,
  Matrix as M,
  unsafeEvalSupported as N,
  GlobalResourceRegistry as O,
  Point as P,
  uid as Q,
  RendererType as R,
  State as S,
  Ticker as T,
  UPDATE_PRIORITY as U,
  Rectangle as V,
  SystemRunner as W,
  multiplyColors as X,
  UPDATE_VISIBLE as Y,
  UPDATE_COLOR as Z,
  UPDATE_BLEND as _,
  EventEmitter as a,
  Color as a0,
  RenderGroup as a1,
  getLocalBounds as a2,
  VERSION as a3,
  deprecation as a4,
  v8_0_0 as a5,
  RendererInitHook as a6,
  Geometry as a7,
  checkMaxIfStatementsInShader as a8,
  compileHighShaderGlProgram as a9,
  colorBitGl as aa,
  generateTextureBatchBitGl as ab,
  roundPixelsBitGl as ac,
  getBatchSamplersUniformGroup as ad,
  BatchableGraphics as ae,
  getAdjustedBlendModeBlend as af,
  ViewableBuffer as ag,
  BitmapFontManager as ah,
  CanvasTextMetrics as ai,
  getBitmapTextLayout as aj,
  Cache as ak,
  Graphics as al,
  updateQuadBounds as am,
  TextStyle as an,
  CanvasTextGenerator as ao,
  GraphicsContextSystem as ap,
  STENCIL_MODES as b,
  Buffer2 as c,
  BindGroup as d,
  extensions as e,
  fastCopy as f,
  getTextureBatchBindGroup as g,
  createIdFromString as h,
  CLEAR as i,
  CanvasSource as j,
  TextureSource as k,
  UniformGroup as l,
  CanvasPool as m,
  compileHighShaderGpuProgram as n,
  colorBit as o,
  generateTextureBatchBit as p,
  roundPixelsBit as q,
  removeItems as r,
  Shader as s,
  Texture as t,
  TextureMatrix as u,
  GlProgram as v,
  warn as w,
  DefaultBatcher as x,
  BigPool as y,
  getGlobalBounds as z
};
//# sourceMappingURL=index-DtxMm1r_.js.map
